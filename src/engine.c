/* board.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


/* The functions in this file implements a go board with incremental
 * update of strings and liberties.
 * 
 * See the Texinfo documentation (Utility Functions: Incremental Board)
 * for an introduction.
 */

/* emgena: #include "gnugo.h" */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <limits.h>
#include <math.h>

/*-------------------------------------------------------*/
#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

/*-------------------------------------------------------*/
#ifdef __MINGW32__
#include <windows.h>
#include <winsock.h>
#include <io.h>
#endif

#ifdef HAVE_VISUAL_C
#include <winsock.h>
#include <io.h>
#endif 

/*-------------------------------------------------------*/

#include "sgf.h"
#include "common.h"
#include "engine.h"
#include "patterns.h"

/*-------------------------------------------------------*/


#define KOMASTER_SCHEME 5
#define KOMASTER_TRACE 0

int tracing_inside_komaster = 0;


/* This can be used for internal checks w/in board.c that should
 * typically not be necessary (for speed). */
#if 1
#define PARANOID1(x, pos) ASSERT1(x, pos)
#else
#define PARANOID1(x, pos)
#endif

/* ================================================================ */
/*                          data structures                         */
/* ================================================================ */


/* Incremental string data. */
struct string_data {
  int color;                       /* Color of string, BLACK or WHITE */
  int size;                        /* Number of stones in string. */
  int origin;                      /* Coordinates of "origin", i.e. */
                                   /* "upper left" stone. */
  int liberties;                   /* Number of liberties. */
  int libs[MAX_LIBERTIES];         /* Coordinates of liberties. */
  int neighbors;                   /* Number of neighbor strings */
  int neighborlist[MAXCHAIN];      /* List of neighbor string numbers. */
  int mark;                        /* General purpose mark. */
};


/* we keep the adress and the old value */
struct change_stack_entry {
  int *address;
  int value;
};

/* we keep the adress and the old value */
struct vertex_stack_entry {
  Intersection *address;
  int value;
};


/* Experimental results show that the average number of change stack
 * entries per move usually is in the 20-30 range and very seldom
 * exceeds 40. But since we have no way to recover from running out of
 * stack space, we allocate with a substantial safety margin.
 */
#define STACK_SIZE 80 * MAXSTACK


#define CLEAR_STACKS()\
(change_stack_pointer = change_stack, \
 vertex_stack_pointer = vertex_stack)

/* Begin a record : adress == NULL */
#define BEGIN_CHANGE_RECORD()\
((change_stack_pointer++)->address = NULL,\
 (vertex_stack_pointer++)->address = NULL)

/* Save a value : store the adress and the value in the stack */
#define PUSH_VALUE(v)\
(change_stack_pointer->address = &(v),\
 (change_stack_pointer++)->value = (v))

/* Save a board value : store the adress and the value in the stack */
#define PUSH_VERTEX(v)\
(vertex_stack_pointer->address = &(v),\
 (vertex_stack_pointer++)->value = (v))

#define POP_MOVE()\
  while ((--change_stack_pointer)->address)\
  *(change_stack_pointer->address) =\
  change_stack_pointer->value


#define POP_VERTICES()\
  while ((--vertex_stack_pointer)->address)\
  *(vertex_stack_pointer->address) =\
  vertex_stack_pointer->value


/* ================================================================ */
/*                      static data structures                      */
/* ================================================================ */


/* Main array of string information. */
static struct string_data  string[MAX_STRINGS];

/* Stacks and stack pointers. */
static struct change_stack_entry change_stack[STACK_SIZE];
static struct change_stack_entry *change_stack_pointer;

static struct vertex_stack_entry vertex_stack[STACK_SIZE];
static struct vertex_stack_entry *vertex_stack_pointer;


/* Index into list of strings. The index is only valid if there is a
 * stone at the vertex.
 */
static int string_number[BOARDMAX];


/* The stones in a string are linked together in a cyclic list. 
 * These are the coordinates to the next stone in the string.
 */
static int next_stone[BOARDMAX];


/* ---------------------------------------------------------------- */


/* Macros to traverse the stones of a string.
 *
 * Usage:
 * int s, pos;
 * s = find_the_string()
 * pos = FIRST_STONE(s);
 *   do {
 *    use_stone(pos);
 *    pos = NEXT_STONE(pos);
 *  } while (!BACK_TO_FIRST_STONE(s, pos));
 */
#define FIRST_STONE(s) \
  (string[s].origin)

#define NEXT_STONE(pos) \
  (next_stone[pos])

#define BACK_TO_FIRST_STONE(s, pos) \
  ((pos) == string[s].origin)


/* Assorted useful macros.
 *
 * Some of them could have been functions but are implemented as
 * macros for speed.
 */

#define LIBERTY(pos) \
  (board[pos] == EMPTY)

#define UNMARKED_LIBERTY(pos) \
  (board[pos] == EMPTY && ml[pos] != liberty_mark)

#define MARK_LIBERTY(pos) \
  ml[pos] = liberty_mark

#define UNMARKED_STRING(pos) \
  (string[string_number[pos]].mark != string_mark)

#define UNMARKED_OPPONENT_STRING(s, pos)\
  (board[pos] == OTHER_COLOR(string[s].color)\
   && string[string_number[pos]].mark != string_mark)

#define UNMARKED_OWN_STRING(s, pos)\
  (board[pos] == string[s].color\
   && string[string_number[pos]].mark != string_mark)

#define MARK_STRING(pos) string[string_number[pos]].mark = string_mark

#define STRING_AT_VERTEX(pos, s)\
  (IS_STONE(board[pos]) && string_number[pos] == (s))
  
#define LIBERTIES(pos)\
  string[string_number[pos]].liberties

#define COUNTSTONES(pos) \
  string[string_number[pos]].size

#define ADD_LIBERTY(s, pos)\
  do {\
    if (string[s].liberties < MAX_LIBERTIES)\
      string[s].libs[string[s].liberties] = pos;\
    string[s].liberties++;\
  } while (0)

#define ADD_AND_MARK_LIBERTY(s, pos)\
  do {\
    if (string[s].liberties < MAX_LIBERTIES)\
      string[s].libs[string[s].liberties] = pos;\
    string[s].liberties++;\
    ml[pos] = liberty_mark;\
  } while (0)

#define ADD_NEIGHBOR(s, pos)\
  string[s].neighborlist[string[s].neighbors++] = string_number[pos]

#define DO_ADD_STONE(pos, color)\
  do {\
    PUSH_VERTEX(board[pos]);\
    board[pos] = color;\
    hashdata_invert_stone(&hashdata, pos, color);\
  } while (0)

#define DO_REMOVE_STONE(pos)\
  do {\
    PUSH_VERTEX(board[pos]);\
    hashdata_invert_stone(&hashdata, pos, board[pos]);\
    board[pos] = EMPTY;\
  } while (0)


/* ---------------------------------------------------------------- */


/* True if the data structures are up to date for the current 
 * board position.
 */
static int strings_initialized = 0;


/* Number of the next free string. */
static int next_string;


/* For marking purposes. */
static int ml[BOARDMAX];
static int liberty_mark;
static int string_mark;


/* Forward declarations. */
static int do_trymove(int pos, int color, int ignore_ko);
static void undo_trymove(void);
static void new_position(void);
static void init_board(void);
static int propagate_string(int stone, int str);
static void find_liberties_and_neighbors(int s);
static int do_remove_string(int s);
static void do_play_move(int pos, int color);
static int slow_approxlib(int pos, int color, int maxlib, int *libs);
static int incremental_sloppy_self_atari(int pos, int color);


/* Statistics. */
static int trymove_counter = 0;

/* Coordinates for the eight directions, ordered
 * south, west, north, east, southwest, northwest, northeast, southeast.
 */
int deltai[8] = { 1,  0, -1,  0,  1, -1, -1, 1};
int deltaj[8] = { 0, -1,  0,  1, -1, -1,  1, 1};
int delta[8]  = { NS, -1, -NS, 1, NS-1, -NS-1, -NS+1, NS+1};


/* ================================================================ */
/*                    Board initialization                          */
/* ================================================================ */

/*
 * Save board state.
 */

void
store_board(struct board_state *state)
{
  int k;

  gg_assert(stackp == 0);

  state->board_size = board_size;

  memcpy(state->board, board, sizeof(board));
  memcpy(state->initial_board, initial_board, sizeof(initial_board));

  state->board_ko_pos = board_ko_pos;
  state->white_captured = white_captured;
  state->black_captured = black_captured;
  
  state->initial_board_ko_pos = initial_board_ko_pos;
  state->initial_white_captured = initial_white_captured;
  state->initial_black_captured = initial_black_captured;
  
  state->move_history_pointer = move_history_pointer;
  for (k = 0; k < move_history_pointer; k++) {
    state->move_history_color[k] = move_history_color[k];
    state->move_history_pos[k] = move_history_pos[k];
  }

  state->komi = komi;
  state->move_number = movenum;
}


/*
 * Restore a saved board state.
 */

void
restore_board(struct board_state *state)
{
  int k;

  gg_assert(stackp == 0);

  board_size = state->board_size;

  memcpy(board, state->board, sizeof(board));
  memcpy(initial_board, state->initial_board, sizeof(initial_board));

  board_ko_pos = state->board_ko_pos;
  white_captured = state->white_captured;
  black_captured = state->black_captured;
  
  initial_board_ko_pos = state->initial_board_ko_pos;
  initial_white_captured = state->initial_white_captured;
  initial_black_captured = state->initial_black_captured;
  
  move_history_pointer = state->move_history_pointer;
  for (k = 0; k < move_history_pointer; k++) {
    move_history_color[k] = state->move_history_color[k];
    move_history_pos[k] = state->move_history_pos[k];
  }

  komi = state->komi;
  movenum = state->move_number;
  
  hashdata_recalc(&hashdata, board, board_ko_pos);
  new_position();
}


/*
 * Clear the internal board.
 */

void
clear_board(void)
{
  int k;

  gg_assert(board_size > 0 && board_size <= MAX_BOARD);
  
  memset(board, EMPTY, sizeof(board));
  memset(initial_board, EMPTY, sizeof(initial_board));
  for (k = 0; k < BOARDSIZE; k++) {
    if (!ON_BOARD2(I(k), J(k))) {
      board[k] = GRAY;
      initial_board[k] = GRAY;
    }
  }

  board_ko_pos = NO_MOVE;
  white_captured = 0;
  black_captured = 0;

  initial_board_ko_pos = NO_MOVE;
  initial_white_captured = 0;
  initial_black_captured = 0;

  move_history_pointer = 0;
  movenum = 0;
  
  hashdata_recalc(&hashdata, board, board_ko_pos);
  new_position();
}

/* Test the integrity of the gray border. */
int
test_gray_border(void)
{
  int k;

  gg_assert(board_size > 0 && board_size <= MAX_BOARD);
  
  for (k = 0; k < BOARDSIZE; k++)
    if (!ON_BOARD2(I(k), J(k)))
      if (board[k] != GRAY)
      	return k;
  
  return -1;
}


/* ================================================================ */
/*                      Temporary moves                             */
/* ================================================================ */


/* Stack of trial moves to get to current
 * position and which color made them. Perhaps 
 * this should be one array of a structure 
 */
static int stack[MAXSTACK];
static int move_color[MAXSTACK];

static Hash_data hashdata_stack[MAXSTACK];


/* KOMASTER_SCHEME 4 handles empty case differently from other schemes */
int
komaster_is_empty(int komaster, int kom_pos)
{
  if (KOMASTER_SCHEME == 4)
    return kom_pos == PASS_MOVE;
  else
    return komaster == EMPTY;
}

/* KOMASTER_SCHEME 4 handles komaster interpretation differently from 
 * other schemes */
const char *
komaster_to_string(int komaster, int kom_pos)
{
#if KOMASTER_SCHEME == 4 
  const char *b[4] = {"O-Illegal", "X-Illegal", "O-Legal", "X-Legal"};
  ASSERT1(komaster >= 0 && komaster <= 3, 0);
  if (kom_pos == PASS_MOVE) 
    return "EMPTY";
  return b[komaster];
#else
  UNUSED(kom_pos);
  return color_to_string(komaster);
#endif
}


/*
 * trymove pushes the position onto the stack, and makes a move
 * at pos of color. Returns one if the move is legal. The
 * stack pointer is only incremented if the move is legal.
 *
 * The way to use this is:
 *
 *   if (trymove(...)) {
 *      ...
 *      popgo();
 *   }   
 *
 * The message can be written as a comment to an sgf file using 
 * sgfdump(). str can be NO_MOVE if it is not needed but otherwise  
 * the location of str is included in the comment.
 */

int 
trymove(int pos, int color, const char *message, int str,
	int komaster, int kom_pos)
{
  /* Do the real work elsewhere. */
  if (!do_trymove(pos, color, 0))
    return 0;

  /* Store the move in an sgf tree if one is available. */
  if (sgf_dumptree) {
    char buf[100];

    if (message == NULL)
      message = "UNKNOWN";

    if (str == NO_MOVE) {
      if (!komaster_is_empty(komaster, kom_pos))
	gg_snprintf(buf, 100, "%s (variation %d, hash %lx, komaster %s:%s)", 
		    message, count_variations, hashdata.hashval[0],
		    komaster_to_string(komaster, kom_pos),
		    location_to_string(kom_pos));
      else
	gg_snprintf(buf, 100, "%s (variation %d, hash %lx)", 
		    message, count_variations, hashdata.hashval[0]);
    }
    else {
      if (!komaster_is_empty(komaster, kom_pos))
	gg_snprintf(buf, 100, 
		    "%s at %s (variation %d, hash %lx, komaster %s:%s)", 
		    message, location_to_string(str), count_variations,
		    hashdata.hashval[0], 
                    komaster_to_string(komaster, kom_pos),
		    location_to_string(kom_pos));
      else
	gg_snprintf(buf, 100, "%s at %s (variation %d, hash %lx)", 
		    message, location_to_string(str), count_variations,
		    hashdata.hashval[0]);
    }
    sgftreeAddPlayLast(sgf_dumptree, NULL, color, I(pos), J(pos));
    sgftreeAddComment(sgf_dumptree, NULL, buf);
  }
  
  if (count_variations)
    count_variations++;
  stats.nodes++;

  return 1;
}


/*
 * Special version for semeai reading.
 */

int 
semeai_trymove(int pos, int color, const char *message, int str1, int str2,
	       int owl_phase, int value)
{
  /* Do the real work elsewhere. */
  if (!do_trymove(pos, color, 0))
    return 0;

  if (message == NULL)
    message = "UNKNOWN";
  
  /* Store the move in an sgf tree if one is available. */
  if (sgf_dumptree) {
    char buf[100];
    char sbuf1[5], sbuf2[5];
    /* Simply calling location_to_string three times doesn't work
     * because the internal buffer of that function gets overwritten
     * too soon. So we allocate our own char buffers.
     */
    location_to_buffer(str1, sbuf1);
    location_to_buffer(str2, sbuf2);

    if (owl_phase)
      gg_snprintf(buf, 100, 
		  "%s in semeai %s-%s (variation %d, value %d, owl_phase)",
		  message, sbuf1, sbuf2, count_variations, value);
    else
      gg_snprintf(buf, 100, 
		  message, sbuf1, sbuf2, count_variations, value);
    sgftreeAddPlayLast(sgf_dumptree, NULL, color, I(pos), J(pos));
    sgftreeAddComment(sgf_dumptree, NULL, buf);
  }
  
  if (count_variations)
    count_variations++;
  stats.nodes++;

  return 1;
}


/*
 * tryko pushes the position onto the stack, and makes a move
 * at (pos) of (color). The move is allowed even if it is an
 * illegal ko capture. It is to be imagined that (color) has
 * made an intervening ko threat which was answered and now
 * the continuation is to be explored.
 *
 * Return 1 if the move is legal with the above caveat. Returns
 * zero if it is not legal because of suicide.
 */

int 
tryko(int pos, int color, const char *message, int komaster, int kom_pos)
{
  /* Do the real work elsewhere. */
  if (!do_trymove(pos, color, 1))
    return 0;

  if (sgf_dumptree) {
    char buf[100];
    if (message == NULL)
      message = "UNKNOWN";
    if (!komaster_is_empty(komaster, kom_pos))
      gg_snprintf(buf, 100, "tryko: %s (variation %d, %lx, komaster %s:%s)", 
		  message, count_variations, hashdata.hashval[0],
		  komaster_to_string(komaster, kom_pos), 
                  location_to_string(kom_pos));
    else
      gg_snprintf(buf, 100, "tryko: %s (variation %d, %lx)", 
		  message, count_variations, hashdata.hashval[0]);

    /* Add two pass moves to the SGF output to simulate the ko threat
     * and the answer.
     *
     * The reason we add these is that certain SGF viewers, including
     * Cgoban 1, won't properly display variations with illegal ko
     * captures. SGF FF[4] compliant browsers should have no problem
     * with this, though.
     */
    sgftreeAddPlayLast(sgf_dumptree, NULL, color, -1, -1);
    sgftreeAddComment(sgf_dumptree, NULL, "tenuki (ko threat)");
    sgftreeAddPlayLast(sgf_dumptree, NULL, OTHER_COLOR(color), -1, -1);
    sgftreeAddComment(sgf_dumptree, NULL, "tenuki (answers ko threat)");

    sgftreeAddPlayLast(sgf_dumptree, NULL, color, I(pos), J(pos));
    sgftreeAddComment(sgf_dumptree, NULL, buf);
  }
  
  if (count_variations)
    count_variations++;
  stats.nodes++;

  return 1;
}


/*
 * Do the main work of trymove() and tryko(), i.e. the common parts.
 * The ignore_ko flag tells whether an illegal ko capture may be done.
 * Return 1 if the move was valid, otherwise 0.
 */

static int 
do_trymove(int pos, int color, int ignore_ko)
{
  if (0 || KOMASTER_TRACE) {
    if (tracing_inside_komaster)
      gprintf("%o  ");

    if (ignore_ko)
      gprintf("%otryko");
    else
      gprintf("%otrymove");

    gprintf("%o %C %1m\n", color, pos);
  }

  /* 1. The move must be inside the board and the color must be BLACK
   * or WHITE.
   */
  ASSERT_ON_BOARD1(pos);
  gg_assert(color == BLACK || color == WHITE);
 
  /* Update the reading tree shadow. */
  shadow[pos] = 1;

  /* 2. The location must be empty. */
  if (board[pos] != EMPTY)
    return 0;

  /* 3. The location must not be the ko point, unless ignore_ko == 1. */
  if (!ignore_ko && pos == board_ko_pos) {
    if (board[WEST(pos)] == OTHER_COLOR(color)
	|| board[EAST(pos)] == OTHER_COLOR(color)) {
      RTRACE("%1m would violate the ko rule\n", pos);
      return 0;
    }
  }

  /* 4. Test for suicide. */
  if (is_suicide(pos, color)) {
    RTRACE("%1m would be suicide\n", pos);
    return 0;
  }
  
  /* Check for stack overflow. */
  if (stackp >= MAXSTACK-2) {
    fprintf(stderr, 
	    "gnugo: Truncating search. This is beyond my reading ability!\n");
    /* FIXME: Perhaps it's best to just assert here and be done with it? */
    if (0) {
      ASSERT1(0 && "trymove stack overflow", pos);
    }
    if (verbose > 0) {
      showboard(0);
      dump_stack();
    }
    fflush(stdout);
    fflush(stderr);
    return 0;
  }


  /* Only count trymove when we do create a new position. */
  trymove_counter++;
  
  /* So far, so good. Now push the move on the move stack. These are
   * needed for dump_stack().
   */
  stack[stackp] = pos;
  move_color[stackp] = color;

  /*
   * FIXME: Do we really have to store hashdata in a stack?
   *
   * Answer: No, we don't.  But for every stone that we add
   *         or remove, we must call hashdata_invert_stone(). This is
   *         not difficult per se, but the whole board.c 
   *         will have to be checked, and there is lots of room
   *         for mistakes.
   *
   *         At the same time, profiling shows that storing the
   *         hashdata in a stack doesn't take a lot of time, so
   *         this is not an urgent FIXME.
   */
  BEGIN_CHANGE_RECORD();
  PUSH_VALUE(board_ko_pos);
  memcpy(&hashdata_stack[stackp], &hashdata, sizeof(hashdata));

  if (board_ko_pos != NO_MOVE)
    hashdata_invert_ko(&hashdata, board_ko_pos);
  board_ko_pos = NO_MOVE;
  
  PUSH_VALUE(black_captured);
  PUSH_VALUE(white_captured);

  ++stackp;

  if (verbose == 4)
    dump_stack();

  do_play_move(pos, color);

  return 1;
}


/*
 * popgo pops the position from the stack.
 */

void
popgo()
{
  stackp--;
  
  undo_trymove();
  
  memcpy(&hashdata, &(hashdata_stack[stackp]), sizeof(hashdata));
  if (sgf_dumptree) {
    char buf[100];
    gg_snprintf(buf, 100, "(next variation: %d)", count_variations);
    sgftreeAddComment(sgf_dumptree, NULL, buf);
    sgf_dumptree->lastnode = sgf_dumptree->lastnode->parent;
    /* After tryko() we need to undo two pass nodes too. Since we have
     * no other way to identify ko moves, we skip all pass nodes.
     */
    while (is_pass_node(sgf_dumptree->lastnode, board_size))
      sgf_dumptree->lastnode = sgf_dumptree->lastnode->parent;
  }
}


/* Silent version of popgo(), suitable for use if you have called
 * do_trymove() without passing through trymove() or tryko().
 */

static void
silent_popgo(void)
{
  stackp--;
  undo_trymove();
  memcpy(&hashdata, &(hashdata_stack[stackp]), sizeof(hashdata));
}


/* Restore board state to the position before the last move. This is
 * accomplished by popping everything that was stored on the stacks
 * since the last BEGIN_CHANGE_RECORD().
 */

static void
undo_trymove()
{
  if (0 || KOMASTER_TRACE) {
    if (tracing_inside_komaster) {
      gprintf("%o  ");
    }
    gprintf("%opopgo\n");
  }

  gg_assert(strings_initialized);
  gg_assert(change_stack_pointer - change_stack <= STACK_SIZE);

  if (0) {
    gprintf("Change stack size = %d\n", change_stack_pointer - change_stack);
    gprintf("Vertex stack size = %d\n", vertex_stack_pointer - vertex_stack);
  }

  POP_MOVE();
  POP_VERTICES();
}




/*
 * dump_stack() for use under gdb prints the move stack. 
 */

void
dump_stack(void)
{
  int n;

  for (n = 0; n < stackp; n++)
    gprintf("%o%s:%1m ", move_color[n] == BLACK ? "B" : "W", stack[n]);
  
#if !TRACE_READ_RESULTS
  if (count_variations)
    gprintf("%o (variation %d)", count_variations-1);
#else
  gprintf("%o (%d)", hashdata.hashval[0]);
#endif

  gprintf("%o\n");
  fflush(stdout);
  fflush(stderr);
}


/* ================================================================ */
/*                     Permanent moves                              */
/* ================================================================ */


static void
reset_move_history(void)
{
  memcpy(initial_board, board, sizeof(board));
  initial_board_ko_pos = board_ko_pos;
  initial_white_captured = white_captured;
  initial_black_captured = black_captured;
  move_history_pointer = 0;
}

/* Place a stone on the board and update the hashdata. This operation
 * destroys all move history.
 */

void
add_stone(int pos, int color)
{
  ASSERT1(stackp == 0, pos);
  ASSERT_ON_BOARD1(pos);
  ASSERT1(board[pos] == EMPTY, pos);

  board[pos] = color;
  hashdata_invert_stone(&hashdata, pos, color);
  reset_move_history();
  new_position();
}


/* Remove a stone from the board and update the hashdata. This
 * operation destroys the move history.
 */

void
remove_stone(int pos)
{
  ASSERT1(stackp == 0, pos);
  ASSERT_ON_BOARD1(pos);
  ASSERT1(IS_STONE(board[pos]), pos);

  hashdata_invert_stone(&hashdata, pos, board[pos]);
  board[pos] = EMPTY;
  reset_move_history();
  new_position();
}

static void
play_move_no_history(int pos, int color)
{
#if CHECK_HASHING
  Hash_data oldkey;

  /* Check the hash table to see if it corresponds to the cumulative one. */
  hashdata_recalc(&oldkey, board, board_ko_pos);
#if FULL_POSITION_IN_HASH
  gg_assert(hashdata_diff_dump(&oldkey, &hashdata) == 0);
#else
  gg_assert(hashdata_compare(&oldkey, &hashdata) == 0);
#endif
#endif

  if (board_ko_pos != NO_MOVE)
    hashdata_invert_ko(&hashdata, board_ko_pos);
  board_ko_pos = NO_MOVE;

  /* If the move is a pass, we can skip some steps. */
  if (pos != PASS_MOVE) {
    ASSERT_ON_BOARD1(pos);
    ASSERT1(board[pos] == EMPTY, pos);

    /* Do play the move. */
    do_play_move(pos, color);

#if CHECK_HASHING
    /* Check the hash table to see if it equals the previous one. */
    hashdata_recalc(&oldkey, board, board_ko_pos);
#if FULL_POSITION_IN_HASH
    gg_assert(hashdata_diff_dump(&oldkey, &hashdata) == 0);
#else
    gg_assert(hashdata_compare(&oldkey, &hashdata) == 0);
#endif
#endif
  }
  new_position();
}

/* Load the initial position and replay the first n moves. */
static void
replay_move_history(int n)
{
  int k;
  
  memcpy(board, initial_board, sizeof(board));
  board_ko_pos = initial_board_ko_pos;
  white_captured = initial_white_captured;
  black_captured = initial_black_captured;
  new_position();

  for (k = 0; k < n; k++)
    play_move_no_history(move_history_pos[k], move_history_color[k]);
}

/* Play a move. If you want to test for legality you should first call
 * is_legal(). This function strictly follows the algorithm: 
 * 1. Place a stone of given color on the board.
 * 2. If there are any adjacent opponent strings without liberties,
 *    remove them and increase the prisoner count. 
 * 3. If the newly placed stone is part of a string without liberties,
 *    remove it and increase the prisoner count.
 *
 * In spite of the name "permanent move", this move can (usually) be
 * unplayed by undo_move(), but it is significantly more costly than
 * unplaying a temporary move. There are limitations on the available
 * move history, so under certain circumstances the move may not be
 * possible to unplay at a later time.
 */
void
play_move(int pos, int color)
{
  ASSERT1(stackp == 0, pos);

  if (move_history_pointer >= MAX_MOVE_HISTORY) {
    /* The move history is full. We resolve this by collapsing the
     * first about 10% of the moves into the initial position.
     */
    int number_collapsed_moves = 1 + MAX_MOVE_HISTORY / 10;
    int k;
    Intersection saved_board[BOARDSIZE];
    int saved_board_ko_pos = board_ko_pos;
    int saved_white_captured = white_captured;
    int saved_black_captured = black_captured;
    memcpy(saved_board, board, sizeof(board));

    replay_move_history(number_collapsed_moves);

    memcpy(initial_board, board, sizeof(board));
    initial_board_ko_pos = board_ko_pos;
    initial_white_captured = white_captured;
    initial_black_captured = black_captured;

    for (k = number_collapsed_moves; k < move_history_pointer; k++) {
      move_history_color[k - number_collapsed_moves] = move_history_color[k];
      move_history_pos[k - number_collapsed_moves] = move_history_pos[k];
    }
    move_history_pointer -= number_collapsed_moves;

    memcpy(board, saved_board, sizeof(board));
    board_ko_pos = saved_board_ko_pos;
    white_captured = saved_white_captured;
    black_captured = saved_black_captured;
  }

  move_history_color[move_history_pointer] = color;
  move_history_pos[move_history_pointer] = pos;
  move_history_pointer++;
  
  play_move_no_history(pos, color);
  
  movenum++;
}


/* Undo n permanent moves. Returns 1 if successful and 0 if it fails.
 * If n moves cannot be undone, no move is undone.
 */
int
undo_move(int n)
{
  gg_assert(stackp == 0);
  
  /* Fail if and only if the move history is too short. */
  if (move_history_pointer < n)
    return 0;

  replay_move_history(move_history_pointer - n);
  move_history_pointer -= n;
  movenum -= n;

  return 1;
}


/* Return the last move done by the opponent to color. Both if no move
 * was found or if the last move was a pass, PASS_MOVE is returned.
 */
int
get_last_opponent_move(int color)
{
  int k;
  
  for (k = move_history_pointer - 1; k >= 0; k--)
    if (move_history_color[k] == OTHER_COLOR(color))
      return move_history_pos[k];

  return PASS_MOVE;
}

/* Return the last move done by anyone. Both if no move was found or
 * if the last move was a pass, PASS_MOVE is returned.
 */
int
get_last_move()
{
  if (move_history_pointer == 0)
    return PASS_MOVE;

  return move_history_pos[move_history_pointer - 1];
}

/* ================================================================ */
/*                        Utility functions                         */
/* ================================================================ */


/*
 * Test if the move is a pass or not.  Return 1 if it is.
 */

int
is_pass(int pos)
{
  return pos == 0;
}


/*
 * is_legal(pos, color) determines whether the move (color) at
 * pos is legal.
 */

int 
is_legal(int pos, int color)
{
  /* 0. A pass move is always legal. */
  if (pos == 0)
    return 1;

  /* 1. The move must be inside the board. */
  ASSERT_ON_BOARD1(pos);

  /* 2. The location must be empty. */
  if (board[pos] != EMPTY) 
    return 0;

  /* 3. The location must not be the ko point. */
  if (pos == board_ko_pos)
    if (board[WEST(pos)] == OTHER_COLOR(color)
	|| board[EAST(pos)] == OTHER_COLOR(color)) {
      RTRACE("%1m would violate the ko rule\n", pos);
      return 0;
    }

  /* Check for stack overflow. */
  if (stackp >= MAXSTACK-2) {
    fprintf(stderr, 
	    "gnugo: Truncating search. This is beyond my reading ability!\n");
    /* FIXME: Perhaps it's best to just assert here and be done with it? */
    if (0) {
      ASSERT1(0 && "is_legal stack overflow", pos);
    }
    return 0;
  }

  /* Check for suicide. */
  if (!allow_suicide && is_suicide(pos, color)) {
    RTRACE("%1m would be suicide\n", pos);
    return 0;
  }
  
  return 1;
}


/*
 * is_suicide(pos, color) determines whether the move (color) at
 * (pos) would be a suicide.
 *
 * This is the case if
 * 1. There is no neighboring empty intersection.
 * 2. There is no neighboring opponent string with exactly one liberty.
 * 3. There is no neighboring friendly string with more than one liberty.
 */
int 
is_suicide(int pos, int color)
{
  ASSERT_ON_BOARD1(pos);
  ASSERT1(board[pos] == EMPTY, pos);

  if (!strings_initialized)
    init_board();
  
  /* Check for suicide. */
  if (LIBERTY(SOUTH(pos))
      || (ON_BOARD(SOUTH(pos))
	  && ((board[SOUTH(pos)] == color) ^ (LIBERTIES(SOUTH(pos)) == 1))))
    return 0;

  if (LIBERTY(WEST(pos))
      || (ON_BOARD(WEST(pos))
	  && ((board[WEST(pos)] == color) ^ (LIBERTIES(WEST(pos)) == 1))))
    return 0;

  if (LIBERTY(NORTH(pos))
      || (ON_BOARD(NORTH(pos))
	  && ((board[NORTH(pos)] == color) ^ (LIBERTIES(NORTH(pos)) == 1))))
    return 0;

  if (LIBERTY(EAST(pos))
      || (ON_BOARD(EAST(pos))
	  && ((board[EAST(pos)] == color) ^ (LIBERTIES(EAST(pos)) == 1))))
    return 0;

  return 1;
}


/*
 * is_illegal_ko_capture(pos, color) determines whether the move
 * (color) at (pos) would be an illegal ko capture.
 */
int 
is_illegal_ko_capture(int pos, int color)
{
  ASSERT_ON_BOARD1(pos);
  ASSERT1(board[pos] == EMPTY, pos);

  return (pos == board_ko_pos
	  && ((board[WEST(pos)] == OTHER_COLOR(color))
	      || (board[EAST(pos)] == OTHER_COLOR(color))));
}


/* Variation of trymove()/tryko() where ko captures (both conditional
 * and unconditional) must follow a komaster scheme.
 *
 * FIXME: This function could be optimized by integrating the
 * trymove()/tryko() code.
 */

#if KOMASTER_TRACE

/* This version of komaster_trymove is for tracing the calls to 
 * and return values from komaster_trymove.
 */
int komaster_trymove_ORIGINAL(int pos, int color,
			      const char *message, int str,
			      int komaster, int kom_pos,
			      int *new_komaster, int *new_kom_pos,
			      int *is_conditional_ko,
			      int consider_conditional_ko);

int
komaster_trymove(int pos, int color, const char *message, int str,
		 int komaster, int kom_pos,
		 int *new_komaster, int *new_kom_pos,
		 int *is_conditional_ko, int consider_conditional_ko)
{
  int ret;
  int traceon = 1;
  tracing_inside_komaster = 1;
  if (traceon) {
    gprintf("%okomaster_trymove %1m %C %s %1m %d\n",
                pos,
                color,
    	        komaster_to_string(komaster, kom_pos),
	        kom_pos,
                consider_conditional_ko);
  }
  ret = komaster_trymove_ORIGINAL(
                pos, color, message, str,
	  	komaster, kom_pos,
		new_komaster, new_kom_pos,
		is_conditional_ko, consider_conditional_ko);
  if (traceon) {
    if (*is_conditional_ko 
        || komaster != *new_komaster 
        || kom_pos  != *new_kom_pos) {
      char buff[255];
      gg_snprintf(buff, 255, "komaster:%s@%s->%s@%s is_conditional_ko:%d\n",
              komaster_to_string(komaster, kom_pos), 
              location_to_string(kom_pos),
              komaster_to_string(*new_komaster, *new_kom_pos),
              location_to_string(*new_kom_pos),
              *is_conditional_ko);
      gprintf("%o%s", buff);
      if (sgf_dumptree) {
        sgftreeAddComment(sgf_dumptree, NULL, buff);
      }
    }
  }
  tracing_inside_komaster = 0;
  return ret;
}


/* Replace komaster_trymove implementation with komaster_trymove_trace */
#define komaster_trymove komaster_trymove_ORIGINAL

#endif /* KOMASTER_TRACE */


#if KOMASTER_SCHEME == 1

/* I. Dan's simple scheme, O to move.
 * 
 * 1. Komaster is EMPTY.
 * 1a) Unconditional ko capture is allowed. Komaster remains EMPTY.
 * 1b) Conditional ko capture is allowed. Komaster is set to O and
 *     kom_pos to the location of the ko, where a stone was
 *     just removed.
 * 
 * 2. Komaster is O:
 * 2a) Only nested ko captures are allowed.
 * 2b) If komaster fills the ko at kom_pos then komaster reverts to
 *     EMPTY.
 * 
 * 3. Komaster is X:
 *    Play at kom_pos is not allowed. Any other ko capture
 *    is allowed. If O takes another ko, komaster becomes GRAY.
 * 
 * 4. Komaster is GRAY:
 *    Ko captures are not allowed. If the ko at kom_pos is
 *    filled then the komaster reverts to EMPTY.
 * 
 */
int
komaster_trymove(int pos, int color, const char *message, int str,
		 int komaster, int kom_pos,
		 int *new_komaster, int *new_kom_pos,
		 int *is_conditional_ko, int consider_conditional_ko)
{
  int other = OTHER_COLOR(color);
  int ko_move;
  int kpos;

  /* First we check whether the ko claimed by komaster has been
   * resolved. If that is the case, we revert komaster to EMPTY.
   *
   * The ko has been resolved in favor of the komaster if it has
   * been filled, or if it is no longer a ko and an opponent move
   * there is suicide. If komaster == GRAY we don't remember who
   * owns the ko so we have to try both colors.
   */
  if (komaster != EMPTY
      && (IS_STONE(board[kom_pos])
	  || (komaster != GRAY
	      && !is_ko(kom_pos, OTHER_COLOR(komaster), NULL)
	      && is_suicide(kom_pos, OTHER_COLOR(komaster)))
	  || (komaster == GRAY
	      && !is_ko(kom_pos, BLACK, NULL)
	      && !is_ko(kom_pos, WHITE, NULL)
	      && (is_suicide(kom_pos, BLACK)
		  || is_suicide(kom_pos, WHITE))))) {
    komaster = EMPTY;
    kom_pos = 0;
  }

  /* Usually the komaster parameters are unchanged. */
  *new_komaster = komaster;
  *new_kom_pos = kom_pos;

  *is_conditional_ko = 0;
  ko_move = is_ko(pos, color, &kpos);

  if (ko_move) {
    /* If opponent is komaster we may not capture his ko. */
    if (komaster == other && pos == kom_pos)
      return 0;

    /* If komaster is gray we may not capture ko at all. */
    if (komaster == GRAY)
      return 0;

    /* If we are komaster, we may only do nested captures. */
    if (komaster == color
	&& !(kpos == SW(kom_pos) || kpos == NW(kom_pos)
	     || kpos == NE(kom_pos) || kpos == SE(kom_pos)))
      return 0;
  }

  if (!trymove(pos, color, message, str, komaster, kom_pos)) {
    if (!consider_conditional_ko)
      return 0;

    if (!tryko(pos, color, message, komaster, kom_pos))
      return 0; /* Suicide. */
      
    *is_conditional_ko = 1;

    /* Conditional ko capture, set komaster parameters. */
    if (komaster == EMPTY) {
      *new_komaster = color;
      *new_kom_pos = kpos;
      return 1;
    }
  }

  if (!ko_move)
    return 1;

  if (komaster == other)
    *new_komaster = GRAY;
  *new_kom_pos = kpos;

  return 1;
}

#endif

#if KOMASTER_SCHEME == 5

#define GRAY_WHITE 4
#define GRAY_BLACK 5
#define WEAK_KO    6

/* V. Complex scheme, O to move.
 * 
 * 1. Komaster is EMPTY.
 * 1a) Unconditional ko capture is allowed.
 *       Komaster remains EMPTY if previous move was not a ko capture.
 *       Komaster is set to WEAK_KO if previous move was a ko capture
 *       and kom_pos is set to the old value of board_ko_pos.
 * 1b) Conditional ko capture is allowed. Komaster is set to O and
 *     kom_pos to the location of the ko, where a stone was
 *     just removed.
 * 
 * 2. Komaster is O:
 * 2a) Only nested ko captures are allowed. Kom_pos is moved to the
 *     new removed stone.
 * 2b) If komaster fills the ko at kom_pos then komaster reverts to
 *     EMPTY.
 * 
 * 3. Komaster is X:
 *    Play at kom_pos is not allowed. Any other ko capture
 *    is allowed. If O takes another ko, komaster becomes GRAY_X.
 * 
 * 4. Komaster is GRAY_O or GRAY_X:
 *    Ko captures are not allowed. If the ko at kom_pos is
 *    filled then the komaster reverts to EMPTY.
 *
 * 5. Komaster is WEAK_KO:
 * 5a) After a non-ko move komaster reverts to EMPTY.
 * 5b) Unconditional ko capture is only allowed if it is nested ko capture.
 *     Komaster is changed to WEAK_X and kom_pos to the old value of
 *     board_ko_pos.
 * 5c) Conditional ko capture is allowed according to the rules of 1b.
 */
int
komaster_trymove(int pos, int color, const char *message, int str,
		 int komaster, int kom_pos,
		 int *new_komaster, int *new_kom_pos,
		 int *is_conditional_ko, int consider_conditional_ko)
{
  int other = OTHER_COLOR(color);
  int ko_move;
  int kpos;
  int previous_board_ko_pos = board_ko_pos;

  /* First we check whether the ko claimed by komaster has been
   * resolved. If that is the case, we revert komaster to EMPTY.
   *
   * The ko has been resolved in favor of the komaster if it has
   * been filled, or if it is no longer a ko and an opponent move
   * there is suicide.
   */
  if (((komaster == WHITE || komaster == GRAY_WHITE)
       && (IS_STONE(board[kom_pos])
	   || (!is_ko(kom_pos, BLACK, NULL)
	       && is_suicide(kom_pos, BLACK))))
      || ((komaster == BLACK || komaster == GRAY_BLACK)
	  && (IS_STONE(board[kom_pos])
	      || (!is_ko(kom_pos, WHITE, NULL)
		  && is_suicide(kom_pos, WHITE))))) {
    komaster = EMPTY;
    kom_pos = NO_MOVE;
  }

  /* Usually the komaster parameters are unchanged. */
  *new_komaster = komaster;
  *new_kom_pos = kom_pos;

  *is_conditional_ko = 0;
  ko_move = is_ko(pos, color, &kpos);

  if (!ko_move) {
    if (komaster == WEAK_KO) {
      *new_komaster = EMPTY;
      *new_kom_pos = NO_MOVE;
    }
  }
  else {
    /* If opponent is komaster we may not capture his ko. */
    if (komaster == other && pos == kom_pos)
      return 0;

    /* If komaster is gray we may not capture ko at all. */
    if (komaster == GRAY_WHITE || komaster == GRAY_BLACK)
      return 0;

    /* If we are komaster, we may only do nested captures. */
    if (komaster == color
	&& !(kpos == SW(kom_pos) || kpos == NW(kom_pos)
	     || kpos == NE(kom_pos) || kpos == SE(kom_pos)))
      return 0;

    /* If komaster is WEAK_KO, we may only do nested ko capture or
     * conditional ko capture.
     */
    if (komaster == WEAK_KO) {
      if (pos != board_ko_pos
	  && !(kpos == SW(kom_pos) || kpos == NW(kom_pos)
	       || kpos == NE(kom_pos) || kpos == SE(kom_pos)))
	return 0;
    }
  }

  if (!trymove(pos, color, message, str, komaster, kom_pos)) {
    if (!consider_conditional_ko)
      return 0;

    if (!tryko(pos, color, message, komaster, kom_pos))
      return 0; /* Suicide. */
      
    *is_conditional_ko = 1;

    /* Conditional ko capture, set komaster parameters. */
    if (komaster == EMPTY || komaster == WEAK_KO) {
      *new_komaster = color;
      *new_kom_pos = kpos;
      return 1;
    }
  }

  if (!ko_move)
    return 1;

  if (komaster == other) {
    if (color == WHITE)
      *new_komaster = GRAY_BLACK;
    else
      *new_komaster = GRAY_WHITE;
  }
  else if (komaster == color) {
    /* This is where we update kom_pos after a nested capture. */
    *new_kom_pos = kpos;
  }
  else {
    /* We can reach here when komaster is EMPTY or WEAK_KO. If previous
     * move was also a ko capture, we now set komaster to WEAK_KO.
     */
    if (previous_board_ko_pos != NO_MOVE) {
      *new_komaster = WEAK_KO;
      *new_kom_pos = previous_board_ko_pos;
    }
  }
  
  return 1;
}

#endif

#if KOMASTER_SCHEME == 2

/* Simple komaster scheme, equivalent to the one implemented in 2.7.232.
 *
 * (II) Original 2.7.232 scheme, O to move.
 * 
 * 1. Komaster is EMPTY.
 * 1a) Unconditional ko capture is allowed. Komaster remains EMPTY.
 * 1b) Conditional ko capture is allowed. Komaster is set to O and
 *     kom_pos to the location of the ko, where a stone was
 *     just removed.
 * 
 * 2. Komaster is O:
 * 2a) Conditional ko capture is not allowed.
 * 2b) Unconditional ko capture is allowed. Komaster parameters unchanged.
 * 
 * 3. Komaster is X:
 * 3a) Conditional ko capture is not allowed.
 * 3b) Unconditional ko capture is allowed except for a move at kom_pos.
 *     Komaster parameters unchanged.
 * 
 * 4. Komaster is GRAY:
 *    Doesn't happen.
 */
int
komaster_trymove(int pos, int color, const char *message, int str,
		 int komaster, int kom_pos,
		 int *new_komaster, int *new_kom_pos,
		 int *is_conditional_ko, int consider_conditional_ko)
{
  int other = OTHER_COLOR(color);
  int kpos;

  /* Usually the komaster parameters are unchanged. */
  *new_komaster = komaster;
  *new_kom_pos = kom_pos;

  *is_conditional_ko = 0;

  /* If opponent is komaster we may not capture his ko. */
  if (is_ko(pos, color, &kpos) && komaster == other && pos == kom_pos)
    return 0;

  if (trymove(pos, color, message, str, komaster, kom_pos))
    return 1;

  /* Conditional ko captures are only allowed if the komaster is EMPTY. */
  if (!consider_conditional_ko || komaster != EMPTY)
    return 0;

  if (tryko(pos, color, message, komaster, kom_pos)) {
    /* Conditional ko capture, set komaster parameters. */
    *new_komaster = color;
    *new_kom_pos = kpos;
    *is_conditional_ko = 1;
    return 1;
  }
  
  /* If we come here, the move was a suicide. */
  return 0;
}

#endif

#if KOMASTER_SCHEME == 3

/* Slightly more complex komaster scheme.
 *
 * (III) Revised 2.7.232 version, O to move.
 * 
 * 1. Komaster is EMPTY.
 * 1a) Unconditional ko capture is allowed. Komaster remains EMPTY.
 * 1b) Conditional ko capture is allowed. Komaster is set to O and
 *     kom_pos to the location of the ko, where a stone was
 *     just removed.
 * 
 * 2. Komaster is O:
 *    Ko capture (both kinds) is allowed only if after playing the move,
 *    is_ko(kom_pos, X) returns false. In that case, kom_pos
 *    is updated to the new ko position, i.e. the stone captured by this
 *    move. 
 * 
 * 3. Komaster is X:
 * 3a) Conditional ko capture is not allowed.
 * 3b) Unconditional ko capture is allowed except for a move at kom_pos.
 *     Komaster parameters unchanged.
 * 
 * 4. Komaster is GRAY:
 *    Doesn't happen.
 * 
 */
int
komaster_trymove(int pos, int color, const char *message, int str,
		 int komaster, int kom_pos,
		 int *new_komaster, int *new_kom_pos,
		 int *is_conditional_ko, int consider_conditional_ko)
{
  int other = OTHER_COLOR(color);
  int ko_move;
  int kpos;

  /* Usually the komaster parameters are unchanged. */
  *new_komaster = komaster;
  *new_kom_pos = kom_pos;

  *is_conditional_ko = 0;

  /* If opponent is komaster we may not capture his ko. */
  ko_move = is_ko(pos, color, &kpos);
  if (ko_move && komaster == other && pos == kom_pos)
    return 0;

  if (!trymove(pos, color, message, str, komaster, kom_pos)) {
    /* Conditional ko captures are allowed if komaster is EMPTY or our
     * color.
     */
    if (!consider_conditional_ko || komaster == other)
      return 0;

    if (!tryko(pos, color, message, komaster, kom_pos))
      return 0; /* Suicide. */
      
    *is_conditional_ko = 1;

    /* Conditional ko capture, set komaster parameters. */
    if (komaster == EMPTY) {
      *new_komaster = color;
      *new_kom_pos = kpos;
    }
  }

  if (!ko_move)
    return 1;

  /* Remains to check that if we are komaster, the old ko is gone. */
  if (komaster != color)
    return 1;
  
  if (!is_ko(kom_pos, other, NULL)) {
    *new_kom_pos = kpos;
    return 1;
  }

  /* The old ko was still around, move not accepted. */
  popgo();
  return 0;
}

#endif


#if KOMASTER_SCHEME == 4

/* Returns true if the (pos1) and (pos2) are directly adjacent */
static int
is_next_to(int pos1, int pos2)
{
  int diff = pos1 - pos2;
  ASSERT_ON_BOARD1(pos1);
  ASSERT_ON_BOARD1(pos2);
  return diff == WE || diff == -WE || diff == NS || diff == -NS;
}

#define KOMASTER_X 1
#define KOMASTER_LEGAL 2

/* (IV) A different komaster approach.
 * As of 3.1.27 it's quite slow, and has been tested primarily
 * in the context of pattern-based reading, where the other 
 * komaster schemes weren't sufficient.  It does eliminate all
 * tested cyclic ko problems, but still fails a few regressions.
 *
 * Currently this komaster scheme is slow.
 * 
 * If kom_pos == PASS, then there is no ko restriction in place.
 * This allows us to forgo an empty komaster status.  The extra
 * 1/2 bit gives us room to track some more information.
 * Logically, the komaster can take these values:
 *   KOMASTER_O_legal    0
 *   KOMASTER_X_legal    1
 *   KOMASTER_O_illegal  2
 *   KOMASTER_X_illegal  3
 * These values aren't actually defined, but are built up out
 * of KOMASTER_X and KOMASTER_LEGAL.  They're used in the comments
 * below for simplicity, however.
 *
 * 1. Komaster_pos is PASS:
 *   Move always allowed.
 *   If it's a legal ko capture, then komaster becomes KOMASTER_{OX}_legal, 
 *     and komaster_pos set to (pos). OX determined by color parameter.
 *   If it's an illegal ko capture, komaster becomes KOMASTER_{OX}_illegal,
 *     and komaster_pos set to (pos). OX determined by color parameter.
 *     If !consider_conditional_ko, the move is not allowed.
 *   If it's not a ko, komaster_pos remains PASS.
 *
 * The treatment of KOMASTER_O and KOMASTER_X are always identical,
 * simply with the player to move switched.  Below, only one of the
 * two identical cases is given.
 *
 * 2. Komaster_pos is (pos), komaster is KOMASTER_O_legal:
 * 2a X to play:
 *    if pos takes same ko as komaster_pos:
 *      if legal, komaster becomes KOMASTER_X_illegal (!).
 *      if illegal (ko threat required),
 *        if consider_conditional_ko
 *          komaster becomes KOMASTER_X_illegal.
 *    X may make any other legal move, including kos, and the komaster
 *      does not change.
 * 2b O to play:
 *    O may resolve this ko, or take a related ko.
 *      if it's a related ko, the komaster_pos changes to this related ko.
 *    O may not take an unrelated ko.  He must resolve this one first.  This
 *      avoids triple ko problems.
 *
 * 3. Komaster_pos is (pos), komaster is KOMASTER_O_illegal:
 * 3a X simply resolves to a trymove(), since O's already made a conditional
 *      capture, X may not make a conditional capture too.
 * 3b O's play is identical to the legal case.  The next statment is probably 
 *      bogus: In particular, he may happily re-take this ko at any time, in 
 *      case X took it back (legally).
 */

int
komaster_trymove(int pos, int color, const char *message, int str,
		 int komaster, int kom_pos,
		 int *new_komaster, int *new_kom_pos,
		 int *is_conditional_ko, int consider_conditional_ko)
{
  int other = OTHER_COLOR(color);
  int ko_move;
  int kpos;
  int new_kom_color_flag = (color == BLACK) ? KOMASTER_X : 0;
  int kom_color = (komaster & KOMASTER_X) ? BLACK : WHITE;
  int log_illegal_moves = !!sgf_dumptree;

  if (!ON_BOARD1(kom_pos) 
      || board[kom_pos] != kom_color
      || !is_ko_point(kom_pos)
      || !board_ko_pos) {
    /* Try clearing komaster is the prev. move is not a ko.
     * i.e. it could have been an internal ko threat.*/
    /* ko's been resolved clear komaster */
    komaster = 0;
    kom_pos = PASS_MOVE;
  }
  /* komaster parameters are a typical default. */
  *new_komaster = komaster;
  *new_kom_pos = kom_pos;
  *is_conditional_ko = 0;

  ko_move = is_ko(pos, color, &kpos);

  if (kom_pos == PASS_MOVE) {
    if (trymove(pos, color, message, str, komaster, kom_pos)) {
      if (ko_move) {
        *new_kom_pos = pos;
        *new_komaster = KOMASTER_LEGAL + new_kom_color_flag;
      } /* else: legal non-ko move (usual case), no komaster change. */
      return 1;
    }
    else {
      if (consider_conditional_ko) {
        if (tryko(pos, color, message, komaster, kom_pos)) {
          /* Must be an illegal ko capture*/
          *new_kom_pos = pos;
          *new_komaster = new_kom_color_flag; /*don't set KOMASTER_LEGAL bit*/
          *is_conditional_ko = 1;
          return 1;
        }
	else {
          /* completely illegal move */
          return 0;
        }
      }
      else {
        /* don't even try to fake a ko threat. */
        if (log_illegal_moves) {
          if (tryko(pos, color, message, komaster, kom_pos)) {
            sgftreeAddComment(sgf_dumptree, NULL, 
                "ILLEGAL - Conditional ko capture not requested. (A)");
            popgo();
          }
        }
        return 0;
      }
    }
  }

  ASSERT_ON_BOARD1(kom_pos);

  /* Different color to move than komaster */
  if (new_kom_color_flag != (komaster & KOMASTER_X)) {
    /* if komaster is ILLEGAL, don't allow opponent to retake the ko. */
    if (!(komaster & KOMASTER_LEGAL)) {
      if (is_next_to(pos, kom_pos)) {
        /* don't let color retake an already spoken-for ko. */
        if (log_illegal_moves) {
          if (tryko(pos, color, message, komaster, kom_pos)) {
            sgftreeAddComment(sgf_dumptree, NULL, 
                "ILLEGAL - Can't retake other player's ko.");
            popgo();
          }
        }
        return 0;
      }
    }
    /* komaster is LEGAL */
    if (trymove(pos, color, message, str, komaster, kom_pos)) {
      if (!is_next_to(pos, kom_pos)) {
        /* An unrelated legal move (possibly another ko) */
        return 1;
      }
      else {
        /* legal ko re-capture */
        *new_kom_pos = pos;
        /* Might be worth trying to set the legal bit to see what happens. */
        /* Note we set the komaster to ILLEGAL anyway to avoid loops */
        *new_komaster = new_kom_color_flag;  /*don't set KOMASTER_LEGAL bit */
        *is_conditional_ko = 0;  /* Should this be set to 1? */
        return 1;
      }
    }
    else {
      if (consider_conditional_ko) {
        if (tryko(pos, color, message, komaster, kom_pos)) {
          /* illegal ko re-capture */
          *new_kom_pos = pos;
          *new_komaster = new_kom_color_flag;  /*don't set KOMASTER_LEGAL bit */
          *is_conditional_ko = 1;
          return 1;
        }
	else {
          /* completely illegal move */
          return 0;
        }
      }
      else {
        /* don't even try to fake a ko threat. */
        if (log_illegal_moves) {
          if (tryko(pos, color, message, komaster, kom_pos)) {
            sgftreeAddComment(sgf_dumptree, NULL, 
                "ILLEGAL - Conditional ko capture not requested. (B)");
            popgo();
          }
        }
        return 0;
      }
    }
  }

  /* komaster is trying to make a move */
  ASSERT1(new_kom_color_flag == (komaster & KOMASTER_X), pos);

  /* Same color case: same for LEGAL or ILLEGAL komaster status. */
  /* If we are komaster, we may only do nested captures. */
  if (ko_move
      && kpos != SW(kom_pos) 
      && kpos != NW(kom_pos)
      && kpos != NE(kom_pos)
      && kpos != SE(kom_pos)) {
    if (log_illegal_moves) {
      if (tryko(pos, color, message, komaster, kom_pos)) {
        sgftreeAddComment(sgf_dumptree, NULL, "ILLEGAL - Komaster can't switch kos.");
        popgo();
      }
    }
    return 0;
  }
  else
    return trymove(pos, color, message, str, komaster, kom_pos);

  /* Should have taken care of all cases by here. */
  gg_assert(0 && "Getting here should not be possible.");
}

#endif


#undef komaster_trymove  /* In case KOMASTER_TRACE munged it */


/* Determine whether vertex is on the edge. */
int
is_edge_vertex(int pos)
{
  ASSERT_ON_BOARD1(pos);
  if (!ON_BOARD(SW(pos))
      || !ON_BOARD(NE(pos)))
    return 1;

  return 0;
}



/* Count the number of liberties of the string at pos. pos must not be
 * empty.
 */
int
countlib(int str)
{
  ASSERT1(IS_STONE(board[str]), str);
  
  if (!strings_initialized)
    init_board();

  /* We already know the number of liberties. Just look it up. */
  return string[string_number[str]].liberties;
}


/* Find the liberties of the string at str. str must not be
 * empty. The locations of up to maxlib liberties are written into
 * libs[]. The full number of liberties is returned.
 *
 * If you want the locations of all liberties, whatever their number,
 * you should pass MAXLIBS as the value for maxlib and allocate space
 * for libs[] accordingly.
 */

int
findlib(int str, int maxlib, int *libs)
{
  int k;
  int liberties;
  int s;
  
  ASSERT1(IS_STONE(board[str]), str);
  ASSERT1(libs != NULL, str);
  
  if (!strings_initialized)
    init_board();

  /* We already have the list of liberties and only need to copy it to
   * libs[].
   *
   * However, if the string has more than MAX_LIBERTIES liberties the
   * list is truncated and if maxlib is also larger than MAX_LIBERTIES
   * we have to traverse the stones in the string in order to find
   * where the liberties are.
   */
  s = string_number[str];
  liberties = string[s].liberties;

  if (liberties <= MAX_LIBERTIES || maxlib <= MAX_LIBERTIES) {
    /* The easy case, it suffices to copy liberty locations from the
     * incrementally updated list.
     */
    for (k = 0; k < maxlib && k < liberties; k++)
      libs[k] = string[s].libs[k];
  }
  else {
    /* The harder case, where we have to traverse the stones in the
     * string. We don't have to check explicitly if we are back to
     * the start of the chain since we will run out of liberties
     * before that happens.
     */
    int pos;
    liberty_mark++;
    for (k = 0, pos = FIRST_STONE(s);
	 k < maxlib && k < liberties;
	 pos = NEXT_STONE(pos)) {
      if (UNMARKED_LIBERTY(SOUTH(pos))) {
	libs[k++] = SOUTH(pos);
	MARK_LIBERTY(SOUTH(pos));
	if (k >= maxlib)
	  break;
      }
      
      if (UNMARKED_LIBERTY(WEST(pos))) {
	libs[k++] = WEST(pos);
	MARK_LIBERTY(WEST(pos));
	if (k >= maxlib)
	  break;
      }
      
      if (UNMARKED_LIBERTY(NORTH(pos))) {
	libs[k++] = NORTH(pos);
	MARK_LIBERTY(NORTH(pos));
	if (k >= maxlib)
	  break;
      }
      
      if (UNMARKED_LIBERTY(EAST(pos))) {
	libs[k++] = EAST(pos);
	MARK_LIBERTY(EAST(pos));
	if (k >= maxlib)
	  break;
      }
    }
  }
      
  return liberties;
}

/* Count the liberties a stone of the given color would get if played
 * at (pos).  Captures are ignored based on the ignore_capture flag.
 * (pos) must be empty.  It will fail if there is more than one
 * string neighbor of the same color.  In this case, the return value
 * is -1.  Captures are not handled, so if ignore_capture is 0, and
 * a capture is required, -1 is returned.
 *
 * The intent of this function is to be as fast as possible, not
 * necessarily complete.
 *
 * Note well, that it relies on incremental data (?), and the number
 * of liberties (if over MAX_LIBERTIES) may be inaccurate (?).
 */

int
fastlib(int pos, int color, int ignore_capture)
{
  int k;
  int ally1 = NO_MOVE;
  int ally2 = NO_MOVE;
  int fast_liberties = 0;
  int other = OTHER_COLOR(color);

  ASSERT1(board[pos] == EMPTY, pos);
  ASSERT1(IS_STONE(color), pos);

  if (!strings_initialized)
    init_board();

  for (k = 0; k < 4; k++) {
    int neighbor = pos + delta[k];
    if (board[neighbor] == color) {
      if (ally1 != NO_MOVE) {
        if (string_number[ally1] != string_number[neighbor]) { 
          if (ally2 != NO_MOVE) {
            if (string_number[ally2] != string_number[neighbor]) {
	      /* More than 2 allies not implemented (yet).*/
              return -1;
            }
          }
	  else
            ally2 = neighbor;
        }
      }
      else
        ally1 = neighbor;
    }
  }
  for (k = 0; k < 4; k++) {
    int neighbor = pos + delta[k];
    int neighbor_color = board[neighbor];
    if (!ignore_capture
        && neighbor_color == other
	&& LIBERTIES(neighbor) == 1) {
      int neighbor_size = COUNTSTONES(neighbor);
      if ((neighbor_size <= 2 && !ally1)
          || (neighbor_size == 1
              && ally1 
              && !ally2
              && countstones(ally1) == 1)) {
        /* Here, we can gain only the adjacent new liberty. */
        fast_liberties++;
      }
      else
        return -1;
    }
    if (neighbor_color == EMPTY) {
      if ((!ally1 || !liberty_of_string(neighbor, ally1))
          && (!ally2 || !liberty_of_string(neighbor, ally2))) {
	fast_liberties++;
      }
    }
  }

  if (ally1)
    fast_liberties += LIBERTIES(ally1) - 1;
  if (ally2)
    fast_liberties += LIBERTIES(ally2) - count_common_libs(ally1, ally2);
  return fast_liberties;
}

/* Find the liberties a stone of the given color would get if played
 * at (pos), ignoring possible captures of opponent stones. (pos)
 * must be empty. If libs != NULL, the locations of up to maxlib
 * liberties are written into libs[]. The counting of
 * liberties may or may not be halted when maxlib is reached. The
 * number of liberties found is returned.
 *
 * If you want the number or the locations of all liberties, however
 * many they are, you should pass MAXLIBS as the value for maxlib and
 * allocate space for libs[] accordingly.
 */

int
approxlib(int pos, int color, int maxlib, int *libs)
{
  int k;
  int liberties = 0;
  int fast_liberties = 0;

  ASSERT1(board[pos] == EMPTY, pos);
  ASSERT1(IS_STONE(color), pos);

  if (!libs) {
    fast_liberties = fastlib(pos, color, 1);
    if (fast_liberties >= 0) {
      return fast_liberties;
    }
  }

  if (!strings_initialized)
    init_board();

  /* Look for empty neighbors and the liberties of the adjacent
   * strings of the given color. The algorithm below won't work
   * correctly if any of the adjacent strings have more than
   * MAX_LIBERTIES liberties AND maxlib is larger than MAX_LIBERTIES.
   * If this might be the case, we use a more robust fallback.
   */
  if (maxlib > MAX_LIBERTIES)
    return slow_approxlib(pos, color, maxlib, libs);
  
  /* Start by marking pos itself so it isn't counted among its own
   * liberties.
   */
  liberty_mark++;
  MARK_LIBERTY(pos);
    
  if (UNMARKED_LIBERTY(SOUTH(pos))) {
    if (libs != NULL && liberties < maxlib)
      libs[liberties] = SOUTH(pos);
    liberties++;
    /* Stop counting if we reach maxlib. */
    if (liberties >= maxlib)
      return liberties;
    MARK_LIBERTY(SOUTH(pos));
  }
  else if (board[SOUTH(pos)] == color) {
    int s = string_number[SOUTH(pos)];
    for (k = 0; k < string[s].liberties; k++) {
      int lib = string[s].libs[k];
      if (UNMARKED_LIBERTY(lib)) {
	if (libs != NULL && liberties < maxlib)
	  libs[liberties] = lib;
	liberties++;
	if (liberties >= maxlib)
	  return liberties;
	MARK_LIBERTY(lib);
      }
    }
  }
  
  if (UNMARKED_LIBERTY(WEST(pos))) {
    if (libs != NULL && liberties < maxlib)
      libs[liberties] = WEST(pos);
    liberties++;
    /* Stop counting if we reach maxlib. */
    if (liberties >= maxlib)
      return liberties;
    MARK_LIBERTY(WEST(pos));
  }
  else if (board[WEST(pos)] == color) {
    int s = string_number[WEST(pos)];
    for (k = 0; k < string[s].liberties; k++) {
      int lib = string[s].libs[k];
      if (UNMARKED_LIBERTY(lib)) {
	if (libs != NULL && liberties < maxlib)
	  libs[liberties] = lib;
	liberties++;
	if (liberties >= maxlib)
	  return liberties;
	MARK_LIBERTY(lib);
      }
    }
  }
  
  if (UNMARKED_LIBERTY(NORTH(pos))) {
    if (libs != NULL && liberties < maxlib)
      libs[liberties] = NORTH(pos);
    liberties++;
    /* Stop counting if we reach maxlib. */
    if (liberties >= maxlib)
      return liberties;
    MARK_LIBERTY(NORTH(pos));
  }
  else if (board[NORTH(pos)] == color) {
    int s = string_number[NORTH(pos)];
    for (k = 0; k < string[s].liberties; k++) {
      int lib = string[s].libs[k];
      if (UNMARKED_LIBERTY(lib)) {
	if (libs != NULL && liberties < maxlib)
	  libs[liberties] = lib;
	liberties++;
	if (liberties >= maxlib)
	  return liberties;
	MARK_LIBERTY(lib);
      }
    }
  }
  
  if (UNMARKED_LIBERTY(EAST(pos))) {
    if (libs != NULL && liberties < maxlib)
      libs[liberties] = EAST(pos);
    liberties++;
    /* Stop counting if we reach maxlib. */
    if (liberties >= maxlib)
      return liberties;
    /* Unneeded since we're about to leave. */
#if 0
    MARK_LIBERTY(EAST(pos));
#endif
  }
  else if (board[EAST(pos)] == color) {
    int s = string_number[EAST(pos)];
    for (k = 0; k < string[s].liberties; k++) {
      int lib = string[s].libs[k];
      if (UNMARKED_LIBERTY(lib)) {
	if (libs != NULL && liberties < maxlib)
	  libs[liberties] = lib;
	liberties++;
	if (liberties >= maxlib)
	  return liberties;
	MARK_LIBERTY(lib);
      }
    }
  }  

  return liberties;
}


/* Find the number of common liberties of the two strings at str1 and str2.
 */

int
count_common_libs(int str1, int str2)
{
  int libs1[MAXLIBS];
  int liberties1;
  int commonlibs;
  int k;
  
  ASSERT_ON_BOARD1(str1);
  ASSERT_ON_BOARD1(str2);
  ASSERT1(IS_STONE(board[str1]), str1);
  ASSERT1(IS_STONE(board[str2]), str2);
  
  if (!strings_initialized)
    init_board();

  if (countlib(str1) > countlib(str2)) {
    int tmp = str1;
    str1 = str2;
    str2 = tmp;
  }

  liberties1 = findlib(str1, MAXLIBS, libs1);
  commonlibs = 0;
  for (k = 0; k < liberties1; k++)
    if (neighbor_of_string(libs1[k], str2))
      commonlibs++;
  
  return commonlibs;
}


/* Find the common liberties of the two strings at str1 and str2. The
 * locations of up to maxlib common liberties are written into libs[].
 * The full number of common liberties is returned.
 *
 * If you want the locations of all common liberties, whatever their
 * number, you should pass MAXLIBS as the value for maxlib and
 * allocate space for libs[] accordingly.
 */

int
find_common_libs(int str1, int str2, int maxlib, int *libs)
{
  int libs1[MAXLIBS];
  int liberties1;
  int commonlibs;
  int k;
  
  ASSERT_ON_BOARD1(str1);
  ASSERT_ON_BOARD1(str2);
  ASSERT1(IS_STONE(board[str1]), str1);
  ASSERT1(IS_STONE(board[str2]), str2);
  ASSERT1(libs != NULL, str1);
  
  if (!strings_initialized)
    init_board();

  if (countlib(str1) > countlib(str2)) {
    int tmp = str1;
    str1 = str2;
    str2 = tmp;
  }

  liberties1 = findlib(str1, MAXLIBS, libs1);
  commonlibs = 0;
  for (k = 0; k < liberties1; k++) {
    if (neighbor_of_string(libs1[k], str2)) {
      if (commonlibs < maxlib)
	libs[commonlibs] = libs1[k];
      commonlibs++;
    }
  }
  
  return commonlibs;
}


/* Determine whether two strings have at least one common liberty.
 * If they have and lib != NULL, one common liberty is returned in *lib.
 */

int
have_common_lib(int str1, int str2, int *lib)
{
  int libs1[MAXLIBS];
  int liberties1;
  int k;
  
  ASSERT_ON_BOARD1(str1);
  ASSERT_ON_BOARD1(str2);
  ASSERT1(IS_STONE(board[str1]), str1);
  ASSERT1(IS_STONE(board[str2]), str2);
  
  if (!strings_initialized)
    init_board();

  if (countlib(str1) > countlib(str2)) {
    int tmp = str1;
    str1 = str2;
    str2 = tmp;
  }

  liberties1 = findlib(str1, MAXLIBS, libs1);
  for (k = 0; k < liberties1; k++) {
    if (neighbor_of_string(libs1[k], str2)) {
      if (lib)
	*lib = libs1[k];
      return 1;
    }
  }
  
  return 0;
}



/*
 * Report the number of stones in a string.
 */

int
countstones(int str)
{
  ASSERT_ON_BOARD1(str);
  ASSERT1(IS_STONE(board[str]), str);

  if (!strings_initialized)
    init_board();

  return COUNTSTONES(str);
}


/* Find the stones of the string at str. str must not be
 * empty. The locations of up to maxstones stones are written into
 * stones[]. The full number of stones is returned.
 */

int
findstones(int str, int maxstones, int *stones)
{
  int s;
  int size;
  int pos;
  int k;
  
  ASSERT_ON_BOARD1(str);
  ASSERT1(IS_STONE(board[str]), str);

  if (!strings_initialized)
    init_board();

  s = string_number[str];
  size = string[s].size;
  
  /* Traverse the stones of the string, by following the cyclic chain. */
  pos = FIRST_STONE(s);
  for (k = 0; k < maxstones && k < size; k++) {
    stones[k] = pos;
    pos = NEXT_STONE(pos);
  }

  return size;
}


/* chainlinks returns (in the (adj) array) the chains surrounding
 * the string at (str). The number of chains is returned.
 */

int 
chainlinks(int str, int adj[MAXCHAIN])
{
  struct string_data *s;
  int k;

  ASSERT1(IS_STONE(board[str]), str);

  if (!strings_initialized)
    init_board();

  /* We already have the list ready, just copy it and fill in the
   * desired information.
   */
  s = &string[string_number[str]];
  for (k = 0; k < s->neighbors; k++)
    adj[k] = string[s->neighborlist[k]].origin;

  return s->neighbors;
}


/* chainlinks2 returns (in adj array) the chains surrounding
 * the string at str, which has exactly lib liberties. The number
 * of such chains is returned.
 */

int
chainlinks2(int str, int adj[MAXCHAIN], int lib)
{
  struct string_data *s, *t;
  int k;
  int neighbors;

  ASSERT1(IS_STONE(board[str]), str);

  if (!strings_initialized)
    init_board();

  /* We already have the list ready, just copy the strings with the
   * right number of liberties.
   */
  neighbors = 0;
  s = &string[string_number[str]];
  for (k = 0; k < s->neighbors; k++) {
    t = &string[s->neighborlist[k]];
    if (t->liberties == lib)
      adj[neighbors++] = t->origin;
  }
  return neighbors;
}


/* chainlinks3 returns (in adj array) the chains surrounding
 * the string at str, which have less or equal lib liberties.
 * The number of such chains is returned.
 */

int
chainlinks3(int str, int adj[MAXCHAIN], int lib)
{
  struct string_data *s, *t;
  int k;
  int neighbors;

  ASSERT1(IS_STONE(board[str]), str);

  if (!strings_initialized)
    init_board();

  /* We already have the list ready, just copy the strings with the
   * right number of liberties.
   */
  neighbors = 0;
  s = &string[string_number[str]];
  for (k = 0; k < s->neighbors; k++) {
    t = &string[s->neighborlist[k]];
    if (t->liberties <= lib)
      adj[neighbors++] = t->origin;
  }
  return neighbors;
}


/*
 * Find the origin of a worm or a cavity, i.e. the point with the
 * smallest 1D board coordinate. The idea is to have a canonical
 * reference point for a string.
 */

int
find_origin(int str)
{
  ASSERT1(IS_STONE(board[str]), str);

  if (!strings_initialized)
    init_board();
  
  return string[string_number[str]].origin;
}


/* Determine whether a move by color at (pos) would be a self atari,
 * i.e. whether it would get more than one liberty. This function
 * returns true also for the case of a suicide move.
 */

int
is_self_atari(int pos, int color)
{
  int liberties;
  int result;
  
  ASSERT_ON_BOARD1(pos);
  ASSERT1(board[pos] == EMPTY, pos);
  ASSERT1(IS_STONE(color), pos);

  if (!strings_initialized)
    init_board();

  /* 1. Try first without really putting the stone on the board. */
  /* FIXME: Integrate incremental_sloppy_self_atari() here. */
  result = incremental_sloppy_self_atari(pos, color);
  if (result != -1)
    return result;

  /* 2. It was not so easy.  Now see if we can put the stone on the board.
   *    If we can't, this is a self atari.
   */
  if (!do_trymove(pos, color, 1))
    return 1;
  liberties = countlib(pos);
  silent_popgo();
  
  return liberties <= 1;
}


/*
 * Returns true if pos is a liberty of the string at str.
 */

int
liberty_of_string(int pos, int str)
{
  ASSERT_ON_BOARD1(pos);
  ASSERT_ON_BOARD1(str);
  if (IS_STONE(board[pos]))
    return 0;

  return neighbor_of_string(pos, str);
}


/*
 * Returns true if pos is a second order liberty of the string at str.
 */
int
second_order_liberty_of_string(int pos, int str)
{
  int k;
  ASSERT_ON_BOARD1(pos);
  ASSERT_ON_BOARD1(str);

  for (k = 0; k < 4; k++)
    if (board[pos + delta[k]] == EMPTY
	&& neighbor_of_string(pos + delta[k], str))
      return 1;

  return 0;
}


/*
 * Returns true if pos is adjacent to the string at str.
 */

int
neighbor_of_string(int pos, int str)
{
  int s;
  int color = board[str];

  ASSERT1(IS_STONE(color), str);
  ASSERT_ON_BOARD1(pos);

  if (!strings_initialized)
    init_board();

  s = string_number[str];
  
  if (board[SOUTH(pos)] == color
      && string_number[SOUTH(pos)] == s)
    return 1;

  if (board[WEST(pos)] == color
      && string_number[WEST(pos)] == s)
    return 1;

  if (board[NORTH(pos)] == color
      && string_number[NORTH(pos)] == s)
    return 1;

  if (board[EAST(pos)] == color
      && string_number[EAST(pos)] == s)
    return 1;

  return 0;
}


/*
 * Returns true if str1 and str2 belong to the same string.
 */

int
same_string(int str1, int str2)
{
  ASSERT_ON_BOARD1(str1);
  ASSERT_ON_BOARD1(str2);
  ASSERT1(IS_STONE(board[str1]), str1);
  ASSERT1(IS_STONE(board[str2]), str2);

  if (!strings_initialized)
    init_board();

  return string_number[str1] == string_number[str2];
}


/*
 * Returns true if the strings at str1 and str2 are adjacent.
 */

int
adjacent_strings(int str1, int str2)
{
  int s1, s2;
  int k;
  
  ASSERT_ON_BOARD1(str1);
  ASSERT_ON_BOARD1(str2);
  ASSERT1(IS_STONE(board[str1]), str1);
  ASSERT1(IS_STONE(board[str2]), str2);

  if (!strings_initialized)
    init_board();

  s1 = string_number[str1];
  s2 = string_number[str2];

  for (k = 0; k < string[s1].neighbors; k++)
    if (string[s1].neighborlist[k] == s2)
      return 1;

  return 0;
}


/*
 * Return true if the move (pos) by (color) is a ko capture
 * (whether capture is legal on this move or not). If so,
 * and if ko_pos is not a NULL pointer, then
 * *ko_pos returns the location of the captured ko stone.
 * If the move is not a ko capture, *ko_pos is set to 0.
 *
 * A move is a ko capture if and only if
 *    1. All neighbors are opponent stones.
 *    2. The number of captured stones is exactly one.
 */

int
is_ko(int pos, int color, int *ko_pos)
{
  int other = OTHER_COLOR(color);
  int captures = 0;
  int kpos = 0;
  
  ASSERT_ON_BOARD1(pos);
  ASSERT1(color == WHITE || color == BLACK, pos);

  if (!strings_initialized)
    init_board();
  
  if (ON_BOARD(SOUTH(pos))) {
    if (board[SOUTH(pos)] != other)
      return 0;
    else if (LIBERTIES(SOUTH(pos)) == 1) {
      kpos = SOUTH(pos);
      captures += string[string_number[SOUTH(pos)]].size;
      if (captures > 1)
	return 0;
    }
  }
  
  if (ON_BOARD(WEST(pos))) {
    if (board[WEST(pos)] != other)
      return 0;
    else if (LIBERTIES(WEST(pos)) == 1) {
      kpos = WEST(pos);
      captures += string[string_number[WEST(pos)]].size;
      if (captures > 1)
	return 0;
    }
  }
  
  if (ON_BOARD(NORTH(pos))) {
    if (board[NORTH(pos)] != other)
      return 0;
    else if (LIBERTIES(NORTH(pos)) == 1) {
      kpos = NORTH(pos);
      captures += string[string_number[NORTH(pos)]].size;
      if (captures > 1)
	return 0;
    }
  }
  
  if (ON_BOARD(EAST(pos))) {
    if (board[EAST(pos)] != other)
      return 0;
    else if (LIBERTIES(EAST(pos)) == 1) {
      kpos = EAST(pos);
      captures += string[string_number[EAST(pos)]].size;
      if (captures > 1)
	return 0;
    }
  }
  
  if (captures == 1) {
    if (ko_pos)
      *ko_pos = kpos;
    return 1;
  }
  return 0;
}


/* Return true if pos is either a stone, which if captured would give
 * ko, or if pos is an empty intersection adjacent to a ko stone.
 */
int
is_ko_point(int pos)
{
  ASSERT_ON_BOARD1(pos);

  if (!strings_initialized)
    init_board();
  
  if (board[pos] == EMPTY) {
    int color;
    if (ON_BOARD(SOUTH(pos)))
      color = board[SOUTH(pos)];
    else
      color = board[NORTH(pos)];
    if (IS_STONE(color) && is_ko(pos, OTHER_COLOR(color), NULL))
      return 1;
  }
  else {
    struct string_data *s = &string[string_number[pos]];
    if (s->liberties == 1 && s->size == 1
	&& is_ko(s->libs[0], OTHER_COLOR(s->color), NULL))
      return 1;
  }

  return 0;
}


/* Returns 1 if at least one string is captured when color plays at pos.
 */
int
does_capture_something(int pos, int color)
{
  int other = OTHER_COLOR(color);

  ASSERT1(board[pos] == EMPTY, pos);

  if (!strings_initialized)
    init_board();

  if (board[SOUTH(pos)] == other && LIBERTIES(SOUTH(pos)) == 1)
    return 1;
  
  if (board[WEST(pos)] == other && LIBERTIES(WEST(pos)) == 1)
    return 1;
  
  if (board[NORTH(pos)] == other && LIBERTIES(NORTH(pos)) == 1)
    return 1;
  
  if (board[EAST(pos)] == other && LIBERTIES(EAST(pos)) == 1)
    return 1;

  return 0;
}


/* For each stone in the string at pos, set mx to value mark. If
 * some of the stones in the string are marked prior to calling this
 * function, only the connected unmarked stones starting from pos
 * are guaranteed to become marked. The rest of the string may or may
 * not become marked. (In the current implementation, it will.)
 */
void
mark_string(int str, char mx[BOARDMAX], char mark)
{
  int pos = str;

  ASSERT1(IS_STONE(board[str]), str);

  if (!strings_initialized)
    init_board();

  do {
    mx[pos] = mark;
    pos = NEXT_STONE(pos);
  } while (pos != str);
}


/* Returns true if at least one move has been played at pos
 * at deeper than level 'cutoff' in the reading tree.
 */
int
move_in_stack(int pos, int cutoff)
{
  int k;
  for (k = cutoff; k < stackp; k++)
    if (stack[k] == pos)
      return 1;
  
  return 0;
}


/* Retrieve a move from the move stack. */
void
get_move_from_stack(int k, int *move, int *color)
{
  gg_assert(k < stackp);
  *move = stack[k];
  *color = move_color[k];
}

/* Return the number of stones of the indicated color(s) on the board.
 * This only counts stones in the permanent position, not stones placed
 * by trymove() or tryko(). Use stones_on_board(BLACK | WHITE) to get
 * the total number of stones on the board.
 */
int
stones_on_board(int color)
{
  static int stone_count_for_position = -1;
  static int white_stones = 0;
  static int black_stones = 0;

  gg_assert(stackp == 0);

  if (stone_count_for_position != position_number) {
    int pos;
    white_stones = 0;
    black_stones = 0;
    for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
      if (board[pos] == WHITE)
	white_stones++;
      else if (board[pos] == BLACK)
	black_stones++;
    }
    
    stone_count_for_position = position_number;
  }

  return ((color & BLACK ? black_stones : 0) +
	  (color & WHITE ? white_stones : 0));
}


/* ===================== Statistics  ============================= */


/* Clear statistics. */
void
reset_trymove_counter()
{
  trymove_counter = 0;
}


/* Retrieve statistics. */
int
get_trymove_counter()
{
  return trymove_counter;
}


/* ================================================================ */
/*                      Lower level functions                       */
/* ================================================================ */


/* Don't trust the incremental string data until it's reinitialized.
 *
 * This function should be called if the board is modified by other
 * means than do_play_move() or undo_trymove().
 * It's also useful to force a recomputation of the strings if we
 * don't have any immediate plans to undo the move, because it recovers
 * undo stack space and holes in the 'string' array.
 */

/* We have reached a new position. Increase the position counter and
 * invalidate the incremental strings.
 */

static void
new_position(void)
{
  position_number++;
  strings_initialized = 0;
}


/* Set up incremental board structures and populate them with the
 * strings available in the position given by board[]. Clear the stacks
 * and start the mark numbers from zero. All undo information is lost
 * by calling this function.
 */

static void
init_board()
{
  int pos;
  int s;
  next_string = 0;
  liberty_mark = 0;
  string_mark = 0;
  CLEAR_STACKS();

  memset(string, 0, sizeof(string));
  memset(ml, 0, sizeof(ml));

  /* propagate_string relies on non-assigned stones to have
   * string_number -1.
   */
  for (pos = BOARDMIN; pos < BOARDMAX; pos++)
    if (ON_BOARD(pos))
      string_number[pos] = -1;

  /* Find the existing strings. */
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (!ON_BOARD(pos))
      continue;
    if (IS_STONE(board[pos]) && string_number[pos] == -1) {
      string_number[pos] = next_string;
      string[next_string].size = propagate_string(pos, pos);
      string[next_string].color = board[pos];
      string[next_string].origin = pos;
      string[next_string].mark = 0;
      next_string++;
    }
  }
  
  /* Fill in liberty and neighbor info. */
  for (s = 0; s < next_string; s++) {
    find_liberties_and_neighbors(s);
  }

  /* Now we can trust the information. */
  strings_initialized = 1;
}


#if 0

/*
 * Debug function. Dump all string information.
 */

static void
dump_incremental_board(void)
{
  int pos;
  int s;
  int i;
  
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (!ON_BOARD(pos))
      continue;
    if (board[pos] == EMPTY)
      fprintf(stderr, " . ");
    else
      fprintf(stderr, "%2d ", string_number[pos]);
    fprintf(stderr, "\n");
  }

  for (s = 0; s < next_string; s++) {
    if (board[string[s].origin] == EMPTY)
      continue;
    
    gprintf("%o%d %s %1m size %d, %d liberties, %d neighbors\n", s,
	    color_to_string(string[s].color),
	    string[s].origin, string[s].size,
	    string[s].liberties, string[s].neighbors);
    gprintf("%ostones:");

    pos = FIRST_STONE(s);
    do {
      gprintf("%o %1m", pos);
      pos = NEXT_STONE(pos);
    } while (!BACK_TO_FIRST_STONE(s, pos));
    
    gprintf("%o\nliberties:");
    for (i = 0; i < string[s].liberties; i++)
      gprintf("%o %1m", string[s].libs[i]);
    
    gprintf("%o\nneighbors:");
    for (i = 0; i < string[s].neighbors; i++)
      gprintf("%o %d(%1m)", string[s].neighborlist[i],
	      string[string[s].neighborlist[i]].origin);
    gprintf("%o\n\n");
  }
}
#endif


/* Build a string and its cyclic list representation from scratch.
 * propagate_string(stone, str) adds the stone (stone) to the string
 * (str) and recursively continues with not already included friendly
 * neighbors. To start a new string at (stone), use
 * propagate_string(stone, stone). The size of the string is returned.
 */

static int
propagate_string(int stone, int str)
{
  int size = 1;
  int k;
  
  if (stone == str) {
    /* Start a new string. */
    next_stone[stone] = stone;
  }
  else {
    /* Link the stone at (stone) to the string including (str) */
    string_number[stone] = string_number[str];
    next_stone[stone] = next_stone[str];
    next_stone[str] = stone;
  }

  /* Look in all four directions for more stones to add. */
  for (k = 0; k < 4; k++) {
    int d = delta[k];
    if (ON_BOARD(stone + d)
	&& board[stone + d] == board[stone]
	&& string_number[stone + d] == -1)
      size += propagate_string(stone + d, str);
  }
  
  return size;
}


/* Build the lists of liberties and neighbors of a string from
 * scratch. No information is pushed onto the stack by this function.
 */

static void
find_liberties_and_neighbors(int s)
{
  int pos;

  /* Clear the marks. */
  liberty_mark++;
  string_mark++;

  /* Traverse the stones of the string, by following the cyclic chain. */
  pos = FIRST_STONE(s);
  do {
    /* Look in each direction for new liberties or new neighbors. Mark
     * already visited liberties and neighbors.
     */
    if (UNMARKED_LIBERTY(SOUTH(pos))) {
      ADD_AND_MARK_LIBERTY(s, SOUTH(pos));
    }
    else if (UNMARKED_OPPONENT_STRING(s, SOUTH(pos))) {
      ADD_NEIGHBOR(s, SOUTH(pos));
      MARK_STRING(SOUTH(pos));
    }
    
    if (UNMARKED_LIBERTY(WEST(pos))) {
      ADD_AND_MARK_LIBERTY(s, WEST(pos));
    }
    else if (UNMARKED_OPPONENT_STRING(s, WEST(pos))) {
      ADD_NEIGHBOR(s, WEST(pos));
      MARK_STRING(WEST(pos));
    }
    
    if (UNMARKED_LIBERTY(NORTH(pos))) {
      ADD_AND_MARK_LIBERTY(s, NORTH(pos));
    }
    else if (UNMARKED_OPPONENT_STRING(s, NORTH(pos))) {
      ADD_NEIGHBOR(s, NORTH(pos));
      MARK_STRING(NORTH(pos));
    }
    
    if (UNMARKED_LIBERTY(EAST(pos))) {
      ADD_AND_MARK_LIBERTY(s, EAST(pos));
    }
    else if (UNMARKED_OPPONENT_STRING(s, EAST(pos))) {
      ADD_NEIGHBOR(s, EAST(pos));
      MARK_STRING(EAST(pos));
    }
    
    pos = NEXT_STONE(pos);
  } while (!BACK_TO_FIRST_STONE(s, pos));
}


/* Update the liberties of a string from scratch, first pushing the
 * old information.
 */

static void
update_liberties(int s)
{
  int pos;
  int k;

  /* Push the old information. */
  PUSH_VALUE(string[s].liberties);
  for (k = 0; k < string[s].liberties && k < MAX_LIBERTIES; k++) {
    PUSH_VALUE(string[s].libs[k]);
  }
  string[s].liberties = 0;

  /* Clear the liberty mark. */
  liberty_mark++;

  /* Traverse the stones of the string, by following the cyclic chain. */
  pos = FIRST_STONE(s);
  do {
    /* Look in each direction for new liberties. Mark already visited
     * liberties. 
     */
    if (UNMARKED_LIBERTY(SOUTH(pos))) {
      ADD_AND_MARK_LIBERTY(s, SOUTH(pos));
    }
    
    if (UNMARKED_LIBERTY(WEST(pos))) {
      ADD_AND_MARK_LIBERTY(s, WEST(pos));
    }
    
    if (UNMARKED_LIBERTY(NORTH(pos))) {
      ADD_AND_MARK_LIBERTY(s, NORTH(pos));
    }
    
    if (UNMARKED_LIBERTY(EAST(pos))) {
      ADD_AND_MARK_LIBERTY(s, EAST(pos));
    }
    
    pos = NEXT_STONE(pos);
  } while (!BACK_TO_FIRST_STONE(s, pos));
}


/* Remove a string from the list of neighbors and push the changed
 * information.
 */

static void
remove_neighbor(int str_number, int n)
{
  int k;
  int done = 0;
  struct string_data *s = &string[str_number];
  for (k = 0; k < s->neighbors; k++)
    if (s->neighborlist[k] == n) {
      /* We need to push the last entry too because it may become
       * destroyed later.
       */
      PUSH_VALUE(s->neighborlist[s->neighbors - 1]);
      PUSH_VALUE(s->neighborlist[k]);
      PUSH_VALUE(s->neighbors);
      s->neighborlist[k] = s->neighborlist[s->neighbors - 1];
      s->neighbors--;
      done = 1;
      break;
    }
  gg_assert(done);
}


/* Remove one liberty from the list of liberties, pushing changed
 * information. If the string had more liberties than the size of the
 * list, rebuild the list from scratch.
 */

static void
remove_liberty(int str_number, int pos)
{
  int k;
  struct string_data *s = &string[str_number];
  
  if (s->liberties > MAX_LIBERTIES)
    update_liberties(str_number);
  else {
    for (k = 0; k < s->liberties; k++)
      if (s->libs[k] == pos) {
	/* We need to push the last entry too because it may become
	 * destroyed later.
	 */
	PUSH_VALUE(s->libs[s->liberties - 1]);
	PUSH_VALUE(s->libs[k]);
	PUSH_VALUE(s->liberties);
	s->libs[k] = s->libs[s->liberties - 1];
	s->liberties--;
	break;
      }
  }
}


/* Remove a string from the board, pushing necessary information to
 * restore it. Return the number of removed stones.
 */

static int
do_remove_string(int s)
{
  int pos;
  int k;

  /* Traverse the stones of the string, by following the cyclic chain. */
  pos = FIRST_STONE(s);
  do {
    /* Push color, string number and cyclic chain pointers. */
    PUSH_VALUE(string_number[pos]);
    PUSH_VALUE(next_stone[pos]);
    DO_REMOVE_STONE(pos);
    pos = NEXT_STONE(pos);
  } while (!BACK_TO_FIRST_STONE(s, pos));

  /* The neighboring strings have obtained some new liberties and lost
   * a neighbor.
   */
  for (k = 0; k < string[s].neighbors; k++) {
    remove_neighbor(string[s].neighborlist[k], s);
    update_liberties(string[s].neighborlist[k]);
  }

  /* Update the number of captured stones. These are assumed to
   * already have been pushed.
   */
  if (string[s].color == WHITE)
    white_captured += string[s].size;
  else
    black_captured += string[s].size;
    
  return string[s].size;
}


/* We have played an isolated new stone and need to create a new
 * string for it.
 */
static void
create_new_string(int pos)
{
  int s;
  int color = board[pos];

  /* Get the next free string number. */
  PUSH_VALUE(next_string);
  s = next_string++;
  string_number[pos] = s;
  /* Set up a size one cycle for the string. */
  next_stone[pos] = pos;

  /* Set trivially known values and initialize the rest to zero. */
  string[s].color = color;
  string[s].size = 1;
  string[s].origin = pos;
  string[s].liberties = 0;
  string[s].neighbors = 0;
  string[s].mark = 0;

  /* Clear the string mark. */
  string_mark++;

  /* In each direction, look for a liberty or a nonmarked opponent
   * neighbor. Mark visited neighbors. There is no need to mark the
   * liberties since we can't find them twice. */
  if (LIBERTY(SOUTH(pos))) {
    ADD_LIBERTY(s, SOUTH(pos));
  }
  else if (UNMARKED_OPPONENT_STRING(s, SOUTH(pos))) {
    int s2 = string_number[SOUTH(pos)];
    /* Add the neighbor to our list. */
    ADD_NEIGHBOR(s, SOUTH(pos));
    /* Add us to our neighbor's list. */
    PUSH_VALUE(string[s2].neighbors);
    ADD_NEIGHBOR(s2, pos);
    MARK_STRING(SOUTH(pos));
  }
  
  if (LIBERTY(WEST(pos))) {
    ADD_LIBERTY(s, WEST(pos));
  }
  else if (UNMARKED_OPPONENT_STRING(s, WEST(pos))) {
    int s2 = string_number[WEST(pos)];
    /* Add the neighbor to our list. */
    ADD_NEIGHBOR(s, WEST(pos));
    /* Add us to our neighbor's list. */
    PUSH_VALUE(string[s2].neighbors);
    ADD_NEIGHBOR(s2, pos);
    MARK_STRING(WEST(pos));
  }
  
  if (LIBERTY(NORTH(pos))) {
    ADD_LIBERTY(s, NORTH(pos));
  }
  else if (UNMARKED_OPPONENT_STRING(s, NORTH(pos))) {
    int s2 = string_number[NORTH(pos)];
    /* Add the neighbor to our list. */
    ADD_NEIGHBOR(s, NORTH(pos));
    /* Add us to our neighbor's list. */
    PUSH_VALUE(string[s2].neighbors);
    ADD_NEIGHBOR(s2, pos);
    MARK_STRING(NORTH(pos));
  }
  
  if (LIBERTY(EAST(pos))) {
    ADD_LIBERTY(s, EAST(pos));
  }
  else if (UNMARKED_OPPONENT_STRING(s, EAST(pos))) {
    int s2 = string_number[EAST(pos)];
    /* Add the neighbor to our list. */
    ADD_NEIGHBOR(s, EAST(pos));
    /* Add us to our neighbor's list. */
    PUSH_VALUE(string[s2].neighbors);
    ADD_NEIGHBOR(s2, pos);
    /* No need to mark since no visits left. */
#if 0
    MARK_STRING(EAST(pos));
#endif
  }
}


/* We have played a stone with exactly one friendly neighbor. Add the
 * new stone to that string.
 */
static void
extend_neighbor_string(int pos, int s)
{
  int k;
  int liberties_updated = 0;

  /* Link in the stone in the cyclic list. */
  int pos2 = string[s].origin;
  next_stone[pos] = next_stone[pos2];
  PUSH_VALUE(next_stone[pos2]);
  next_stone[pos2] = pos;
  
  /* Do we need to update the origin? */
  if (pos < pos2) {
    PUSH_VALUE(string[s].origin);
    string[s].origin = pos;
  }
  
  string_number[pos] = s;

  /* The size of the string has increased by one. */
  PUSH_VALUE(string[s].size);
  string[s].size++;

  /* If s has too many liberties, we don't know where they all are and
   * can't update the liberties with the algorithm we otherwise
   * use. In that case we can only recompute the liberties from
   * scratch.
   */
  if (string[s].liberties > MAX_LIBERTIES) {
    update_liberties(s);
    liberties_updated = 1;
  }
  else {
    /* The place of the new stone is no longer a liberty. */
    remove_liberty(s, pos);
  }

  /* Mark old neighbors of the string. */
  string_mark++;
  for (k = 0; k < string[s].neighbors; k++)
    string[string[s].neighborlist[k]].mark = string_mark;

  /* Look at the neighbor locations of pos for new liberties and/or
   * neighbor strings.
   */

  /* If we find a liberty, look two steps away to determine whether
   * this already is a liberty of s.
   */
  if (LIBERTY(SOUTH(pos))) {
    if (!liberties_updated
	&& !(STRING_AT_VERTEX(SS(pos), s)
	     || STRING_AT_VERTEX(SW(pos), s)
	     || STRING_AT_VERTEX(SE(pos), s)))
      ADD_LIBERTY(s, SOUTH(pos));
  }
  else if (UNMARKED_OPPONENT_STRING(s, SOUTH(pos))) {
    int s2 = string_number[SOUTH(pos)];
    PUSH_VALUE(string[s].neighbors);
    ADD_NEIGHBOR(s, SOUTH(pos));
    PUSH_VALUE(string[s2].neighbors);
    ADD_NEIGHBOR(s2, pos);
    MARK_STRING(SOUTH(pos));
  }
  
  if (LIBERTY(WEST(pos))) {
    if (!liberties_updated
	&& !(STRING_AT_VERTEX(WW(pos), s)
	     || STRING_AT_VERTEX(NW(pos), s)
	     || STRING_AT_VERTEX(SW(pos), s)))
      ADD_LIBERTY(s, WEST(pos));
  }
  else if (UNMARKED_OPPONENT_STRING(s, WEST(pos))) {
    int s2 = string_number[WEST(pos)];
    PUSH_VALUE(string[s].neighbors);
    ADD_NEIGHBOR(s, WEST(pos));
    PUSH_VALUE(string[s2].neighbors);
    ADD_NEIGHBOR(s2, pos);
    MARK_STRING(WEST(pos));
  }
  
  if (LIBERTY(NORTH(pos))) {
    if (!liberties_updated
	&& !(STRING_AT_VERTEX(NN(pos), s)
	     || STRING_AT_VERTEX(NW(pos), s)
	     || STRING_AT_VERTEX(NE(pos), s)))
      ADD_LIBERTY(s, NORTH(pos));
  }
  else if (UNMARKED_OPPONENT_STRING(s, NORTH(pos))) {
    int s2 = string_number[NORTH(pos)];
    PUSH_VALUE(string[s].neighbors);
    ADD_NEIGHBOR(s, NORTH(pos));
    PUSH_VALUE(string[s2].neighbors);
    ADD_NEIGHBOR(s2, pos);
    MARK_STRING(NORTH(pos));
  }
  
  if (LIBERTY(EAST(pos))) {
    if (!liberties_updated
	&& !(STRING_AT_VERTEX(EE(pos), s)
	     || STRING_AT_VERTEX(NE(pos), s)
	     || STRING_AT_VERTEX(SE(pos), s)))
      ADD_LIBERTY(s, EAST(pos));
  }
  else if (UNMARKED_OPPONENT_STRING(s, EAST(pos))) {
    int s2 = string_number[EAST(pos)];
    PUSH_VALUE(string[s].neighbors);
    ADD_NEIGHBOR(s, EAST(pos));
    PUSH_VALUE(string[s2].neighbors);
    ADD_NEIGHBOR(s2, pos);
#if 0
    MARK_STRING(EAST(pos));
#endif
  }
  
}


/* Incorporate the string at pos with the string s.
 */

static void
assimilate_string(int s, int pos)
{
  int k;
  int last;
  int s2 = string_number[pos];
  string[s].size += string[s2].size;

  /* Walk through the s2 stones and change string number. Also pick up
   * the last stone in the cycle for later use.
   */
  pos = FIRST_STONE(s2);
  do {
    PUSH_VALUE(string_number[pos]);
    string_number[pos] = s;
    last = pos;
    pos = NEXT_STONE(pos);
  } while (!BACK_TO_FIRST_STONE(s2, pos));

  /* Link the two cycles together. */
  {
    int pos2 = string[s].origin;
    PUSH_VALUE(next_stone[last]);
    PUSH_VALUE(next_stone[pos2]);
    next_stone[last] = next_stone[pos2];
    next_stone[pos2] = string[s2].origin;
    
    /* Do we need to update the origin? */
    if (string[s2].origin < pos2)
      string[s].origin = string[s2].origin;
  }

  /* Pick up the liberties of s2 that we don't already have.
   * It is assumed that the liberties of s have been marked before
   * this function is called.
   */
  if (string[s2].liberties <= MAX_LIBERTIES) {
    for (k = 0; k < string[s2].liberties; k++) {
      int pos2 = string[s2].libs[k];
      if (UNMARKED_LIBERTY(pos2)) {
	ADD_AND_MARK_LIBERTY(s, pos2);
      }
    }
  }
  else {
    /* If s2 had too many liberties the above strategy wouldn't be
     * effective, since not all liberties are listed in
     * libs[] the chain of stones for s2 is no
     * longer available (it has already been merged with s) so we
     * can't reconstruct the s2 liberties. Instead we capitulate and
     * rebuild the list of liberties for s (including the neighbor
     * strings assimilated so far) from scratch.
     */
    liberty_mark++;          /* Reset the mark. */
    string[s].liberties = 0; /* To avoid pushing the current list. */
    update_liberties(s);
  }

  /* Remove s2 as neighbor to the neighbors of s2 and instead add s if
   * they don't already have added it. Also add the neighbors of s2 as
   * neighbors of s, unless they already have been added. The already
   * known neighbors of s are assumed to have been marked before this
   * function is called.
   */
  for (k = 0; k < string[s2].neighbors; k++) {
    int t = string[s2].neighborlist[k];
    remove_neighbor(t, s2);
    if (string[t].mark != string_mark) {
      PUSH_VALUE(string[t].neighbors);
      string[t].neighborlist[string[t].neighbors++] = s;
      string[s].neighborlist[string[s].neighbors++] = t;
      string[t].mark = string_mark;
    }
  }
}


/* Create a new string for the stone at pos and assimilate all
 * friendly neighbor strings.
 */

static void
assimilate_neighbor_strings(int pos)
{
  int s;
  int color = board[pos];

  /* Get the next free string number. */
  PUSH_VALUE(next_string);
  s = next_string++;
  PARANOID1(s < MAX_STRINGS, pos); 
  string_number[pos] = s;
  /* Set up a size one cycle for the string. */
  next_stone[pos] = pos;
  
  /* Set trivially known values and initialize the rest to zero. */
  string[s].color = color;
  string[s].size = 1;
  string[s].origin = pos;
  string[s].liberties = 0;
  string[s].neighbors = 0;

  /* Clear the marks. */
  liberty_mark++;
  string_mark++;

  /* Mark ourselves. */
  string[s].mark = string_mark;

  /* Look in each direction for
   *
   * 1. liberty: Add if not already visited.
   * 2. opponent string: Add it among our neighbors and us among its
   *    neighbors, unless already visited.
   * 3. friendly string: Assimilate.
   */
  if (UNMARKED_LIBERTY(SOUTH(pos))) {
    ADD_AND_MARK_LIBERTY(s, SOUTH(pos));
  }
  else if (UNMARKED_OPPONENT_STRING(s, SOUTH(pos))) {
    ADD_NEIGHBOR(s, SOUTH(pos));
    PUSH_VALUE(string[string_number[SOUTH(pos)]].neighbors);
    ADD_NEIGHBOR(string_number[SOUTH(pos)], pos);
    MARK_STRING(SOUTH(pos));
  }
  else if (UNMARKED_OWN_STRING(s, SOUTH(pos))) {
    assimilate_string(s, SOUTH(pos));
  }

  if (UNMARKED_LIBERTY(WEST(pos))) {
    ADD_AND_MARK_LIBERTY(s, WEST(pos));
  }
  else if (UNMARKED_OPPONENT_STRING(s, WEST(pos))) {
    ADD_NEIGHBOR(s, WEST(pos));
    PUSH_VALUE(string[string_number[WEST(pos)]].neighbors);
    ADD_NEIGHBOR(string_number[WEST(pos)], pos);
    MARK_STRING(WEST(pos));
  }
  else if (UNMARKED_OWN_STRING(s, WEST(pos))) {
    assimilate_string(s, WEST(pos));
  }
  
  if (UNMARKED_LIBERTY(NORTH(pos))) {
    ADD_AND_MARK_LIBERTY(s, NORTH(pos));
  }
  else if (UNMARKED_OPPONENT_STRING(s, NORTH(pos))) {
    ADD_NEIGHBOR(s, NORTH(pos));
    PUSH_VALUE(string[string_number[NORTH(pos)]].neighbors);
    ADD_NEIGHBOR(string_number[NORTH(pos)], pos);
    MARK_STRING(NORTH(pos));
  }
  else if (UNMARKED_OWN_STRING(s, NORTH(pos))) {
    assimilate_string(s, NORTH(pos));
  }
  
  if (UNMARKED_LIBERTY(EAST(pos))) {
    ADD_AND_MARK_LIBERTY(s, EAST(pos));
  }
  else if (UNMARKED_OPPONENT_STRING(s, EAST(pos))) {
    ADD_NEIGHBOR(s, EAST(pos));
    PUSH_VALUE(string[string_number[EAST(pos)]].neighbors);
    ADD_NEIGHBOR(string_number[EAST(pos)], pos);
    MARK_STRING(EAST(pos));
  }
  else if (UNMARKED_OWN_STRING(s, EAST(pos))) {
    assimilate_string(s, EAST(pos));
  }
}


/* Suicide at pos. Remove the neighboring friendly strings.
 */

static void
do_commit_suicide(int pos, int color)
{
  if (board[SOUTH(pos)] == color)
    do_remove_string(string_number[SOUTH(pos)]);

  if (board[WEST(pos)] == color)
    do_remove_string(string_number[WEST(pos)]);

  if (board[NORTH(pos)] == color)
    do_remove_string(string_number[NORTH(pos)]);

  if (board[EAST(pos)] == color)
    do_remove_string(string_number[EAST(pos)]);
}


/* Play a move without legality checking. Suicide is allowed.
 */

static void
do_play_move(int pos, int color)
{
  int other = OTHER_COLOR(color);
  int captured_stones = 0;
  int neighbor_allies = 0;
  int have_liberties = 0;
  int s = -1;
  
  if (!strings_initialized)
    init_board();
    
  /* Remove captured stones and check for suicide.*/
  if (board[SOUTH(pos)] == other && LIBERTIES(SOUTH(pos)) == 1)
    captured_stones += do_remove_string(string_number[SOUTH(pos)]);
  else if (LIBERTY(SOUTH(pos)) || (board[SOUTH(pos)] == color
				   && LIBERTIES(SOUTH(pos)) > 1))
    have_liberties = 1;

  if (board[WEST(pos)] == other && LIBERTIES(WEST(pos)) == 1)
    captured_stones += do_remove_string(string_number[WEST(pos)]);
  else if (LIBERTY(WEST(pos)) || (board[WEST(pos)] == color
				  && LIBERTIES(WEST(pos)) > 1))
    have_liberties = 1;

  if (board[NORTH(pos)] == other && LIBERTIES(NORTH(pos)) == 1)
    captured_stones += do_remove_string(string_number[NORTH(pos)]);
  else if (LIBERTY(NORTH(pos)) || (board[NORTH(pos)] == color
				   && LIBERTIES(NORTH(pos)) > 1))
    have_liberties = 1;

  if (board[EAST(pos)] == other && LIBERTIES(EAST(pos)) == 1)
    captured_stones += do_remove_string(string_number[EAST(pos)]);
  else if (LIBERTY(EAST(pos)) || (board[EAST(pos)] == color
				  && LIBERTIES(EAST(pos)) > 1))
    have_liberties = 1;

  /* No captures and no liberties -> suicide. */
  if (have_liberties == 0 && captured_stones == 0) {
    do_commit_suicide(pos, color);
    return;
  }
  
  /* Put down the stone. */
  DO_ADD_STONE(pos, color);

  /* Count the number of adjacent strings of my color and remove
   * pos as liberty for the adjacent opponent strings.
   */
  string_mark++;

  if (board[SOUTH(pos)] == color && UNMARKED_STRING(SOUTH(pos))) {
    neighbor_allies++;
    s = string_number[SOUTH(pos)];
    MARK_STRING(SOUTH(pos));
  }
  else if (board[SOUTH(pos)] == other && UNMARKED_STRING(SOUTH(pos))) {
    remove_liberty(string_number[SOUTH(pos)], pos);
    MARK_STRING(SOUTH(pos));
  }    
  
  if (board[WEST(pos)] == color && UNMARKED_STRING(WEST(pos))) {
    neighbor_allies++;
    s = string_number[WEST(pos)];
    MARK_STRING(WEST(pos));
  }
  else if (board[WEST(pos)] == other && UNMARKED_STRING(WEST(pos))) {
    remove_liberty(string_number[WEST(pos)], pos);
    MARK_STRING(WEST(pos));
  }    
  
  if (board[NORTH(pos)] == color && UNMARKED_STRING(NORTH(pos))) {
    neighbor_allies++;
    s = string_number[NORTH(pos)];
    MARK_STRING(NORTH(pos));
  }
  else if (board[NORTH(pos)] == other && UNMARKED_STRING(NORTH(pos))) {
    remove_liberty(string_number[NORTH(pos)], pos);
    MARK_STRING(NORTH(pos));
  }    
  
  if (board[EAST(pos)] == color && UNMARKED_STRING(EAST(pos))) {
    neighbor_allies++;
    s = string_number[EAST(pos)];
#if 0
    MARK_STRING(EAST(pos));
#endif
  }
  else if (board[EAST(pos)] == other && UNMARKED_STRING(EAST(pos))) {
    remove_liberty(string_number[EAST(pos)], pos);
#if 0
    MARK_STRING(EAST(pos));
#endif
  }    
  

  /* Choose strategy depending on the number of friendly neighbors. */
  if (neighbor_allies == 0)
    create_new_string(pos);
  else if (neighbor_allies == 1) {
    gg_assert(s >= 0);
    extend_neighbor_string(pos, s);
  }
  else
    assimilate_neighbor_strings(pos);

  /* Check whether this move was a ko capture and if so set 
   * board_ko_pos.
   *
   * No need to push board_ko_pos on the stack, 
   * because this has been done earlier.
   */
  s = string_number[pos];
  if (string[s].liberties == 1
      && string[s].size == 1
      && captured_stones == 1) {
    /* In case of a double ko: clear old ko position first. */
    if (board_ko_pos != NO_MOVE)
      hashdata_invert_ko(&hashdata, board_ko_pos);
    board_ko_pos = string[s].libs[0];
    hashdata_invert_ko(&hashdata, board_ko_pos);
  }
}


/* Find the liberties a move of the given color at pos would have,
 * excluding possible captures, by traversing all adjacent friendly
 * strings. This is a fallback used by approxlib() when a
 * faster algorithm can't be used.
 */

static int
slow_approxlib(int pos, int color, int maxlib, int *libs)
{
  int liberties = 0;
  int k;

  liberty_mark++;
  MARK_LIBERTY(pos);
  string_mark++;
  for (k = 0; k < 4; k++) {
    int d = delta[k];
    if (UNMARKED_LIBERTY(pos + d)) {
      if (libs)
	libs[liberties] = pos + d;
      liberties++;
      if (liberties == maxlib)
	return liberties;
      MARK_LIBERTY(pos + d);
    }
    else if (board[pos + d] == color
	     && UNMARKED_STRING(pos + d)) {
      int s = string_number[pos + d];
      int pos2;
      pos2 = FIRST_STONE(s);
      do {
	int l;
	for (l = 0; l < 4; l++) {
	  int d2 = delta[l];
	  if (UNMARKED_LIBERTY(pos2 + d2)) {
	    if (libs)
	      libs[liberties] = pos2 + d2;
	    liberties++;
	    if (liberties == maxlib)
	      return liberties;
	    MARK_LIBERTY(pos2 + d2);
	  }
	}
	
	pos2 = NEXT_STONE(pos2);
      } while (!BACK_TO_FIRST_STONE(s, pos2));
      MARK_STRING(pos + d);
    }
  }
  return liberties;
}


/* Determine whether a move by color at pos might be a self atari.
 * This function is sloppy in that it only does a quick check for two
 * liberties and might miss certain cases.
 * Return value 0 means it cannot be a self atari.
 * Return value 1 means it definitely is a self atari.
 * Return value -1 means uncertain.
 */

static int
incremental_sloppy_self_atari(int pos, int color)
{
  int other = OTHER_COLOR(color);
  /* number of empty neighbors */
  int trivial_liberties = 0;
  /* number of captured opponent strings */
  int captures = 0;
  /* Whether there is a friendly neighbor with a spare liberty. If it
   * has more than one spare liberty we immediately return 0.
   */
  int far_liberties = 0;

  /* Clear string mark. */
  string_mark++;
  
  if (board[SOUTH(pos)] == EMPTY)
    trivial_liberties++;
  else if (board[SOUTH(pos)] == color) {
    if (LIBERTIES(SOUTH(pos)) > 2)
      return 0;
    if (LIBERTIES(SOUTH(pos)) == 2)
      far_liberties++;
  }
  else if (board[SOUTH(pos)] == other
	   && LIBERTIES(SOUTH(pos)) == 1 && UNMARKED_STRING(SOUTH(pos))) {
    captures++;
    MARK_STRING(SOUTH(pos));
  }

  if (board[WEST(pos)] == EMPTY)
    trivial_liberties++;
  else if (board[WEST(pos)] == color) {
    if (LIBERTIES(WEST(pos)) > 2)
      return 0;
    if (LIBERTIES(WEST(pos)) == 2)
      far_liberties++;
  }
  else if (board[WEST(pos)] == other
	   && LIBERTIES(WEST(pos)) == 1 && UNMARKED_STRING(WEST(pos))) {
    captures++;
    MARK_STRING(WEST(pos));
  }

  if (board[NORTH(pos)] == EMPTY)
    trivial_liberties++;
  else if (board[NORTH(pos)] == color) {
    if (LIBERTIES(NORTH(pos)) > 2)
      return 0;
    if (LIBERTIES(NORTH(pos)) == 2)
      far_liberties++;
  }
  else if (board[NORTH(pos)] == other
	   && LIBERTIES(NORTH(pos)) == 1 && UNMARKED_STRING(NORTH(pos))) {
    captures++;
    MARK_STRING(NORTH(pos));
  }

  if (board[EAST(pos)] == EMPTY)
    trivial_liberties++;
  else if (board[EAST(pos)] == color) {
    if (LIBERTIES(EAST(pos)) > 2)
      return 0;
    if (LIBERTIES(EAST(pos)) == 2)
      far_liberties++;
  }
  else if (board[EAST(pos)] == other
	   && LIBERTIES(EAST(pos)) == 1 && UNMARKED_STRING(EAST(pos))) {
    captures++;
    MARK_STRING(EAST(pos));
  }

  /* Each captured string is guaranteed to produce at least one
   * liberty. These are disjoint from both trivial liberties and far
   * liberties. The two latter may however coincide.
   */
  
  if (trivial_liberties + captures >= 2)
    return 0;

  if ((far_liberties > 0) + captures >= 2)
    return 0;

  if (captures == 0 && far_liberties + trivial_liberties <= 1)
    return 1;

  return -1;
}


/* ================================================================ *
 * The following functions don't actually belong here. They are  
 * only here because they are faster here where they have access to
 * the incremental data structures. 
 * ================================================================ */


/* Help collect the data needed by order_moves() in reading.c.
 * It's the caller's responsibility to initialize the result parameters.
 */
#define NO_UNROLL 0
void
incremental_order_moves(int move, int color, int str,
			int *number_edges, int *number_same_string,
			int *number_own, int *number_opponent,
			int *captured_stones, int *threatened_stones,
			int *saved_stones, int *number_open)
{
#if NO_UNROLL == 1
  int pos;
  int k;

  /* Clear the string mark. */
  string_mark++;

  for (k = 0; k < 4; k++) {
    pos = move + delta[k];
    if (!ON_BOARD(pos))
      (*number_edges)++;
    else if (board[pos] == EMPTY)
      (*number_open)++;
    else {
      int s = string_number[pos];
      if (string_number[str] == s)
	(*number_same_string)++;
      
      if (board[pos] == color) {
	(*number_own)++;
	if (string[s].liberties == 1)
	  (*saved_stones) += string[s].size;
      }
      else {
	(*number_opponent)++;
	if (string[s].liberties == 1) {
	  int r;
	  struct string_data *t;
	  (*captured_stones) += string[s].size;
	  for (r = 0; r < string[s].neighbors; r++) {
	    t = &string[string[s].neighborlist[r]];
	    if (t->liberties == 1)
	      (*saved_stones) += t->size;
	  }
	}
	else if (string[s].liberties == 2 && UNMARKED_STRING(pos)) {
	  (*threatened_stones) += string[s].size;
	  MARK_STRING(pos);
	}
      }
    }
  }
  
#else
#define code1(arg) \
  if (!ON_BOARD(arg)) \
    (*number_edges)++; \
  else if (board[arg] == EMPTY) \
    (*number_open)++; \
  else { \
    int s = string_number[arg]; \
    if (string_number[str] == s) \
      (*number_same_string)++; \
    if (board[arg] == color) { \
      (*number_own)++; \
      if (string[s].liberties == 1) \
	(*saved_stones) += string[s].size; \
    } \
    else { \
      (*number_opponent)++; \
      if (string[s].liberties == 1) { \
	int r; \
	struct string_data *t; \
	(*captured_stones) += string[s].size; \
	for (r = 0; r < string[s].neighbors; r++) { \
	  t = &string[string[s].neighborlist[r]]; \
	  if (t->liberties == 1) \
	    (*saved_stones) += t->size; \
	} \
      } \
      else if (string[s].liberties == 2 && UNMARKED_STRING(arg)) { \
	(*threatened_stones) += string[s].size; \
        MARK_STRING(arg); \
      } \
    } \
  }

  /* Clear the string mark. */
  string_mark++;

  code1(SOUTH(move));
  code1(WEST(move));
  code1(NORTH(move));
  code1(EAST(move));

/* emgena */
#undef code1

#endif
}


/* Reorientation of point (i, j) into (*ri, *rj). */
void
rotate2(int i, int j, int *ri, int *rj, int rot)
{
  ASSERT2(rot >= 0 && rot < 8, i, j);
  if (is_pass(POS(i, j))) {
    *ri = i;
    *rj = j;
    return;
  }
  ASSERT_ON_BOARD2(i, j);
  rotate(i, j, ri, rj, board_size, rot);
}

/* Inverse reorientation of reorientation rot. */
void
inv_rotate2(int i, int j, int *ri, int *rj, int rot)
{
  ASSERT2(rot >= 0 && rot < 8, i, j);
  if (is_pass(POS(i, j))) {
    *ri = i;
    *rj = j;
    return;
  }
  ASSERT_ON_BOARD2(i, j);
  inv_rotate(i, j, ri, rj, board_size, rot);
}

/* 1D board: return reorientation of point pos */
int
rotate1(int pos, int rot)
{
  int i, j;
  ASSERT1(rot >= 0 && rot < 8, pos);
  if (is_pass(pos))
    return PASS_MOVE;
  ASSERT_ON_BOARD1(pos);
  rotate2(I(pos), J(pos), &i, &j, rot);
  return POS(i, j);
}

/* 1D board: return inverse reorientation of point pos */
int
inv_rotate1(int pos, int rot)
{
  int i, j;
  ASSERT1(rot >= 0 && rot < 8, pos);
  if (is_pass(pos))
    return PASS_MOVE;
  ASSERT_ON_BOARD1(pos);
  inv_rotate2(I(pos), J(pos), &i, &j, rot);
  return POS(i, j);
}


/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */


/* globals.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* #include <stdio.h> */

/* #include "sgftree.h" */
/* #include "gnugo.h" */
/* #include "liberty.h" */

/* #include "sgftree.h" */
/* #include "config.h" */

/* 
 * Define all global variables used within the engine.
 */


/* The go board and position. */
int          board_size = 19; /* board size */
Intersection board[BOARDSIZE];
int          board_ko_pos;
int          white_captured;    /* number of black and white stones captured */
int          black_captured;

Intersection initial_board[BOARDSIZE];
int          initial_board_ko_pos;
int          initial_white_captured;
int          initial_black_captured;
int          move_history_color[MAX_MOVE_HISTORY];
int          move_history_pos[MAX_MOVE_HISTORY];
int          move_history_pointer;

int thrashing_dragon = 0; /* Dead opponent's dragon trying to live */

float        komi;
int          movenum;

Intersection shadow[BOARDMAX];

/* Hashing of positions. */
Hash_data    hashdata;

int hashflags = HASH_DEFAULT;

float potential_moves[MAX_BOARD][MAX_BOARD];

/* Used by reading. */
int stackp;             /* stack pointer */
int position_number;    /* position number */
int depth;              /* deep reading cut off */
int backfill_depth;     /* deep reading cut off */
int backfill2_depth;    /* deep reading cut off */
int superstring_depth;  /* deep reading cut off */
int fourlib_depth;      /* deep reading cut off */
int ko_depth;           /* deep reading cut off */
int branch_depth;       /* deep reading cut off */
int aa_depth;
int aa_threat_depth;
int owl_distrust_depth;   /* below this owl trusts the optics code */
int owl_branch_depth;     /* below this owl tries only one variation */
int owl_reading_depth;    /* owl does not read below this depth */
int owl_node_limit;       /* maximum number of nodes considered */
int mandated_depth;             /* deep reading cut off, mandated value */
int mandated_backfill_depth;    /* deep reading cut off, mandated value */
int mandated_backfill2_depth;   /* deep reading cut off, mandated value */
int mandated_superstring_depth; /* deep reading cut off, mandated value */
int mandated_fourlib_depth;     /* deep reading cut off, mandated value */
int mandated_ko_depth;          /* deep reading cut off, mandated value */
int mandated_branch_depth;      /* deep reading cut off, mandated value */
int mandated_aa_depth;
int mandated_aa_threat_depth = -1;
int mandated_owl_distrust_depth;  
int mandated_owl_branch_depth;  
int mandated_owl_reading_depth; 
int mandated_owl_node_limit;    

/* Miscellaneous. */
int quiet            = 0;  /* minimal output */
int showstatistics   = 0;  /* print statistics */
int profile_patterns = 0;  /* print statistics of pattern usage */
int allpats          = 0;  /* generate all patterns, even small ones */
int printworms       = 0;  /* print full data on each string */
int printmoyo        = 0;  /* print moyo board each move */
int printboard       = 0;  /* print board each move */
int count_variations = 0;  /* used by decide_string */
int sgf_dump         = 0;  /* used by decide_string */
SGFTree *sgf_dumptree = NULL;
int random_seed      = 0;  /* random seed */
int loading          = 0;  /* TRUE if last loaded move comes from file */
int life             = 0;  /* use eye reading code */
int life_eyesize     = 0;  /* max eyesize for life code */
int fusekidb         = 1;  /* use fuseki database */
int disable_fuseki   = 0;  /* do not generate fuseki moves */
int josekidb         = 1;  /* use fuseki database */
int showtime         = 0;  /* print time to find move */
int showscore        = 0;  /* print estimated score */
float score          = 0.0;
float lower_bound    = 0.0;
float upper_bound    = 0.0;
int level            = DEFAULT_LEVEL; /* strength; up to 10 supported */
int urgent           = 0;  /* urgent move on board */
int debug            = 0;  /* controls debug output */
int verbose          = 0;  /* trace level */

int disable_threat_computation = 0;
int disable_endgame_patterns   = 0;
int doing_scoring              = 0;

int chinese_rules       = 0;    /* ruleset choice for GMP connection */
/* use experimental semeai module */
int experimental_semeai = EXPERIMENTAL_SEMEAI;
int semeai_variations   = DEFAULT_SEMEAI_VARIATIONS;
/* use experimental connection module */
int experimental_connections = EXPERIMENTAL_CONNECTIONS;
/* use alternate connection reading algorithm */
int alternate_connections = ALTERNATE_CONNECTIONS;
int owl_threats = OWL_THREATS;          /* compute owl threats */

/* use experimental influence module */
int experimental_influence = EXPERIMENTAL_INFLUENCE;

int allow_suicide       = 0;    /* allow opponent to make suicide moves */
int capture_all_dead    = 0;    /* capture all dead opponent stones */
int play_out_aftermath  = 0;    /* make everything unconditionally settled */

float best_move_values[10];
int   best_moves[10];

/* Various statistics are collected here. */
struct stats_data stats;

struct worm_data      worm[BOARDMAX];
struct dragon_data    dragon[BOARDMAX];
int                   number_of_dragons;
struct dragon_data2   *dragon2 = NULL;
struct half_eye_data  half_eye[BOARDMAX];
struct half_eye_data  owl_half_eye[BOARDMAX];
struct eye_data       black_eye[BOARDMAX];
struct eye_data       white_eye[BOARDMAX];
struct eye_data       owl_black_eye[BOARDMAX];
struct eye_data       owl_white_eye[BOARDMAX];



/* hash.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* #include <stdio.h> */
/* #include <stdlib.h> */
/* #include <limits.h> */

/* #include "gnugo.h" */
/* #include "liberty.h" */

/* #include "hash.h" */
/* #include "random.h" */


/*
 * This file, together with engine/hash.h implements hashing of go positions
 * using a method known as Zobrist hashing.  See the Texinfo documentation
 * (Reading/Hashing) for more information.  
 */


static int is_initialized = 0;


/* Random values for the hash function.  For stones and ko position. */
static Hashvalue white_hash[BOARDMAX][NUM_HASHVALUES];	
static Hashvalue black_hash[BOARDMAX][NUM_HASHVALUES];	
static Hashvalue ko_hash[BOARDMAX][NUM_HASHVALUES];

#if FULL_POSITION_IN_HASH
static Compacttype white_patterns[4 * sizeof(Compacttype)];
static Compacttype black_patterns[4 * sizeof(Compacttype)];
#endif


/* Get a random Hashvalue, where all bits are used. */
static Hashvalue
hash_rand(void)
{
  int i;
  Hashvalue h = 0;

  for (i = 0; 32*i < (int) (CHAR_BIT*sizeof(Hashvalue)); i++)
    h |= (Hashvalue) gg_urand() << 32*i;

  return h;
}


/*
 * Initialize the entire hash system.
 */

void
hash_init(void)
{
  int pos;
  int i;
  struct gg_rand_state state;
#if FULL_POSITION_IN_HASH
  int x;
#endif

  if (is_initialized)
    return;
  
  /* Since the hash initialization consumes a varying number of random
   * numbers depending on the size of the Hashvalue type, we save the
   * state of the random generator now and restore it afterwards.
   */
  gg_get_rand_state(&state);
  
#if TRACE_READ_RESULTS
  /* We need consistent hash values when this option is enabled. */
  gg_srand(1);
#endif
  
  for (i = 0; i < NUM_HASHVALUES; i++)
    for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
      /* Note: We initialize _all_ positions, not just those on board.
       * This way we don't have to worry about changing board sizes.
       */
      black_hash[pos][i] = hash_rand();
      white_hash[pos][i] = hash_rand();
      ko_hash[pos][i]    = hash_rand();
    }

  gg_set_rand_state(&state);
  
#if FULL_POSITION_IN_HASH
  {
    Compacttype mask;

    for (x = 0, mask = 1; mask; x++, mask <<= 2) {
      white_patterns[x] = mask;
      black_patterns[x] = mask << 1;
    }
  }
#endif

  is_initialized = 1;
}


/* ---------------------------------------------------------------- */


/* Return 0 if *pos1 == *pos2, otherwise return 1.
 * This adheres (almost) to the standard compare function semantics 
 * which are used e.g. by the comparison functions used in qsort().
 */

#if FULL_POSITION_IN_HASH
int
hashposition_compare(Hashposition *pos1, Hashposition *pos2)
{
  int i;

  /* We need only compare to board_size.  MAX_BOARD is not necessary. */
  for (i = 0; i < (int) (board_size * board_size / POINTSPERCOMPACT + 1); i++)
    if (pos1->board[i] != pos2->board[i]) {
      stats.hash_collisions++;
      return 1;
    }

  if (pos1->ko_pos != pos2->ko_pos) {
    stats.hash_collisions++;
    return 1;
  }

  return 0;
}


/*
 * Dump an ASCII representation of the contents of a Hashposition onto
 * the FILE outfile. 
 */

void
hashposition_dump(Hashposition *pos, FILE *outfile)
{
  int i;

  gfprintf(outfile, "Board:  ");
  for (i = 0; i < (int) COMPACT_BOARD_SIZE; ++i)
    gfprintf(outfile, " %lx", (unsigned long) pos->board[i]);

  if (pos->ko_pos == 0)
    gfprintf(outfile, "  No ko");
  else
    gfprintf(outfile, "  Ko position: %1m", pos->ko_pos);
}
#endif 		/* FULL_POSITION_IN_HASH */


/* ---------------------------------------------------------------- */


/* Calculate the compactboard and the hashvalues in one function.
 * They are always used together and it saves us a loop and a function 
 * call.
 */

void 
hashdata_recalc(Hash_data *target, Intersection *p, int ko_pos)
{
#if FULL_POSITION_IN_HASH
  unsigned int index;
  Compacttype bits;
#endif
  int pos;
  int i;

  for (i = 0; i < NUM_HASHVALUES; i++)
    target->hashval[i] = 0;
#if FULL_POSITION_IN_HASH
  bits = 1;
  index = 0;
  target->hashpos.board[index] = 0;
#endif
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (!ON_BOARD(pos))
      continue;
    switch (p[pos]) {
      default:
      case EMPTY: 
#if FULL_POSITION_IN_HASH
	bits <<= 2;
#endif
	break;
      case WHITE:
        for (i = 0; i < NUM_HASHVALUES; i++)
	  target->hashval[i] ^= white_hash[pos][i];
#if FULL_POSITION_IN_HASH
	target->hashpos.board[index] |= bits;
	bits <<= 2;
#endif
	break;
      case BLACK:
        for (i = 0; i < NUM_HASHVALUES; i++)
	  target->hashval[i] ^= black_hash[pos][i];
#if FULL_POSITION_IN_HASH
	bits <<= 1;
	target->hashpos.board[index] |= bits;
	bits <<= 1;
#endif
	break;
    }

#if FULL_POSITION_IN_HASH
    if (!bits) {
      /* This means the bit fell off the left side. */
      bits = 1;
      index++;
      if (index < COMPACT_BOARD_SIZE)
	target->hashpos.board[index] = 0;
    }
#endif
  }

  /* This cleans up garbage bits at the (unused) end of the array.
   * It probably should not really be necessary.
   */
#if FULL_POSITION_IN_HASH
  while (++index < COMPACT_BOARD_SIZE)
    target->hashpos.board[index] = 0;
#endif

  if (ko_pos != 0)
    for (i = 0; i < NUM_HASHVALUES; i++)
      target->hashval[i] ^= ko_hash[ko_pos][i];

#if FULL_POSITION_IN_HASH
  target->hashpos.ko_pos = ko_pos;
#endif
}


/*
 * Set or remove ko in the hash value and hash position.
 */

void
hashdata_invert_ko(Hash_data *hd, int pos)
{
  int i;
  for (i = 0; i < NUM_HASHVALUES; i++)
    hd->hashval[i] ^= ko_hash[pos][i];
#if FULL_POSITION_IN_HASH
  hd->hashpos.ko_pos = pos;
#endif
}



/*
 * Set or remove a stone of COLOR at pos in a Hash_data.
 */

void
hashdata_invert_stone(Hash_data *hd, int pos, int color)
{
#if FULL_POSITION_IN_HASH
  int i = I(pos);
  int j = J(pos);
  int index = (i * board_size + j) / POINTSPERCOMPACT;
  int subindex = (i * board_size + j) % POINTSPERCOMPACT;
#endif
  int k;

  if (color == BLACK) {
    for (k = 0; k < NUM_HASHVALUES; k++)
      hd->hashval[k] ^= black_hash[pos][k];
#if FULL_POSITION_IN_HASH
    hd->hashpos.board[index] ^= black_patterns[subindex];
#endif
  }
  else if (color == WHITE) {
    for (k = 0; k < NUM_HASHVALUES; k++)
      hd->hashval[k] ^= white_hash[pos][k];
#if FULL_POSITION_IN_HASH
    hd->hashpos.board[index] ^= white_patterns[subindex];
#endif
  }
}


/*
 * Compare two Hash_data, if different: dump an ASCII representation 
 * of the differences to stderr.
 * return is the same as for hashposition_compare()
 */

#if FULL_POSITION_IN_HASH
int
hashdata_diff_dump(Hash_data *hd1, Hash_data *hd2)
{
  int retval;
  int pos, i;
  int count1[4], count2[4];
  static const char letter[] = "abcdefghjklmnopqrstuvwxyz";
  static const char *hashcolors[] = {"Empty", "White", "Black", "Grey!"};

  retval = hashdata_compare(hd1, hd2);
  if (retval == 0)
    return retval;

  for (i = 0; i < 4; i++) {
    count1[i] = 0;
    count2[i] = 0;
  }

  fprintf(stderr, "Differences: ");
  for (i = 0; i < COMPACT_BOARD_SIZE; i++) {
    if (hd1->hashpos.board[i] != hd2->hashpos.board[i])
      fprintf(stderr, "\nSlot %d: (%lx <==> %lx)" , i,
	      (unsigned long) hd1->hashpos.board[i],
	      (unsigned long) hd2->hashpos.board[i]);
    
    for (pos = 0; pos < POINTSPERCOMPACT; pos++) {
      unsigned int u1, u2;
      int xx, yy, zz;

      u1 = (hd1->hashpos.board[i] >> (2*pos)) & 3;
      u2 = (hd2->hashpos.board[i] >> (2*pos)) & 3;
      count1[u1]++;
      count2[u2]++;
      if (u1 == u2)
	continue;
      
      zz = (i * POINTSPERCOMPACT) + pos;
      xx = zz / MAX_BOARD;
      yy = zz % MAX_BOARD;
      fprintf(stderr, "\n#%2d: [%c%d] %s<==>%s", pos, letter[xx], yy,
	      hashcolors[u1], hashcolors[u2]);
    }
  }

  if (hd1->hashpos.ko_pos == 0 && hd2->hashpos.ko_pos == 0)
    fprintf(stderr, "\nNo ko\n");
  else if (hd1->hashpos.ko_pos == hd2->hashpos.ko_pos)
    gfprintf(stderr, "\nEqual Ko position:[%1m]\n", hd1->hashpos.ko_pos);
  else
    gfprintf(stderr, "\nDifferent Ko position:[%1m] <==> [%1m]\n",
	    hd1->hashpos.ko_pos, hd2->hashpos.ko_pos);

  fprintf(stderr, "Total [%d,%d,%d,%d]",
	  count1[0], count1[1], count1[2], count1[3]);
  fprintf(stderr, " <==> [%d,%d,%d,%d]\n",
	  count2[0], count2[1], count2[2], count2[3]);

  return retval;
}
#endif


int
hashdata_compare(Hash_data *hd1, Hash_data *hd2)
{
  int rc = 0;
  int i;

  for (i = 0; i < NUM_HASHVALUES; i++)
    if (hd1->hashval[i] != hd2->hashval[i]) 
      rc = 2;
  if ( rc == 2 && i > 0)
    stats.hash_collisions++;

#if FULL_POSITION_IN_HASH
  if (rc == 0)
    rc = hashposition_compare(&hd1->hashpos, &hd2->hashpos);
#endif

  return rc;
}


/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */



/* printutils.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* #include <stdio.h> */
/* #include <string.h> */
/* #include <stdlib.h> */
/* #include <stdarg.h> */
/* #include <ctype.h> */

/* #include "gnugo.h" */
/* #include "liberty.h" */
/* #include "gg_utils.h" */

/* #include "cache.h" */


/*
 * This function underpins all the TRACE and DEBUG stuff.
 * It accepts %c, %d, %f, %s, and %x as usual. But it
 * also accepts %m, which takes TWO integers and writes a move.
 * Other accepted formats are
 * %H: Print a hashvalue.
 * %C: Print a color as a string.
 * %M: Like %m but three characters wide for all moves (pads with spaces).
 * Nasty bodge: %o at the start means outdent, i.e. cancel indent.
 */

static void 
vgprintf(FILE* outputfile, const char *fmt, va_list ap)
{
  if (fmt[0] == '%' && fmt[1] == 'o')
    fmt += 2;  /* cancel indent */
  else if (stackp > 0)
    fprintf(outputfile, "%.*s", stackp*2, "                                ");

  for (; *fmt ; ++fmt) {
    if (*fmt == '%') {
      switch (*++fmt) {
      case 'c':
      {
	/* rules of promotion => passed as int, not char */
	int c = va_arg(ap, int);
	putc(c, outputfile);
	break;
      }
      case 'd':
      {
	int d = va_arg(ap, int);
	fprintf(outputfile, "%d", d);
	break;
      }
      case 'x':
      {
	int d = va_arg(ap, int);
	fprintf(outputfile, "%x", d);
	break;
      }
      case 'f':
      {
	double f = va_arg(ap, double); /* passed as double, not float */
	fprintf(outputfile, "%.2f", f);
	break;
      }
      case 's':
      {
	char *s = va_arg(ap, char*);
	fputs(s, outputfile);
	break;
      }
      case 'm':
      case 'M':
      {
	char movename[4];
	int m = va_arg(ap, int);
	int n = va_arg(ap, int);
	if (m == -1 && n == -1)
	  fputs("PASS", outputfile);
	else if (!ON_BOARD2(m, n))
	  fprintf(outputfile, "[%d,%d]", m, n);
	else {
	  /* Generate the move name. */
	  if (n < 8)
	    movename[0] = n + 65;
	  else
	    movename[0] = n + 66;
	  if (*fmt == 'm')
	    sprintf(movename+1, "%d", board_size - m);
	  else
	    sprintf(movename+1, "%-2d", board_size - m);
	  fputs(movename, outputfile);
	}
	break;
      }
      case '1':
      fmt++;
      if (*fmt != 'm' && *fmt != 'M') {
	fprintf(outputfile, "\n\nUnknown format string '1%c'\n", *fmt);
	break;
      }
      else {
	char movename[4];
	int pos = va_arg(ap, int);
	int m = I(pos);
	int n = J(pos);
	if (pos == NO_MOVE)
	  fputs("PASS", outputfile);
	else if (!ON_BOARD1(pos))
	  fprintf(outputfile, "[%d]", pos);
	else {
	  /* Generate the move name. */
	  if (n < 8)
	    movename[0] = n + 65;
	  else
	    movename[0] = n + 66;
	  if (*fmt == 'm')
	    sprintf(movename + 1, "%d", board_size - m);
	  else
	    sprintf(movename + 1, "%-2d", board_size - m);
	  fputs(movename, outputfile);
	}
	break;
      }
      case 'H':
      {
	long h = va_arg(ap, int);
	fprintf(outputfile, "%lx", h);
	break;
      }
      case 'C':
      {
	int color = va_arg(ap, int);
	fputs(color_to_string(color), outputfile);
	break;
      }
      default:
	fprintf(outputfile, "\n\nUnknown format character '%c'\n", *fmt);
	break;
      }
    }
    else
      putc(*fmt, outputfile);
  }
}


/*
 * required wrapper around vgprintf, writes to outfile.
 */

void 
gfprintf(FILE *outfile, const char *fmt, ...)
{
  va_list ap;
  va_start(ap, fmt);
  vgprintf(outfile, fmt, ap);
  va_end(ap);
}


/*
 * required wrapper around vgprintf, writes to stderr.
 * Always returns 1 to allow use in short-circuit logical expressions.
 */

int 
gprintf(const char *fmt, ...)
{
  va_list ap;
  va_start(ap, fmt);
  vgprintf(stderr, fmt, ap);
  va_end(ap);
  return 1;
}


/*
 * required wrapper around vgprintf, in contrast to gprintf this one
 * writes to stdout.
 */

void
mprintf(const char *fmt, ...)
{
  va_list ap;
  va_start(ap, fmt);
  vgprintf(stdout, fmt, ap);
  va_end(ap);
}

#ifndef HAVE_VARIADIC_DEFINE

/* See gnugo.h for related TRACE family macro definitions */

int trace_dummy;

/* Always returns 1 to allow use in short-circuit logical expressions. */
int 
DEBUG_func(int flag, const char *fmt, ...)
{
  va_list ap;

  if (debug & flag) {
    va_start(ap, fmt);
    vgprintf(stderr, fmt, ap);
    va_end(ap);
  }

  return 1;
}

#endif /*HAVE_VARIADIC_DEFINE*/


/*
 * A wrapper around abort() which shows the state variables at the time
 * of the problem.  (i, j) are typically a related move, or -1, -1.
 */

void 
abortgo(const char *file, int line, const char *msg, int x, int y)
{
  verbose = 4;
  TRACE("%o\n\n***assertion failure:\n%s:%d - %s near %m***\n\n",
	file, line, msg, x, y);
  dump_stack();

  /* Dump the stack as board images. */
  showboard(0);
  while (stackp > 0) {
    popgo();
    showboard(0);
  }

#if 0
  if (sgf_root) {
    sgf_write_header(sgf_root, 1, random_seed, komi, level);
    writesgf(sgf_root, "abortgo.sgf");
  }
#endif

  fprintf(stderr, "\ngnugo %s (seed %d): You stepped on a bug.\n",
          gg_version(), random_seed);
  if (board_size >= 9 && board_size <= 19) {
    fprintf(stderr, "\
Please save this game as an sgf file and mail it to gnugo@gnu.org\n\
If you can, please also include the debug output above this message.\n");
  }
  fprintf(stderr, "\n");

  fflush(stderr);
  fflush(stdout);

  abort();  /* cause core dump */
}


/* Convert a color value to a string. */
const char *
color_to_string(int color)
{
  if (color == EMPTY)
    return "empty";
  else if (color == WHITE)
    return "white";
  else if (color == BLACK)
    return "black";
  else if (color == GRAY)
    return "gray";
  else if (color == WHITE_BORDER)
    return "white border";
  else if (color == BLACK_BORDER)
    return "black border";
  else
    return "purple?";
}

/* Convert a location to a string. */
const char *
location_to_string(int pos)
{
  static int init = 0;
  static char buf[BOARDSIZE][5];
  if (!init) {
    int pos;
    for (pos = 0; pos < BOARDSIZE; pos++)
      location_to_buffer(pos, buf[pos]);
    init = 1;
  }
  ASSERT1(pos >= 0 && pos < BOARDSIZE, pos);
  return buf[pos];
}

/* Convert a location to a string, writing to a buffer. */

void
location_to_buffer(int pos, char *buf)
{
  char *bufp = buf;
  int i = I(pos);
  int j = J(pos);

  if (pos == NO_MOVE) {
    strcpy(buf, "Pass");
    return;
  }

  *bufp = 'A'+j;
  if (*bufp >= 'I')
    (*bufp)++;
  bufp++;

  i = board_size - i;
  if (i > 9)
    *bufp++ = '0' + i/10;
  *bufp++ = '0' + i%10;

  *bufp = 0;
}

/* Convert a status value to a string. */
const char *
status_to_string(int status)
{
  if (status == DEAD)
    return "DEAD";
  else if (status == ALIVE)
    return "ALIVE";
  else if (status == CRITICAL)
    return "CRITICAL";
  else if (status == UNKNOWN)
    return "UNKNOWN";
  else if (status == UNCHECKED)
    return "UNCHECKED";
  else if (status == CAN_THREATEN_ATTACK)
    return "CAN_THREATEN_ATTACK";
  else if (status == CAN_THREATEN_DEFENSE)
    return "CAN_THREATEN_DEFENSE";
  else
    return "ERROR";
}


/* Convert a safety value to a string. */
const char *
safety_to_string(int status)
{
  if (status == DEAD)
    return "DEAD";
  else if (status == ALIVE)
    return "ALIVE";
  else if (status == CRITICAL)
    return "CRITICAL";
  else if (status == INESSENTIAL)
    return "INESSENTIAL";
  else if (status == TACTICALLY_DEAD)
    return "TACTICALLY_DEAD";
  else if (status == INESSENTIAL)
    return "INESSENTIAL";
  else if (status == TACTICALLY_DEAD)
    return "TACTICALLY_DEAD";
  else if (status == WEAK)
    return "WEAK";
  else if (status == WEAKLY_ALIVE)
    return "WEAKLY_ALIVE";
  else if (status == ALIVE_IN_SEKI)
    return "ALIVE_IN_SEKI";
  else if (status == STRONGLY_ALIVE)
    return "STRONGLY_ALIVE";
  else if (status == INVINCIBLE)
    return "INVINCIBLE";
  else if (status == INSUBSTANTIAL)
    return "INSUBSTANTIAL";
  else if (status == CAN_THREATEN_ATTACK)
    return "CAN_THREATEN_ATTACK";
  else if (status == CAN_THREATEN_DEFENSE)
    return "CAN_THREATEN_DEFENSE";
  else
    return "ERROR";
}

/* Convert a routine to a string. */
const char *
routine_to_string(int routine)
{
  if (routine == FIND_DEFENSE)
    return "FIND_DEFENSE";
  else if (routine == DEFEND1)
    return "DEFEND1";
  else if (routine == DEFEND2)
    return "DEFEND2";
  else if (routine == DEFEND3)
    return "DEFEND3";
  else if (routine == DEFEND4)
    return "DEFEND4";
  else if (routine == ATTACK)
    return "ATTACK";
  else if (routine == ATTACK2)
    return "ATTACK2";
  else if (routine == ATTACK3)
    return "ATTACK3";
  else if (routine == OWL_ATTACK)
    return "OWL_ATTACK";
  else if (routine == OWL_DEFEND)
    return "OWL_DEFEND";
  else if (routine == SEMEAI)
    return "SEMEAI";
  else if (routine == CONNECT)
    return "CONNECT";
  else if (routine == DISCONNECT)
    return "DISCONNECT";
  else
    return "ERROR";
}

/* Convert a read result to a string */
const char *
result_to_string(int result)
{
  if (result == 0)
    return "0";
  else if (result == KO_A)
    return "KO_A";
  else if (result == KO_B)
    return "KO_B";
  else if (result == WIN)
    return "WIN";
  else if (result == ALIVE_IN_SEKI)
    return "SEKI";
  else
    return "ERROR";
}



/*
 * Get the (m, n) coordinates in the standard GNU Go coordinate system
 * from the string STR.  This means that m is the nth row from the top
 * and n is the column. Both coordinates are between 0 and boardsize-1,
 * inclusive.
 *
 * Return 1 if ok, otherwise return 0;
 */

int
string_to_location(int boardsize, char *str, int *m, int *n)
{
  if (*str == '\0')
    return 0;

  if (!isalpha((int) *str))
    return 0;
  *n = tolower((int) *str) - 'a';
  if (tolower((int) *str) >= 'i')
    --*n;
  if (*n < 0 || *n > boardsize - 1)
    return 0;

  if (!isdigit((int) *(str+1)))
    return 0;
  *m = boardsize - atoi(str + 1);
  if (*m < 0 || *m > boardsize - 1)
    return 0;

  return 1;
}


/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */




/* sgffile.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*
 * sgffile.c
 *
 * This file contains functions that create an SGF file on the fly.
 * There can be only one file open simultaneously.
 *
 * See sgf/sgftree.c for more general handling of SGF trees and file I/O.
 *
 */

/* #include <stdio.h> */
/* #include <stdarg.h> */
/* #include <stdlib.h> */
/* #include <signal.h> */
/* #include <string.h> */

/* #include "sgftree.h" */

/* #include "gnugo.h" */
/* #include "liberty.h" */


/* The SGF file while a game is played. */
static FILE *sgfout = NULL;

static int sgffile_flush_file(void);


/* ================================================================ */


/*
 * Handling of the SGF file itself (open, close, etc).
 */


/*
 * Open the sgf file for output.  The filename "-" means stdout.
 */

int 
sgffile_open_file(const char *sgf_filename)
{
  /* If the file already was open, close it and assume we want to
   * start writing from scratch.
   */
  if (sgfout)
    sgffile_close_file();
  
  if (strcmp(sgf_filename, "-") == 0)
    sgfout = stdout;
  else
    sgfout = fopen(sgf_filename, "w");
  
  if (!sgfout)
    return 0;
  else
    return 1;
}


/*
 * Flush buffered output to the sgf file.
 */

static int 
sgffile_flush_file()
{
  if (!sgfout) 
    return 0;
  
  fflush(sgfout);
  return 1;
}


/*
 * Close the sgf file for output.
 */

int 
sgffile_close_file()
{
  if (!sgfout)
    return 0;
  
  fprintf(sgfout, ")\n");
  /* Don't close sgfout if it happens to be stdout. */
  if (sgfout != stdout)
    fclose(sgfout);
  sgfout = NULL;
  
  return 1;
}


/* ---------------------------------------------------------------- */


/*
 * Basic output functions.
 */


/*
 * Write a line to the sgf file.
 */

int 
sgffile_write_line(const char * line, ...)
{
  va_list ap;

  if (!sgfout)
    return 0;

  va_start(ap, line);
  vfprintf(sgfout, line, ap);
  va_end(ap);

  return sgffile_flush_file();
}


/*
 * Write a comment to the SGF file.
 */

void
sgffile_write_comment(const char *comment)
{
  if (sgfout)
    fprintf(sgfout, "C[%s]", comment);
}


/*
 * Add a stone to the SGF file.
 */

void
sgffile_put_stone(int i, int j, int color)
{
  if (sgfout)
    fprintf(sgfout, "A%c[%c%c]", color==WHITE ? 'W' : 'B',
	    'a' + j, 'a' + i);
}


/*
 * Add a circle mark to the SGF file
 */

void
sgffile_write_circle_mark(int i, int j)
{
  if (sgfout)
    fprintf(sgfout, "CR[%c%c]", 'a' + j, 'a' + i);
}


/* 
 * Write header information to the sgf file.
 */

int 
sgffile_write_gameinfo(Gameinfo *ginfo, const char *gametype)
{
  char outbuf[200];

  if (!sgfout) 
    return 0;

  fprintf(sgfout, "(;GM[1]FF[4]");
  fprintf(sgfout, "RU[%s]", "Japanese");
  fprintf(sgfout, "SZ[%d]", board_size);
  fprintf(sgfout, "\n");
  
  sprintf(outbuf, "GNU Go %s (level %d) %s", VERSION, level, gametype);
  fprintf(sgfout, "PW[%s]PB[%s]", 
	  (ginfo->computer_player == WHITE 
	   || ginfo->computer_player == GRAY) ? outbuf : "Unknown",
	  (ginfo->computer_player == BLACK 
	   || ginfo->computer_player == GRAY) ? outbuf : "Unknown");
  fprintf(sgfout, "HA[%d]", ginfo->handicap);
  fprintf(sgfout, "KM[%.1f]", komi);
  fprintf(sgfout, "GN[GNU Go %s %s ", VERSION, gametype);
  fprintf(sgfout, "Random Seed %d", random_seed);
  fprintf(sgfout, "] ");
  fprintf(sgfout, "\n");
  
  return sgffile_flush_file();
}


/* ---------------------------------------------------------------- */


/*
 * The functions below here accesses internal gnugo data structures.
 */


/*
 * A move has been made; Write out the move and the potential moves
 * that were also considered.
 */

void 
sgffile_move_made(int i, int j, int color, int value)
{
  int m, n;
  int done_label = 0;
  
  if (!sgfout)
    return;

  for (m = 0; m < board_size; ++m) {
    for (n = 0; n < board_size; ++n) {
      if (potential_moves[m][n] > 0.0) {
	if (!done_label) {
	  fprintf(sgfout, "\nLB");
	  done_label = 1;
	}
	if (potential_moves[m][n] < 1.0)
	  fprintf(sgfout, "[%c%c:<1]", 'a'+n, 'a'+m);
	else
	  fprintf(sgfout, "[%c%c:%d]", 'a'+n, 'a'+m,
		  (int) potential_moves[m][n]);
      }
    }
  }

  if (value)
    fprintf(sgfout, "\nC[Value of move: %d]", value);

  /* If it is a pass move */
  if (is_pass(POS(i, j))) {
    if (board_size > 19)
      fprintf(sgfout, "\n;%c[]\n", color == WHITE ? 'W' : 'B');
    else
      fprintf(sgfout, "\n;%c[tt]\n", color == WHITE ? 'W' : 'B');
  }
  else
    fprintf(sgfout, "\n;%c[%c%c]\n", color == WHITE ? 'W' : 'B',
	    'a' + j, 'a' + i);

  fflush(sgfout);  /* in case cgoban terminates us without notice */
}  


/*
 * Mark dead and critical dragons in the sgf file.
 */

void 
sgffile_dragon_status(int i, int j, int status)
{
  if (sgfout) {
    switch (status) {
      case DEAD:
	fprintf(sgfout, "LB[%c%c:X]\n", 'a'+j, 'a'+i);
	break;
      case CRITICAL:
	fprintf(sgfout, "LB[%c%c:!]\n", 'a'+j, 'a'+i);
	break;
    }
  }
}


/* ---------------------------------------------------------------- */

/*
 * sgffile_printboard writes the current board position to the output file.
 * The parameter next, tells whose turn it is to move.
 */

void
sgffile_printboard(int next) 
{
  int i, j;
  int start = 0;

  if (!sgfout)
    return;

  /* Write the white stones to the file. */
  for (i = 0; i < board_size; i++) {
    for (j = 0; j < board_size; j++) {
      if (BOARD(i, j) == WHITE) {
	if (!start) {
	  fprintf(sgfout, "AW");
	  start = 1;
	}
	fprintf(sgfout, "[%c%c]", j+'a', i+'a');
      }
    }
  }
  fprintf(sgfout, "\n");

  /* Write the black stones to the file. */
  start = 0;
  for (i = 0; i < board_size; i++) {
    for (j = 0; j < board_size; j++) {
      if (BOARD(i, j) == BLACK) {
	if (!start) {
	  fprintf(sgfout, "AB");
	  start = 1;
	}
	fprintf(sgfout, "[%c%c]", j+'a', i+'a');
      }
    }
  }
  fprintf(sgfout, "\n");

  /* If no game is going on, then return. */
  if (next != WHITE && next != BLACK) 
    return;

  /* Write whose turn it is to move. */
  if (next == WHITE) 
    fprintf(sgfout, "PL[W]\n"); 
  else if (next == BLACK)
    fprintf(sgfout, "PL[B]\n"); 

  /* Mark the intersections where it is illegal to move. */
  start = 0;
  for (i = 0; i < board_size; i++) {
    for (j = 0; j < board_size; j++) {
      if (BOARD(i, j) == EMPTY && !is_legal(POS(i, j), next)) {
	if (!start) {
	  fprintf(sgfout, "IL");
	  start = 1;
	}
	fprintf(sgfout, "[%c%c]", j+'a', i+'a');
      }
    }
  }
  fprintf(sgfout, "\n");
}


/* ================================================================ 
 * Dumping of information about a position into an sgftree.
 * Used by sgffile_decideposition, etc.
 * ================================================================ */


/*
 * begin_sgftreedump begins storing all moves considered by
 * trymove and tryko in an sgf tree in memory.
 *
 * The caller only has to provide an own SGFTree pointer if he wants
 * to do something more with the tree than writing it to file as done
 * by end_sgftreedump().
 */

void
begin_sgftreedump(SGFTree *tree)
{
  SGFNode *node;
  static SGFTree local_tree;
  gg_assert(sgf_dumptree == NULL);

  if (tree == NULL)
    sgf_dumptree = &local_tree;
  else 
    sgf_dumptree = tree;
  
  sgftree_clear(sgf_dumptree);
  node = sgftreeCreateHeaderNode(sgf_dumptree, board_size, 0.0);
  sgftreeSetLastNode(sgf_dumptree, node);
  sgftree_printboard(sgf_dumptree);
}


/*
 * end_sgftreedump ends the dump and writes the sgf tree to file.
 */

void 
end_sgftreedump(const char *filename)
{
  writesgf(sgf_dumptree->root, filename);
  sgf_dumptree = NULL;
}


/*
 * sgftree_printboard adds the current board position to the tree.
 */

void
sgftree_printboard(SGFTree *tree)
{
  int i, j;
  SGFNode *node;
  
  gg_assert(tree);
  node = sgfAddChild(tree->lastnode);
  
  /* Write the white stones to the file. */
  for (i = 0; i < board_size; i++) {
    for (j = 0; j < board_size; j++) {
      if (BOARD(i, j) == WHITE)
	sgfAddStone(node, WHITE, i, j);
    }
  }

  /* Write the black stones to the file. */
  for (i = 0; i < board_size; i++) {
    for (j = 0; j < board_size; j++) {
      if (BOARD(i, j) == BLACK)
	sgfAddStone(node, BLACK, i, j);
    }
  }

  sgftreeSetLastNode(tree, node);
}


void
sgffile_recordboard(SGFNode *node)
{
  int i, j;

  for (i = 0; i < board_size; i++) {
    for (j = 0; j < board_size; j++) {
      if (BOARD(i, j) == BLACK) {
	sgffile_put_stone(i, j, BLACK);
	if (node)
	  sgfAddStone(node, BLACK, i, j);
      }
    }
  }
}


/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */



/* showboard.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*-------------------------------------------------------------
  showbord.c -- Show current go board and playing information
-------------------------------------------------------------*/

/* 
 * NOTE : this is no longer intended as the main user interface
 * as it was in GNU Go 1.2. It is now a debugging aid, showing
 * the internal state of dragons, and things. But with
 * color enabled, it should be easy enough to see the state
 * of play at a glance.
 *
 * Note : the dragons must have been calculated before this is called
 */

/* #include <stdio.h> */
/* #include <stdlib.h> */
/* #include <string.h> */

/* #include "gnugo.h" */
/* #include "liberty.h" */
/* #include "gg_utils.h" */


/*
 * Stuff to enumerate the dragons 
 */

/* Element at origin of each worm stores allocated worm number. */
static unsigned char dragon_num[BOARDMAX];

static int next_white;		/* next worm number to allocate */
static int next_black;

/* linux console :
 *  0=black
 *  1=red             [critical]
 *  2=green           [alive]
 *  3=yellow/brown    [unknown]
 *  4=blue
 *  5=magenta
 *  6=cyan            [dead]
 *  7=white           [unchecked]
 */

/* Both black and white are common background colors and should be
 * avoided.
 */
static const int colors[3][5] = {
  {0,0,0,0,0}, /*not used */
  {6,2,1,3,5}, /* WHITE : dead, alive, critical, unknown, unchecked */
  {6,2,1,3,5}  /* BLACK : dead, alive, critical, unknown, unchecked */
};

static const int domain_colors[4] = {5, 1, 2, 3}; /* gray, black, white, both */


/* True if the coordinate is a hoshi point.
 */
static int
is_hoshi_point(int m, int n)
{
  int hoshi;
  int middle;

  /* No hoshi points on these boards. */
  if (board_size == 2 || board_size == 4)
    return 0;

  /* In the middle of a 3x3 board. */
  if (board_size == 3) {
    if (m == 1 && n == 1)
      return 1;

    return 0;
  }

  if (board_size == 5) {
    if (m == 1 && (n == 1 || n == 3))
      return 1;
    if (m == 2 && n == 2)
      return 1;
    if (m == 3 && (n == 1 || n == 3))
      return 1;

    return 0;
  }

  /* 3-3 points are hoshi on sizes 7--11, 4-4 on larger. */
  if (board_size <= 11)
    hoshi = 2;
  else
    hoshi = 3;

  /* Coordinate for midpoint. */
  middle = board_size/2;
    
  /* Normalize the coordinates by mirroring to the lower numbers. */
  if (m >= middle)
    m = board_size - 1 - m;
  if (n >= middle)
    n = board_size - 1 - n;
  
  /* Is this a corner hoshi? */
  if (m == hoshi && n == hoshi)
    return 1;

  /* If even sized board, only hoshi points in the corner. */
  if (board_size%2 == 0)
    return 0;

  /* Less then 12 in board size only middle point. */
  if (board_size < 12) {
    if (m == middle && n == middle)
      return 1;

    return 0;
  }

  /* Is this a midpoint hoshi? */
  if ((m == hoshi || m == middle)
      && (n == hoshi || n == middle))
    return 1;

  /* No more chances. */
  return 0;
}

/* Print a line with coordinate letters above the board. */
static void
draw_letter_coordinates(void)
{
  int i;
  int ch;
  
  fprintf(stderr, "  ");
  for (i = 0, ch = 'A'; i < board_size; i++, ch++) {
    if (ch == 'I')
      ch++;
    fprintf(stderr, " %c", ch);
  }
}


/* The following four functions define an API for drawing boards. The
 * typical use would be along the following lines:
 *
 * start_draw_board();
 * for (m = 0; m < board_size; m++)
 *   for (n = 0; n < board_size; n++) {
 *     int color = ...;
 *     int c = ...;
 *     draw_color_char(m, n, c, color);
 *   }
 * end_draw_board();
 *
 * Coordinate system, hoshi points, and linefeeds are written
 * automatically by the board drawing functions. The coordinates m, n
 * must be ordered as in the full loops above.
 *
 */

/* Init color and print a line with coordinate letters above the board. */
void
start_draw_board()
{
  gg_init_color();
  draw_letter_coordinates();
}

/* Draw a colored character. If c has the value EMPTY, either a "." or
 * a "+" is drawn, depending on whether it is a hoshi stone. If this
 * is the first or last intersection on a line, the coordinate number
 * is also drawn.
 */
void
draw_color_char(int m, int n, int c, int color)
{
  /* Is this the first column? */
  if (n == 0)
    fprintf(stderr, "\n%2d", board_size - m);

  /* Do we see a hoshi point? */
  if (c == EMPTY) {
    if (is_hoshi_point(m, n))
      c = '+';
    else
      c = '.';
  }

  /* Use fprintf to draw black characters. This way they'll turn out
   * white on terminals with black background.
   */
  if (color == GG_COLOR_BLACK)
    fprintf(stderr, " %c", c);
  else
    write_color_char(color, c);
  
  /* Is this the last column? */
  if (n == board_size - 1)
    fprintf(stderr, " %-2d", board_size - m);
}

/* Draw a black character as specified above. */
void
draw_char(int m, int n, int c)
{
  draw_color_char(m, n, c, GG_COLOR_BLACK);
}

/* Print a line with coordinate letters under the board. */
void
end_draw_board()
{
  fprintf(stderr, "\n");
  draw_letter_coordinates();
  fprintf(stderr, "\n");
}


/* 
 * Write one stone. Use 'empty' if the board is empty ('-' or '+')
 * We use capital letters A,B,... for black, lower case a,b,... for white.
 * This allows us to indicate up to 26 dragons uniquely, and more with
 * low risk of ambiguity.
 */

/* The variable xo=1 if running gnugo -T, 2 if running gnugo -E, or
 * 3 if displaying owl_status.
 */

static void 
showchar(int i, int j, int empty, int xo)
{
  struct dragon_data *d;  /* dragon data at (i, j) */
  int x;
  ASSERT_ON_BOARD2(i, j);
  x = BOARD(i, j);
  d = &(dragon[POS(i, j)]);

  if (x == EMPTY) {
    if (xo != 2)
      fprintf(stderr, " %c", empty);
    else {
      int empty_color;
      char empty_char;
      
      if (black_eye[POS(i, j)].color == BLACK_BORDER) {
	if (white_eye[POS(i, j)].color == WHITE_BORDER)
	  empty_color = domain_colors[3];
	else
	  empty_color = domain_colors[1];

	if (black_eye[POS(i, j)].marginal)
	  empty_char = '!';
	else
	  empty_char = 'x';
      }
      else if (white_eye[POS(i, j)].color == WHITE_BORDER) {
	empty_color = domain_colors[2];
	if (white_eye[POS(i, j)].marginal)
	  empty_char = '!';
	else
	  empty_char = 'o';
      }
      else {
	empty_color = domain_colors[0];
	empty_char = '.';
      }

      write_color_char(empty_color, empty_char);
    }
  }
  else {
    int w;

    if (xo == 0 || ! ON_BOARD1(d->origin)) {
      fprintf(stderr, " %c", BOARD(i, j) == BLACK ? 'X' : 'O');
      return;
    }

    /* Figure out ascii character for this dragon. This is the
     * dragon number allocated to the origin of this worm. */

    w = dragon_num[d->origin];
    if (!w) {
      /* Not yet allocated - allocate next one. */
      /* Count upwards for black, downwards for white to reduce confusion. */
      if (BOARD(i, j) == BLACK)
	w = dragon_num[d->origin] = next_black++;
      else
	w = dragon_num[d->origin] = next_white--; 
    }

    w = w%26 + (BOARD(i, j) == BLACK ? 'A' : 'a');
    
    /* Now draw it. */
    if (xo == 1)
      write_color_char(colors[BOARD(i, j)][d->status], w);
    else if (xo == 2) {
      if (BOARD(i, j) == BLACK)
	write_color_char(domain_colors[1], 'X');
      else
	write_color_char(domain_colors[2], 'O');
    }
    else if (xo == 3)
      write_color_char(colors[BOARD(i, j)][d->owl_status], w);
  }
}




/*
 * Show go board.
 *
 * xo=0:      black and white XO board for ascii game
 * xo=1:      colored dragon display
 * xo=2:      colored eye display
 * xo=3:      colored owl display
 *
 */

void
showboard(int xo)
{
  int i, j, ii;
  gg_init_color();

  /* Set all dragon numbers to 0. */
  memset(dragon_num, 0, sizeof(dragon_num));
  
  next_white = (259 - 26);
  next_black = 26;
  
  start_draw_board();
  
  for (i = 0; i < board_size; i++) {
    ii = board_size - i;
    fprintf(stderr, "\n%2d", ii);
    
    for (j = 0; j < board_size; j++)
      showchar(i, j, is_hoshi_point(i, j) ? '+' : '.', xo);
    
    fprintf(stderr, " %d", ii);
    
    if ((xo == 0) && ((board_size < 10 && i == board_size-2)
	|| (board_size >= 10 && i == 8)))
      fprintf(stderr, "     WHITE has captured %d stones", black_captured);
    
    if ((xo == 0) && ((board_size < 10 && i == board_size-1)
	|| (board_size >= 10 && i == 9)))
      fprintf(stderr, "     BLACK has captured %d stones", white_captured);
  
    if (xo == 3) {
      if (i == board_size-5)
	write_color_string(GG_COLOR_GREEN, "    green=alive");
      if (i == board_size-4)
	write_color_string(GG_COLOR_CYAN, "    cyan=dead");
      if (i == board_size-3)
	write_color_string(GG_COLOR_RED, "    red=critical");
      if (i == board_size-2)
	write_color_string(GG_COLOR_YELLOW, "    yellow=unknown");
      if (i == board_size-1)
	write_color_string(GG_COLOR_MAGENTA, "    magenta=unchecked");
    }
  }

  end_draw_board();
}



/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */
/********************************************************************/

/* aftermath.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


/* #include <stdio.h> */
/* #include <stdlib.h> */
/* #include <string.h> */

/* #include "gnugo.h" */
/* #include "liberty.h" */


SGFTree *aftermath_sgftree;

/* Generate a move to definitely settle the position after the game
 * has been finished. The purpose of this is to robustly determine
 * life and death status and to distinguish between life in seki and
 * life with territory.
 *
 * The strategy is basically to turn all own living stones into
 * invincible ones and remove from the board all dead opponent stones.
 * Stones which cannot be removed, nor turned invincible, are alive in
 * seki.
 *
 * If do_capture_dead_stones is 0, opponent stones are not necessarily
 * removed from the board. This happens if they become unconditionally
 * dead anyway.
 *
 * Moves are generated in the following order of priority:
 * 0. Play edge liberties in certain positions. This is not really
 *    necessary, but often it can simplify the tactical and strategical
 *    reading substantially, making subsequent moves faster to generate.
 * 1. Capture an opponent string in atari and adjacent to own
 *    invincible string. Moves leading to ko or snapback are excluded.
 * 2. Extend an invincible string to a liberty of an opponent string.
 * 3. Connect a non-invincible string to an invincible string.
 * 4. Extend an invincible string towards an opponent string or an own
 *    non-invincible string.
 * 5. Split a big eyespace of an alive own dragon without invincible
 *    strings into smaller pieces.
 * 6. Play a liberty of a dead opponent dragon.
 *
 * Steps 2--4 are interleaved to try to optimize the efficiency of the
 * moves. In step 5 too, efforts are made to play efficient moves.  By
 * efficient we here mean moves which are effectively settling the
 * position and simplify the tactical and strategical reading for
 * subsequent moves.
 *
 * Steps 1--4 are guaranteed to be completely safe. Step 0 and 5
 * should also be risk-free. Step 6 on the other hand definitely
 * isn't. Consider for example this position:
 *
 * .XXXXX.
 * XXOOOXX
 * XOO.OOX
 * XOXXXOX
 * XO.XXOX
 * -------
 *
 * In order to remove the O stones, it is necessary to play on one of
 * the inner liberties, but one of them lets O live. Thus we have to
 * check carefully for blunders at this step.
 *
 * Update: Step 0 is only safe against blunders if care is taken not
 *         to get into a shortage of liberties.
 *         Step 5 also has some risks. Consider this position:
 *
 *         |XXXXX.
 *         |OOOOXX
 *         |..O.OX
 *         |OX*OOX
 *         +------
 *
 *         Playing at * allows X to make seki.
 *
 * IMPORTANT RESTRICTION:
 * Before calling this function it is mandatory to call genmove() or
 * genmove_conservative(). For this function to be meaningful, the
 * genmove() call should return pass.
 */
int
aftermath_genmove(int *aftermath_move, int color,
		  int under_control[BOARDMAX],
		  int do_capture_dead_stones)
{
  int k;
  int other = OTHER_COLOR(color);
  int distance[BOARDMAX];
  int score[BOARDMAX];
  float owl_hotspot[BOARDMAX];
  float reading_hotspot[BOARDMAX];
  int dragons[BOARDMAX];
  int something_found;
  int closest_opponent = NO_MOVE;
  int closest_own = NO_MOVE;
  int d;
  int move = NO_MOVE;
  int pos = NO_MOVE;
  int best_score;
  int best_scoring_move;
  
  owl_hotspots(owl_hotspot);
  reading_hotspots(reading_hotspot);
  
  /* As a preparation we compute a distance map to the invincible strings. */
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (!ON_BOARD(pos))
      continue;
    else if (board[pos] == color && worm[pos].unconditional_status == ALIVE)
      distance[pos] = 0;
    else if (!do_capture_dead_stones
	     && board[pos] == other 
	     && worm[pos].unconditional_status == DEAD)
      distance[pos] = 0;
    else
      distance[pos] = -1;
  }
  
  d = 0;
  do {
    something_found = 0;
    for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
      if (ON_BOARD(pos) && distance[pos] == -1) {
	for (k = 0; k < 4; k++) {
	  int pos2 = pos + delta[k];
	  if (!ON_BOARD(pos2))
	    continue;
	  if ((d == 0 || board[pos2] == EMPTY)
	      && distance[pos2] == d) {
	    if (d > 0 && board[pos] == other) {
	      distance[pos] = d + 1;
	      if (closest_opponent == NO_MOVE)
		closest_opponent = pos;
	    }
	    else if (d > 0 && board[pos] == color) {
	      distance[pos] = d + 1;
	      if (closest_own == NO_MOVE)
		closest_own = pos;
	    }
	    else if (board[pos] == EMPTY) {
	      distance[pos] = d + 1;
	      something_found = 1;
	    }
	    break;
	  }
	}
      }
    }
    d++;
  } while (something_found);

  if (under_control) {
    for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
      if (!ON_BOARD(pos))
	continue;
      else if (distance[pos] == -1)
	under_control[pos] = 0;
      else
	under_control[pos] = 1;
    }
  }
  
  if (debug & DEBUG_AFTERMATH) {
    int m, n;
    for (m = 0; m < board_size; m++) {
      for (n = 0; n < board_size; n++) {
	pos = POS(m, n);
	if (distance[pos] > 0)
	  fprintf(stderr, "%2d", distance[pos]);
	else if (distance[pos] == 0) {
	  if (board[pos] == WHITE)
	    gprintf(" o");
	  else if (board[pos] == BLACK)
	    gprintf(" x");
	  else
	    gprintf(" ?");
	}
	else {
	  if (board[pos] == WHITE)
	    gprintf(" O");
	  else if (board[pos] == BLACK)
	    gprintf(" X");
	  else
	    gprintf(" .");
	}
      }
      gprintf("\n");
    }
  
    gprintf("Closest opponent %1m", closest_opponent);
    if (closest_opponent != NO_MOVE)
      gprintf(", distance %d\n", distance[closest_opponent]);
    else
      gprintf("\n");

    gprintf("Closest own %1m", closest_own);
    if (closest_own != NO_MOVE)
      gprintf(", distance %d\n", distance[closest_own]);
    else
      gprintf("\n");
  }

  /* Case 0. This is a special measure to avoid a certain kind of
   * tactical reading inefficiency.
   *
   * Here we play on edge liberties in the configuration
   *
   * XO.
   * .*.
   * ---
   *
   * to stop X from "leaking" out along the edge. Sometimes this can
   * save huge amounts of tactical reading for later moves.
   */
  best_scoring_move = NO_MOVE;
  best_score = 5;
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    int libs;
    if (board[pos] != EMPTY
	|| distance[pos] == 0)
      continue;

    libs = approxlib(pos, color, 3, NULL);
    if (libs < 3)
      continue;

    if (is_self_atari(pos, other))
      continue;
    
    for (k = 0; k < 4; k++) {
      int dir = delta[k];
      int right = delta[(k+1)%4];
      if (!ON_BOARD(pos - dir)
	  && board[pos + dir] == color
	  && board[pos + dir + right] == other
	  && board[pos + dir - right] == other
	  && (libs > countlib(pos + dir)
	      || (libs > 4
		  && libs == countlib(pos + dir)))
	  && (DRAGON2(pos + dir).safety == INVINCIBLE
	      || DRAGON2(pos + dir).safety == STRONGLY_ALIVE)) {
	int score = 20 * (owl_hotspot[pos] + reading_hotspot[pos]);
	if (score > best_score) {
	  best_score = score;
	  best_scoring_move = pos;
	}
      }
    }
  }
  
  if (best_scoring_move != NO_MOVE
      && safe_move(best_scoring_move, color) == WIN) {
    *aftermath_move = best_scoring_move;
    DEBUG(DEBUG_AFTERMATH, "Closing edge at %1m\n", best_scoring_move);
    return 1;
  }

  /* Case 1. */
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    int lib;
    if (board[pos] == other
	&& worm[pos].unconditional_status != DEAD
	&& countlib(pos) == 1
	&& ((ON_BOARD(SOUTH(pos))    && distance[SOUTH(pos)] == 0)
	    || (ON_BOARD(WEST(pos))  && distance[WEST(pos)]  == 0)
	    || (ON_BOARD(NORTH(pos)) && distance[NORTH(pos)] == 0)
	    || (ON_BOARD(EAST(pos))  && distance[EAST(pos)]  == 0))) {
      findlib(pos, 1, &lib);
      /* Make sure we don't play into a ko or a (proper) snapback. */
      if (countstones(pos) > 1 || !is_self_atari(lib, color)) {
	*aftermath_move = lib;
	return 1;
      }
    }
  }

  /* Cases 2--4. */
  if (closest_opponent != NO_MOVE || closest_own != NO_MOVE) {
    if (closest_own == NO_MOVE)
      move = closest_opponent;
    else
      move = closest_own;

    /* if we're about to play at distance 1, try to optimize the move. */
    if (distance[move] == 2) {
      char mx[BOARDMAX];
      char mark = 0;
      memset(mx, 0, sizeof(mx));
      best_score = 0;
      best_scoring_move = move;

      for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
	int score = 0;
	int move_ok = 0;
	if (!ON_BOARD(pos) || distance[pos] != 1)
	  continue;
	mark++;
	for (k = 0; k < 4; k++) {
	  int pos2 = pos + delta[k];
	  if (!ON_BOARD(pos2))
	    continue;
	  if (distance[pos2] < 1)
	    score--;
	  else if (board[pos2] == EMPTY)
	    score++;
	  else if (mx[pos2] == mark)
	    score--;
	  else {
	    if (board[pos2] == color) {
	      move_ok = 1;
	      score += 7;
	      if (countstones(pos2) > 2)
		score++;
	      if (countstones(pos2) > 4)
		score++;
	      if (countlib(pos2) < 4)
		score++;
	      if (countlib(pos2) < 3)
		score++;
	    }
	    else {
	      int deltalib = (approxlib(pos, other, MAXLIBS, NULL)
			      - countlib(pos2));
	      move_ok = 1;
	      score++;
	      if (deltalib >= 0)
		score++;
	      if (deltalib > 0)
		score++;
	    }
	    mark_string(pos2, mx, mark);
	  }
	}
	if (is_suicide(pos, other))
	  score -= 3;
	
	if (0)
	  gprintf("Score %1m = %d\n", pos, score);
	
	if (move_ok && score > best_score) {
	  best_score = score;
	  best_scoring_move = pos;
	}
      }
      move = best_scoring_move;
    }

    while (distance[move] > 1) {
      for (k = 0; k < 4; k++) {
	int pos2 = move + delta[k];
	if (ON_BOARD(pos2)
	    && board[pos2] == EMPTY
	    && distance[pos2] == distance[move] - 1) {
	  move = pos2;
	  break;
	}
      }
    }
    *aftermath_move = move;
    return 1;
  }
  
  /* Case 5.
   * If we reach here, either all strings of a dragon are invincible
   * or no string is. Next we try to make alive dragons invincible by
   * splitting big eyes into smaller ones. Our strategy is to search
   * for an empty vertex with as many eye points as possible adjacent
   * and with at least one alive but not invincible stone adjacent or
   * diagonal.
   */
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    int eyespace_neighbors = 0;
    int own_neighbors = 0;
    int own_diagonals = 0;
    int opponent_dragons = 0;
    int own_worms = 0;
    int safety = UNKNOWN;
    int bonus = 0;
    int mx[BOARDMAX];
    score[pos] = 0;
      
    if (board[pos] != EMPTY || distance[pos] != -1)
      continue;

    memset(mx, 0, sizeof(mx));
    
    for (k = 0; k < 8; k++) {
      int pos2 = pos + delta[k];
      if (!ON_BOARD(pos2))
	continue;
      
      if (board[pos2] == EMPTY) {
	if (k < 4)
	  eyespace_neighbors++;
	continue;
      }
      
      if (board[pos2] == other) {
	int origin = dragon[pos2].origin;
	
	if (k < 4) {
	  if (dragon[pos2].matcher_status == ALIVE) {
	    safety = DEAD;
	    break;
	  }
	  else if (!mx[origin]) {
	    eyespace_neighbors++;
	    opponent_dragons++;
	  }
	}

	if (!mx[origin] && dragon[pos2].matcher_status == DEAD) {
	  bonus++;
	  if (k < 4 
	      && countlib(pos2) <= 2 
	      && countstones(pos2) >= 3)
	    bonus++;
	  
	  if (k < 4 && countlib(pos2) == 1)
	    bonus += 3;
	}
	mx[origin] = 1;
      }
      else if (board[pos2] == color) {
	dragons[pos] = pos2;
	
	if (safety == UNKNOWN && dragon[pos2].matcher_status == ALIVE)
	  safety = ALIVE;
	
	if (DRAGON2(pos2).safety == INVINCIBLE)
	  safety = INVINCIBLE;
	
	if (k < 4) {
	  int apos = worm[pos2].origin;
	  
	  if (!mx[apos]) {
	    own_worms++;
	    if (countstones(apos) == 1)
	      bonus += 2;
	    if (countlib(apos) < 6
		&& approxlib(pos, color, 5, NULL) < countlib(apos))
	      bonus -= 5;
	    mx[apos] = 1;
	  }
	  
	  if (countlib(apos) <= 2) {
	    int r;
	    int important = 0;
	    int safe_atari = 0;
	    for (r = 0; r < 4; r++) {
	      int d = delta[r];
	      if (!ON_BOARD(apos+d))
		continue;
	      if (board[apos+d] == other
		  && dragon[apos+d].matcher_status == DEAD)
		important = 1;
	      else if (board[apos+d] == EMPTY
		       && !is_self_atari(apos+d, other))
		safe_atari = 1;
	    }
	    if (approxlib(pos, color, 3, NULL) > 2) {
	      bonus++;
	      if (important) {
		bonus += 2;
		if (safe_atari)
		  bonus += 2;
	      }
	    }
	  }
	  
	  own_neighbors++;
	}
	else
	  own_diagonals++;
      }
    }
    if (safety == DEAD || safety == UNKNOWN
	|| eyespace_neighbors == 0
	|| (own_neighbors + own_diagonals) == 0)
      continue;
    
    if (bonus < 0)
      bonus = 0;
      
    score[pos] = 4 * eyespace_neighbors + bonus;
    if (safety == INVINCIBLE) {
      score[pos] += own_neighbors;
      if (own_neighbors < 2)
	score[pos] += own_diagonals;
      if (own_worms > 1 && eyespace_neighbors >= 1)
	score[pos] += 10 + 5 * (own_worms - 2);
    }
    else if (eyespace_neighbors > 2)
      score[pos] += own_diagonals;
    
    /* Splitting bonus. */
    if (opponent_dragons > 1)
      score[pos] += 10 * (opponent_dragons - 1);
    
    /* Hotspot bonus. */
    {
      int owl_hotspot_bonus = (int) (20.0 * owl_hotspot[pos]);
      int reading_hotspot_bonus = (int) (20.0 * reading_hotspot[pos]);
      int hotspot_bonus = owl_hotspot_bonus + reading_hotspot_bonus;
      
      /* Don't allow the hotspot bonus to turn a positive score into
       * a non-positive one.
       */
      if (score[pos] > 0 && score[pos] + hotspot_bonus <= 0)
	hotspot_bonus = 1 - score[pos];
      
      score[pos] += hotspot_bonus;
      
      if (1 && (debug & DEBUG_AFTERMATH))
	gprintf("Score %1M = %d (hotspot bonus %d + %d)\n", pos, score[pos],
		owl_hotspot_bonus, reading_hotspot_bonus);
    }
    
    /* Avoid taking ko. */
    if (is_ko(pos, color, NULL))
      score[pos] = (score[pos] + 1) / 2;
  }
  
  while (1) {
    int bb;
    best_score = 0;
    move = NO_MOVE;
    for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
      if (ON_BOARD(pos) && score[pos] > best_score) {
	best_score = score[pos];
	move = pos;
      }
    }

    if (move == NO_MOVE)
      break;

    bb = dragons[move];
    if (is_illegal_ko_capture(move, color)
	|| !safe_move(move, color)
	|| (DRAGON2(bb).safety != INVINCIBLE
	    && DRAGON2(bb).safety != STRONGLY_ALIVE
	    && owl_does_defend(move, bb) != WIN)
	|| (!confirm_safety(move, color, 0, NULL, NULL, NULL))) {
      score[move] = 0;
    }
    else {
      /* If we're getting short of liberties, we must be more careful.
       * Check that no adjacent string or dragon gets more alive by
       * the move.
       */
      int libs = approxlib(move, color, 5, NULL);
      int move_ok = 1;
      if (libs < 5) {
	for (k = 0; k < 4; k++) {
	  if (board[move + delta[k]] == color
	      && countlib(move + delta[k]) > libs)
	    break;
	}
	if (k < 4) {
	  if (trymove(move, color, "aftermath-B", move + delta[k],
		      EMPTY, NO_MOVE)) {
	    int adjs[MAXCHAIN];
	    int neighbors;
	    int r;
	    neighbors = chainlinks(move, adjs);
	    for (r = 0; r < neighbors; r++) {
	      if (worm[adjs[r]].attack_codes[0] != 0
		  && (find_defense(adjs[r], NULL)
		      > worm[adjs[r]].defend_codes[0])) {
		DEBUG(DEBUG_AFTERMATH,
		      "Blunder: %1m becomes tactically safer after %1m\n",
		      adjs[r], move);
		move_ok = 0;
	      }
	    }
	    popgo();
	    for (r = 0; r < neighbors && move_ok; r++) {
	      if (dragon[adjs[r]].matcher_status == DEAD
		  && !owl_does_attack(move, adjs[r])) {
		DEBUG(DEBUG_AFTERMATH,
		      "Blunder: %1m becomes more alive after %1m\n",
		      adjs[r], move);
		move_ok = 0;
	      }
	    }
	  }
	}
      }

      if (!move_ok)
	score[move] = 0;
      else {
	*aftermath_move = move;
	DEBUG(DEBUG_AFTERMATH, "Splitting eyespace at %1m\n", move);
	return 1;
      }
    }
  }

  /* Case 6.
   * Finally we try to play on liberties of remaining DEAD opponent
   * dragons, carefully checking against mistakes.
   */
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    int move;
    int target;
    int cc = NO_MOVE;
    int self_atari_ok = 0;
    if (board[pos] != EMPTY || distance[pos] != -1)
      continue;
    target = NO_MOVE;
    for (k = 0; k < 4; k++) {
      int pos2 = pos + delta[k];
      if (!ON_BOARD(pos2))
	continue;
      if (board[pos2] == other 
	  && dragon[pos2].matcher_status != ALIVE
	  && (do_capture_dead_stones 
	      || worm[pos2].unconditional_status != DEAD)
	  && DRAGON2(pos2).safety != INESSENTIAL) {
	target = pos2;
	break;
      }
    }
    if (target == NO_MOVE)
      continue;
    
    /* At this point, (pos) is a move that potentially may capture
     * a dead opponent string at (target).
     */
    
    if (!trymove(pos, color, "aftermath-A", target, EMPTY, NO_MOVE))
      continue;
    
    /* It is frequently necessary to sacrifice own stones in order
     * to force the opponent's stones to be removed from the board,
     * e.g. by adding stones to fill up a nakade shape. However, we
     * should only play into a self atari if the sacrificed stones
     * are classified as INESSENTIAL. Thus it would be ok for O to
     * try a self atari in this position:
     *
     * |OOOO
     * |XXXO
     * |..XO
     * |OOXO
     * +----
     *
     * but not in this one:
     *
     * |XXX..
     * |OOXX.
     * |.OOXX
     * |XXOOX
     * |.O.OX
     * +-----
     */

    self_atari_ok = 1;
    for (k = 0; k < 4; k++) {
      if (board[pos + delta[k]] == color
	  && DRAGON2(pos + delta[k]).safety != INESSENTIAL) {
	self_atari_ok = 0;
	cc = pos + delta[k];
	break;
      }
    }
    
    /* Copy the potential move to (move). */
    move = pos;
    
    /* If the move is a self atari, but that isn't okay, try to
     * recursively find a backfilling move which later makes the
     * potential move possible.
     */
    if (!self_atari_ok) {
      while (countlib(pos) == 1) {
	int lib;
	findlib(pos, 1, &lib);
	move = lib;
	if (!trymove(move, color, "aftermath-B", target, EMPTY, NO_MOVE))
	  break;
      }
      
      if (countlib(pos) == 1)
	move = NO_MOVE;
    }

    while (stackp > 0)
      popgo();
    
    if (move == NO_MOVE)
      continue;
      
    /* Make sure that the potential move really isn't a self
     * atari. In the case of a move found after backfilling this
     * could happen (because the backfilling moves happened to
     * capture some stones).
     */
    if (!self_atari_ok && is_self_atari(move, color))
      continue;
    
    /* Consult the owl code to determine whether the considered move
     * really is effective. Blunders should be detected here.
     */
    if (owl_does_attack(move, target) == WIN) {
      /* If we have an adjacent own dragon, which is not inessential,
       * verify that it remains safe.
       */
      if (cc != NO_MOVE && !owl_does_defend(move, cc))
	continue;

      /* If we don't allow self atari, also call confirm safety to
       * avoid setting up combination attacks.
       */
      if (!self_atari_ok && !confirm_safety(move, color, 0, NULL, NULL, NULL))
	continue;
	  
      *aftermath_move = move;
      DEBUG(DEBUG_AFTERMATH, "Filling opponent liberty at %1m\n", move);
      return 1;
    }
  }
  
  /* Case 7.
   * In very rare cases it turns out we need yet another pass. An
   * example is this position:
   *
   * |.....
   * |OOOO.
   * |XXXO.
   * |.OXO.
   * |O.XO.
   * +-----
   *
   * Here the X stones are found tactically dead and therefore the
   * corner O stones have been amalgamated with the surrounding
   * stones. Since the previous case only allows sacrificing
   * INESSENTIAL stones, it fails to take X off the board.
   *
   * The solution is to look for tactically attackable opponent stones
   * that still remain on the board but should be removed.
   */
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (board[pos] == other
	&& (worm[pos].unconditional_status == UNKNOWN
	    || do_capture_dead_stones)
	&& (DRAGON2(pos).safety == DEAD
	    || DRAGON2(pos).safety == TACTICALLY_DEAD)
	&& worm[pos].attack_codes[0] != 0
	&& !is_illegal_ko_capture(worm[pos].attack_points[0], color)) {
      *aftermath_move = worm[pos].attack_points[0];
      DEBUG(DEBUG_AFTERMATH, "Tactically attack %1m at %1m\n",
	    pos, *aftermath_move);
      return 1;
    }
  }
  
  /* No move found. */
  return -1;
}

/* This is a substitute for genmove_conservative() which only does
 * what is required when doing the aftermath. Notice though that this
 * generates an "ordinary" move, in contrast to aftermath_genmove().
 * Usually this should turn up a pass, but when it doesn't it's
 * important not to miss the move.
 */
static int
reduced_genmove(int *move, int color)
{
  float val;
  int save_verbose;

  /* no move is found yet. */
  *move = NO_MOVE;  
  val = -1; 
  
  /* Prepare pattern matcher and reading code. */
  reset_engine();

  /* Find out information about the worms and dragons. */
  examine_position(color, EXAMINE_ALL);

  /* Make a score estimate. This can be used in later stages of the 
   * move generation.  If we are ahead, we can play safely and if
   * we are behind, we have to play more daringly.
   */
  if (level >= 8) {
    estimate_score(&lower_bound, &upper_bound);
    if (verbose || showscore) {
      if (lower_bound == upper_bound)
	gprintf("\nScore estimate: %s %f\n",
		lower_bound > 0 ? "W " : "B ", gg_abs(lower_bound));
      else
	gprintf("\nScore estimate: %s %f to %s %f\n",
		lower_bound > 0 ? "W " : "B ", gg_abs(lower_bound),
		upper_bound > 0 ? "W " : "B ", gg_abs(upper_bound));
      fflush(stderr);
    }

    /* The score will be used to determine when we are safely
     * ahead. So we want the most conservative score.
     */
    if (color == WHITE)
      score = lower_bound;
    else
      score = upper_bound;
  }
  else
    score = 0.0;

  gg_assert(stackp == 0);
  
  /*
   * Ok, information gathering is complete. Now start to find some moves!
   */

  /* Pick up tactical moves. */
  worm_reasons(color);
  
  /* Pick up owl moves. */
  save_verbose = verbose;
  if (verbose > 0)
    verbose--;
  owl_reasons(color);
  verbose = save_verbose;
  
  /* Look for combination attacks and defenses against them. */
  combinations(color);
  gg_assert(stackp == 0);

  /* Review the move reasons and estimate move values. */
  if (review_move_reasons(move, &val, color, 0.0, lower_bound))
    TRACE("Move generation likes %1m with value %f\n", *move, val);
  gg_assert(stackp == 0);

  /* If no move is found then pass. */
  if (val < 0.0) {
    TRACE("I pass.\n");
    *move = NO_MOVE;
  }
  else
    TRACE("reduced_genmove() recommends %1m with value %f\n", *move, val);
 
 return val;
}

/* Preliminary function for playing through the aftermath. */
static void
do_play_aftermath(int color, struct aftermath_data *a)
{
  int move;
  int pass = 0;
  int moves = 0;
  int color_to_play = color;
  DEBUG(DEBUG_AFTERMATH, "The aftermath starts.\n");

  /* Disable computing worm and owl threats. */
  disable_threat_computation = 1;
  /* Disable matching of endgame patterns. */
  disable_endgame_patterns = 1;

  while (pass < 2 && moves < board_size * board_size) {
    int reading_nodes = get_reading_node_counter();
    int owl_nodes = get_owl_node_counter();
    int move_val = reduced_genmove(&move, color_to_play);
    if (move_val < 0) {
      int save_verbose = verbose;
      if (verbose > 0)
	verbose--;
      move_val = aftermath_genmove(&move, color_to_play,
				   (color_to_play == WHITE ?
				    a->white_control : a->black_control),
				   0);
      verbose = save_verbose;
    }
    play_move(move, color_to_play);
    if (aftermath_sgftree)
      sgftreeAddPlay(aftermath_sgftree, NULL, color_to_play, I(move), J(move));
    moves++;
    DEBUG(DEBUG_AFTERMATH, "%d %C move %1m (nodes %d, %d  total %d, %d)\n",
	  movenum, color_to_play, move, get_owl_node_counter() - owl_nodes,
	  get_reading_node_counter() - reading_nodes,
	  get_owl_node_counter(), get_reading_node_counter());
    if (move != PASS_MOVE)
      pass = 0;
    else
      pass++;
    color_to_play = OTHER_COLOR(color_to_play);
  }
  
  /* Reenable worm and dragon threats and endgame patterns. */
  disable_threat_computation = 0;
  disable_endgame_patterns   = 0;
}

static struct aftermath_data aftermath;

static void
play_aftermath(int color)
{
  int pos;
  struct board_state saved_board;
  struct aftermath_data *a = &aftermath;
  static int current_board[BOARDMAX];
  static int current_color = EMPTY;
  int cached_board = 1;
  gg_assert(color == BLACK || color == WHITE);

  if (current_color != color) {
    current_color = color;
    cached_board = 0;
  }

  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (ON_BOARD(pos) && board[pos] != current_board[pos]) {
      current_board[pos] = board[pos];
      cached_board = 0;
    }
  }

  /* If this is exactly the same position as the one we analyzed the
   * last time, the content of the aftermath struct is up to date.
   */
  if (cached_board)
    return;

  a->white_captured = white_captured;
  a->black_captured = black_captured;
  a->white_prisoners = 0;
  a->black_prisoners = 0;
  a->white_territory = 0;
  a->black_territory = 0;
  a->white_area = 0;
  a->black_area = 0;
  
  store_board(&saved_board);
  do_play_aftermath(color, a);
  restore_board(&saved_board);
  
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (!ON_BOARD(pos))
      continue;
    if (a->black_control[pos]) {
      a->black_area++;
      if (board[pos] == WHITE) {
	a->black_territory++;
	a->white_prisoners++;
	a->final_status[pos] = DEAD;
      }
      else if (board[pos] == EMPTY) {
	a->black_territory++;
	a->final_status[pos] = BLACK_TERRITORY;
      }
      else
	a->final_status[pos] = ALIVE;
    }
    else if (a->white_control[pos]) {
      a->white_area++;
      if (board[pos] == BLACK) {
	a->white_territory++;
	a->black_prisoners++;
	a->final_status[pos] = DEAD;
      }
      else if (board[pos] == EMPTY) {
	a->white_territory++;
	a->final_status[pos] = WHITE_TERRITORY;
      }
      else
	a->final_status[pos] = ALIVE;
    }
    else {
      if (board[pos] == EMPTY)
	a->final_status[pos] = DAME;
      else {
	a->final_status[pos] = ALIVE_IN_SEKI;
	if (board[pos] == WHITE)
	  a->white_area++;
	else
	  a->black_area++;
      }
    }
  }
}

float
aftermath_compute_score(int color, float komi, SGFTree *tree)
{
  struct aftermath_data *a = &aftermath;
  aftermath_sgftree = tree;
  play_aftermath(color);
  if (chinese_rules)
    return (a->white_area
	    - a->black_area
	    + komi);
  else
    return (a->white_territory
	    + a->black_captured
	    + a->black_prisoners
	    - (a->black_territory
	       + a->white_captured
	       + a->white_prisoners)
	    + komi);
}

/* Report the final status of a vertex on the board.
 * Possible results are ALIVE, DEAD, ALIVE_IN_SEKI, WHITE_TERRITORY,
 * BLACK_TERRITORY, and DAME.
 */
int
aftermath_final_status(int color, int pos)
{
  ASSERT_ON_BOARD1(pos);
  aftermath_sgftree = NULL;
  play_aftermath(color);
  return aftermath.final_status[pos];
}

/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */


/* cashe.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* #include <stdio.h> */
/* #include <stdlib.h> */
/* #include <limits.h> */
/* #include <string.h> */

/* #include "sgftree.h" */
/* #include "gnugo.h" */
/* #include "liberty.h" */

/* #include "hash.h" */
/* #include "cache.h" */



Hashtable *movehash;

static int hashtable_init(Hashtable *table, int tablesize, int num_nodes,
			  int num_results);
static Hashtable *hashtable_new(int tablesize, int num_nodes, int num_results);
static void hashtable_clear(Hashtable *table);

static Hashnode *hashtable_enter_position(Hashtable *table, Hash_data *hd);
static Hashnode *hashtable_search(Hashtable *table, Hash_data *hd);

static Read_result *hashnode_search(Hashnode *node, int routine, int komaster,
				    int kom_pos, int str1, int str2);
static Read_result *hashnode_new_result(Hashtable *table, Hashnode *node, 
					int routine, int komaster,
					int kom_pos, int str1, int str2);

static void hashtable_unlink_closed_results(Hashnode *node, 
					    int exclusions, 
					    unsigned int stackplimit,
					    int statistics[][20]);
static void hashtable_partially_clear(Hashtable *table);
static int do_get_read_result(int routine, int komaster, int kom_pos,
			      int str1, int str2, Read_result **read_result);

/*
 * Dump an ASCII representation of the contents of a Read_result onto
 * the FILE outfile. 
 */



void
read_result_dump(Read_result *result, FILE *outfile)
{
  fprintf(outfile, "Komaster %d (%d, %d) Routine %d, (%d, %d), depth: %d ",
	  rr_get_komaster(*result),
	  I(rr_get_kom_pos(*result)),
	  J(rr_get_kom_pos(*result)),
	  rr_get_routine(*result),
	  I(rr_get_str(*result)),
	  J(rr_get_str(*result)),
	  rr_get_stackp(*result));
  fprintf(outfile, "Result: %d %d, (%d, %d)\n",
	  rr_get_status(*result),
	  rr_get_result(*result),
	  I(rr_get_move(*result)),
	  J(rr_get_move(*result)));
}


/*
 * Dump an ASCII representation of the contents of a Hashnode onto
 * the FILE outfile. 
 */

void
hashnode_dump(Hashnode *node, FILE *outfile)
{
  Read_result *result;

  /* Data about the node itself. */
  fprintf(outfile, "Hash value: %lx\n", (unsigned long) node->key.hashval);
#if FULL_POSITION_IN_HASH
  hashposition_dump(&(node->key.hashpos), outfile);
#endif

  for (result = node->results; result != NULL; result = result->next) {
    read_result_dump(result, outfile);
  }
  /* FIXME: Dump contents of data also. */
}


/*
 * Dump an ASCII representation of the contents of a Hashtable onto
 * the FILE outfile. 
 */

void
hashtable_dump(Hashtable *table, FILE *outfile)
{
  int i;
  Hashnode *hn;

  /* Data about the table itself. */
  fprintf(outfile, "Dump of hashtable\n");
  fprintf(outfile, "Total size: %d\n", table->num_nodes);
  fprintf(outfile, "Size of hash table: %d\n", table->hashtablesize);
  fprintf(outfile, "Number of positions in table: %d\n", table->free_node);

  /* Data about the contents. */
  for (i = 0; i < table->hashtablesize; ++i) {
    fprintf(outfile, "Bucket %5d: ", i);
    hn = table->hashtable[i];
    if (hn == NULL)
      fprintf(outfile, "empty");
    else
      while (hn) {
	hashnode_dump(hn, outfile);
	hn = hn->next;
      }
    fprintf(outfile, "\n");
  }
}


#if 0
/*
 * Dump an alternative representation of the contents of a Hashtable
 * onto the FILE outfile. This one is mainly useful if you have to
 * debug the hashtable implementation itself.
 */

static void
hashtable_dump2(Hashtable *table, FILE *outfile)
{
  int i;
  for (i = 0; i < table->hashtablesize; i++) {
    fprintf(outfile, "bucket %d: ", i);
    if (table->hashtable[i] == NULL)
      fprintf(outfile, "NULL\n");
    else
      fprintf(outfile, "%d\n", table->hashtable[i] - table->all_nodes);
  }

  for (i = 0; i < table->num_nodes; i++) {
    Hashnode *node = &(table->all_nodes[i]);
    if (node->results == NULL)
      continue;
    fprintf(outfile, "node %d: ", i);
    if (node->results == NULL)
      fprintf(outfile, "NULL ");
    else
      fprintf(outfile, "%d ", node->results - table->all_results);
    if (node->next == NULL)
      fprintf(outfile, "NULL\n");
    else
      fprintf(outfile, "%d\n", node->next - table->all_nodes);
  }
  
  for (i = 0; i < table->num_results; i++) {
    Read_result *result = &(table->all_results[i]);
    if (rr_get_status(*result) == 0)
      continue;
    fprintf(outfile, "result %d ", i);
    if (result->next == NULL)
      fprintf(outfile, "NULL ");
    else
      fprintf(outfile, "%d ", result->next - table->all_results);
    read_result_dump(result, outfile);
  }
}
#endif


/*
 * Initialize a hash table for a given total size and size of the
 * hash table.
 *
 * Return 0 if something went wrong.  Just now this means that there
 * wasn't enough memory available.
 */

static int
hashtable_init(Hashtable *table,
	       int tablesize, int num_nodes, int num_results)
{
  /* Make sure the hash system is initialized. */
  hash_init();

  /* Allocate memory for the pointers in the hash table proper. */
  table->hashtablesize = tablesize;
  table->hashtable = (Hashnode **) malloc(tablesize * sizeof(Hashnode *));
  if (table->hashtable == NULL) {
    free(table);
    return 0;
  }

  /* Allocate memory for the nodes. */
  table->num_nodes = num_nodes;
  table->all_nodes = (Hashnode *) malloc(num_nodes * sizeof(Hashnode));
  if (table->all_nodes == NULL) {
    free(table->hashtable);
    free(table);
    return 0;
  }

  /* Allocate memory for the results. */
  table->num_results = num_results;
  table->all_results = (Read_result *) malloc(num_results 
					      * sizeof(Read_result));
  if (table->all_results == NULL) {
    free(table->hashtable);
    free(table->all_nodes);
    free(table);
    return 0;
  }

  /* Initialize the table and all nodes to the empty state . */
  hashtable_clear(table);

  return 1;
}


/*
 * Allocate a new hash table and return a pointer to it. 
 *
 * Return NULL if there is insufficient memory.
 */

static Hashtable *
hashtable_new(int tablesize, int num_nodes, int num_results)
{
  Hashtable *table;

  /* Make sure the hash system is initialized. */
  hash_init();

  /* Allocate the hashtable struct. */
  table = (Hashtable *) malloc(sizeof(Hashtable));
  if (table == NULL)
    return NULL;

  /* Initialize the table. */
  if (!hashtable_init(table, tablesize, num_nodes, num_results)) {
    free(table);
    return NULL;
  }

  return table;
}


/*
 * Clear an existing hash table.  
 */

static void
hashtable_clear(Hashtable *table)
{
  int bucket;
  int i;
  
  if (!table)
    return;
  
  /* Initialize all hash buckets to the empty list. */
  for (bucket = 0; bucket < table->hashtablesize; ++bucket)
    table->hashtable[bucket] = NULL;

  /* Mark all read_results as free. */
  for (i = 0; i < table->num_results; i++)
    table->all_results[i].data2 = 0;
  
  /* Mark all nodes as free. */
  for (i = 0; i < table->num_nodes; i++)
    table->all_nodes[i].results = NULL;
  
  table->free_node = 0;
  table->free_result = 0;
}


/*
 * Unlink the closed results from the linked list of results at a node.
 */

static void
hashtable_unlink_closed_results(Hashnode *node, 
				int exclusions, unsigned int stackplimit,
				int statistics[][20])
{
  Read_result *previous_result = NULL;
  Read_result *current_result = node->results;
  
  while (current_result != NULL) {
    int stackp;
    int routine;

    stackp = depth - rr_get_stackp(*current_result);
    if (stackp > 19)
      stackp = 19;
    if (stackp < 0)
      stackp = 0;

    routine = rr_get_routine(*current_result);
    gg_assert(routine >= 0 && routine < NUM_ROUTINES);
    statistics[routine][stackp]++;

    if (rr_get_status(*current_result) == 2
	&& ((1 << rr_get_routine(*current_result)) & exclusions) == 0
	&& depth - rr_get_stackp(*current_result) >= stackplimit) {
      if (previous_result == NULL)
	node->results = current_result->next;
      else
	previous_result->next = current_result->next;
      current_result->data2 = 0;
    }
    else
      previous_result = current_result;

    current_result = current_result->next;
  }
}



/*
 * Clear an existing hash table except for open nodes.
 *
 * Don't even think about compressing the node and results arrays
 * afterwards in order to simplify distribution of new nodes and
 * results. The read result pointers out in reading.c and owl.c will
 * never know that you moved them around.
 */

static void
hashtable_partially_clear(Hashtable *table)
{
  Hashnode *node;
  int bucket;
  Hashnode *previous;
  Hashnode *current;
  int k, l;
  
  int statistics[NUM_ROUTINES][20];

  DEBUG(DEBUG_READING_PERFORMANCE,
	"Hashtable cleared because it was full.\n");

  for (k = 0; k < NUM_ROUTINES; ++k)
    for (l = 0; l < 20; ++l)
      statistics[k][l] = 0;

  /* Walk through all_nodes. Closed nodes are unlinked from the
   * linked lists and marked as free.
   */
  for (k = 0; k < table->num_nodes; k++) {
    node = &(table->all_nodes[k]);
    bucket = node->key.hashval[0] % table->hashtablesize;
    previous = NULL;
    current = table->hashtable[bucket];

    /* If there are no results attached, this node is not in the table. */
    if (node->results == NULL)
      continue;

    /* Remove all closed results for this node except OWL_{ATTACK,DEFEND}. */
    hashtable_unlink_closed_results(node, 
				    (1 << OWL_ATTACK | 1 << OWL_DEFEND
				     | 1 << SEMEAI), 3,
				    statistics);
    if (node->results != NULL)
      continue;

    /* Find the node in the linked list and unlink. */
    while (current != NULL) {
      if (current != node) {
	previous = current;
	current = current->next;
      }
      else {
	if (previous == NULL)
	  table->hashtable[bucket] = current->next;
	else
	  previous->next = current->next;
	break;
      }
    }
  }

  if (debug & DEBUG_READING_PERFORMANCE) {
    /* FIXME: These names should be where the constants are defined. */
    const char *routines[] = {
      "find_defense", "defend1",    "defend2", "defend3",
      "defend4",      "attack",     "attack2", "attack3",
      "owl_attack",   "owl_defend", "",        "",
      "",             "",           "",        "",
    };
    int total;

    fprintf(stderr, "routine        total     0     1     2     3     4     5     6     7     8     9    10    11    12    13    14    15    16    17    18    19\n");

    for (k = 0; k < NUM_ROUTINES; ++k) {
      total = 0; 
      for (l = 0; l < 20; ++l)
	total += statistics[k][l];

      if (total == 0)
	continue;

      fprintf(stderr, "%-14s%6d", routines[k], total);
      for (l = 0; l < 20; ++l)
	fprintf(stderr, "%6d", statistics[k][l]);
      fprintf(stderr, "\n");
    }
  }


  /* FIXME: This is not entirely safe although it probably works more
   * than 99.999% of all cases.  If result no 0 or node no 0 is not
   * free after the partial clearing, this will explode into our face.
   */
  table->free_result = 0;
  table->free_node = 0;
}


/*
 * Enter a position with a given hash value into the table.  Return 
 * a pointer to the hash node where it was stored.  If it is already
 * there, don't enter it again, but return a pointer to the old one.
 */

static Hashnode *
hashtable_enter_position(Hashtable *table, Hash_data *hd)
{
  Hashnode *node;
  int bucket;

  /* If the position is already in the table, return a pointer to it. */
  node = hashtable_search(table, hd);
  if (node != NULL) {
    return node;
  }

  /* If the next node is not free, skip until we find one which is free. */
  while (table->free_node < table->num_nodes
	 && table->all_nodes[table->free_node].results != NULL)
    table->free_node++;
  
  /* If the table is full, return NULL */
  if (table->free_node == table->num_nodes)
    return NULL;

  /* It wasn't there and there is still room. Allocate a new node for it... */
  node = &(table->all_nodes[table->free_node++]);
  node->key = *hd;
  node->results = NULL;

  /* ...and enter it into the table. */
  bucket = hd->hashval[0] % table->hashtablesize;
  node->next = table->hashtable[bucket];
  table->hashtable[bucket] = node;

  stats.position_entered++;
  return node;
}


/* 
 * Given a Hashposition and a Hash value, find the hashnode which contains
 * this very position with the given hash value.  
 *
 * We could compute the hash value within this functions, but later
 * when we have incremental calculation of the hash function, this 
 * would be dumb. So we demand the hash value from outside from the 
 * very beginning.
 */

static Hashnode *
hashtable_search(Hashtable *table, Hash_data *hd)
{
  Hashnode *node;
  int bucket;
  int i;

  bucket = hd->hashval[0] % table->hashtablesize;
  for (node = table->hashtable[bucket]; node != NULL; node = node->next) {
    if (node->key.hashval[0] != hd->hashval[0])
      continue;
    for (i = 1; i < NUM_HASHVALUES; i++)
      if (node->key.hashval[i] != hd->hashval[i]) {
	stats.hash_collisions++;
	break;
      }
    if (i >= NUM_HASHVALUES)
#if FULL_POSITION_IN_HASH
      if (hashposition_compare(&hd->hashpos, &node->key.hashpos) == 0)
	break;
#else
      break;
#endif
  }
  return node;
}


/* 
 * Search the result list in a hash node for a particular result. This
 * result is from ROUTINE (e.g. readlad1) at (i, j) and reading depth
 * stackp.
 *
 * All these numbers must be unsigned, and 0 <= x <= 255).
 */

static Read_result *
hashnode_search(Hashnode *node, int routine, int komaster, int kom_pos,
		int str1, int str2)
{
  Read_result *result;
  unsigned int search_for1;
  unsigned int search_for2;

  search_for1 = rr_input_data1(routine, komaster, kom_pos, str1,
			       depth - stackp);
  search_for2 = rr_input_data2(str2);

  for (result = node->results; result != NULL; result = result->next) {
    if (result->data1 == search_for1
	&& (result->data2 & RR_INPUT_DATA2) == search_for2)
      break;
    }

  return result;
}


/*
 * Enter a new Read_result into a Hashnode.
 * We already have the node, now we just want to enter the result itself.
 * We will fill in the result itself later, so we only need the routine
 * number for now.
 */

static Read_result *
hashnode_new_result(Hashtable *table, Hashnode *node, int routine, 
		    int komaster, int kom_pos, int str1, int str2)
{
  Read_result *result;

  /* If the next result is not free, skip until we find one which is free. */
  while (table->free_result < table->num_results
	 && rr_get_status(table->all_results[table->free_result]) != 0)
    table->free_result++;
  
  /* If the table is full, return NULL */
  if (table->free_result == table->num_results)
    return NULL;

  /* There is still room. Allocate a new node for it... */
  result = &(table->all_results[table->free_result++]);

  /* ...and enter it into the table. */
  result->next = node->results;
  node->results = result;

  /* Now, put the input data into it. This also sets status to open. */
  rr_set_input_data2(*result, routine, komaster, kom_pos, str1, str2,
		     depth - stackp);

  stats.read_result_entered++;
  return result;

}

/* Initialize the cache for read results, using at most the given
 * number of bytes of memory. If the memory isn't sufficient to
 * allocate a single node or if the allocation fails, the caching is
 * disabled.
 */
void
reading_cache_init(int bytes)
{
  /* Initialize hash table.
   *
   * The number 1.4 below is the quotient between the number of nodes
   * and the number of read results.  It was found in a test that this 
   * number varies between 1.15 and 1.4.  Thus we use 1.4.
   */
  float nodes = ((float) bytes
		 / (1.5 * sizeof(Hashnode *)
		    + sizeof(Hashnode)
		    + 1.4 * sizeof(Read_result)));
  if (0)
    gprintf("Allocated memory for %d hash nodes. \n", (int) nodes);
  /* If we get a zero size hash table, disable hashing completely. */
  if (nodes < 1.0)
    hashflags = HASH_NOTHING;
  movehash = hashtable_new((int) (1.5 * nodes),  /* table size   */
			   (int) nodes,          /* nodes        */
			   (int) (1.4 * nodes)); /* read results */
  
  if (!movehash) {
    fprintf(stderr,
	    "Warning: failed to allocate hashtable, caching disabled.\n");
    hashflags = HASH_NOTHING;
  }
}

/* Clear the cache for read results. */
void
reading_cache_clear()
{
  hashtable_clear(movehash);
}

/*
 * Return a Read_result for the current position, routine and location.
 * For performance, the location is changed to the origin of the string.
 */

int
get_read_result(int routine, int komaster, int kom_pos, int *str,
		Read_result **read_result)
{
  int result;
  /* Only store the result if stackp <= depth. Above that, there
   * is no branching, so we won't gain anything.
   */
  if (stackp > depth) {
    *read_result = NULL;
    return 0;
  }
  
  /* Find the origin of the string containing (si, sj),
   * in order to make the caching of read results work better.
   */
  *str = find_origin(*str);
  
  result = do_get_read_result(routine, komaster, kom_pos, *str, NO_MOVE,
			      read_result);
  if (*read_result == NULL) {
    /* Clean up the hashtable and try once more. */
    hashtable_partially_clear(movehash);
    result = do_get_read_result(routine, komaster, kom_pos, *str, NO_MOVE,
				read_result);
  }
  return result;
}

/*
 * Variant with two calling strings.
 */

int
get_read_result2(int routine, int komaster, int kom_pos, int *str1, int *str2,
		 Read_result **read_result)
{
  int result;
  /* Only store the result if stackp <= depth. Above that, there
   * is no branching, so we won't gain anything.
   */
  if (stackp > depth) {
    *read_result = NULL;
    return 0;
  }
  
  /* Find the origin of the string containing (si, sj),
   * in order to make the caching of read results work better.
   */
  *str1 = find_origin(*str1);
  *str2 = find_origin(*str2);
  
  result = do_get_read_result(routine, komaster, kom_pos, *str1, *str2,
			      read_result);
  if (*read_result == NULL) {
    /* Clean up the hashtable and try once more. */
    hashtable_partially_clear(movehash);
    result = do_get_read_result(routine, komaster, kom_pos, *str1, *str2,
				read_result);
  }
  return result;
}


static int
do_get_read_result(int routine, int komaster, int kom_pos,
		   int str1, int str2, Read_result **read_result)
{
  Hashnode *hashnode;
  int retval;

#if CHECK_HASHING
  Hash_data    key;

  /* Check the hash table to see if we have had this position before. */
  hashdata_recalc(&key, board, board_ko_pos);
#if FULL_POSITION_IN_HASH
  gg_assert(hashdata_diff_dump(&key, &hashdata) == 0);
#else
  gg_assert(hashdata_compare(&key, &hashdata) == 0);
#endif

  /* Find this position in the table.  If it wasn't found, enter it. */
  hashnode = hashtable_search(movehash, &hashdata);
  if (hashnode != NULL) {
    stats.position_hits++;
    DEBUG(DEBUG_READING_CACHE, "We found position %H in the hash table...\n",
	  (unsigned long) hashdata.hashval);
  }
  else {
    hashnode = hashtable_enter_position(movehash, &hashdata);
    if (hashnode)
      DEBUG(DEBUG_READING_CACHE, "Created position %H in the hash table...\n",
	    (unsigned long) hashdata.hashval);
  }
#else
  /* Find this position in the table.  If it wasn't found, enter it. */
  hashnode = hashtable_search(movehash, &hashdata);
  if (hashnode != NULL) {
    stats.position_hits++;
    DEBUG(DEBUG_READING_CACHE, "We found position %H in the hash table...\n",
	  (unsigned long) hashdata.hashval);
  }
  else {
    hashnode = hashtable_enter_position(movehash, &hashdata);
    if (hashnode)
      DEBUG(DEBUG_READING_CACHE, "Created position %H in the hash table...\n",
	    (unsigned long) hashdata.hashval);
  }
#endif

  retval = 0;
  if (hashnode == NULL) {
    /* No hash node, so we can't enter a result into it. */
    *read_result = NULL;

  }
  else {

    /* We found it!  Now see if we can find a previous result. */
    *read_result = hashnode_search(hashnode, routine, komaster, kom_pos,
				   str1, str2);

    if (*read_result != NULL) {
      stats.read_result_hits++;
      retval = 1;
    }
    else {
      DEBUG(DEBUG_READING_CACHE,
	    "...but no previous result for routine %d and (%1m, %1m)...",
	    routine, str1, str2);

      *read_result = hashnode_new_result(movehash, hashnode, routine,
					 komaster, kom_pos, str1, str2);
      
      if (*read_result == NULL)
	DEBUG(DEBUG_READING_CACHE,
	      "%o...and unfortunately there was no room for one.\n");
      else
	DEBUG(DEBUG_READING_CACHE, "%o...so we allocate a new one.\n");
    }
  }

  return retval;
}


/* Write reading trace data to an SGF file. Normally called through the
 * macro SGFTRACE in cache.h.
 */

void
sgf_trace(const char *func, int str, int move, int result,
	  const char *message)
{
  char buf[100];

  sprintf(buf, "%s %c%d: ", func, J(str) + 'A' + (J(str) >= 8),
	  board_size - I(str));
  
  if (result == 0)
    sprintf(buf + strlen(buf), "0");
  else if (ON_BOARD(move))
    sprintf(buf + strlen(buf), "%s %c%d", result_to_string(result), 
	    J(move) + 'A' + (J(move) >= 8),
	    board_size - I(move));
  else if (is_pass(move))
    sprintf(buf + strlen(buf), "%s PASS", result_to_string(result));
  else
    sprintf(buf + strlen(buf), "%s [%d]", result_to_string(result), move);

  if (message)
    sprintf(buf + strlen(buf), " (%s)", message);
  
  sgftreeAddComment(sgf_dumptree, NULL, buf);
}

/* Write two group reading (connection or semeai) trace data to an SGF
 * file. Normally called through the macro SGFTRACE2 in cache.h.
 */

void
sgf_trace2(const char *func, int str1, int str2, int move, int result,
	   const char *message)
{
  char buf[100];

  sprintf(buf, "%s %c%d %c%d: ", func,
	  J(str1) + 'A' + (J(str1) >= 8), board_size - I(str1),
	  J(str2) + 'A' + (J(str2) >= 8), board_size - I(str2));
  
  if (result == 0)
    sprintf(buf + strlen(buf), "0");
  else if (ON_BOARD(move))
    sprintf(buf + strlen(buf), "%s %c%d", result_to_string(result), 
	    J(move) + 'A' + (J(move) >= 8),
	    board_size - I(move));
  else if (is_pass(move))
    sprintf(buf + strlen(buf), "%s PASS", result_to_string(result));
  else
    sprintf(buf + strlen(buf), "%s [%d]", result_to_string(result), move);

  if (message)
    sprintf(buf + strlen(buf), " (%s)", message);
  
  sgftreeAddComment(sgf_dumptree, NULL, buf);
}

/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */



/* clock.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* ============================================================= *\
 *                        Time handling                          *
 *                          for GNU Go                           *
 *                         __       __                           *
 *                        <  >     <  >                          *
 *                      +--++-------++--+                        *
 *                      |  .'11 12 1'.  |                        *
 *                      |  :10 \    2:  |                        *
 *                      |  :9   @-> 3:  |                        *
 *                      |  :8       4;  |                        *
 *                      |  '..7 6 5..'  |                        *
 *                      |_______________|                        *
 *                                                               *
\* ============================================================= */

/* #include "gnugo.h" */
/* #include "liberty.h" */
/* #include "gg_utils.h" */

/* #include "clock.h" */



/* parameters */
#define CLOCK_MAX_MOVES           500   /* max number of moves for a game */
#define CLOCK_STEP                0.4   /* modification step for level */
#define CLOCK_HURRY               10    /* Last chance limit: */
#define CLOCK_HURRYR              0.02  /* (10 sec or or 2% of main_time) */
#define CLOCK_HURRY_LEVEL         1     /* Last chance level: */
#define CLOCK_SAFE                300   /* Keep Ahead limit: */
#define CLOCK_SAFER               0.20  /* (5min or 20% of time) */
#define CLOCK_DELTA               10    /* Maximal time difference: */
#define CLOCK_DELTAR              0.10  /* 10sec or 10% of left time */
#define CLOCK_TIME_CONTRACT       0.75  /* 75% of time to play */
#define CLOCK_MOVE_CONTRACT(b)    (((b)*(b))/2)
#define CLOCK_CONTRACT_MIN_LEVEL  5


/*************************/
/* Datas and other stuff */
/*************************/

extern int board_size;

typedef struct {

  /* clock parameters */
  int     clock_on;
  int     ready;
  double  main_time;
  double  byoyomi_time; /* zero if no byo-yomi */
  int     byoyomi_stones;

  /* clock status */
  double  timer[3];
  double  btimer[3];
  int     byoyomi[3];
  int     dead[3];

  /* dates of each move */
  int     moveno; /* invariant: COLOR(clk.moveno) = color of last move */
  double  date[CLOCK_MAX_MOVES];

  /* adapative system parameters */
  int     autolevel_on;
  double  min_level;
  double  level;
  double  levels[CLOCK_MAX_MOVES];
  double  expected[CLOCK_MAX_MOVES];
  double  max_level;
  double  error; /* time/move estimation error */
} gnugo_clock;

static gnugo_clock clk;

/* Color macro:
 *   WHITE : odd moves
 *   BLACK : even moves. 
 */
#define COLOR(m)  ((m) % 2 ? WHITE : BLACK)


static const char *pname[3] = {"     ", "White", "Black"};


/* forward declarations */

static double estimate_time_by_move(int color, int move);




/* Echo a time value in STANDARD format */

static void
timeval_print(FILE* outfile, double tv)
{
  int     min;
  double  sec;

  min = (int) tv / 60;
  sec = tv - min*60;

  fprintf(outfile, "%3dmin %.2fsec ", min, sec);
}

/******************************/
/*  Initialization functions  */
/******************************/


/*
 * Initialize the structure.
 * -1 means "do not modify this value".
 * clock_init(-1, -1, -1) only resets the clock.
 */
void
clock_init(int time, int byo_time, int byo_stones)
{
  int  color;

  if (time > 0) {
    clk.main_time = time;
    clk.ready = 1;
  }

  if (byo_time >= 0)
    clk.byoyomi_time = byo_time;

  if (byo_stones >= 0)
    clk.byoyomi_stones = byo_stones;

  clk.moveno = -1;
  for (color = WHITE ; color <= BLACK ; color++) {
    clk.timer[color] = 0;
    clk.btimer[color] = 0;
    clk.byoyomi[color] = 0;
    clk.dead[color] = 0;
  }
}


/*
 * Activate the clock.
 */
void 
clock_enable(void)
{
  gg_assert(clk.ready);
  clk.clock_on = 1;
}

/* 
 * set the autolevel parameters.
 */
void 
clock_init_autolevel(int min_level, int max_level)
{
  clk.min_level = min_level;  
  clk.max_level = max_level;
}

/*
 * Activate Autolevel.
 */
void 
clock_enable_autolevel(void)
{
  gg_assert(clk.clock_on);
  clk.autolevel_on = 1;
}


/***********************/
/*  Access functions.  */
/***********************/


/* 
 * Maintain timers and all stuff up to date
 * (used by push_button).
 */
static void
clock_byoyomi_update(int color, double dt)
{
  gg_assert(clk.moveno > 0);

  /* update byoyomi timer */
  if (clk.byoyomi[color])
    clk.btimer[color] = clk.btimer[color] + dt;
 
  /* Check if player is just begining byoyomi. */
  if (clk.timer[color] < clk.main_time && !clk.byoyomi[color]) {
    clk.byoyomi[color] = clk.moveno;
    clk.btimer[color] = dt;
  }
  
  /* Check if player is time-out. */
  clk.dead[color] |= (clock_is_byoyomi(color)
		      && clk.byoyomi_time < clk.btimer[color]);

  /* Check byoyomi period reset. */
  if (clk.byoyomi[color]
      && clk.moveno - clk.byoyomi[color] == 2 * clk.byoyomi_stones - 1) {
    clk.byoyomi[color] = clk.moveno;
    clk.btimer[color] = 0;
  }
}


/*
 * Update the clock.
 */
void
clock_push_button(int color)
{
  double  now, dt, tme;

  if (!clk.clock_on)
    return;

  now = gg_gettimeofday();
  gg_assert(clk.ready);

  /* time/move estimation */
  tme = estimate_time_by_move(color, clk.moveno);

  /* first move */
  if (clk.moveno == -1) {
    /* fprintf(stderr, "clock: first move by %s.\n", pname[color]); */
    clk.moveno++;
    clk.date[0] = now;

    if (color != BLACK) { /* do an empty move for BLACK */
      clk.date[1] = now;
      clk.moveno++;
    }
    return;
  }

  /* fprintf(stderr, "clock: %s push the button.\n", pname[color]);*/
  /* fprintf(stderr, "clock: %s's turn.\n", pname[COLOR(clk.moveno+1)]);*/

  /* Pushing twice on the button does nothing. */
  if (color != COLOR(clk.moveno+1)) {
    fprintf(stderr, "clock: double push.\n");
    return;
  }

  /* Other moves (clk. moveno > -1) */
  clk.moveno++;
  gg_assert(clk.moveno < CLOCK_MAX_MOVES);
  clk.date[clk.moveno] = now;

  /* Update main timer. */
  dt = clk.date[clk.moveno] - clk.date[clk.moveno - 1];
  clk.timer[color] += dt;

  /* Estimate prediction error for next move. */
  if (clk.moveno > 11)
    clk.error = (clk.error + 2 * gg_abs(dt-tme))/3;
  else
    clk.error = 3.0;

  clock_byoyomi_update(color, dt);
  clock_print(color);
}


/*
 * Unplay a move.
 */
void 
clock_unpush_button(int color)
{
  double dt;

  if (!clk.clock_on)
    return;
     
  gg_assert(clk.ready);
  gg_assert(color == COLOR(clk.moveno));

  if (clk.moveno < 1) {
    clock_init(-1, -1, -1);
    return;
  }

  /* Update main timer. */
  dt = clk.date[clk.moveno] - clk.date[clk.moveno - 1];
  clk.timer[color] -= dt;
  clk.moveno--;

  /* Check if back from byoyomi. */
  if (clk.timer[color] < clk.main_time) {
    clk.byoyomi[color] = 0;
    clk.btimer[color] = 0;
  }
     
  /* Update byoyomi timer. */
  if (clk.byoyomi[color])
    clk.btimer[color] -= dt;

  clock_print(color);
}


/*
 * return the (exact) main timer value.
 */
double
clock_get_timer(int color)
{
  double dt;

  gg_assert(clk.clock_on && clk.ready);

  dt = gg_gettimeofday() - clk.date[clk.moveno];

  if (COLOR(clk.moveno) != color)
    return clk.timer[color] + dt;
  else 
    return clk.timer[color];
}


/*
 * Give the time left or negative if in byoyomi.
 */
double  
clock_get_time_left(int color)
{
  return clk.main_time - clock_get_timer(color);
}


/*
 * Check if color is (officially) in byoyomi.
 */
int
clock_is_byoyomi(int color)
{
  return clock_get_time_left(color) < 0;
}


/*
 * Return the (exact) main timer value.
 */
double
clock_get_btimer(int color)
{
  double dt;
  
  /* sanity check */
  gg_assert(clk.clock_on && clk.ready);
  dt = gg_gettimeofday() - clk.date[clk.moveno];

  if (COLOR(clk.moveno) != color)
    return clk.btimer[color] + dt;
  else 
    return clk.btimer[color];
}


/*
 * Get The Byoyomi time left and the number of stones to play.
 */
double
clock_get_btime_left(int color, int *stones)
{
  if (stones != NULL)
    *stones = clk.byoyomi_stones - (clk.moveno - clk.byoyomi[color]) / 2;

  return clk.byoyomi_time - clock_get_btimer(color);
}


/*
 * Check if a player is time over.
 */
int  
clock_is_time_over(int color)
{
  return clock_is_byoyomi(color) && clock_get_btime_left(color, NULL) <= 0;
}


void
clock_print(int color)
{
  double tleft;
  int stones;

  if (!clk.clock_on)
    return;

  gg_assert(clk.ready);

  fprintf(stderr, "clock: "); 
  fprintf(stderr, "%s ", pname[color]);

  if (clock_is_time_over(color))
    fprintf(stderr, "TIME OUT! ");
  else {
    if (clock_is_byoyomi(color))
      tleft = clock_get_btime_left(color, &stones);
    else
      tleft = clock_get_time_left(color);
      
    if (clock_is_byoyomi(color)) {
      fprintf(stderr, "byoyomi");
      timeval_print(stderr, tleft);
      fprintf(stderr, "for %d stones.\n", stones);
    }
    else
      timeval_print(stderr, tleft);

  }
  fprintf(stderr, "\n");
}



/**********************/
/*  Autolevel system  */
/**********************/



/* Write the time/move to outfile */
void 
clock_report_autolevel(FILE *outfile, int color)
{
  int i, first;
  double dt, est, exp;

  if (!clk.autolevel_on)
    return;

  if (outfile == NULL)
    outfile = fopen("autolevel.dat", "w");
  if (outfile == NULL)
    return;

  fprintf(outfile, "#\n#  level  prediction   expected  time/move\n");  
  fprintf(outfile, "#-----------------------------------------\n"); 

  if (color == WHITE)
    first = 8;
  else
    first = 9;

  for (i = first; i < clk.moveno; i += 2) {
    dt = clk.date[i+1] - clk.date[i];
    est = estimate_time_by_move(color, i);
    exp = clk.expected[i + 1];
    fprintf(outfile, "%5.2f  %5.2f  %5.2f  %5.2f\n",
	    clk.levels[i + 1], est, exp, dt);
  }
}


/* 
 * Give an estimation of the time/move 
 * based on the last played move.
 */

/* coeficients to estimate time/move */
static const double 
coef[5] = {
  1.0/15.0, 2.0/15.0, 3.0/15.0, 4.0/15.0, 5.0/15.0 
};

static double
estimate_time_by_move(int color, int move)
{
  double res;
  int i;

  if (move <= 10)
    return 0;

  gg_assert(COLOR(move) == OTHER_COLOR(color));

  res = 0;
  for (i = 0 ; i < 5 ; i++)
    res += coef[i] * (clk.date[move-9+i*2] - clk.date[move-10+i*2]);
  
  return res;
}


/* 
 * Try to respect a "time contract". 
 */
static void 
respect_time_contract(int color)
{
  double time_left, expected_tm, predicted_tm;
  double moves_left;

  fprintf(stderr, "\n*** time contract:\n");

  predicted_tm = estimate_time_by_move(color, clk.moveno);

  /* Compute the expected mean time/move 
   * to recpect the contract.
   */
  moves_left = (CLOCK_MOVE_CONTRACT(board_size) - clk.moveno) / 2.0;
  time_left = (clock_get_time_left(color)
	       - (1.0 - CLOCK_TIME_CONTRACT) * clk.main_time);
  expected_tm = time_left / moves_left;

  clk.expected[clk.moveno + 1] = expected_tm;

  fprintf(stderr, "%4.0f moves ", moves_left);
  fprintf(stderr, "must be played in %.2fsec\n", time_left);
  fprintf(stderr, "time/move: prediction=%.2f", predicted_tm);
  fprintf(stderr, "+/-%.2fsec --> ", clk.error);
  fprintf(stderr, "expected=%.2f\n", expected_tm);

  /* Compare this result with the prediction
   * (up to prediction error estimation)
   * and update the level.
   */ 
  if (clk.level > CLOCK_CONTRACT_MIN_LEVEL)
    if ((predicted_tm - clk.error) > expected_tm)
      clk.level -= CLOCK_STEP;
  if ((predicted_tm + clk.error) < expected_tm)
    clk.level += CLOCK_STEP;
}


/* 
 * Try to keep gnugo ahead on the clock. 
 */
static void
keep_ahead(int color)
{
  double dt, st, delta_max;

  fprintf(stderr, "*** safe limit reached: trying to keep ahead\n");

  dt = clock_get_time_left(color) - clock_get_time_left(OTHER_COLOR(color));
  st = clock_get_time_left(color) + clock_get_time_left(OTHER_COLOR(color));
  delta_max = gg_max(CLOCK_DELTA, CLOCK_DELTAR * st);

  fprintf(stderr, "deltamax: %gsec, delta=%gsec => ", delta_max, dt);
      
  if (dt < -delta_max) {
    fprintf(stderr, "behind\n");
    clk.level -= CLOCK_STEP;
  }
  else {
    if (dt > delta_max) {
      fprintf(stderr, "ahead\n");
      clk.level += CLOCK_STEP;
    }
    else
      fprintf(stderr, "equal\n");
  }
}


/* 
 * Modify the level during a game to avoid losing by time.
 */
void
clock_adapt_level(int *p_level, int color)
{
  int old_level;
  double hurry_limit, safe_limit;

  /* 
   * Do not touch the level during the first 10 moves
   * to estimate time/move on a reasonable sample.
   */
  if (clk.moveno < 10 || !clk.autolevel_on) {
    clk.level = *p_level;
    clk.levels[clk.moveno + 1] = clk.level;
    return;
  }

  old_level = *p_level;
  
  /* 
   * Hurry strategy:
   * Behind this limit the only priority is finish at all costs.
   */
  hurry_limit = gg_max(CLOCK_HURRY, CLOCK_HURRYR * clk.main_time);
  if (clock_get_time_left(color) < hurry_limit) {
    fprintf(stderr, "*** hurry limit reached:\n");
    clk.level = CLOCK_HURRY_LEVEL;
    *p_level = clk.level;
    return;
  }

  /* 
   * Time contract strategy:
   * try to respect the time of a standard game. 
   */
    if (clk.moveno < CLOCK_MOVE_CONTRACT(board_size))
      respect_time_contract(color);

  /* 
   * Keep ahead strategy:
   * When the safe_limit is reached gnugo tries to keep ahead in time.
   */
  safe_limit = gg_max(CLOCK_SAFE, CLOCK_SAFER * clk.main_time);
  if (clock_get_time_left(color) < safe_limit) 
    keep_ahead(color);

  /* Update the level. */
  if (clk.level > clk.max_level)
    clk.level = clk.max_level;
  if (clk.level < clk.min_level)
    clk.level = clk.min_level;

  clk.levels[clk.moveno + 1] = clk.level;
  *p_level = clk.level;
  
  fprintf(stderr, "level %4.1f at move %d\n", clk.level, movenum);
}



/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */


/* combination.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


/* This file contains functions that deals with threats and, 
 * especially, combinations of threats.
 */

/* #include <string.h> */

/* #include "gnugo.h" */
/* #include "liberty.h" */
/* #include "gg_utils.h" */

/* #include "patterns.h" */


static void find_double_threats(int color);

/* Generate move reasons for combination attacks and defenses against
 * them.
 *
 * This is one of the move generators called from genmove().
 */

void
combinations(int color)
{
  int save_verbose;
  int attack_point;
  int defense_point;
  int other = OTHER_COLOR(color);
  int aa_val;

  /* Find intersections with multiple threats. */
  find_double_threats(color);

  save_verbose = verbose;
  if (verbose > 0)
    verbose--;

  if (save_verbose)
    gprintf("\nlooking for combination attacks ...\n");
  
  aa_val = atari_atari(color, &attack_point, NULL, save_verbose);
  if (aa_val > 0) {
    if (save_verbose)
      gprintf("Combination attack for %C with size %d found at %1m\n",
	      color, aa_val, attack_point);
    add_my_atari_atari_move(attack_point, aa_val);
  }
  
  aa_val = atari_atari(other, &attack_point, &defense_point, save_verbose);
  if (aa_val > 0) {
    int libs[2];
    if (save_verbose)
      gprintf("Combination attack for %C with size %d found at %1m, defense at %1m\n",
	      other, aa_val, attack_point, defense_point);
    if (safe_move(defense_point, color))
      add_your_atari_atari_move(defense_point, aa_val);
    /* Playing at the attack point is probably also a defense. */
    if (safe_move(attack_point, color))
      add_your_atari_atari_move(attack_point, aa_val);
    /* If the attacking move gets two liberties, playing first on one
     * of them is probably a defense.
     */
    if (approxlib(attack_point, other, 2, libs) == 2) {
      if (safe_move(libs[0], color))
	add_your_atari_atari_move(libs[0], aa_val);
      if (safe_move(libs[1], color))
	add_your_atari_atari_move(libs[1], aa_val);
    }
  }
  verbose = save_verbose;
}


#define MAX_THREATENED_STRINGS  10  /* Should be enough for one intersection */

static void
find_double_threats(int color)
{
  int i, j;
  int ii;
  int k;
  int l;

  for (i = 0; i < board_size; ++i)
    for (j = 0; j < board_size; ++j) {
      int num_a_threatened_groups;
      int a_threatened_groups[MAX_THREATENED_STRINGS];
#if 0
      int num_d_threatened_groups;
      int d_threatened_groups[MAX_THREATENED_STRINGS];
#endif

      ii = POS(i, j);
      
      /* Generate ATTACK_EITHER_MOVE move reasons for each pair of the 
       * threatened strings.  We must also remove the threats, because
       * otherwise we would get followup points for them also.     
       *
       * FIXME: 
       *   - This is perhaps not the best way to do it, but realistically
       *     it will be seldom that more than two strings are threatened
       *     at the same point.  Still, we should find a better way.
       *   - ATTACK_EITHER_MOVE should be generalized to more than two strings.
       */
      num_a_threatened_groups = get_attack_threats(ii, MAX_THREATENED_STRINGS,
						   a_threatened_groups);
      if (num_a_threatened_groups > 1) {
	if (trymove(ii, color, "find_double_threats-A", ii, EMPTY, NO_MOVE)) {
	  for (k = 0; k < num_a_threatened_groups - 1; ++k)
	    for (l = k + 1; l < num_a_threatened_groups; ++l) {
	      /* Note: If we used attack_either() here instead of trymove()
	       *       and !defend_both(), we would not make use of the fact
	       *       that we already know of a common threat point for
	       *       the two strings.
	       * Besides, attack_either is currently (3.1.11) not very good.
	       *
	       * The call to attack() is intended to detect the case
	       * where the move at ii is a snapback capture.
	       */
	      if (board[a_threatened_groups[k]] == EMPTY
		  || board[a_threatened_groups[l]] == EMPTY) {
		if (!attack(ii, NULL)) {
		  add_either_move(ii, ATTACK_STRING, a_threatened_groups[k], 
				  ATTACK_STRING, a_threatened_groups[l]);
		  remove_attack_threat_move(ii, a_threatened_groups[k]);
		  remove_attack_threat_move(ii, a_threatened_groups[l]);
		}
	      }
	      else if (!defend_both(a_threatened_groups[k],
				    a_threatened_groups[l])) {
		add_either_move(ii, ATTACK_STRING, a_threatened_groups[k], 
				ATTACK_STRING, a_threatened_groups[l]);
		remove_attack_threat_move(ii, a_threatened_groups[k]);
		remove_attack_threat_move(ii, a_threatened_groups[l]);
	      }
	    }
	  popgo();
	}
      }
    }


  /* FIXME:
   *   TODO:
   *     - defense threats
   *     - combinations of owl threats and other threats
   *     - combinations of threats to cut and connect
   *     - combinations of breakins into enemy territory
   */
}


/* ================================================================ */
/*                       Combination attacks                        */
/* ================================================================ */


/* atari_atari(color, *move) looks for a series of ataris on
 * strings of the other color culminating in the capture of
 * a string which is thought to be invulnerable by the reading
 * code. Such a move can be missed since it may be that each
 * string involved individually can be rescued, but nevertheless
 * one of them can be caught. The simplest example is a double
 * atari. The return value is the size of the smallest opponent
 * worm. 
 *
 * One danger with this scheme is that the first atari
 * tried might be irrelevant to the actual combination.
 * To detect this possibility, once we've found a combination,
 * we mark that first move as forbidden, then try again. If
 * no combination of the same size or larger turns up, then
 * the first move was indeed essential.
 *
 * For the purpose of the move generation, returns the
 * size of the smallest of the worms under attack.
 */

/* Local struct to keep track of atari_atari attack moves and what
 * they threat.
 */
#define AA_MAX_TARGETS_PER_MOVE 4

#define MAX_AA_DIST 5

struct aa_move {
  int move;
  int target[AA_MAX_TARGETS_PER_MOVE];
};

#define AA_MAX_MOVES MAX_BOARD * MAX_BOARD  
static int aa_status[BOARDMAX]; /* ALIVE, DEAD or CRITICAL */
static int forbidden[BOARDMAX];
static int vital_string[BOARDMAX]; /* May not sacrifice these stones. */
static int aa_values[BOARDMAX];
static void compute_aa_status(int color, int saved_dragons[BOARDMAX],
			      int saved_worms[BOARDMAX]);
static void compute_aa_values(int color);
static int get_aa_status(int pos);
static int is_vital_string(int str);
static int do_atari_atari(int color, int *attack_point,
			  int *defense_point, int last_friendly,
			  int save_verbose, int minsize,
			  char goal[BOARDMAX]);
static int atari_atari_succeeded(int color, int *attack_point,
                                int *defense_point, int last_friendly,
                                int save_verbose, int minsize);
static void atari_atari_find_attack_moves(int color, int minsize,
					  struct aa_move attacks[AA_MAX_MOVES],
					  char goal[BOARDMAX]);
static void atari_atari_attack_patterns(int color, int minsize,
					struct aa_move attacks[AA_MAX_MOVES],
					char goal[BOARDMAX]);
static void atari_atari_attack_callback(int m, int n, int color,
					struct pattern *pattern,
					int ll, void *data);
static int atari_atari_find_defense_moves(int targets[AA_MAX_TARGETS_PER_MOVE],
					  int moves[AA_MAX_MOVES]);
static int get_aa_value(int str);
static int update_aa_goal(char goal[BOARDMAX], char new_goal[BOARDMAX],
			  int apos, int color);
static void aa_init_moves(struct aa_move attacks[AA_MAX_MOVES]);
static void aa_add_move(struct aa_move attacks[AA_MAX_MOVES],
			int move, int target);
static int aa_move_known(struct aa_move attacks[AA_MAX_MOVES],
			 int move, int target);
static void aa_sort_moves(struct aa_move attacks[AA_MAX_MOVES]);

/* Set to 1 if you want verbose traces from this function. */

int
atari_atari(int color, int *attack_move, int *defense_move, int save_verbose)
{
  int apos;
  int dpos;
  int aa_val;

  /* Collect worm statuses of opponent's worms. We need to
   * know this because we only want to report unexpected
   * results. For example, we do not want to report success
   * if we find we can kill a worm which is already dead.
   * The worm status of empty points is set to UNKNOWN to signal
   * that stones added along the way need special attention.
   */
  if (aa_depth < 2)
    return 0;
  memset(forbidden, 0, sizeof(forbidden));

  compute_aa_status(color, NULL, NULL);
  compute_aa_values(color);
  
  aa_val = do_atari_atari(color, &apos, &dpos, NO_MOVE,
			  save_verbose, 0, NULL);

  if (aa_val == 0)
    return 0;

  /* We try excluding the first atari found and see if the
   * combination still works. Repeat until failure.
   */
  while (1) {
    int new_aa_val;
    
    if (attack_move)
      *attack_move = apos;
    if (defense_move)
      *defense_move = dpos;
    
    forbidden[apos] = 1;
    new_aa_val = do_atari_atari(color, &apos, &dpos, NO_MOVE,
				save_verbose, aa_val, NULL);

    /* The last do_atari_atari call fails. When do_atari_atari fails,
     * it does not change the value of (apos), so these correspond
     * to a move that works and is necessary.
     */
    if (new_aa_val == 0)
      return aa_val;
    else
      aa_val = new_aa_val;
  }

  /* We'll never get here, but the compiler may be more happy if it
   * looks like we're returning something.
   */
  return 0;
}


/* Ask the atari_atari code whether there appears any combination
 * attack which would capture at least minsize stones after playing at
 * (move). If this happens, (*defense) points to a move which prevents
 * this blunder.
 *
 * The arrays saved_dragons[] and saved_worms[] should be one for
 * stones belonging to dragons or worms respectively, which are
 * supposedly saved by (move). These may be NULL if no stones are
 * supposed to gaving been saved.
 */
int
atari_atari_confirm_safety(int color, int move, int *defense, int minsize,
			   int saved_dragons[BOARDMAX],
			   int saved_worms[BOARDMAX])
{
  int apos;
  int defense_point = NO_MOVE, after_defense_point = NO_MOVE;
  int aa_val, after_aa_val;
  int other = OTHER_COLOR(color);

  /* If aa_depth is too small, we can't see any combination attacks,
   * so in this respect the move is safe enough.
   */
  if (aa_depth < 2)
    return 1;

  memset(forbidden, 0, sizeof(forbidden));

  compute_aa_status(other, saved_dragons, saved_worms);
  compute_aa_values(other);

  /* Accept illegal ko capture here. */
  if (!tryko(move, color, NULL, EMPTY, NO_MOVE))
    /* Really shouldn't happen. */
    abortgo(__FILE__, __LINE__, "trymove", I(move), J(move));
  increase_depth_values();

  aa_val = do_atari_atari(other, &apos, &defense_point, NO_MOVE, 0, minsize,
			  NULL);
  after_aa_val = aa_val;

  if (aa_val == 0 || defense_point == NO_MOVE) {

  /* No sufficiently large combination attack, so the move is safe from
   * this danger.
   *
   * On rare occasions do_atari_atari might find a combination
   * but no defense. In this case we assume that the combination
   * is illusory.
   */

    popgo();
    decrease_depth_values();
    return 1;
  }

  while (aa_val >= after_aa_val) {
    /* Try dropping moves from the combination and see if it still
     * works. What we really want is to get the proper defense move
     * into (*defense).
     */
    after_defense_point = defense_point;
    forbidden[apos] = 1;
    aa_val = do_atari_atari(other, &apos, &defense_point, NO_MOVE, 0, aa_val,
			    NULL);
  }

  popgo();
  decrease_depth_values();
  /* We know that a combination exists, but we don't know if
   * the original move at (aa) was really relevant. So we
   * try omitting it and see if a combination is still found.
   */
  compute_aa_status(other, NULL, NULL);
  compute_aa_values(other);
  if (do_atari_atari(other, NULL, NULL, NO_MOVE,
		     0, minsize, NULL) >= after_aa_val)
    return 1;
  else {
    if (defense)
      *defense = after_defense_point;
    return 0;
  }
}


/* ---------------------------------------------------------------- */
/*                Helper functions for atari_atari.                 */
/* ---------------------------------------------------------------- */


/* Helper function for computing the aa_status for a string. It also
 * sets up the vital_string[] array.
 */

static void
compute_aa_status(int color, int saved_dragons[BOARDMAX],
		  int saved_worms[BOARDMAX])
{
  int other = OTHER_COLOR(color);
  int pos;
  SGFTree *save_sgf_dumptree = sgf_dumptree;
  int save_count_variations = count_variations;
  int save_verbose = verbose;
  sgf_dumptree = NULL;
  count_variations = 0;
  if (verbose)
    verbose--;
  
  /* Collect worm statuses of opponent's worms. We need to
   * know this because we only want to report unexpected
   * results. For example, we do not want to report success
   * if we find we can kill a worm which is already dead.
   * The worm status of empty points is set to UNKNOWN to signal
   * that stones added along the way need special attention.
   */
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (board[pos] == other) {
      if (dragon[pos].matcher_status == DEAD)
	aa_status[pos] = DEAD;
      else if (dragon[pos].matcher_status == CRITICAL
	       && (!saved_dragons || !saved_dragons[pos]))
	aa_status[pos] = CRITICAL;
      else if (worm[pos].attack_codes[0] != 0) {
	if (worm[pos].defend_codes[0] != 0) {
	  if (saved_worms && saved_worms[pos])
	    aa_status[pos] = ALIVE;
	  else
	    aa_status[pos] = CRITICAL;
	}
	else
	  aa_status[pos] = DEAD;
      }
      else
	aa_status[pos] = ALIVE;
    }
    else if (ON_BOARD(pos))
      aa_status[pos] = UNKNOWN;
  }
  
  /* reclassify a worm with 2 liberties as INSUBSTANTIAL if capturing
   * it does not result in a live group.
   */
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (board[pos] == other
	&& worm[pos].origin == pos
	&& worm[pos].liberties == 2
	&& aa_status[pos] == ALIVE
	&& !owl_substantial(pos)) {
      int pos2;
      for (pos2 = BOARDMIN; pos2 < BOARDMAX; pos2++)
	if (ON_BOARD(pos2) && is_worm_origin(pos2, pos))
	  aa_status[pos2] = INSUBSTANTIAL;
    }
  }
    
  if (debug & DEBUG_ATARI_ATARI) {
    gprintf("compute_aa_status() for %C\n", color);
    gprintf("aa_status: (ALIVE worms not listed)\n");
    for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
      if (board[pos] == other && is_worm_origin(pos, pos)) {
	const char *status = "UNKNOWN (shouldn't happen)";
	if (aa_status[pos] == DEAD)
	  status = "DEAD";
	else if (aa_status[pos] == CRITICAL)
	  status = "CRITICAL";
	else if (aa_status[pos] == INSUBSTANTIAL)
	  status = "INSUBSTANTIAL";
	
	if (aa_status[pos] != ALIVE)
	  gprintf("%1M: %s\n", pos, status);
      }
    }
  }

  /* Set up the vital strings array. This contains stones we can't be
   * allowed to sacrifice. This is used by
   * atari_atari_confirm_safety() to make sure that stones which are
   * supposedly saved by the move can't be captured in a combination
   * attack.
   */

  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (ON_BOARD(pos)
	&& ((saved_dragons && saved_dragons[pos])
	    || (saved_worms && saved_worms[pos])))
      vital_string[pos] = 1;
    else
      vital_string[pos] = 0;
  }
  
  sgf_dumptree = save_sgf_dumptree;
  count_variations = save_count_variations;
  verbose = save_verbose;
}


/* Helper function for retrieving the aa_status for a string. We can't
 * reliably do this simply by looking up aa_status[pos] since this is
 * only valid at vertices which were non-empty at the start of the
 * reading. For later added stones, we need to find their aa_status by
 * locating a part of the string which was a worm at the beginning of
 * the reading.
 */

static int
get_aa_status(int pos)
{
  int stones[MAX_BOARD * MAX_BOARD];
  int num_stones;
  int k;

  if (aa_status[pos] != UNKNOWN)
    return aa_status[pos];

  num_stones = findstones(pos, MAX_BOARD * MAX_BOARD, stones);
  for (k = 0; k < num_stones; k++)
    if (aa_status[stones[k]] != UNKNOWN)
      return aa_status[stones[k]];

  return UNKNOWN;
}


/* Helper function to examine whether a stone is part of a vital
 * string. Since the vital_string[] array was generated at stackp == 0
 * new stones may have appeared on the board.
 */
static int
is_vital_string(int str)
{
  int stones[MAX_BOARD * MAX_BOARD];
  int n = findstones(str, MAX_BOARD * MAX_BOARD, stones);
  int k;
  for (k = 0; k < n; k++)
    if (vital_string[stones[k]])
      return 1;

  return 0;
}


/* Helper function for atari_atari. Here worms is the number of
 * opponent worms involved in the combination, and (last_friendly) is
 * the location of the last friendly move played. Moves marked
 * with the forbidden array are not tried. If no move is found,
 * the values of *attack_point and *defense_point are not changed.
 *
 * If not NULL, *attack_point is left pointing to the location of the
 * attacking move, and *defense_point points to a move defending the
 * combination. In rare cases a defensive move might not be found. If
 * a non-static function calling do_atari_atari gets a return value of
 * 1 but NO_MOVE as the defense point, this should be treated as
 * equivalent to a return value of 0.
 *
 * The goal array limits where we are allowed to consider threats.
 * Only strings for which goal is set to 1 may be threatened. If goal
 * is NULL, anything may be attacked. Thus goal is typically NULL when
 * do_atari_atari() is called from an external function. After the
 * first threat has been made, the goal array is set to one in a
 * neighborhood of the move and after subsequent threats it is
 * expanded with neighborhoods of those moves. The details of this can
 * be found in the function update_aa_goal().
 */

static int
do_atari_atari(int color, int *attack_point, int *defense_point,
	       int last_friendly, int save_verbose, int minsize,
	       char goal[BOARDMAX])
{
  int other = OTHER_COLOR(color);
  int k;
  struct aa_move attacks[AA_MAX_MOVES];
  int num_defense_moves;
  int defense_moves[AA_MAX_MOVES];
  int pos;
  SGFTree *save_sgf_dumptree;
  int save_count_variations;
  
  if (debug & DEBUG_ATARI_ATARI) {
    gprintf("%odo_atari_atari: ");
    dump_stack();
    gprintf("%oforbidden moves: ");
    for (pos = BOARDMIN; pos < BOARDMAX; pos++)
      if (ON_BOARD(pos) && forbidden[pos])
	gprintf("%o%1m ", pos);
    gprintf("\n");
  }

  /* First look for strings adjacent to the last friendly move played
   * (or to another stone in the same string) which can be
   * unexpectedly attacked.  If so, the combination attack
   * has succeeded.
   */
  if (last_friendly != NO_MOVE) {
    int retval;
    save_sgf_dumptree = sgf_dumptree;
    save_count_variations = count_variations;
    sgf_dumptree = NULL;
    count_variations = 0;
    retval = atari_atari_succeeded(color, attack_point, defense_point,
				   last_friendly, save_verbose, minsize);
    sgf_dumptree = save_sgf_dumptree;
    count_variations = save_count_variations;
    if (retval != 0) {
      if (sgf_dumptree)
	/* FIXME: Better message. */
	sgftreeAddComment(sgf_dumptree, NULL, "attack found");
      return retval;
    }
  }

  if (stackp > aa_depth)
    return 0;

  /* Find attack moves. These are typically ataris but may also be
   * more general.
   */
  save_sgf_dumptree = sgf_dumptree;
  save_count_variations = count_variations;
  sgf_dumptree = NULL;
  count_variations = 0;
  atari_atari_find_attack_moves(color, minsize, attacks, goal);
  sgf_dumptree = save_sgf_dumptree;
  count_variations = save_count_variations;

  /* Try the attacking moves and let the opponent defend. Then call
   * ourselves recursively.
   */
  for (k = 0; attacks[k].move != NO_MOVE; k++) {
    int aa_val;
    int str = attacks[k].target[0];
    int apos = attacks[k].move;
    int bpos;
    int r;
    
    if (!trymove(apos, color, "do_atari_atari-A", str, EMPTY, NO_MOVE))
      continue;
	
    if (!IS_STONE(board[str])) {
      /* Error situation. This could be caused by a wrong matcher status. */
      if (save_verbose || (debug & DEBUG_ATARI_ATARI))
	gprintf("%oError condition found by atari_atari\n");
      popgo();
      return 0;
    }

    /* Try to defend the stone (str) which is threatened. */
    aa_val = get_aa_value(str);

    /* Pick up defense moves. */
    save_sgf_dumptree = sgf_dumptree;
    save_count_variations = count_variations;
    sgf_dumptree = NULL;
    count_variations = 0;
    num_defense_moves = atari_atari_find_defense_moves(attacks[k].target,
						       defense_moves);
    sgf_dumptree = save_sgf_dumptree;
    count_variations = save_count_variations;
    
    for (r = 0; r < num_defense_moves; r++) {
      bpos = defense_moves[r];

      if (trymove(bpos, other, "do_atari_atari-B", str, EMPTY, NO_MOVE)) {
	int new_aa_val;
	char new_goal[BOARDMAX];
	/* These moves may have been irrelevant for later
	 * reading, so in order to avoid horizon problems, we
	 * need to temporarily increase the depth values.
	 */
	modify_depth_values(2);
	update_aa_goal(goal, new_goal, apos, color);
	new_aa_val = do_atari_atari(color, NULL, defense_point,
				    apos, save_verbose, minsize,
				    new_goal);
	modify_depth_values(-2);
	if (new_aa_val < aa_val)
	  aa_val = new_aa_val;
	popgo();
      }

      /* Defense successful, no need to try any further. */
      if (aa_val == 0)
	break;
    }

    /* Undo the attacking move. */
    popgo();

    if (aa_val == 0)
      continue;

    /* atari_atari successful */
    if (num_defense_moves == 0) {
      if (save_verbose || (debug & DEBUG_ATARI_ATARI)) {
	gprintf("%oThe worm %1m can be attacked at %1m after ", str, apos);
	dump_stack();
      }
      if (sgf_dumptree)
	/* FIXME: Better message. */
	sgftreeAddComment(sgf_dumptree, NULL, "attack found");
    }

    if (attack_point)
      *attack_point = apos;

    if (defense_point) {
      save_sgf_dumptree = sgf_dumptree;
      save_count_variations = count_variations;
      sgf_dumptree = NULL;
      count_variations = 0;

      if (!find_defense(str, defense_point))
	*defense_point = NO_MOVE;

      /* If no defense point is known and (apos) is a safe
       * move for other, it probably defends the combination.
       */
      if ((*defense_point == NO_MOVE || !safe_move(*defense_point, other))
	  && safe_move(apos, other))
	*defense_point = apos;

      sgf_dumptree = save_sgf_dumptree;
      count_variations = save_count_variations;
    }
    
    DEBUG(DEBUG_ATARI_ATARI, "%oreturn value:%d (%1m)\n", aa_val, str);
    return aa_val;
  }
    
  /* No atari_atari attack. */
  return 0;
}


static int
atari_atari_succeeded(int color, int *attack_point, int *defense_point,
		      int last_friendly, int save_verbose, int minsize)
{
  int m, n;
  int other = OTHER_COLOR(color);

  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      int ii = POS(m, n);
      int aa;

      if (board[ii] != other)
       continue;

      if (ii != find_origin(ii))
       continue;

      if (minsize > 0
	  && get_aa_value(ii) < minsize
	  && !is_vital_string(ii))
       continue;

      if (get_aa_status(ii) != ALIVE)
       continue;

      if (board[last_friendly] != EMPTY
	  && !adjacent_strings(last_friendly, ii))
       continue;

      if (board[last_friendly] == EMPTY
	  && !liberty_of_string(last_friendly, ii))
       continue;

      if (debug & DEBUG_ATARI_ATARI)
	gprintf("Considering attack of %1m. depth = %d.\n", ii, depth);

      if (attack(ii, &aa) && !forbidden[aa]) {
	if (save_verbose || (debug & DEBUG_ATARI_ATARI)) {
	  gprintf("%oThe worm %1m can be attacked at %1m after ", ii, aa);
	  dump_stack();
	}
	if (attack_point)
	  *attack_point = aa;

	/* We look for a move defending the combination.
	 * Normally this is found by find_defense but failing
	 * that, if the attacking move is a safe move for color,
	 * it probably defends.
	 */
	if (defense_point) {
	  if (!find_defense(ii, defense_point)) {
	    if (safe_move(aa, other))
	      *defense_point = aa;
	    else
	      *defense_point = NO_MOVE;
	  }
	}
	
	DEBUG(DEBUG_ATARI_ATARI, "%oreturn value:%d (%1m)\n",
	      get_aa_value(ii), ii);
	return get_aa_value(ii);
      }
    }
  
  return 0;
}

#define MAX_THREAT_MOVES  MAX_TACTICAL_POINTS

static void
atari_atari_find_attack_moves(int color, int minsize,
			      struct aa_move attacks[AA_MAX_MOVES],
			      char goal[BOARDMAX])
{
  int k;
  int r;

  aa_init_moves(attacks);

  atari_atari_attack_patterns(color, minsize, attacks, goal);

  /* Sort the attack moves. */
  aa_sort_moves(attacks);
  
  if (debug & DEBUG_ATARI_ATARI) {
    gprintf("Attack moves:");
    for (k = 0; k < AA_MAX_MOVES && attacks[k].move != NO_MOVE; k++) {
      gprintf("%o %1m(", attacks[k].move);
      for (r = 0; r < AA_MAX_TARGETS_PER_MOVE; r++) {
	if (attacks[k].target[r] == NO_MOVE)
	  break;
	gprintf("%o%s%1m", r == 0 ? "" : ",", attacks[k].target[r]);
      }
      gprintf("%o)");
    }
    gprintf("%o\n");
  }
}

/* FIXME: Move these to a struct and pass to callback through the
 * *data parameter.
 */
static int current_minsize;
static struct aa_move *current_attacks;
static int conditional_attack_point[BOARDMAX];

static void
atari_atari_attack_patterns(int color, int minsize,
			    struct aa_move attacks[AA_MAX_MOVES],
			    char goal[BOARDMAX])
{
  char revised_goal[BOARDMAX];
  current_minsize = minsize;
  current_attacks = attacks;
  memset(conditional_attack_point, 0, sizeof(conditional_attack_point));

  /* If goal is NULL and there are forbidden moves we need to compute
   * a new goal around the forbidden moves.
   */
  if (goal == NULL && update_aa_goal(goal, revised_goal, NO_MOVE, color))
    goal = revised_goal;

#if 0
  if (goal != NULL) {
    int pos;
    gprintf("goal:");
    for (pos = BOARDMIN; pos < BOARDMAX; pos++)
      if (ON_BOARD(pos) && goal[pos])
	gprintf("%o %1m", pos);
    gprintf("%o\n");
  }
#endif
  
  matchpat(atari_atari_attack_callback, color, &aa_attackpat_db, NULL, goal);
}

/* Try to attack every X string in the pattern, whether there is an attack
 * before or not. Only exclude already known attacking moves.
 */
static void
atari_atari_attack_callback(int m, int n, int color,
			    struct pattern *pattern, int ll, void *data)
{
  int move;
  int k;
  UNUSED(data);

  move = AFFINE_TRANSFORM(pattern->movei, pattern->movej, ll, m, n);

  if (forbidden[move])
    return;
  
  /* If the pattern has a constraint, call the autohelper to see
   * if the pattern must be rejected.
   */
  if (pattern->autohelper_flag & HAVE_CONSTRAINT)
    if (!pattern->autohelper(pattern, ll, move, color, 0))
      return;

  /* If the pattern has a helper, call it to see if the pattern must
   * be rejected.
   */
  if (pattern->helper)
    if (!pattern->helper(pattern, ll, move, color))
      return;

  /* Loop through pattern elements in search of X strings to
   * threaten to attack.
   */
  for (k = 0; k < pattern->patlen; ++k) { /* match each point */
    if (pattern->patn[k].att == ATT_X) {
      /* transform pattern real coordinate */
      int str = find_origin(AFFINE_TRANSFORM(pattern->patn[k].x,
					     pattern->patn[k].y, ll, m, n));

      if (current_minsize > 0
	  && get_aa_value(str) < current_minsize
	  && !is_vital_string(str))
	continue;

      if (aa_move_known(current_attacks, move, str))
	continue;

      if (get_aa_status(str) != ALIVE)
	continue;

      /* Usually we don't want to play self atari. However, if we
       * capture in snapback it's okay. For s class patterns we don't
       * have this requirement.
       */
      if (!(pattern->class & CLASS_s) && is_self_atari(move, color)) {
	if (countlib(str) > 2)
	  continue;

	if (!safe_move(move, color))
	  continue;
      }
      
      /*
       * Play (move) and see if there is an attack.
       */
      if (trymove(move, color, "attack_callback", str, EMPTY, NO_MOVE)) {
	int acode;
	int attack_point = NO_MOVE;

	if (!board[str])
	  acode = WIN;
	else
	  acode = attack(str, &attack_point);

	popgo();

	if (acode != 0) {
	  if ((pattern->class & CLASS_c)
	      && !aa_move_known(current_attacks, move, NO_MOVE)) {
	    /* Conditional pattern. */
	    DEBUG(DEBUG_ATARI_ATARI,
		  "aa_attack pattern %s+%d (conditional) found threat on %1m at %1m with code %d\n",
		  pattern->name, ll, str, move, acode);
	    if (conditional_attack_point[move] == NO_MOVE)
	      conditional_attack_point[move] = str;
	    else if (conditional_attack_point[move] != str) {
	      aa_add_move(current_attacks, move,
			  conditional_attack_point[move]);
	      aa_add_move(current_attacks, move, str);
	    }
	  }
	  else {
	    aa_add_move(current_attacks, move, str);
	    DEBUG(DEBUG_ATARI_ATARI,
		  "aa_attack pattern %s+%d found threat on %1m at %1m with code %d\n",
		  pattern->name, ll, str, move, acode);
	  }
	}
      }
    }
  }
}


static int
atari_atari_find_defense_moves(int targets[AA_MAX_TARGETS_PER_MOVE],
			       int moves[AA_MAX_MOVES])
{
  int num_moves = 0;
  int move;
  int k;
  int liberties;
  int libs[4];
  int neighbors;
  int adjs[MAXCHAIN];
  int mx[BOARDMAX];
  int r, s;

  memset(mx, 0, sizeof(mx));

  for (r = 0; r < AA_MAX_TARGETS_PER_MOVE && targets[r] != NO_MOVE; r++) {
    int str = targets[r];

    /* If the attack move happened to remove (str), there's no defense. */
    if (board[str] == EMPTY)
      continue;
    
    /* Because we know (str) is threatened there is an
     * attack and we can be sure find_defense() will give a
     * useful defense point if it returns non-zero. Usually we
     * would need to call attack_and_defend() to be certain of
     * this.
     */
    if (!find_defense(str, &move))
      continue;
    moves[num_moves++] = move;
    if (num_moves == AA_MAX_MOVES)
      return num_moves;
    mx[move] = 1;
    
    /* Consider all moves to attack a neighbor or to play on a liberty. */
    liberties = findlib(str, 4, libs);
    for (k = 0; k < liberties; k++) {
      if (!mx[libs[k]]
	  && trymove(libs[k], board[str], "aa_defend-A", str,
		     EMPTY, NO_MOVE)) {
	if (attack(str, NULL) == 0) {
	  moves[num_moves++] = libs[k];
	  mx[libs[k]] = 1;
	}
	popgo();
	if (num_moves == AA_MAX_MOVES)
	  return num_moves;
      }
    }
    
    neighbors = chainlinks(str, adjs);
    for (k = 0; k < neighbors; k++) {
      int attack_point;
      if (attack(adjs[k], &attack_point) == WIN
	  && !mx[attack_point]) {
	moves[num_moves++] = attack_point;
	if (num_moves == AA_MAX_MOVES)
	  return num_moves;
	mx[attack_point] = 1;
      }

      /* If the neighbor has at most three liberties, try all of them
       * for defense, except self-ataris.
       */
      liberties = findlib(adjs[k], 3, libs);
      if (liberties <= 3) {
	for (s = 0; s < liberties; s++) {
	  if (!mx[libs[s]]
	      && !is_self_atari(libs[s], board[str])
	      && trymove(libs[s], board[str], "aa_defend-B", str,
			 EMPTY, NO_MOVE)) {
	    if (attack(str, NULL) == 0) {
	      moves[num_moves++] = libs[s];
	      mx[libs[s]] = 1;
	    }
	    popgo();
	    if (num_moves == AA_MAX_MOVES)
	      return num_moves;
	  }
	}
      }
    }
    
    if (debug & DEBUG_ATARI_ATARI) {
      gprintf("Defense moves for %1m:", str);
      for (k = 0; k < num_moves; k++)
	gprintf("%o %1m", moves[k]);
      gprintf("%o\n");
    }
  }
  
  return num_moves;
}


/* Try to guess the value of the strings. We do this by adding twice
 * the number of stones to the number of liberties and second order
 * liberties within the moyo around the string. This is of course
 * quite crude since it doesn't take into account any strategic
 * effects, e.g. a string being cutting stones. 
 */
static void
compute_aa_values(int color)
{
  int other = OTHER_COLOR(color);
  int pos;
  int value;
  int liberties;
  int libs[MAXLIBS];
  int mx[BOARDMAX];
  int r, k;

  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (board[pos] != other
	|| pos != find_origin(pos)
	|| aa_status[pos] != ALIVE) {
      aa_values[pos] = 0;
      continue;
    }
      
    memset(mx, 0, sizeof(mx));
    liberties = findlib(pos, MAXLIBS, libs);
    value = 2 * countstones(pos);

    for (r = 0; r < liberties; r++) {
      if (!mx[libs[r]] && (influence_moyo_color(libs[r]) == other
			   || influence_moyo_color_opposite(libs[r]))) {
	mx[libs[r]] = 1;
	value++;
      }
      for (k = 0; k < 4; k++) {
	int librd = libs[r] + delta[k];
	if (!ON_BOARD1(librd) || mx[librd])
	  continue;
	mx[librd] = 1;
	if (board[librd] == EMPTY
	    && (influence_moyo_color(librd) == other
		|| (influence_moyo_color_opposite(librd) == other)))
	  value++;
      }
    }

    aa_values[pos] = value;
    if (1)
      DEBUG(DEBUG_ATARI_ATARI, "aa_value for %1m = %d\n", pos, value);
  }
}

/* The aa_value for a string is the sum of the aa_values for all
 * included strings in the original position. This will systematically
 * overvalue strings which consist of multiple original strings, but
 * this is okay since the defender very rarely should defend a string
 * first and then sacrifice it later.
 */
static int
get_aa_value(int str)
{
  int stones[MAX_BOARD * MAX_BOARD];
  int k;
  int num_stones = findstones(str, MAX_BOARD * MAX_BOARD, stones);
  int value = 0;
  
  for (k = 0; k < num_stones; k++)
    value += aa_values[stones[k]];

  return value;
}


/* update_aa_goal(goal, new_goal, apos, color) extends the goal array
 * with vertices in a neighborhood of apos. The algorithm is that
 * starting at apos, a distance measure is computed to nearby
 * vertices. The distance increases with one for each step through
 * empty vertices and by a liberty depending number when passing
 * through strings of the attacked color. Strings with 3 or fewer
 * liberties are free to pass through while strings with more
 * liberties cost (libs - 3) to pass through. Stones with a distance
 * of 5 or less are included in the goal.
 *
 * Additionally neighborhoods of the moves in the forbidden array are
 * included in the goal, to make it possible to limit the goal to a
 * specific area from the beginning. This is needed when trying to
 * decide which moves are relevant to the combination.
 */

#define ENQUEUE(pos, dist) \
    do { \
      if ((dist) <= MAX_AA_DIST) { \
        if (dists[pos] == 0) { \
          queue[queue_end++] = (pos); \
          dists[pos] = (dist); \
        } \
        else if (dists[pos] < (dist)) \
          dists[pos] = (dist); \
      } \
    } while (0);

static int
update_aa_goal(char goal[BOARDMAX], char new_goal[BOARDMAX], int apos,
	       int color)
{
  int other = OTHER_COLOR(color);
  int dists[BOARDMAX];
  int queue[MAX_BOARD * MAX_BOARD];
  int queue_end = 0;
  int k, r, s;
  int pos;
  
  if (goal == NULL)
    memset(new_goal, 0, BOARDMAX);
  else
    memcpy(new_goal, goal, BOARDMAX);

  memset(dists, 0, sizeof(dists));

  if (apos != NO_MOVE) {
    dists[apos] = 1;
    queue[queue_end++] = apos;
  }

  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (ON_BOARD(pos) && forbidden[pos]) {
      dists[pos] = 1;
      queue[queue_end++] = pos;
    }
  }

  if (queue_end == 0)
    return 0;
  
  for (r = 0; r < queue_end; r++) {
    int smallest_dist = MAX_BOARD * MAX_BOARD;
    int best_index = -1;

    gg_assert(queue_end < MAX_BOARD * MAX_BOARD);
    
    for (k = r; k < queue_end; k++) {
      if (dists[queue[k]] < smallest_dist) {
	smallest_dist = dists[queue[k]];
	best_index = k;
      }
    }
    
    if (best_index != r) {
      int tmp = queue[r];
      queue[r] = queue[best_index];
      queue[best_index] = tmp;
    }
    
    pos = queue[r];
    if (board[pos] == other)
      new_goal[pos] = 1;

    /* FIXME: We shouldn't let dead opponent stones stop the
     * propagation of distance.
     *
     * As a partial fix we include pos == apos in a test below.
     */
    for (k = 0; k < 4; k++) {
      int pos2 = pos + delta[k];
      if ((board[pos] == other || pos == apos) && board[pos2] == EMPTY) {
        ENQUEUE(pos2, dists[pos] + 1);
      }
      else if (board[pos] != other && board[pos2] == other) {
	int stones[MAX_BOARD * MAX_BOARD];
	int size = findstones(pos2, MAX_BOARD * MAX_BOARD, stones);
	int libs = countlib(pos2);
	int deltadist = libs - 3;
	if (deltadist < 0)
	  deltadist = 0;
	for (s = 0; s < size; s++)
	  ENQUEUE(stones[s], dists[pos] + deltadist);
      }
    }
  }
  return 1;
}

/* Initialize an array with atari_atari attacks. The convention is that
 * the array ends when a NO_MOVE is encountered in the move field.
 */
static void
aa_init_moves(struct aa_move attacks[AA_MAX_MOVES])
{
  attacks[0].move = NO_MOVE;
}


/* Add an atari_atari attack move to a struct aa_move array. If the
 * move already is included in the array, we check whether the target
 * also is known for that move and add it if not.
 */
static void
aa_add_move(struct aa_move attacks[AA_MAX_MOVES], int move, int target)
{
  int k;
  int r;

  for (k = 0; k < AA_MAX_MOVES; k++)
    if (attacks[k].move == move || attacks[k].move == NO_MOVE)
      break;

  /* If the array is full, give up. */
  if (k == AA_MAX_MOVES)
    return;

  target = find_origin(target);

  /* New move. */
  if (attacks[k].move == NO_MOVE) {
    attacks[k].move = move;
    attacks[k].target[0] = target;
    if (AA_MAX_TARGETS_PER_MOVE > 0)
      attacks[k].target[1] = NO_MOVE;

    if (k < AA_MAX_MOVES - 1)
      attacks[k+1].move = NO_MOVE;

    return;
  }

  /* Known move, maybe new target. */
  for (r = 0; r < AA_MAX_TARGETS_PER_MOVE; r++)
    if (attacks[k].target[r] == target || attacks[k].target[r] == NO_MOVE)
      break;

  /* No place for more targets. */
  if (r == AA_MAX_TARGETS_PER_MOVE)
    return;

  /* Target known. */
  if (attacks[k].target[r] == target)
    return;

  /* Add target. */
  attacks[k].target[r] = target;
  if (r < AA_MAX_TARGETS_PER_MOVE - 1)
    attacks[k].target[r + 1] = NO_MOVE;
}

/* Check whether an atari_atari attack move is included in an struct
 * aa_move array. If target is not NO_MOVE, we also require that the
 * target is known for the move.
 */
static int
aa_move_known(struct aa_move attacks[AA_MAX_MOVES], int move, int target)
{
  int k;
  int r;

  for (k = 0; k < AA_MAX_MOVES; k++)
    if (attacks[k].move == move || attacks[k].move == NO_MOVE)
      break;

  /* If the array is full, give up and claim the move to be known. */
  if (k == AA_MAX_MOVES)
    return 1;

  /* Unknown move. */
  if (attacks[k].move == NO_MOVE)
    return 0;

  /* Move known, but how about the target?
   * If no target specified, just return 1.
   */
  if (target == NO_MOVE)
    return 1;

  target = find_origin(target);
  for (r = 0; r < AA_MAX_TARGETS_PER_MOVE; r++)
    if (attacks[k].target[r] == target || attacks[k].target[r] == NO_MOVE)
      break;

  /* No place for more targets. Give up and claim the target to be known. */
  if (r == AA_MAX_TARGETS_PER_MOVE)
    return 1;

  /* Target known. */
  if (attacks[k].target[r] == target)
    return 1;

  /* Unknown target. */
  return 0;
}


/* Auxiliary function for aa_sort_moves(). */
static int
target_comp_func(const void *a, const void *b)
{
  int asize = get_aa_value(*((const int *) a));
  int bsize = get_aa_value(*((const int *) b));
  return asize - bsize;
}


/* Auxiliary function for aa_sort_moves(). */
static int
move_comp_func(const void *a, const void *b)
{
  const struct aa_move *aa = a;
  const struct aa_move *bb = b;
  int asize = get_aa_value(aa->target[0]);
  int bsize = get_aa_value(bb->target[0]);
  return asize - bsize;
}

/* Sort the attack moves. For each move the targets are sorted in
 * decreasing size. Then the moves are sorted with increasing size
 * of their first target.
 */
static void
aa_sort_moves(struct aa_move attacks[AA_MAX_MOVES])
{
  int k;
  int r;
  int number_of_attacks;
  int number_of_targets;

  for (k = 0; k < AA_MAX_MOVES && attacks[k].move != NO_MOVE; k++) {
    for (r = 0; r < AA_MAX_TARGETS_PER_MOVE; r++)
      if (attacks[k].target[r] == NO_MOVE)
	break;
    number_of_targets = r;
    gg_sort(attacks[k].target, number_of_targets,
	    sizeof(attacks[k].target[0]), target_comp_func);
  }
  number_of_attacks = k;
  gg_sort(attacks, number_of_attacks, sizeof(attacks[0]), move_comp_func);
}


#if 0

/* Returns true if a move by (color) at (pos) is atari on something.
 * Currently unused.
 */

static int
is_atari(int pos, int color)
{
  int other = OTHER_COLOR(color);

  if (!is_legal(pos, color))
    return 0;
  
  if (board[SOUTH(pos)] == other 
      && countlib(SOUTH(pos)) == 2)
    return 1;
  
  if (board[WEST(pos)] == other 
      && countlib(WEST(pos)) == 2)
    return 1;
  
  if (board[NORTH(pos)] == other 
      && countlib(NORTH(pos)) == 2)
    return 1;
  
  if (board[EAST(pos)] == other 
      && countlib(EAST(pos)) == 2)
    return 1;
  
  return 0;
}

#endif


/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* A "dragon" is a union of strings of the same color which will be
 * treated as a unit. The dragons are generated anew at each
 * move. If two strings are in the dragon, it is GNU Go's working
 * hypothesis that they will live or die together and are
 * effectively connected.
 *
 *                    _____/|        (! !)
 *                   / ____/|        /@ @)
 *                  / /   __        //  +--oo
 *                 | /   |   >>    /<  _v---}
 *                 | |   UUU\\\     / / \\
 *                 | |   __ _\\\    \ \  U
 *                 | |  /  V  \\-->  \ \ 
 *                 | <_/           \_/  }
 *                 |      __     ____  /
 *                  \    /  \___/   / /\
 *                  <  \<          < <\ \
 *                   ( )))         ( ))))) 
 */

/* #include <stdio.h> */
/* #include <stdlib.h> */
/* #include <string.h> */
/* #include <ctype.h> */

/* #include "gnugo.h" */
/* #include "liberty.h" */


static void initialize_supplementary_dragon_data(void);
static void find_neighbor_dragons(void);
static void add_adjacent_dragons(int a, int b);
static void add_adjacent_dragon(int a, int b);
static int dragon_invincible(int pos);
static int dragon_looks_inessential(int origin);
static int compute_dragon_status(int pos);
static void dragon_eye(int pos, struct eye_data[BOARDMAX]);
static int compute_escape(int pos, int dragon_status_known);
static void compute_surrounding_moyo_sizes(int opposite);

static int dragon2_initialized;
static int lively_white_dragons;
static int lively_black_dragons;

/* Alternative for DRAGON2 macro with asserts. */
struct dragon_data2 *
dragon2_func(int pos)
{
  ASSERT1(ON_BOARD1(pos)
          && dragon[pos].id >= 0 
          && dragon[pos].id < number_of_dragons, pos);
  return &dragon2[dragon[pos].id];
}

/* This basic function finds all dragons and collects some basic information
 * about them in the dragon array.
 *
 * color is the player in turn to move. This does in no way affect the
 * information collected about the dragons, but it does affect what
 * information is passed on to the move generation code. If
 * color == EMPTY no information at all is passed on to the move generation.
 */

void 
make_dragons(int color, int stop_before_owl, int save_verbose)
{
  int str;
  int i, j;
  int dr;
  int d;
  int k;
  int last_move;

  start_timer(2);
  dragon2_initialized = 0;
  initialize_dragon_data();
  time_report(2, "  time to initialize dragons", NO_MOVE, 1.0);

  make_domains(black_eye, white_eye, 0);
  time_report(2, "  time to make domains", NO_MOVE, 1.0);

  /* Find explicit connections patterns in database and amalgamate
   * involved dragons.
   */
  find_connections();
  time_report(2, "  time to find connections", NO_MOVE, 1.0);
  
  /* Amalgamate dragons sharing an eyespace (not ko). At the same time
   * we decide to which dragon an eyespace belongs. Ko eyespaces
   * (typically false eyes but sometimes halfeyes) get assigned to an
   * arbitrary neighbor that is not the ko stone.
   */

  for (str = BOARDMIN; str < BOARDMAX; str++)
    if (ON_BOARD(str)) {

      if (black_eye[str].color == BLACK_BORDER
	  && black_eye[str].origin == str) {
	if (!is_ko_point(str)
	    || black_eye[str].esize > 1) /* Only exclude living kos. */
	  dragon_eye(str, black_eye);
	else {
	  for (k = 0; k < 4; k++)
	    if (ON_BOARD(str + delta[k]) && !is_ko_point(str + delta[k])) {
	      black_eye[str].dragon = dragon[str + delta[k]].origin;
	      break;
	    }
	}
      }
	  
      if (white_eye[str].color == WHITE_BORDER
	  && white_eye[str].origin == str) {
	if (!is_ko_point(str)
	    || white_eye[str].esize > 1) /* Only exclude living kos. */
	  dragon_eye(str, white_eye);
	else {
	  for (k = 0; k < 4; k++)
	    if (ON_BOARD(str + delta[k]) && !is_ko_point(str + delta[k])) {
	      white_eye[str].dragon = dragon[str + delta[k]].origin;
	      break;
	    }
	}
      }
    }
  time_report(2, "  time to amalgamate dragons", NO_MOVE, 1.0);
  
  /* At this time, all dragons have been finalized and we can
   * initialize the dragon2[] array. After that we can no longer allow
   * amalgamation of dragons.
   */
  initialize_supplementary_dragon_data();
  time_report(2, "  time to initialize dragon2", NO_MOVE, 1.0);
  
  /* Find adjacent worms which can be easily captured: */
  
  for (str = BOARDMIN; str < BOARDMAX; str++)
    if (ON_BOARD(str)) {
      int food;

      if (worm[str].origin != str
	  || board[str] == EMPTY
	  || worm[str].lunch == NO_MOVE)
	continue;

      food = worm[str].lunch;

      /* In contrast to worm lunches, a dragon lunch must also be
       * able to defend itself. 
       */
      if (worm[food].defend_codes[0] == 0)
	continue;

      /* Tell the move generation code about the lunch. */
      if (IS_STONE(color))
	add_lunch(str, food);
	
      /* If several lunches are found, we pick the juiciest.
       * First maximize cutstone, then minimize liberties.
       */
      {
	int origin = dragon[str].origin;
	int lunch = DRAGON2(origin).lunch;

	if (lunch == NO_MOVE
	    || worm[food].cutstone > worm[lunch].cutstone
	    || (worm[food].cutstone == worm[lunch].cutstone
		&& (worm[food].liberties < worm[lunch].liberties))) {
	  DRAGON2(origin).lunch = worm[food].origin;
	  TRACE("at %1m setting %1m.lunch to %1m (cutstone=%d)\n",
		str, origin,
		worm[food].origin, worm[food].cutstone);
	}
      }
    }
  time_report(2, "  time to find lunches", NO_MOVE, 1.0);

  /* In case origins of dragons got moved, put the dragons of eyes aright. */
  for (str = BOARDMIN; str < BOARDMAX; str++) {
    if (!ON_BOARD(str))
      continue;
    
    if (black_eye[str].dragon != NO_MOVE) {
      dr = dragon[black_eye[str].dragon].origin;
      black_eye[str].dragon = dr;
    }
    
    if (white_eye[str].dragon != NO_MOVE) {
      dr = dragon[white_eye[str].dragon].origin;
      white_eye[str].dragon = dr;
    }
  }
  time_report(2, "  time to fix origins", NO_MOVE, 1.0);
  
  /* Find topological half eyes and false eyes by analyzing the
   * diagonal intersections, as described in the Texinfo
   * documentation (Eyes/Eye Topology).
   *
   * FIXME: Consolidate this piece of code with the very similar one
   * in owl_determine_life().
   */

  for (str = BOARDMIN; str < BOARDMAX; str++)
    if (ON_BOARD(str)) {
      float sum;

      if (black_eye[str].color == BLACK_BORDER
	  && (!black_eye[str].marginal || life)
	  && black_eye[str].neighbors <= 1
	  && black_eye[str].dragon != NO_MOVE) {
	sum = topological_eye(str, BLACK, black_eye, white_eye, half_eye);
	if (sum >= 4.0) {
	  half_eye[str].type = FALSE_EYE;
	  if (black_eye[str].esize == 1
	      || is_legal(str, WHITE)
	      || board[str] == WHITE)
	    add_false_eye(str, black_eye, half_eye);
	}
	else if (sum > 2.0)
	  half_eye[str].type = HALF_EYE;
      }
      
      if (white_eye[str].color == WHITE_BORDER
	  && (!white_eye[str].marginal || life)
	  && white_eye[str].neighbors <= 1
	  && white_eye[str].dragon != NO_MOVE) {
	sum = topological_eye(str, WHITE, black_eye, white_eye, half_eye);
	if (sum >= 4.0) {
	  half_eye[str].type = FALSE_EYE;
	  if (white_eye[str].esize == 1
	      || is_legal(str, BLACK)
	      || board[str] == BLACK)
	    add_false_eye(str, white_eye, half_eye);
	}
	else if (sum > 2.0)
	  half_eye[str].type = HALF_EYE;
      }
    }

  /* Pattern based modification of the eye shapes computed by
   * make_domains and halfeye analysis.
   */
  modify_eye_spaces();
  
  /* Compute the number of eyes, half eyes, etc. in an eye space. */
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      str = POS(i, j);

      if (black_eye[str].color == BLACK_BORDER
	  && black_eye[str].origin == str
	  && black_eye[str].dragon != NO_MOVE)
      {
	int max, min, attack_point, defense_point;

	compute_eyes(str, &max, &min, &attack_point, &defense_point, 
		     black_eye, half_eye, 1, color);
	DEBUG(DEBUG_EYES, "Black eyespace at %1m: min=%d, max=%d\n",
	      str, min, max);
	black_eye[str].maxeye = max;
	black_eye[str].mineye = min;
	black_eye[str].attack_point = attack_point;
	black_eye[str].defense_point = defense_point;
	propagate_eye(str, black_eye);
      }

      if (white_eye[str].color == WHITE_BORDER
	  && white_eye[str].origin == str
	  && white_eye[str].dragon != NO_MOVE)
      {
	int max, min, attack_point, defense_point;

	compute_eyes(str, &max, &min, &attack_point, &defense_point,
		     white_eye, half_eye, 1, color);
	DEBUG(DEBUG_EYES, "White eyespace at %1m: min=%d, max=%d\n",
	      str, min, max);
	white_eye[str].maxeye = max;
	white_eye[str].mineye = min;
	white_eye[str].attack_point = attack_point;
	white_eye[str].defense_point = defense_point;
	propagate_eye(str, white_eye);
      }
    }
  time_report(2, "  time to find eyes", NO_MOVE, 1.0);

  /* Now we compute the genus. */
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      str = POS(i, j);

      if (black_eye[str].color == BLACK_BORDER
	  && black_eye[str].dragon != NO_MOVE
	  && black_eye[str].origin == str)
      {
	dr = black_eye[str].dragon;

	gg_assert(board[dr] == BLACK);
	TRACE("eye at %1m found for dragon at %1m--augmenting genus\n",
	      str, dr);
	DRAGON2(dr).genus += (black_eye[str].mineye);
	DRAGON2(dr).heyes += (black_eye[str].maxeye - black_eye[str].mineye);
	if (black_eye[str].maxeye - black_eye[str].mineye > 0)
	  DRAGON2(dr).heye = black_eye[str].attack_point;
      }
      if ((white_eye[str].color == WHITE_BORDER) 
	  && (white_eye[str].dragon != NO_MOVE)
	  && (white_eye[str].origin == str)) 
      {
	dr = white_eye[str].dragon;

	gg_assert(board[dr] == WHITE);
	TRACE("eye at %1m found for dragon at %1m--augmenting genus\n", 
	      str, dr);
	DRAGON2(dr).genus += (white_eye[str].mineye);
	DRAGON2(dr).heyes += (white_eye[str].maxeye - white_eye[str].mineye);
	if (white_eye[str].maxeye - white_eye[str].mineye > 0) {
	  DRAGON2(dr).heye = white_eye[str].attack_point;
	}
      }
    }
  time_report(2, "  time to compute genus", NO_MOVE, 1.0);

  /* Compute the escape route measure. */
  for (str = BOARDMIN; str < BOARDMAX; str++)
    if (ON_BOARD(str)) {
      if (dragon[str].origin == str
	  && IS_STONE(board[str])) {
	DRAGON2(str).escape_route = compute_escape(str, 0);
      }
    }
  time_report(2, "  time to compute escape", NO_MOVE, 1.0);

  /* Update the segmentation of the initial influence before we
   * compute the surrounding moyo sizes. The reason for this is that
   * now the eyespace inhibition found by find_cuts() can be taken
   * into account.
   */
  resegment_initial_influence();
  time_report(2, "  resegment_initial_influence", NO_MOVE, 1.0);

  /* Compute the surrounding moyo sizes. */
  for (d = 0; d < number_of_dragons; d++) 
    dragon2[d].moyo = 2 * BOARDMAX;
  /* Set moyo sizes according to initial_influence. */
  compute_surrounding_moyo_sizes(0);
  /* Set moyo sizes according to initial_opposite_influence if
   * this yields smaller results.
   */
  compute_surrounding_moyo_sizes(1);
  time_report(2, "  time to compute moyo sizes", NO_MOVE, 1.0);
  
  /* Determine status: ALIVE, DEAD, CRITICAL or UNKNOWN */
  for (str = BOARDMIN; str < BOARDMAX; str++)
    if (ON_BOARD(str)) {
      if (dragon[str].origin == str && board[str]) {
	dragon[str].status = compute_dragon_status(str);
	sgffile_dragon_status(I(str), J(str), dragon[str].status);
      }
    }
  time_report(2, "  compute_dragon_status", NO_MOVE, 1.0);
  
  /* We must update the dragon status at every intersection before we
   * call the owl code. This updates all fields.
   */
  for (str = BOARDMIN; str < BOARDMAX; str++)
    if (ON_BOARD(str)) {
      struct dragon_data *dd = &(dragon[str]);
      
      dragon[str] = dragon[dd->origin];
    }
  
  find_neighbor_dragons();
  time_report(2, "  find_neighbor_dragons", NO_MOVE, 1.0);
  
  if (stop_before_owl)
    return;
  
  /* Determine life and death status of each dragon using the owl code
   * if necessary.
   */
  purge_persistent_owl_cache();
  for (str = BOARDMIN; str < BOARDMAX; str++)
    if (ON_BOARD(str)) {
      int attack_point = NO_MOVE;
      int defense_point = NO_MOVE;
      
      if (board[str] == EMPTY
	  || dragon[str].origin != str)
	continue;
      
      /* Some dragons can be ignored but be extra careful with big dragons. */
      if (DRAGON2(str).escape_route > 25
	  || DRAGON2(str).moyo > 20
	  || (DRAGON2(str).moyo > 10
	      && DRAGON2(str).moyo > dragon[str].size)) {
	dragon[str].owl_status = UNCHECKED;
	dragon[str].owl_attack_point  = NO_MOVE;
	dragon[str].owl_defense_point = NO_MOVE;
      }
      else {
	int acode = 0;
	int dcode = 0;
	start_timer(3);
	acode = owl_attack(str, &attack_point, 
			   &dragon[str].owl_attack_certain);
	if (acode != 0) {
	  dragon[str].owl_attack_point = attack_point;
	  dragon[str].owl_attack_code = acode;
	  if (attack_point != NO_MOVE) {
	    dcode = owl_defend(str, &defense_point,
			       &dragon[str].owl_defense_certain);
	    if (dcode != 0) {
	      if (defense_point != NO_MOVE) {
		dragon[str].owl_status = CRITICAL;
		dragon[str].owl_defense_point = defense_point;
		dragon[str].owl_defense_code = dcode;
	      }
	      else {
		/* Due to irregularities in the owl code, it may
		 * occasionally happen that a dragon is found to be
		 * attackable but also alive as it stands. In this case
		 * we still choose to say that the owl_status is
		 * CRITICAL, although we don't have any defense move to
		 * propose. Having the status right is important e.g.
		 * for connection moves to be properly valued.
		 */
		dragon[str].owl_status = CRITICAL;
		DEBUG(DEBUG_OWL_PERFORMANCE,
		      "Inconsistent owl attack and defense results for %1m.\n", 
		      str);
	      }
	    }
	  }
	  if (dcode == 0) {
	    dragon[str].owl_status = DEAD; 
	    dragon[str].owl_defense_point = NO_MOVE;
	    dragon[str].owl_defense_code = 0;
	  }
	}
	else {
	  if (!dragon[str].owl_attack_certain) {
	    dcode = owl_defend(str, &defense_point, 
			       &dragon[str].owl_defense_certain);
	    if (dcode != 0) {
	      /* If the result of owl_attack was not certain, we may
	       * still want the result of owl_defend */
	      dragon[str].owl_defense_point = defense_point;
	      dragon[str].owl_defense_code = dcode;
	    }
	  }
	  dragon[str].owl_status = ALIVE;
	  dragon[str].owl_attack_point = NO_MOVE;
	  dragon[str].owl_attack_code = 0;
	  
	  time_report(3, "    owl reading for dragon at ", str, 1.0);
	}
      }
    }
  time_report(2, "  owl reading", NO_MOVE, 1.0);
  
  /* Compute the status to be used by the matcher. We most trust the
   * owl status, if it is available.
   */
  for (str = BOARDMIN; str < BOARDMAX; str++)
    if (ON_BOARD(str)) {
      if (IS_STONE(board[str])) {
	if (dragon[str].owl_status != UNCHECKED)
	  dragon[str].matcher_status = dragon[str].owl_status;
	else if (dragon[str].status == DEAD 
		 || dragon[str].status == CRITICAL) {
	  /* If a dragon has sufficient escape potential or
	   * surrounding moyo to stop the owl code from being run, the
	   * matcher_status should be no worse than UNKNOWN,
	   * regardless what the static life and death analysis
	   * guesses.
	   */
	  dragon[str].matcher_status = UNKNOWN;
	}
	else
	  dragon[str].matcher_status = dragon[str].status;
      }
    }
  time_report(2, "  compute matcher status", NO_MOVE, 1.0);

  /* The dragon data is now correct at the origin of each dragon but
   * we need to copy it to every vertex.  
   */
  for (str = BOARDMIN; str < BOARDMAX; str++)
    if (ON_BOARD(str)) {
      struct dragon_data *dd = &(dragon[str]);
      dragon[str] = dragon[dd->origin];
    }

  /* If the opponent's last move is a dead dragon, this is
   * called a *thrashing dragon*. We must be careful because
   * the opponent may be trying to trick us, so even though
   * GNU Go thinks the stone is dead, we should consider
   * attacking it, particularly if we are ahead.
   */

  last_move = get_last_move();
  if (last_move != NO_MOVE
      && dragon[last_move].matcher_status == DEAD) {
    thrashing_dragon = dragon[last_move].origin;
    if (save_verbose)
      gprintf("thrashing dragon found at %1m\n", thrashing_dragon);
  }
  else
    thrashing_dragon = 0;

  /* Owl threats. */
  for (str = BOARDMIN; str < BOARDMAX; str++)
    if (ON_BOARD(str) 
	&& board[str] != EMPTY 
	&& dragon[str].origin == str) {
      /* Some dragons can be ignored but be extra careful with big dragons. */
      if (DRAGON2(str).escape_route > 25
	  || DRAGON2(str).moyo > 20
	  || (DRAGON2(str).moyo > 10
	      && DRAGON2(str).moyo > dragon[str].size)) {
	dragon[str].owl_threat_status = UNCHECKED;
	dragon[str].owl_second_attack_point  = NO_MOVE;
	dragon[str].owl_second_defense_point = NO_MOVE;
      }
      else {
	int acode = dragon[str].owl_attack_code;
	int dcode = dragon[str].owl_defense_code;
	int defense_point, second_defense_point;
	
	if (level >= 8
	    && !disable_threat_computation
	    && (owl_threats 
		|| (thrashing_dragon
		    && is_same_dragon(str, thrashing_dragon)))) {
	  if (acode && !dcode && dragon[str].owl_attack_point != NO_MOVE) {
	    if (owl_threaten_defense(str, &defense_point,
				     &second_defense_point)) {
	      dragon[str].owl_threat_status = CAN_THREATEN_DEFENSE;
	      dragon[str].owl_defense_point = defense_point;
	      dragon[str].owl_second_defense_point = second_defense_point;
	    }
	    else
	      dragon[str].owl_threat_status = DEAD;;
	  }
	  else if (!acode) {
	    int attack_point, second_attack_point;
	    if (owl_threaten_attack(str, 
				    &attack_point, &second_attack_point)) {
	      dragon[str].owl_threat_status = CAN_THREATEN_ATTACK;
	      dragon[str].owl_attack_point = attack_point;
	      dragon[str].owl_second_attack_point = second_attack_point;
	    }
	    else
	      dragon[str].owl_threat_status = ALIVE;
	  }
	}
	time_report(3, "    owl threats for dragon at ", str, 1.0);
      }
    }
  
  /* Once again, the dragon data is now correct at the origin of each dragon
   * but we need to copy it to every vertex.  
   */
  for (str = BOARDMIN; str < BOARDMAX; str++)
    if (ON_BOARD(str)) {
      struct dragon_data *dd = &(dragon[str]);
      dragon[str] = dragon[dd->origin];
    }

  time_report(2, "  owl threats ", NO_MOVE, 1.0);
  
  /* Compute the safety value. */
  for (d = 0; d < number_of_dragons; d++) {
    int true_genus;
    int origin = dragon2[d].origin;

    true_genus = 2 * dragon2[d].genus + dragon2[d].heyes;
    if (dragon_looks_inessential(origin))
      dragon2[d].safety = INESSENTIAL;
    else if (dragon[origin].size == worm[origin].size
	     && worm[origin].attack_codes[0] != 0
	     && worm[origin].defend_codes[0] == 0)
      dragon2[d].safety = TACTICALLY_DEAD;
    else if (0) /* Seki is detected by the call to semeai() below. */
      dragon2[d].safety = ALIVE_IN_SEKI;
    else if (dragon[origin].owl_status == DEAD)
      dragon2[d].safety = DEAD;
    else if (dragon[origin].owl_status == CRITICAL)
      dragon2[d].safety = CRITICAL;
    else if (dragon[origin].owl_status == UNCHECKED
	     && true_genus < 4
	     && dragon2[d].moyo <= 10)
      dragon2[d].safety = WEAK;
    else if (dragon_invincible(origin))
      dragon2[d].safety = INVINCIBLE;
    else if (true_genus >= 6 || dragon2[d].moyo > 20)
      dragon2[d].safety = STRONGLY_ALIVE;
    else if ((2 * true_genus + dragon2[d].moyo
	      + 2 * (dragon2[d].lunch != NO_MOVE) < 8
	      && dragon2[d].escape_route < 10)
	     || (dragon[origin].owl_threat_status == CAN_THREATEN_ATTACK)) {
      if (DRAGON(d).owl_attack_certain)
	  dragon2[d].safety = WEAKLY_ALIVE;
      else
	  dragon2[d].safety = WEAK;
    }
    else
      dragon2[d].safety = ALIVE;
  }
  time_report(2, "  compute dragon safety", NO_MOVE, 1.0);

  /* Resolve semeais. This may revise the safety and status fields. */
  if (experimental_semeai && level > 7)
    new_semeai(color);
  else 
    semeai(color);

  time_report(2, "  semeai module", NO_MOVE, 1.0);

  /* The matcher_status is now correct at the origin of each dragon
   * but we need to copy it to every vertex.
   */
  for (str = BOARDMIN; str < BOARDMAX; str++)
    if (ON_BOARD(str))
      dragon[str].matcher_status = dragon[dragon[str].origin].matcher_status;

  /* Revise essentiality of critical worms. Specifically, a critical
   * worm which is adjacent to no enemy dragon with matcher_status
   * better than DEAD, is considered INESSENTIAL.
   */
  for (str = BOARDMIN; str < BOARDMAX; str++)
    if (ON_BOARD(str)) {
      if (is_worm_origin(str, str)
	  && worm[str].attack_codes[0] != 0
	  && worm[str].defend_codes[0] != 0
	  && !worm[str].inessential) {
	int adjs[MAXCHAIN];
	int neighbors;
	int r;
	int essential = 0;
	
	neighbors = chainlinks(str, adjs);
	for (r = 0; r < neighbors; r++)
	  if (dragon[adjs[r]].matcher_status != DEAD) {
	    essential = 1;
	    break;
	  }

	if (!essential) {
	  DEBUG(DEBUG_WORMS, "Worm %1m revised to be inessential.\n", str);
	  worm[str].inessential = 1;
	  propagate_worm(str);
	}
      }
    }
  time_report(2, "  revise inessentiality", NO_MOVE, 1.0);

  /* Count the non-dead dragons. */
  lively_white_dragons = 0;
  lively_black_dragons = 0;
  for (d = 0; d < number_of_dragons; d++)
    if (DRAGON(d).status != DEAD) {
      if (DRAGON(d).color == WHITE)
	lively_white_dragons++;
      else
	lively_black_dragons++;
    }
}


/* Initialize the dragon[] array. */

void
initialize_dragon_data(void)
{
  int str;
  for (str = BOARDMIN; str < BOARDMAX; str++)
    if (ON_BOARD(str)) {

      dragon[str].id                 = -1;
      dragon[str].size               = worm[str].size;
      dragon[str].effective_size     = worm[str].effective_size;
      dragon[str].color              = worm[str].color;
      dragon[str].origin             = worm[str].origin;
      dragon[str].owl_attack_point   = NO_MOVE;
      dragon[str].owl_attack_code    = 0;
      dragon[str].owl_attack_certain = 1;
      dragon[str].owl_defense_point  = NO_MOVE;
      dragon[str].owl_defense_code   = 0;
      dragon[str].owl_defense_certain = 1;
      dragon[str].owl_status         = UNCHECKED;
      dragon[str].status             = UNKNOWN;
      dragon[str].matcher_status     = UNKNOWN;
      dragon[str].owl_threat_status  = UNCHECKED;
      dragon[str].owl_second_attack_point  = NO_MOVE;
      dragon[str].owl_second_defense_point = NO_MOVE;
      half_eye[str].type             =  0;
      half_eye[str].value            =  10.0; /* Something big. */
      
      if (IS_STONE(board[str]) && worm[str].origin == str)
	DEBUG(DEBUG_DRAGONS, 
	      "Initializing dragon from worm at %1m, size %d\n", 
	      str, worm[str].size);
    }
}


/* Initialize the dragon2[] array. */
static void
initialize_supplementary_dragon_data(void)
{
  int str;
  int d;
  int origin;
  
  /* Give each dragon (caves excluded) an id number for indexing into
   * the dragon2 array. After this the DRAGON2 macro can be used.
   */
  number_of_dragons = 0;
  for (str = BOARDMIN; str < BOARDMAX; str++) {
    if (!ON_BOARD(str))
      continue;
    origin = dragon[str].origin;
    
    if (board[str] == EMPTY)
      continue;
    
    if (dragon[origin].id == -1)
      dragon[origin].id = number_of_dragons++;
    dragon[str].id = dragon[origin].id;
  }
  
  /* Now number_of_dragons contains the number of dragons and we can
   * allocate a dragon2 array of the appropriate size. First throw
   * away the old array.
   *
   * FIXME: As a future optimization we should only allocate a new
   *       array if the old one is too small.
   */
  if (dragon2 != NULL)
    free(dragon2);
  
  dragon2 = malloc(number_of_dragons * sizeof(*dragon2));
  gg_assert(dragon2 != NULL);
  
  /* Find the origins of the dragons to establish the mapping back to
   * the board. After this the DRAGON macro can be used.
   */
  for (str = BOARDMIN; str < BOARDMAX; str++) {
    if (!ON_BOARD(str))
      continue;
    if (IS_STONE(board[str])
	&& dragon[str].origin == str) {
      DRAGON2(str).origin = str;
    }
  }
  
  /* Initialize the rest of the dragon2 data. */
  for (d = 0; d < number_of_dragons; d++) {
    dragon2[d].neighbors            = 0;
    dragon2[d].hostile_neighbors    = 0;
    dragon2[d].moyo                 = -1;
    dragon2[d].safety               = -1;
    dragon2[d].escape_route         = 0;
    dragon2[d].genus                = 0;
    dragon2[d].heyes                = 0;
    dragon2[d].heye                 = NO_MOVE;
    dragon2[d].lunch                = NO_MOVE;
    dragon2[d].semeai               = 0;
    dragon2[d].semeai_margin_of_safety = -1;
  }
  
  dragon2_initialized = 1;
}
 

/* Examine which dragons are adjacent to each other. This is
 * complicated by the fact that adjacency may involve a certain
 * amount of empty space.
 *
 * The approach we use is to extend the dragons into their
 * surrounding influence areas until they collide. We also accept
 * one step extensions into neutral regions. After having done this
 * we can look for immediate adjacencies.
 */
static void
find_neighbor_dragons()
{
  int m, n;
  int ii;
  int i, j;
  int jj;
  int d;
  int dragons[BOARDMAX];
  int distances[BOARDMAX];
  int dist;
  int k;
  int color;

  gg_assert(dragon2_initialized);
  
  /* Initialize the arrays. */
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      ii = POS(m, n);

      if (IS_STONE(board[ii])) {
	dragons[ii] = dragon[ii].id;
	distances[ii] = 0;
      }
      else {
	dragons[ii] = -1;
	distances[ii] = -1;
      }
    }

  /* Expand from dist-1 to dist. Break out of the loop at the end if
     * we couldn't expand anything. Never expand more than five steps.
     */
  for (dist = 1; dist <= 5; dist++) {
    int found_one = 0;
      
    for (m = 0; m < board_size; m++)
      for (n = 0; n < board_size; n++) {
	ii = POS(m, n);

	if (distances[ii] != dist-1 || dragons[ii] < 0)
	  continue;

	color = DRAGON(dragons[ii]).color;
	for (k = 0; k < 4; k++) {
	  jj = ii + delta[k];

	  if (!ON_BOARD1(jj))
	    continue;

	  /* Consider expansion from (ii) to adjacent intersection
	   * (jj).
	   */
	  if (distances[jj] >= 0 && distances[jj] < dist)
	    continue; /* (jj) already occupied. */

	  if (influence_area_color(ii) == color
	      && influence_area_color(jj) != OTHER_COLOR(color)) {
	    /* Expansion ok. Now see if someone else has tried to
	     * expand here. In that case we indicate a collision by
	     * setting the dragon number to -2.
	     */
	    if (distances[jj] == dist) {
	      if (dragons[jj] != dragons[ii])
		dragons[jj] = -2;
	    }
	    else {
	      dragons[jj] = dragons[ii];
	      distances[jj] = dist;
	      found_one = 1;
	    }
	  }
	}
      }
    if (!found_one)
      break;
  }

  if (0) {
    for (m = 0; m < board_size; m++) {
      for (n = 0; n < board_size; n++) {
	fprintf(stderr, "%3d", dragons[POS(m, n)]);
      }
      fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");
      
    for (m = 0; m < board_size; m++) {
      for (n = 0; n < board_size; n++) {
	fprintf(stderr, "%3d", distances[POS(m, n)]);
      }
      fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");
  }

  /* Now go through dragons to find neighbors. It suffices to look
   * south and east for neighbors. In the case of a collision zone
   * where dragons==-2 we set all the neighbors of this intersection
   * as adjacent to each other.
   */
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      ii = POS(m, n);

      if (dragons[ii] == -2) {
	int neighbors = 0;
	int adjacent[4];

	for (k = 0; k < 4; k++) {
	  jj = ii + delta[k];

	  if (ON_BOARD1(jj) && dragons[jj] >= 0)
	    adjacent[neighbors++] = dragons[jj];
	}
	for (i = 0; i < neighbors; i++)
	  for (j = i+1; j < neighbors; j++)
	    add_adjacent_dragons(adjacent[i], adjacent[j]);
      }
      else if (dragons[ii] >= 0) {
	if (ON_BOARD(NORTH(ii))) {
	  if (dragons[NORTH(ii)] >= 0
	      && dragons[NORTH(ii)] != dragons[ii])
	    add_adjacent_dragons(dragons[ii], dragons[NORTH(ii)]);
	}
	if (ON_BOARD(EAST(ii))) {
	  if (dragons[EAST(ii)] >= 0
	      && dragons[EAST(ii)] != dragons[ii])
	    add_adjacent_dragons(dragons[ii], dragons[EAST(ii)]);
	}
      }
    }

  if (0) {
    for (d = 0; d < number_of_dragons; d++) {
      gprintf("dragon %d at %1m:", d, dragon2[d].origin);
      for (i = 0; i < dragon2[d].neighbors; i++)
	gprintf(" %1m(%d)", dragon2[dragon2[d].adjacent[i]].origin,
		dragon2[d].adjacent[i]);
      gprintf("\n");
    }
  }
}

/* Add the dragons with id a and b as adjacent to each other. */
static void
add_adjacent_dragons(int a, int b)
{
  gg_assert(a >= 0 
	    && a < number_of_dragons && b >= 0 && b < number_of_dragons);
  if (a == b)
    return;
  add_adjacent_dragon(a, b);
  add_adjacent_dragon(b, a);
}

/* Add the dragon with id b as adjacent to a. */
static void
add_adjacent_dragon(int a, int b)
{
  int i;
  gg_assert(a >= 0 
	    && a < number_of_dragons && b >= 0 && b < number_of_dragons);
  /* If the array of adjacent dragons already is full, ignore
   * additional neighbors.
   */
  if (dragon2[a].neighbors == MAX_NEIGHBOR_DRAGONS)
    return;
  
  for (i = 0; i < dragon2[a].neighbors; i++)
    if (dragon2[a].adjacent[i] == b)
      return;

  dragon2[a].adjacent[dragon2[a].neighbors++] = b;
  if (DRAGON(a).color == OTHER_COLOR(DRAGON(b).color))
    dragon2[a].hostile_neighbors++;
}

/* A dragon is considered invincible if it satisfies either of the two
 * following conditions:
 * a) At least two distinct eyespaces without topological halfeyes or
 * marginal vertices.
 * b) At least one string which is unconditionally alive according to the
 * unconditional_life() function in utils.c.
 */

static int
dragon_invincible(int pos)
{
  struct eye_data *eye;
  int i, j;
  int ii;
  int strong_eyes = 0;

  gg_assert(IS_STONE(board[pos]));

  /* First look for invincible strings in the dragon. */
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      ii = POS(i, j);

      if (is_same_dragon(ii, pos) && worm[ii].invincible)
        return 1;
    }

  /* Examine the eye spaces.
   * FIXME: The check for half eyes or false eyes may be too weak.
   */
  if (board[pos] == BLACK)
    eye = black_eye;
  else
    eye = white_eye;

  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      ii = POS(i, j);

      if (eye[ii].origin == ii
          && is_same_dragon(eye[ii].dragon, pos)) {
        if (eye[ii].msize == 0 && eye[ii].mineye > 0)
          strong_eyes++;
      }
    }

  if (strong_eyes >= 2)
    return 1;

  return 0;
}


/* A dragon looks inessential if it satisfies all of
 * 1. Is a single string.
 * 2. Is not owl substantial.
 *
 * FIXME: Probably need a better definition of INESSENTIAL dragons.
 *        There are cases where a string is owl insubstantial
 *        yet allowing it to be captured greatly weakens our
 *        position.
 */
static int
dragon_looks_inessential(int origin)
{
#if 0
  int d;
  int k;
#endif
  
  if (dragon[origin].size != worm[origin].size)
    return 0;

  if (owl_substantial(origin))
    return 0;

#if 0
  /* This is a proposed modification which solves 13x13:72 but
   * breaks buzco:5. It adds the two requirements:
   *
   * 3. Has no opponent neighbor with status better than DEAD.
   * 4. Has no opponent neighbor with escape value bigger than 0.
   *
   * This probably needs to be revised before it's enabled.
   */
  for (k = 0; k < DRAGON2(origin).neighbors; k++) {
    d = DRAGON2(origin).adjacent[k];
    if (DRAGON(d).color != board[origin]
	&& (DRAGON(d).matcher_status != DEAD
	    || dragon2[d].escape_route > 0))
      return 0;
  }
#endif
  
  return 1;
}


/* print status info on all dragons. (Can be invoked from gdb) 
 */
void 
show_dragons(void)
{
  static const char *snames[] = 
    {"dead", "alive", "critical", "unknown", "unchecked"};

  static const char *safety_names[] =
  {"dead", "alive", "critical", "inessential", "tactically dead", "weak",
   "weakly_alive", "alive_in_seki", "strongly_alive", "invincible"};
  
  int pos;
  int k;

  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    struct worm_data *w = &(worm[pos]);
    if (!IS_STONE(board[pos]))
      continue;

    if (w->origin == pos) {
      gprintf("%1m : (dragon %1m) %s string of size %d (%f), genus %d: (%d,%d,%d,%d)",
	      pos, dragon[pos].origin,
	      color_to_string(board[pos]),
	      w->size,
	      w->effective_size,
	      w->genus,
	      w->liberties,
	      w->liberties2,
	      w->liberties3,
	      w->liberties4);
      if (w->cutstone == 1)
	gprintf("%o - is a potential cutting stone\n");
      else if (w->cutstone == 2)
	gprintf("%o - is a cutting stone\n");
      else
	gprintf("%o\n");
      
      if (w->cutstone2 > 0)
	gprintf("- cutstone2 = %d\n", w->cutstone2);
      
      /* FIXME: List all attack and defense points. Also list all
       * threats.
       */
      for (k = 0; k < MAX_TACTICAL_POINTS; k++) {
	if (w->attack_codes[k] == 0)
	  break;
	gprintf("- attackable at %1m, attack code = %d\n",
		w->attack_points[k], w->attack_codes[k]);
      }
      
      for (k = 0; k < MAX_TACTICAL_POINTS; k++) {
	if (w->defend_codes[k] == 0)
	  break;
	if (w->defend_codes[k] != 0)
	  gprintf("- defendable at %1m, defend code = %d\n",
		  w->defense_points[k], w->defend_codes[k]);
      }
      
      for (k = 0; k < MAX_TACTICAL_POINTS; k++) {
	if (w->attack_threat_codes[k] == 0)
	  break;
	gprintf("- attack threat at %1m, attack threat code = %d\n",
		w->attack_threat_points[k], w->attack_threat_codes[k]);
      }
      
      for (k = 0; k < MAX_TACTICAL_POINTS; k++) {
	if (w->defense_threat_codes[k] == 0)
	  break;
	if (w->defense_threat_codes[k] != 0)
	  gprintf("- defense threat at %1m, defense threat code = %d\n",
		  w->defense_threat_points[k], w->defense_threat_codes[k]);
      }
      
      if (w->lunch != NO_MOVE)
	gprintf("... adjacent worm %1m is lunch\n", w->lunch);
      
      if (w->inessential)
	gprintf("- is inessential\n");
      
      if (w->invincible)
	gprintf("- is invincible\n");
      
      if (is_ko_point(pos))
	gprintf("- is a ko stone\n");
    }
  }
    
  gprintf("%o\n");
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    struct dragon_data *dd = &(dragon[pos]);
    struct dragon_data2 *d2;
    
    if (!IS_STONE(board[pos]))
      continue;
    
    d2 = &(dragon2[dd->id]);
    
    if (dd->origin == pos) {
      gprintf("%1m : %s dragon size %d (%f), genus %d, half eyes %d, escape factor %d, status %s, matcher status %s, moyo size %d safety %s",
	      pos,
	      board[pos] == BLACK ? "B" : "W",
	      dd->size,
	      dd->effective_size,
	      d2->genus,
	      d2->heyes,
	      d2->escape_route,
	      snames[dd->status],
	      snames[dd->matcher_status],
	      d2->moyo,
	      safety_names[d2->safety]);
      gprintf(", owl status %s\n", snames[dd->owl_status]);
      if (dd->owl_status == CRITICAL) {
	gprintf("... owl attackable at %1m, code %d\n",
		dd->owl_attack_point, dd->owl_attack_code);
	gprintf("... owl defendable at %1m, code %d\n",
		dd->owl_defense_point, dd->owl_defense_code);
      }
      gprintf("... neighbors");
      for (k = 0; k < d2->neighbors; k++) {
	int d = d2->adjacent[k];
	gprintf(" %1m", dragon2[d].origin);
      }
      gprintf("\n");
      if (d2->lunch != NO_MOVE)
	gprintf("... adjacent worm %1m is lunch\n", d2->lunch);
    }
  }
}



/*
 * dragon_eye(pos, eye_data) is invoked with (pos) the origin of an
 * eyespace. It unites all the worms adjacent to non-marginal points
 * of the eyespace into a single dragon.. In addition to marginal eye
 * space points, amalgamation is inhibited for points with the
 * INHIBIT_CONNECTION type set.
 *
 * This is based on the older function dragon_ring.
 */

static void
dragon_eye(int pos, struct eye_data eye[BOARDMAX])
{
  int i, j;
  int ii;
  int dr = NO_MOVE;
  int color;
  int k;

  /* don't amalgamate across ikken tobi */
  if (eye[pos].esize == 3 && eye[pos].msize > 1)
    return;

  DEBUG(DEBUG_DRAGONS, "amalgamate dragons around %1m\n", pos);
  if (eye[pos].color == BLACK_BORDER)
    color = BLACK;
  else {
    gg_assert(eye[pos].color == WHITE_BORDER);
    color = WHITE;
  }

  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      ii = POS(i, j);

      if (eye[ii].origin == pos
	  && !eye[ii].marginal
	  && !(eye[ii].type & INHIBIT_CONNECTION)) {
	for (k = 0; k < 4; k++) {
	  int d = delta[k];

	  if (board[ii+d] == color) {
	    if (dr == NO_MOVE)
	      dr = dragon[ii+d].origin;
	    else if (dragon[ii+d].origin != dr) {
	      join_dragons(ii+d, dr);
	      dr = dragon[ii+d].origin;
	    }
	  }
	}
      }
    }
  
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      ii = POS(i, j);

      if ((eye[ii].color == BLACK_BORDER 
	   || eye[ii].color == WHITE_BORDER) 
	  && eye[ii].origin == pos)
      {
	eye[ii].dragon = dr;
      }
    }
}


/* 
 * join_dragons amalgamates the dragon at (d1) to the
 * dragon at (d2).
 */

void 
join_dragons(int d1, int d2)
{
  int ii;
  int origin; /* new origin */

  /* Normalize dragon coordinates. */
  d1 = dragon[d1].origin;
  d2 = dragon[d2].origin;
  
  gg_assert(board[d1] == board[d2]);
  gg_assert(dragon2_initialized == 0);
  gg_assert(IS_STONE(board[d1]));

  /* We want to have the origin pointing to the largest string of
   * the dragon.  If this is not unique, we take the "upper
   * leftmost" one.
   */
  if (worm[d1].size > worm[d2].size
      || (worm[d1].size == worm[d2].size
	  && d1 < d2)) {
    origin = d1;
    DEBUG(DEBUG_DRAGONS, "joining dragon at %1m to dragon at %1m\n", d2, d1);
  }
  else {
    origin = d2;
    DEBUG(DEBUG_DRAGONS, "joining dragon at %1m to dragon at %1m\n", d1, d2);
  }
  
  dragon[origin].size  = dragon[d2].size + dragon[d1].size;
  dragon[origin].effective_size  = (dragon[d2].effective_size
				    + dragon[d1].effective_size);

  for (ii = BOARDMIN; ii < BOARDMAX; ii++) {
    if (ON_BOARD(ii)
	&& (dragon[ii].origin == d1 || dragon[ii].origin == d2))
      dragon[ii].origin = origin;
  }
}



/*
 * compute_dragon_status(pos) tries to determine whether the dragon
 * at (pos) is ALIVE, DEAD, or UNKNOWN. The algorithm is not perfect
 * and can give incorrect answers.
 *
 * The dragon is judged alive if its genus is >1. It is judged dead if
 * the genus is <2, it has no escape route, and no adjoining string can
 * be easily captured. Otherwise it is judged UNKNOWN.  */

static int 
compute_dragon_status(int pos)
{
  int true_genus = 2*DRAGON2(pos).genus + DRAGON2(pos).heyes;
  int lunch = DRAGON2(pos).lunch;

  gg_assert(dragon2_initialized);
  
  /* If it has two sure eyes, everything is just dandy. */
  if (true_genus > 3)
    return ALIVE;

  /* If the dragon consists of one worm, there is an attack, but 
   * no defense and there is less than one eye and one half eye,
   * the situation is hopeless.
   */
  if (dragon[pos].size == worm[pos].size
      && worm[pos].attack_codes[0] != 0 
      && worm[pos].defend_codes[0] == 0
      && true_genus < 3)
    return DEAD;
  
  if (lunch != NO_MOVE
      && true_genus < 3
      && worm[lunch].defend_codes[0] != 0
      && DRAGON2(pos).escape_route < 5)
    if (true_genus == 2 || worm[lunch].size > 2)
      return CRITICAL;

  if (lunch != NO_MOVE
      && true_genus >= 3)
    return ALIVE;

  if (lunch == NO_MOVE || worm[lunch].cutstone < 2) {
    if (true_genus < 3
	&& DRAGON2(pos).escape_route == 0
	&& DRAGON2(pos).moyo < 5)
      return DEAD;

    if (true_genus == 3
	&& DRAGON2(pos).escape_route < 5)
      return CRITICAL;
  }

  return UNKNOWN;
}


/* The dragon escape measure. This is defined as follows.
 *   
 * Let a PATH be a sequence of adjacent intersections that do nowhere
 * touch or include an opponent stone or touch the border. It may
 * include friendly stones and those are allowed to touch opponent
 * stones or the border). Let a DISTANCE N INTERSECTION be an
 * intersection connected to a dragon by a path of length N, but by no
 * shorter path. The connection of the path to the dragon may either
 * be by direct adjacency or, in the first step, diagonally if both
 * adjoining intersections are empty.
 *
 * It is assumed that each intersection has an escape value, which
 * would typically depend on influence and (preliminary) dragon
 * status. We define the escape potential as the sum of the escape
 * values over the distance four intersections of the dragon.
 * 
 * Example of distance N intersections, 1 <= N <= 4:
 * 
 * . . . . . . . . .    . . . . . . . . .
 * . . . . . X . . O    . . . . . X . . O
 * . . X . . . . . O    . . X . 2 . 4 . O
 * X . . . . . . . .    X . . 1 1 2 3 4 .
 * X O . O . . . . O    X O 1 O 1 2 3 4 O
 * X O . O . . . . .    X O 1 O 1 . 4 . .
 * X O . . . X . O O    X O 1 . . X . . O
 * . . . X . . . . .    . 1 . X . . . . .
 * X . . . . X . . .    X . . . . X . . .
 * . . . . . . . . .    . . . . . . . . .
 *
 * Additionally, a path may not pass a connection inhibited
 * intersection.
 */

#undef ENQUEUE /* emgena */
#define ENQUEUE(pos) (queue[queue_end++] = (pos),\
		      mx[pos] = 1)

/* Compute the escape potential described above. The dragon is marked
 * in the goal array.
 */
int
dragon_escape(char goal[BOARDMAX], int color,
	      int escape_value[BOARDMAX])
{
  int i, j;
  int ii;
  int k;
  static int mx[BOARDMAX];
  static int mx_initialized = 0;
  int queue[MAX_BOARD * MAX_BOARD];
  int queue_start = 0;
  int queue_end = 0;
  int other = OTHER_COLOR(color);
  int distance;
  int escape_potential = 0;

  gg_assert(IS_STONE(color));
  
  if (!mx_initialized) {
    memset(mx, 0, sizeof(mx));
    mx_initialized = 1;
  }

  /* Enter the stones of the dragon in the queue. */
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      ii = POS(i, j);

      if (goal[ii])
	ENQUEUE(ii);
    }
  
  /* Find points at increasing distances from the dragon. At distance
   * four, sum the escape values at those points to get the escape
   * potential.
   */
  for (distance = 0; distance <= 4; distance++) {
    int save_queue_end = queue_end;
    while (queue_start < save_queue_end) {
      ii = queue[queue_start];
      queue_start++;

      /* Do not pass connection inhibited intersections. */
      if ((color == WHITE
	   && ((white_eye[ii].type & INHIBIT_CONNECTION)
	       || white_eye[ii].cut == 1))
	  || (color == BLACK
	      && ((black_eye[ii].type & INHIBIT_CONNECTION)
		  || black_eye[ii].cut == 1)))
	continue;
      if (distance == 4)
	escape_potential += escape_value[ii];
      else {
	if (ON_BOARD(SOUTH(ii))
	    && !mx[SOUTH(ii)]
	    && (board[SOUTH(ii)] == color
		|| (board[SOUTH(ii)] == EMPTY
		    && ON_BOARD(SE(ii)) && board[SE(ii)] != other
		    && ON_BOARD(SS(ii)) && board[SS(ii)] != other
		    && ON_BOARD(SW(ii)) && board[SW(ii)] != other)))
	  ENQUEUE(SOUTH(ii));
	
	if (ON_BOARD(WEST(ii))
	    && !mx[WEST(ii)]
	    && (board[WEST(ii)] == color
		|| (board[WEST(ii)] == EMPTY
		    && ON_BOARD(SW(ii)) && board[SW(ii)] != other
		    && ON_BOARD(WW(ii)) && board[WW(ii)] != other
		    && ON_BOARD(NW(ii)) && board[NW(ii)] != other)))
	  ENQUEUE(WEST(ii));
	
	if (ON_BOARD(NORTH(ii))
	    && !mx[NORTH(ii)]
	    && (board[NORTH(ii)] == color
		|| (board[NORTH(ii)] == EMPTY
		    && ON_BOARD(NW(ii)) && board[NW(ii)] != other
		    && ON_BOARD(NN(ii)) && board[NN(ii)] != other
		    && ON_BOARD(NE(ii)) && board[NE(ii)] != other)))
	  ENQUEUE(NORTH(ii));
	
	if (ON_BOARD(EAST(ii))
	    && !mx[EAST(ii)]
	    && (board[EAST(ii)] == color
		|| (board[EAST(ii)] == EMPTY
		    && ON_BOARD(NE(ii)) && board[NE(ii)] != other
		    && ON_BOARD(EE(ii)) && board[EE(ii)] != other
		    && ON_BOARD(SE(ii)) && board[SE(ii)] != other)))
	  ENQUEUE(EAST(ii));
	
	/* For distance one intersections, allow kosumi to move out. I.e.
	 *
	 * ??..
	 * X.*.
	 * ?O.?
	 * ??X?
	 *
	 */
	if (distance == 0) {
	  if (board[SOUTH(ii)] == EMPTY
	      && board[WEST(ii)] == EMPTY
	      && !mx[SW(ii)]
	      && (board[SW(ii)] == color
		  || (board[SW(ii)] == color
		      && ON_BOARD(SOUTH(SW(ii)))
		      && board[SOUTH(SW(ii))] != other
		      && ON_BOARD(WEST(SW(ii)))
		      && board[WEST(SW(ii))] != other)))
	    ENQUEUE(SW(ii));
		      
	  if (board[WEST(ii)] == EMPTY
	      && board[NORTH(ii)] == EMPTY
	      && !mx[NW(ii)]
	      && (board[NW(ii)] == color
		  || (board[NW(ii)] == color
		      && ON_BOARD(WEST(NW(ii)))
		      && board[WEST(NW(ii))] != other
		      && ON_BOARD(NORTH(NW(ii)))
		      && board[NORTH(NW(ii))] != other)))
	    ENQUEUE(NW(ii));
		      
	  if (board[NORTH(ii)] == EMPTY
	      && board[EAST(ii)] == EMPTY
	      && !mx[NE(ii)]
	      && (board[NE(ii)] == color
		  || (board[NE(ii)] == color
		      && ON_BOARD(NORTH(NE(ii)))
		      && board[NORTH(NE(ii))] != other
		      && ON_BOARD(EAST(NE(ii)))
		      && board[EAST(NE(ii))] != other)))
	    ENQUEUE(NE(ii));
		      
	  if (board[EAST(ii)] == EMPTY
	      && board[SOUTH(ii)] == EMPTY
	      && !mx[SE(ii)]
	      && (board[SE(ii)] == color
		  || (board[SE(ii)] == color
		      && ON_BOARD(EAST(SE(ii)))
		      && board[EAST(SE(ii))] != other
		      && ON_BOARD(SOUTH(SE(ii)))
		      && board[SOUTH(SE(ii))] != other)))
	    ENQUEUE(SE(ii));
	}
      }
    }
  }

  /* Reset used mx cells. */
  for (k = 0; k < queue_end; k++) {
    /* The assertion fails if the same element should have been queued
     * twice, which might happen if ENQUEUE() is called without
     * checking mx[].
     */
    ASSERT1(mx[queue[k]] == 1, queue[k]);
    mx[queue[k]] = 0;
  }

  return escape_potential;
}

/* Wrapper to call the function above and compute the escape potential
 * for the dragon at (pos).
 */
static int
compute_escape(int pos, int dragon_status_known)
{
  int i, j;
  int ii;
  char goal[BOARDMAX];
  int escape_value[BOARDMAX];

  ASSERT1(IS_STONE(board[pos]), pos);
  
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      ii = POS(i, j);

      goal[ii] = is_same_dragon(ii, pos);
    }

  /* Compute escape_value array.  Points are awarded for moyo (4),
   * area (2) or EMPTY (1).  Values may change without notice.
   */
  compute_escape_influence(goal, board[pos], escape_value,
			   dragon_status_known);

  /* If we can reach a live group, award 6 points. */
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      ii = POS(i, j);

      if (dragon_status_known) {
	if (dragon[ii].status == ALIVE)
	  escape_value[ii] = 6;
	else if (dragon[ii].status == UNKNOWN
		 && (DRAGON2(ii).escape_route > 5 || DRAGON2(ii).moyo > 5))
	  escape_value[ii] = 4;
      }
      else {
	if (board[ii] == board[pos]
	    && !goal[ii]
	    && worm[ii].attack_codes[0] == 0)
	  escape_value[ii] = 2;
      }
    }

  return dragon_escape(goal, board[pos], escape_value);
}

/*
 * Sum up the surrounding moyo sizes for each dragon. Write this into
 * dragon2[].moyo if it is smaller than the current entry. If (opposite)
 * is true, we use initial_opposite_influence, otherwise initial_influence.
 */
static void
compute_surrounding_moyo_sizes(int opposite)
{
  int pos;
  int d;
  int mx[MAX_MOYOS + 1];
  struct moyo_data moyos;

  influence_get_moyo_segmentation(opposite, &moyos);

  memset(mx, 0, sizeof(mx));
  for (d = 0; d < number_of_dragons; d++) {
    int this_moyo_size = 0;
    for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
      int moyo_number = moyos.segmentation[pos];
      if (moyo_number == 0
          || board[pos] != DRAGON(d).color
          || dragon[pos].id != d
          || moyos.owner[moyo_number] != board[pos])
        continue;

      if (mx[moyo_number] != d + 1) {
        mx[moyo_number] = d + 1;
        this_moyo_size += moyos.size[moyo_number];
      }
    }

    if (this_moyo_size < dragon2[d].moyo)
      dragon2[d].moyo = this_moyo_size;
  }
}


/* 
 * Test whether two dragons are the same. Used by autohelpers and elsewhere.
 */

int
is_same_dragon(int d1, int d2)
{
  if (d1 == NO_MOVE || d2 == NO_MOVE)
    return (d1 == d2);
  
  ASSERT_ON_BOARD1(d1);
  ASSERT_ON_BOARD1(d2);

  return (dragon[d1].origin == dragon[d2].origin);
}

/* Test whether two dragons are neighbors. */
int
are_neighbor_dragons(int d1, int d2)
{
  int k;
  d1 = dragon[d1].origin;
  d2 = dragon[d2].origin;
  
  for (k = 0; k < DRAGON2(d1).neighbors; k++)
    if (dragon2[DRAGON2(d1).adjacent[k]].origin == d2)
      return 1;

  /* Just to be make sure that this function is always symmetric, we
   * do it the other way round too.
   */
  for (k = 0; k < DRAGON2(d2).neighbors; k++)
    if (dragon2[DRAGON2(d2).adjacent[k]].origin == d1)
      return 1;

  return 0;
}

/* ================================================================ */
/*                       A few status functions                     */
/* ================================================================ */

/*
 * These functions are only here because then we don't need to expose
 * the dragon structure to the external program.
 */

int
dragon_status(int pos)
{
  return dragon[pos].status;
}


int
matcher_status(int pos)
{
  return dragon[pos].matcher_status;
}


int
lively_dragon_exists(int color)
{
  if (color == WHITE)
    return lively_white_dragons > 0;
  else
    return lively_black_dragons > 0;
}


/* ================================================================ */
/*                      Debugger functions                          */
/* ================================================================ */

/* For use in gdb, print details of the dragon at (m, n). 
 * Add this to your .gdbinit file:
 *
 * define dragon
 * set ascii_report_dragon("$arg0")
 * end
 *
 * Now 'dragon S8' will report the details of the S8 dragon.
 *
 */

void
ascii_report_dragon(char *string)
{
  int m, n;
  string_to_location(board_size, string, &m, &n);
  report_dragon(m, n);
}


void
report_dragon(int m, int n)
{
  int pos = POS(m, n);
  int i, j;
  int ii;
  int k;
  struct dragon_data *d = &(dragon[pos]);
  struct dragon_data2 *d2 = &(dragon2[d->id]);
  
  if (board[pos] == EMPTY) {
    gprintf("There is no dragon at %1m\n", pos);
    return;
  }

  if (d->id < 0) {
    gprintf("Dragon data not available at %1m\n", pos);
    return;
  }

  gprintf("*** dragon at %1m:\n", pos);
  gprintf("color: %s; origin: %1m; size: %d; effective size: %f\n",
	  (d->color == WHITE) ? "WHITE" : "BLACK",
	  d->origin, d->size, d->effective_size);

  gprintf("strings:");
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      ii = POS(i, j);

      if (worm[ii].origin == ii
	  && is_same_dragon(ii, pos))
	gprintf(" %1m", ii);
    }

  gprintf("\nhalf eyes: %d, ", d2->heyes);
  if (d2->heye != NO_MOVE)
    gprintf("half eye: %1m, ", d2->heye);
  else
    gprintf("half eye: NONE,");

  gprintf(" genus %d, escape_route %d,", d2->genus, d2->escape_route);
  if (d2->lunch != NO_MOVE)
    gprintf(" lunch at %1m\n", d2->lunch);
  else
    gprintf(" no lunch\n");

  gprintf("dragon status %s, owl status %s, matcher status %s, owl threat status %s\n",
	  status_to_string(d->status),
	  status_to_string(d->owl_status),
	  status_to_string(d->matcher_status),
	  status_to_string(d->owl_threat_status));

  if (d->owl_attack_point != NO_MOVE)
    gprintf("owl attack point %1m, code %d, ",
	    d->owl_attack_point, d->owl_attack_code);
  else
    gprintf("no owl attack point, ");

  if (d->owl_second_attack_point != NO_MOVE)
    gprintf("second owl attack point %1m\n", d->owl_second_attack_point);
  else
    gprintf("no second owl attack point\n");

  if (d->owl_defense_point != NO_MOVE)
    gprintf("owl defense point %1m, code %d, ",
	    d->owl_defense_point, d->owl_defense_code);
  else
    gprintf("no owl defense point, ");

  if (d->owl_second_defense_point != NO_MOVE)
    gprintf("second owl defense point %1m\n", d->owl_second_defense_point);
  else
    gprintf("no second owl defense point\n");

  if (d2->semeai)
    gprintf("This dragon is involved in a semeai. Margin of safety %d\n",
	    d2->semeai_margin_of_safety);
  else
    gprintf("This dragon is not involved in a semeai.\n");

  gprintf("neighbor dragons: ");
  for (k = 0; k < d2->neighbors; k++)
    gprintf("%1m ", dragon2[d2->adjacent[k]].origin);
  gprintf("\nhostile neighbors: %d\n", d2->hostile_neighbors);
  gprintf("\nmoyo: %d; safety: %d\n", d2->moyo, d2->safety);
}


/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */



/* filllib.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


/* #include <stdio.h> */
/* #include <stdlib.h> */
/* #include <string.h> */

/* #include "gnugo.h" */
/* #include "liberty.h" */


static int find_backfilling_move(int move, int color, int *backfill_move);
static int filllib_confirm_safety(int move, int color, int *defense_point);

/* Determine whether a point is adjacent to at least one own string which
 * isn't dead.
 */
static int
living_neighbor(int pos, int color)
{
  int k;
  for (k = 0; k < 4; k++) {
    if (board[pos + delta[k]] == color
	&& dragon[pos + delta[k]].matcher_status != DEAD)
      return 1;
  }

  return 0;
}


/* Determine whether (pos) effectively is a black or white point.
 * The test for inessentiality is to avoid filling the liberties
 * around a killing nakade string.
 */
static void
analyze_neighbor(int pos, int *found_black, int *found_white)
{
  switch (board[pos]) {
    case EMPTY:
      if (!(*found_black)
	  && living_neighbor(pos, BLACK)
	  && safe_move(pos, WHITE) != 3)
	*found_black = 1;
      
      if (!(*found_white)
	  && living_neighbor(pos, WHITE)
	  && safe_move(pos, BLACK) != 3)
	*found_white = 1;
      
      break;

    case BLACK:
      if (!worm[pos].inessential && DRAGON2(pos).safety != INESSENTIAL) {
	if (dragon[pos].matcher_status == ALIVE
	    || dragon[pos].matcher_status == UNKNOWN)
	  *found_black = 1;
	else
	  *found_white = 1;
      }
      break;

    case WHITE:
      if (!worm[pos].inessential && DRAGON2(pos).safety != INESSENTIAL) {
	if (dragon[pos].matcher_status == ALIVE
	    || dragon[pos].matcher_status == UNKNOWN)
	  *found_white = 1;
	else
	  *found_black = 1;
      }
      break;
  }
}


/* If no move of value can be found to play, this seeks to fill a
 * common liberty, backfilling or back-capturing if necessary. When
 * backfilling we take care to start from the right end, in the case
 * that several backfilling moves are ultimately necessary.
 *
 * If a move for color is found, return 1, otherwise return 0.
 * The move is returned in (*move).
 */

int 
fill_liberty(int *move, int color)
{
  int m, n;
  int k;
  int other = OTHER_COLOR(color);
  int defense_point;
  int potential_color[BOARDMAX];

  /* We first make a fast scan for intersections which are potential
   * candidates for liberty filling. This is not very accurate, but it
   * does filter out intersections which could never pass the real
   * tests below but might still require a lot of tactical reading in
   * the process.
   */
  memset(potential_color, 0, sizeof(potential_color));
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      int pos = POS(m, n);
      if (board[pos] == EMPTY)
	continue;

      if (worm[pos].inessential || DRAGON2(pos).safety == INESSENTIAL)
	continue;

      if (dragon[pos].matcher_status != ALIVE) {
	for (k = 0; k < 4; k++) {
	  int pos2 = pos + delta[k];
	  if (board[pos2] == EMPTY)
	    potential_color[pos2] |= OTHER_COLOR(board[pos]);
	}
      }
      
      if (dragon[pos].matcher_status != DEAD) {
	for (k = 0; k < 12; k++) {
	  int d = delta[k%8];

	  if (k >= 8) {
 	    if (board[pos + d] != EMPTY)
 	      continue;
	    d *= 2;
	  }
	  if (board[pos + d] == EMPTY)
	    potential_color[pos + d] |= board[pos];
	}
      }
    }

  
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      int pos = POS(m, n);
      /* It seems we can't trust an empty liberty to be gray-colored
       * either as a cave or as a cavity. Instead we look for empty
       * intersections with at least one neighbor of each color, where
       * dead stones count as enemy stones. We also count empty
       * neighbors to either color if the opponent can't play there.
       */
      int found_white = 0;
      int found_black = 0;

      if (board[pos] != EMPTY)
	continue;

      /* Quick rejection based on preliminary test above. */
      if (potential_color[pos] != GRAY)
	continue;

      /* Loop over the neighbors. */
      for (k = 0; k < 4; k++) {
	int d = delta[k];
	if (ON_BOARD(pos + d))
	  analyze_neighbor(pos + d, &found_black, &found_white);
      }
      
      /* Do we have neighbors of both colors? */
      if (!(found_white && found_black))
	continue;

      /* Ok, we wish to play here, but maybe we can't. The following
       * cases may occur:
       * 1. Move is legal and safe.
       * 2. Move is legal but not safe because it's in the middle of a seki.
       * 3. Move is legal but not safe, can be played after backfilling.
       * 4. Move is an illegal ko recapture.
       * 5. Move is illegal but can be played after back-captures.
       * 6. Move would violate confirm_safety.
       */

      DEBUG(DEBUG_FILLLIB, "Filllib: Considering move at %1m.\n", pos);
      
      /* Legal and tactically safe, play it if it passes
       * confirm_safety test, i.e. that it isn't a blunder which
       * causes problems for other strings.
       */
      if (safe_move(pos, color) == WIN) {
	DEBUG(DEBUG_FILLLIB, "Filllib: Tactically safe.\n");
	if (filllib_confirm_safety(pos, color, &defense_point)) {
	  /* Safety confirmed. */
	  DEBUG(DEBUG_FILLLIB, "Filllib: Safety confirmed.\n");
	  *move = pos;
	  return 1;
	}
	else if (defense_point != NO_MOVE) {
	  /* Safety not confirmed because the move at (pos) would set
           * up a double threat. (defense_point) is assumed to defend
           * against this threat.
	   *
	   * FIXME: We should verify that (defense_point) really is effective.
	   */
	  DEBUG(DEBUG_FILLLIB,
		"Filllib: Safety not confirmed, but %1m defends.\n",
		defense_point);
	  *move = defense_point;
	  return 1;
	}
	else {
	  /* The move causes problems somewhere else on the board, so
           * we have to discard it. If everything works right this
           * should not happen at this time.
	   */
	  DEBUG(DEBUG_FILLLIB, "Filllib: Safety not confirmed, discarded.\n");
	  TRACE("Warning: Blunder detected in fill_liberty().\n");
	  continue;
	}
      }
      
      /* Try to play the move. */
      if (trymove(pos, color, "fill_liberty", NO_MOVE, EMPTY, NO_MOVE)) {
	popgo();
	/* Legal, but not safe. Look for backfilling move. */
	DEBUG(DEBUG_FILLLIB,
	      "Filllib: Legal but not safe, looking for backfilling move.\n");

	if (find_backfilling_move(pos, color, move)) {
	  DEBUG(DEBUG_FILLLIB, "Filllib: Backfilling move at %1m.\n", *move);
	  /* In certain positions it may happen that an illegal move
	   * is found. This probably only can happen if we try to play
	   * a move inside a lost semeai. Anyway we should discard the
	   * move.
	   */
	  if (!is_legal(*move, color)) {
	    DEBUG(DEBUG_FILLLIB, "Filllib: Was illegal, discarded.\n");
	    *move = NO_MOVE;
	    continue;
	  }

	  /* If the move turns out to be strategically unsafe, or
           * setting up a double threat elsewhere, also discard it.
	   */
	  if (!filllib_confirm_safety(*move, color, &defense_point)) {
	    DEBUG(DEBUG_FILLLIB,
		  "Filllib: Safety not confirmed, discarded.\n");
	    continue;
	  }

	  /* Seems to be ok. */
	  return 1;
	}
	else {
	  /* If we captured some stones, this move should be ok anyway. */
	  if (does_capture_something(pos, color)) {
	    DEBUG(DEBUG_FILLLIB,
		  "Filllib: Not tactically safe, but captures stones.\n");
	    if (!filllib_confirm_safety(pos, color, &defense_point)) {
	      DEBUG(DEBUG_FILLLIB,
		    "Filllib: Safety not confirmed, discarded.\n");
	      continue;
	    }
	    *move = pos;
	    return 1;
	  }
	}
      }
      else {
	/* Move is illegal. Look for an attack on one of the neighbor
	 * worms. If found, return that move for back-capture.
	 */
	DEBUG(DEBUG_FILLLIB, "Filllib: Illegal, looking for back-capture.\n");
	for (k = 0; k < 4; k++) {
	  int d = delta[k];
	  if (board[pos + d] == other
	      && worm[pos + d].attack_codes[0] == WIN) {
	    *move = worm[pos + d].attack_points[0];
	    DEBUG(DEBUG_FILLLIB, "Filllib: Found at %1m.\n", *move);
	    return 1;
	  }
	}

	DEBUG(DEBUG_FILLLIB,
	      "Filllib: Nothing found, looking for ko back-capture.\n");
	for (k = 0; k < 4; k++) {
	  int d = delta[k];
	  if (board[pos + d] == other
	      && worm[pos + d].attack_codes[0] != 0
	      && is_legal(worm[pos + d].attack_points[0], color)) {
	    *move = worm[pos + d].attack_points[0];
	    DEBUG(DEBUG_FILLLIB, "Filllib: Found at %1m.\n", *move);
	    return 1;
	  }
	}

	DEBUG(DEBUG_FILLLIB,
	      "Filllib: Nothing found, looking for threat to back-capture.\n");
	for (k = 0; k < 4; k++) {
	  int d = delta[k];
	  if (board[pos + d] == other
	      && worm[pos + d].attack_codes[0] != 0) {
	    /* Just pick some other liberty. */
	    int libs[2];
	    if (findlib(pos + d, 2, libs) > 1) {
	      if (is_legal(libs[0], color))
		*move = libs[0];
	      else if (is_legal(libs[1], color))
		*move = libs[1];
	      DEBUG(DEBUG_FILLLIB, "Filllib: Found at %1m.\n", *move);
	      return 1;
	    }
	  }
	}
      }
    }
  
  /* Nothing found. */
  DEBUG(DEBUG_FILLLIB, "Filllib: No move found.\n");
  return 0;
}


/* The strategy for finding a backfilling move is to first identify
 * moves that
 *
 * 1. defends the position obtained after playing (move).
 * 2. captures a stone adjacent to our neighbors to (move), before
 *    (move) is played.
 *
 * Then we check which of these are legal before (move) is played. If
 * there is at least one, we take one of these arbitrarily as a
 * backfilling move.
 *
 * Now it may happen that (move) still isn't a safe move. In that case
 * we recurse to find a new backfilling move. To do things really
 * correctly we should also give the opponent the opportunity to keep
 * up the balance of the position by letting him do a backfilling move
 * of his own. Maybe this could also be arranged by recursing this
 * function. Currently we only do a half-hearted attempt to find
 * opponent moves.
 */
static int adjs[MAXCHAIN];
static int libs[MAXLIBS];

static int
find_backfilling_move(int move, int color, int *backfill_move)
{
  int k;
  int liberties;
  int neighbors;
  int found_one = 0;
  int apos = NO_MOVE;
  int bpos = NO_MOVE;
  int extra_pop = 0;
  int success = 0;
  int acode;
  int saved_move = NO_MOVE;
  
  /* Play (move) and identify all liberties and adjacent strings. */
  if (!trymove(move, color, "find_backfilling_move", move, EMPTY, NO_MOVE))
    return 0; /* This shouldn't happen, I believe. */

  /* The move wasn't safe, so there must be an attack for the
   * opponent. Save it for later use.
   */
  acode = attack(move, &apos);
  gg_assert(acode != 0 && apos > NO_MOVE);
  
  /* Find liberties. */
  liberties = findlib(move, MAXLIBS, libs);

  /* Find neighbors. */
  neighbors = chainlinks(move, adjs);

  /* Remove (move) again. */
  popgo();
  
  /* It's most fun to capture stones. Start by trying to take some
   * neighbor off the board. If the attacking move does not directly
   * reduce the number of liberties of the attacked string we don't
   * trust it but keep it around if we don't find anything else. (See
   * filllib:17 for a position where this matters.)
   *
   * FIXME: Maybe we should take care to find the neighbor with the
   * fewest liberties, since that string probably can be removed
   * fastest. For the moment we assume this to be nonimportant.
   *
   * FIXME: It seems we have to return immediately when we find an
   * attacking move, because recursing for further backfilling might
   * lead to moves which complete the capture but cannot be played
   * before the attacking move itself. This is not ideal but probably
   * good enough.
   */
  for (k = 0; k < neighbors; k++) {
    if (attack(adjs[k], &bpos) == WIN) {
      if (liberty_of_string(bpos, adjs[k])) {
	*backfill_move = bpos;
	return 1;
      }
      else
	saved_move = bpos;
    }
  }
  
  /* Otherwise look for a safe move at a liberty. */
  if (!found_one) {
    for (k = 0; k < liberties; k++) {
      if (safe_move(libs[k], color) == WIN) {
	*backfill_move = libs[k];
	found_one = 1;
	break;
      }
    }
  }

  /* If no luck so far, try with superstring liberties. */
  if (!found_one) {
    trymove(move, color, "find_backfilling_move", move, EMPTY, NO_MOVE);
    find_proper_superstring_liberties(move, &liberties, libs, 0);
    popgo();
    for (k = 0; k < liberties; k++) {
      if (safe_move(libs[k], color) == WIN) {
	*backfill_move = libs[k];
	found_one = 1;
	break;
      }
    }
  }

  /* If no luck so far, try attacking superstring neighbors. */
  if (!found_one) {
    trymove(move, color, "find_backfilling_move", move, EMPTY, NO_MOVE);
    superstring_chainlinks(move, &neighbors, adjs, 4);
    popgo();
    for (k = 0; k < neighbors; k++) {
      if (attack(adjs[k], &bpos) == WIN) {
	if (liberty_of_string(bpos, adjs[k])) {
	  *backfill_move = bpos;
	  return 1;
	}
      }
    }
  }

  if (found_one) {
  
    if (!trymove(*backfill_move, color, "find_backfilling_move", move,
		 EMPTY, NO_MOVE))
      return 0; /* This really shouldn't happen. */
    
    /* Allow opponent to get a move in here. */
    if (trymove(apos, OTHER_COLOR(color), "find_backfilling_move", move, 
		EMPTY, NO_MOVE))
      extra_pop = 1;
    
    /* If still not safe, recurse to find a new backfilling move. */
    if (safe_move(move, color) == WIN)
      success = 1;
    else
      success = find_backfilling_move(move, color, backfill_move);

    /* Pop move(s) and return. */
    if (extra_pop)
      popgo();
    popgo();
  }

  if (!success && saved_move != NO_MOVE) {
    *backfill_move = saved_move;
    success = 1;
  }

  return success;
}


/* Confirm that (move) is a safe move for color. In addition to
 * calling the global confirm_safety(), this function also calls the
 * owl code to verify the strategical viability of the move.
 */
static int
filllib_confirm_safety(int move, int color, int *defense_point)
{
  int k;
  int apos = NO_MOVE;
  int save_verbose;

  gg_assert(stackp == 0);
  gg_assert(defense_point != NULL);
  *defense_point = NO_MOVE;

  /* Before we can call the owl code, we need to find a neighbor of
   * our color.
   */
  for (k = 0; k < 4; k++)
    if (board[move + delta[k]] == color) {
      apos = move + delta[k];
      break;
    }

  /* If none found, look for a neighbor of an attacked adjacent string. */
  if (apos == NO_MOVE)
    for (k = 0; k < 4; k++) {
      int pos2 = move + delta[k];
      if (board[pos2] == OTHER_COLOR(color)
	  && !play_attack_defend_n(color, 0, 1, move, pos2)) {
	int adj;
	adj = chainlinks(pos2, adjs);
	/* It seems unlikely that we would ever get adjacent strings
         * here, but if it should happen we simply give up and say the
         * move is unsafe.
	 */
	if (adj == 0)
	  return 0;
	
	apos = adjs[0];
	break;
      }
    }

  /* We should have found something by now. If not something's
   * probably broken elsewhere. Declare the move unsafe if it happens.
   */
  if (apos == NO_MOVE)
    return 0;

  /* Ask the owl code whether this move is strategically viable. */
  
  save_verbose = verbose;
  if (verbose > 0)
    verbose--;
  if (!owl_does_defend(move, apos))
    return 0;
  verbose = save_verbose;
  
  return confirm_safety(move, color, 0, defense_point, NULL, NULL);
}


/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */


/* fuseki.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* #include <stdio.h> */
/* #include <stdlib.h> */

/* #include "sgftree.h" */
/* #include "gnugo.h" */
/* #include "liberty.h" */

/* #include "patterns.h" */
/* #include "random.h" */


/* Pointless to do fuseki database pattern matching after this number
 * of stones have been placed on the board.
 *
 * Notice that we are not talking of the move number here but the
 * number of stones actually residing on the board. This does in
 * particular include handicap stones.
 */
#define MAX_FUSEKI_DATABASE_STONES 19


#define UPPER_LEFT  0
#define UPPER_RIGHT 1
#define LOWER_LEFT  2
#define LOWER_RIGHT 3

/* Global variables remembering which symmetries the position has. */
int horizontally_symmetric; /* symmetry with respect to K column */
int vertically_symmetric;   /* symmetry with respect to 10 row */
int diagonally_symmetric;   /* ... with respect to diagonal from UR to LL */

/* This value must be lower than the value for an ongoing joseki. 
 * (Gets multiplied with board_size / 19.) 
 */
#define EMPTY_CORNER_VALUE 25

/* check if region from i1, j1 to i2, j2 is open */

static int 
openregion(int i1, int i2, int j1, int j2)
{
  int x, y;

  if (i1 > i2)
    return openregion(i2, i1, j1, j2);
  if (j1 > j2)
    return openregion(i1, i2, j2, j1);

  for (x = i1; x <= i2; x++)
    for (y = j1; y <= j2; y++)
      if (BOARD(x, y) != EMPTY)
	return 0;
  return 1;
}

/* This function sets the global variables indicating symmetries of the
 * position. (Important for etiquette.)
 */
static void
set_symmetries(void)
{
  int i, j;
  horizontally_symmetric = 1;
  vertically_symmetric = 1; 
  diagonally_symmetric = 1;
  for (i = 0; i < board_size
              && (vertically_symmetric || horizontally_symmetric
		  || diagonally_symmetric); i++)
    for (j = 0; j < board_size; j++) {
      if (board[POS(i, j)] != board[POS(i, board_size - 1 - j)])
	horizontally_symmetric = 0;
      if (board[POS(i, j)] != board[POS(board_size - 1 - i, j)])
	vertically_symmetric = 0;
      if (board[POS(i, j)]
	  != board[POS(board_size - 1 - j, board_size - 1 - i)])
	diagonally_symmetric = 0;
    }
}

/* The corner moves. */

static int corners[][2] =
{
  {3, 3},
  {3, 4},
  {4, 3},
  {4, 4},
  {5, 3},
  {3, 5},
  {5, 4},
  {4, 5},
};

/* Relative weights for different corner moves at different board
   sizes. */

/* up to 11x11 */
static int small_board[] =
{
  50,       /* 3-3 */
  18,       /* 3-4 */
  17,       /* 4-3 */
  15,       /* 4-4 */
  0,        /* 5-3 */
  0,        /* 3-5 */
  0,        /* 5-4 */
  0,        /* 4-5 */
};

/* 12x12 to 15x15 */
static int medium_board[] =
{
  30,       /* 3-3 */
  20,       /* 3-4 */
  20,       /* 4-3 */
  22,       /* 4-4 */
  2,        /* 5-3 */
  2,        /* 3-5 */
  2,        /* 5-4 */
  2,        /* 4-5 */
};

/* 16x16 and larger */
static int large_board[] =
{
  15,       /* 3-3 */
  15,       /* 3-4 */
  15,       /* 4-3 */
  35,       /* 4-4 */
  5,        /* 5-3 */
  5,        /* 3-5 */
  5,        /* 5-4 */
  5,        /* 4-5 */
};

static void
choose_corner_move(int corner, int *m, int *n)
{
  int *table = 0;
  int sum_of_weights = 0;
  int i;
  int q;
  
  if (board_size <= 11)
    table = small_board;
  else if (board_size <= 15)
    table = medium_board;
  else 
    table = large_board;

  for (i = 0; i < 8 ;i++)
    sum_of_weights += table[i];

  q = gg_rand() % sum_of_weights;
  for (i = 0; i < 8; i++) {
    q -= table[i];
    if (q < 0)
      break;
  }
  
  *m = corners[i][0];
  *n = corners[i][1];

  switch (corner) {
  case UPPER_LEFT:
    *m = *m - 1;
    *n = *n - 1;
    break;
  case UPPER_RIGHT:
    *m = *m - 1;
    *n = board_size - *n;
    break;
  case LOWER_LEFT:
    *m = board_size - *m;
    *n = *n - 1;
    break;
  case LOWER_RIGHT:
    *m = board_size - *m;
    *n = board_size - *n;
    break;
  }
}


/* Announce move, but check for politeness first. */
static void
announce_move(int move, int val, int color)
{
  int i, j;
  /* This shouldn't happen. */
  if (board[move] != EMPTY)
    return;
  
  /* Politeness: Black plays in lower right half of upper right corner first.
   * White plays in upper left half of lower left corner first.
   * (Not sure whether this is correct for handicap games. Is this an
   * urgent FIXME? :-) )
   */
  if (horizontally_symmetric) {
    i = I(move);
    j = J(move);
    if ((2 * j < board_size - 1) ^ (color == WHITE))
      move = POS(i, board_size - 1 - j);
  }
  if (vertically_symmetric) {
    i = I(move);
    j = J(move);
    if ((2 * i > board_size - 1) ^ (color == WHITE))
      move = POS(board_size - 1 - i, j);
  }
  if (diagonally_symmetric) {
    i = I(move);
    j = J(move);
    if ((board_size - 1 - j > i) ^ (color == WHITE))
      move = POS(board_size - 1 - j, board_size - 1 - i);
  }
  
  if (set_minimum_move_value(move, val))
    TRACE("Fuseki Player suggests %1m with value %d\n", move, val);
}


/* Storage for values collected during pattern matching. */
static int fuseki_moves[MAX_BOARD * MAX_BOARD];
static int fuseki_value[MAX_BOARD * MAX_BOARD];
static int num_fuseki_moves;
static int fuseki_total_value;

/* Callback for fuseki database pattern matching. */
static void
fuseki_callback(int ti, int tj, struct fullboard_pattern *pattern, int ll)
{
  TRACE("Fuseki database move at %1m with relative weight %d, pattern %s+%d\n",
	POS(ti, tj), (int) pattern->value, pattern->name, ll);

  /* Store coordinates and relative weight for the found move. */
  fuseki_moves[num_fuseki_moves] = POS(ti, tj);
  fuseki_value[num_fuseki_moves] = pattern->value;
  fuseki_total_value += pattern->value;
  num_fuseki_moves++;
}

/* Full board matching in database for fuseki moves. Return 1 if any
 * pattern found.
 */
static int
search_fuseki_database(int color)
{
  struct fullboard_pattern *database;
  int q;
  int k;
  int best_fuseki_value;

  /* Disable matching after a certain number of stones are placed on
   * the board.
   */
  if (stones_on_board(BLACK | WHITE) > MAX_FUSEKI_DATABASE_STONES)
    return 0;

  /* We only have databases for 9x9, 13x13 and 19x19. */
  if (board_size == 9)
    database = fuseki9;
  else if (board_size == 13)
    database = fuseki13;
  else if (board_size == 19)
    database = fuseki19;
  else
    return 0;

  /* Do the matching. */
  num_fuseki_moves = 0;
  fuseki_total_value = 0;
  fullboard_matchpat(fuseki_callback, color, database);

  /* No match. */
  if (num_fuseki_moves == 0)
    return 0;

  /* Choose randomly with respect to relative weights for matched moves. */
  /* Do not choose moves with less value than 20% of the best move */
  best_fuseki_value = fuseki_value[0];
  q = gg_rand() % fuseki_total_value;
  for (k = 0; k < num_fuseki_moves; k++) {
    if (fuseki_value[k] < (best_fuseki_value / 5))
      break;
    q -= fuseki_value[k];
    if (q < 0)
      break;
  }

  gg_assert(k < num_fuseki_moves);
  /* Give this move an arbitrary value of 75. The actual value doesn't
   * matter much since the intention is that we should play this move
   * whatever the rest of the analysis thinks.
   */
  announce_move(fuseki_moves[k], 75, color);

  /* Also make sure the other considered moves can be seen in the
   * traces and in the output file.
   */
  for (k = 0; k < num_fuseki_moves; k++)
    set_minimum_move_value(fuseki_moves[k], 74);

  return 1;
}

/* Generate move in empty corner or in middle of small board.*/
void
fuseki(int color)
{
  int i = -1;
  int j = -1;
  int width;  /* Side of the open region required in the corner. */
  int empty_corner_value = EMPTY_CORNER_VALUE * board_size/19;

  /* Return immediately if --disable_fuseki option used. */
  if (disable_fuseki)  /* emgena: ????? */
    return;
  
  set_symmetries();

  /* Search in fuseki database unless disabled by --nofusekidb option. */
  if (fusekidb && search_fuseki_database(color))
    return;

  /* On 9x9, only play open corners after the first move if nothing
   * else useful is found.
   */
  if (board_size == 9 && stones_on_board(color) > 0)
    empty_corner_value = 5;
  
  if (board_size <= 11) {
    /* For boards of size 11x11 or smaller we first go for the center point. */
    int middle = board_size/2;
    if (openregion(middle-2, middle+2, middle-2, middle+2)) {
      announce_move(POS(middle, middle), 45, color);
    }
  }

  if (board_size < 9)
    return;

  if (board_size >= 18)
    width = 8;
  else if (board_size == 9)
    width = 5;
  else
    width = board_size/2;
  
  if (openregion(0, width-1, board_size-width, board_size-1)) {
    choose_corner_move(UPPER_RIGHT, &i, &j);
    announce_move(POS(i, j), empty_corner_value, color);
  }
  
  if (openregion(board_size-width, board_size-1, 0, width-1)) {
    choose_corner_move(LOWER_LEFT, &i, &j);
    announce_move(POS(i, j), empty_corner_value, color);
  }
  if (openregion(board_size-width, board_size-1,
		 board_size-width, board_size-1)) {
    choose_corner_move(LOWER_RIGHT, &i, &j);
    announce_move(POS(i, j), empty_corner_value, color);
  }
  
  if (openregion(0, width-1, 0, width-1)) {
    choose_corner_move(UPPER_LEFT, &i, &j);
    announce_move(POS(i, j), empty_corner_value, color);
  }
}

/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */


/* genmove.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* #include <stdio.h> */
/* #include <stdlib.h> */
/* #include <string.h> */

/* #include "sgftree.h" */
/* #include "gnugo.h" */
/* #include "liberty.h" */
/* #include "random.h" */


/* Return one if x doesn't equal position_number and 0 otherwise.
 * After using this macro x will always have the value
 * position_number.
 */
#define NEEDS_UPDATE(x) (x != position_number ? (x = position_number, 1) : 0)

static int get_level(int *level);
static int do_genmove(int *move, int color, float pure_threat_value);

static double slowest_time = 0.0;
static int    slowest_move = NO_MOVE;
static int    slowest_movenum = 0;
static double total_time = 0.0;

/* Position numbers for which various examinations were last made. */
static int worms_examined = -1;
static int initial_influence_examined = -1;
static int dragons_examined_without_owl = -1;
static int dragons_examined = -1;
static int initial_influence2_examined = -1;

static int revise_semeai(int color);
static int revise_thrashing_dragon(int color, float advantage);

void sgfShowConsideredMoves(void);


/* Reset some things in the engine. 
 *
 * This prepares the hash table for the reading code for use.  It
 * should be called when we start examine a new position.  
 */

void
reset_engine()
{
  /* To improve the reproducability of games, we restart the random
   * number generator with the same seed for each move. Thus we don't
   * have to know how many previous moves have been played, nor
   * actually play through them, in order to get the right random
   * numbers.
   */
  gg_srand(random_seed);

  /* Initialize things for hashing of positions. */
  reading_cache_clear();
  hashdata_recalc(&hashdata, board, board_ko_pos);
  worms_examined = -1;
  initial_influence_examined = -1;
  dragons_examined_without_owl = -1;
  dragons_examined = -1;
  initial_influence2_examined = -1;

  /* Prepare our table of move reasons. */
  clear_move_reasons();

  /* Set up depth values. Level 10 should be more or less the same as level 9
   * except that the superstring technology is used in the reading code. This
   * makes us about 10% slower.
   */
  set_depth_values(level);
}

/*
 * Examine the position and try to gather as much information as possible.
 * This is used mainly for move generation, but could also be called
 * for debugging purposes (decidestring, etc).
 *
 * The parameter how_much tells us how much of the work we have to do.
 * For move generation we have to do it all.  For debugging we can 
 * sometimes stop a little earlier.
 */

void
examine_position(int color, int how_much)
{
  int save_verbose = verbose;

  purge_persistent_reading_cache();
  
  /* Don't print reading traces during make_worms and make_dragons unless 
   * the user really wants it (verbose == 3). 
   */
  if (verbose == 1 || verbose == 2)
    --verbose;

  if (NEEDS_UPDATE(worms_examined)) {
    start_timer(0);
    make_worms(save_verbose);
    time_report(0, "  make worms", NO_MOVE, 1.0);
  }
  if (how_much == EXAMINE_WORMS) {
    verbose = save_verbose;
    gg_assert(test_gray_border() < 0);
    return;
  }

  if (stones_on_board(BLACK | WHITE) != 0) {
    if (NEEDS_UPDATE(initial_influence_examined))
      compute_initial_influence(color, 0);
    if (how_much == EXAMINE_INITIAL_INFLUENCE) {
      verbose = save_verbose;
      gg_assert(test_gray_border() < 0);
      return;
    }

    if (how_much == EXAMINE_DRAGONS_WITHOUT_OWL) {
      if (NEEDS_UPDATE(dragons_examined_without_owl))
	make_dragons(color, 1, save_verbose);
      verbose = save_verbose;
      gg_assert(test_gray_border() < 0);
      return;
    }
    
    if (NEEDS_UPDATE(dragons_examined)) {
      make_dragons(color, 0, save_verbose);
      /* We have automatically done a partial dragon analysis as well. */
      dragons_examined_without_owl = position_number;
    }
    if (how_much == EXAMINE_DRAGONS) {
      verbose = save_verbose;
      gg_assert(test_gray_border() < 0);
      return;
    }
  }
  else if (how_much == EXAMINE_INITIAL_INFLUENCE
	   || how_much == EXAMINE_DRAGONS
	   || how_much == EXAMINE_ALL) {
    initialize_dragon_data();
    verbose = save_verbose;
    gg_assert(test_gray_border() < 0);
    return;
  }
  
  verbose = save_verbose;

  if (printworms)
    show_dragons();

  if (NEEDS_UPDATE(initial_influence2_examined))
    compute_initial_influence(color, 1);
  if (how_much == EXAMINE_INITIAL_INFLUENCE2) {
    gg_assert(test_gray_border() < 0);
    return;
  }
}


/* The same as examine_position(), except that all traces, debug
 * output, and sgf traces are turned off.
 */
void
silent_examine_position(int color, int how_much)
{
  int save_verbose = verbose;
  SGFTree *save_sgf_dumptree = sgf_dumptree;
  int save_count_variations = count_variations;
  int save_debug = debug;
  int save_printmoyo = printmoyo;
  
  verbose = 0;
  sgf_dumptree = NULL;
  count_variations = 0;
  debug = 0;
  printmoyo = 0;
  
  examine_position(color, how_much);

  verbose = save_verbose;
  sgf_dumptree = save_sgf_dumptree;
  count_variations = save_count_variations;
  debug = save_debug;
  printmoyo = save_printmoyo;
}


/*
 * Estimate the current score using the influence function. The value
 * is positive if white is thought to be ahead and negative otherwise.
 *
 * The color is the color to move. We only need this for ugly
 * technical reasons and it shouldn't have any effect on the score
 * estimate.
 */
void
old_estimate_score(int color, float *lower_bound, float *upper_bound)
{
  static int last_scored_position = -1;
  static float lower = 0.0;
  static float upper = 0.0;
  float score1;
  float score2;

  if (position_number != last_scored_position) {
    /* Find out information about the worms and dragons. */
    examine_position(color, EXAMINE_ALL);
    compute_initial_influence(OTHER_COLOR(color), 1);

    /* The coefficients should match those close to the end of
     * estimate_influence_value() in move_reasons.c.
     */
    score1 = influence_estimate_score(0.35, 0.13);
    compute_initial_influence(color, 1);
    score2 = influence_estimate_score(0.35, 0.13);
    
    DEBUG(DEBUG_SCORING, "%f %f %d %d\n", score1, score2,
	  white_captured, black_captured);

    if (score1 > score2) {
      lower = score2;
      upper = score1;
    }
    else {
      lower = score1;
      upper = score2;
    }

    lower += black_captured - white_captured;
    upper += black_captured - white_captured;
 
    last_scored_position = position_number;
  }

  *lower_bound = lower + komi;
  *upper_bound = upper + komi;
  gg_assert(test_gray_border() < 0);
}



/* 
 * Generate computer move for COLOR.
 *
 * Return the generated move in (*i, *j).
 */

int
genmove(int *i, int *j, int color)
{
  int move;
  int retval;

  retval = do_genmove(&move, color, 0.4);

  if (i) *i = I(move);
  if (j) *j = J(move);

  return retval;
}


/* 
 * Same as above but doesn't generate pure threat moves. Useful when
 * trying to score a game.
 */

int
genmove_conservative(int *i, int *j, int color)
{
  int move;
  int retval;

  retval = do_genmove(&move, color, 0.0);

  if (i) *i = I(move);
  if (j) *j = J(move);

  return retval;
}


/* 
 * Perform the actual move generation. 
 */
  
static int
do_genmove(int *move, int color, float pure_threat_value)
{
  float val;
  int save_verbose;

  start_timer(0);
  
  /* Prepare our table of moves considered. */
  memset(potential_moves, 0, sizeof(potential_moves));
  
  /* Reset all the statistics for each move. */
  stats.nodes = 0;
  stats.position_entered    = 0;
  stats.position_hits       = 0;
  stats.read_result_entered = 0;
  stats.read_result_hits    = 0;
  stats.hash_collisions     = 0;
  
  /* no move is found yet. */
  *move = NO_MOVE;  
  val = -1; 
  if (get_level(&level))
    fprintf(stderr, "level = %d\n", level);
  
  /* experimental level adapter */
  clock_adapt_level(&level, color);

  /* Prepare pattern matcher and reading code. */
  reset_engine();

  /* Find out information about the worms and dragons. */
  start_timer(1);
  examine_position(color, EXAMINE_ALL);
  time_report(1, "examine position", NO_MOVE, 1.0);

  /* Make a score estimate. This can be used in later stages of the 
   * move generation.  If we are ahead, we can play safely and if
   * we are behind, we have to play more daringly.
   */
  if (level >= 8) {
    estimate_score(&lower_bound, &upper_bound);
    if (verbose || showscore) {
      if (lower_bound == upper_bound)
	gprintf("\nScore estimate: %s %f\n",
		lower_bound > 0 ? "W " : "B ", gg_abs(lower_bound));
      else
	gprintf("\nScore estimate: %s %f to %s %f\n",
		lower_bound > 0 ? "W " : "B ", gg_abs(lower_bound),
		upper_bound > 0 ? "W " : "B ", gg_abs(upper_bound));
      fflush(stderr);
    }
    time_report(1, "estimate score", NO_MOVE, 1.0);

    /* The score will be used to determine when we are safely
     * ahead. So we want the most conservative score.
     */
    if (color == WHITE)
      score = lower_bound;
    else
      score = upper_bound;
  }
  else
    score = 0.0;

  /*
   * Print some of the information if the user wants to.
   */
  if (printmoyo)
    print_moyo();
  
  if (printboard) {
    if (printboard == 1)
      fprintf(stderr, "\n          dragon_status display:\n\n");
    if (printboard == 2)
      fprintf(stderr, "\n          eye display:\n\n");
    showboard(printboard); 
    if (printboard == 1) {
      fprintf(stderr, "\n           owl_status display:\n\n");      
      showboard(3);
    }
  }
  
  gg_assert(stackp == 0);
  
  /*
   * Ok, information gathering is complete. Now start to find some moves!
   */

  /* Pick up tactical moves. */
  worm_reasons(color);
  
  /* Pick up owl moves. */
  save_verbose = verbose;
  if (verbose > 0)
    verbose--;
  owl_reasons(color);
  verbose = save_verbose;
  
  /* Try to find empty corner moves. */
  fuseki(color);
  gg_assert(stackp == 0);

  /* The general pattern database. */
  start_timer(1);
  shapes(color);
  time_report(1, "shapes", NO_MOVE, 1.0);
  gg_assert(stackp == 0);

  /* Look for combination attacks and defenses against them. */
  combinations(color);
  time_report(1, "combinations", NO_MOVE, 1.0);
  gg_assert(stackp == 0);

  /* Review the move reasons and estimate move values. */
  if (review_move_reasons(move, &val, color, 
			  pure_threat_value, lower_bound))
    TRACE("Move generation likes %1m with value %f\n", *move, val);
  gg_assert(stackp == 0);
  time_report(1, "review move reasons", NO_MOVE, 1.0);

  /* If we are ahead by 15 points or more, consider a thrashing
   * dragon dangerous and change its status from DEAD to
   * UNKNOWN. This may generate a move.
   */
  if (val < 10.0 && !doing_scoring) {
    if (revise_thrashing_dragon(color, 15.0)) {
      shapes(color);
      if (!disable_endgame_patterns)
	endgame_shapes(color);
      if (review_move_reasons(move, &val, color, pure_threat_value, score)) {
	TRACE("Upon reconsideration move generation likes %1m with value %f\n",
	      *move, val); 
      }
    }
    time_report(1, "move reasons with revised semeai status", NO_MOVE, 1.0);
  }

  /* If the move value is 6 or lower, we look for endgame patterns too. */
  if (val <= 6.0 && !disable_endgame_patterns) {
    endgame_shapes(color);
    gg_assert(stackp == 0);
    if (review_move_reasons(move, &val, color, pure_threat_value, score))
      TRACE("Move generation likes %1m with value %f\n", *move, val);
    gg_assert(stackp == 0);
    time_report(1, "endgame", NO_MOVE, 1.0);
  }
  
  /* If no move found yet, revisit any semeai and change the
   * status of the opponent group from DEAD to UNKNOWN, then 
   * run shapes and endgame_shapes again. This may turn up a move.
   */
  if (val < 0.0) {
    if (revise_thrashing_dragon(color, 0.0)
	|| revise_semeai(color)) {
      shapes(color);
      endgame_shapes(color);
      if (review_move_reasons(move, &val, color, pure_threat_value, score)) {
	TRACE("Upon reconsideration move generation likes %1m with value %f\n",
	      *move, val); 
      }
    }
    time_report(1, "move reasons with revised semeai status", NO_MOVE, 1.0);
  }

  /* If still no move, fill a remaining liberty. This should pick up
   * all missing dame points.
   */
  if (val < 0.0 
      && fill_liberty(move, color)) {
    val = 1.0;
    TRACE("Filling a liberty at %1m\n", *move);
    move_considered(*move, val);
    time_report(1, "fill liberty", NO_MOVE, 1.0);
  }

  /* If we're instructed to play out the aftermath or capture all dead
   * opponent stones, or if the opponent is trying to live inside
   * our territory and we are clearly ahead, generate an aftermath move.
   */

  if (val < 0.0
      && !doing_scoring
      && (play_out_aftermath 
	  || capture_all_dead 
	  || (thrashing_dragon
	      && ((color == BLACK && score < -15.0)
		  || (color == WHITE && score > 15.0))))
      && aftermath_genmove(move, color, NULL, 0) > 0) {
    ASSERT1(is_legal(*move, color), *move);
    val = 1.0;
    TRACE("Aftermath move at %1m\n", *move);
    move_considered(*move, val);
    time_report(1, "aftermath_genmove", NO_MOVE, 1.0);
  }

  /* If we're instructed to capture all dead opponent stones, generate
   * a capturing move.
   */
  if (val < 0.0
      && !doing_scoring
      && capture_all_dead 
      && aftermath_genmove(move, color, NULL, 1) > 0) {
    ASSERT1(is_legal(*move, color), *move);
    val = 1.0;
    TRACE("Aftermath move at %1m\n", *move);
    move_considered(*move, val);
    time_report(1, "aftermath_genmove", NO_MOVE, 1.0);
  }

  /* If no move is found then pass. */
  if (val < 0.0) {
    TRACE("I pass.\n");
    *move = NO_MOVE;
  }
  else
    TRACE("genmove() recommends %1m with value %f\n", *move, val);
  
  /* If statistics is turned on, this is the place to show it. */
  if (showstatistics) {
    gprintf("Nodes:                %d\n", stats.nodes);
    gprintf("Positions entered:    %d\n", stats.position_entered);
    gprintf("Position hits:        %d\n", stats.position_hits);
    gprintf("Read results entered: %d\n", stats.read_result_entered);
    gprintf("Read result hits:     %d\n", stats.read_result_hits);
    gprintf("Hash collisions:      %d\n", stats.hash_collisions);
  }
 
 if (showtime) {
    double spent = time_report(0, "TIME to generate move at ", *move, 1.0);
    total_time += spent;
    if (spent > slowest_time) {
      slowest_time = spent;
      slowest_move = *move;
      slowest_movenum = movenum + 1;
    }
    if (*move == NO_MOVE) {
      gprintf("\nSLOWEST MOVE: %d at %1m ", slowest_movenum, slowest_move);
      fprintf(stderr, "(%.2f seconds)\n", slowest_time);
      fprintf(stderr, "\nAVERAGE TIME: %.2f seconds per move\n",
	      total_time / movenum);
      fprintf(stderr, "\nTOTAL TIME: %.2f seconds\n",
	      total_time);

    }
  }
  
  gg_assert(test_gray_border() < 0);
  return val;
}



/* This is called for each move which has been considered. For
 * debugging purposes, we keep a table of all the moves we
 * have considered.
 */

void 
move_considered(int move, float val)
{
  int i = I(move);
  int j = J(move);
  if (val > potential_moves[i][j]) {
    potential_moves[i][j] = val;
  }
}


/* If there is a file with the name "level", reads it
 * each move and corrects the value of level.
 */

static int
get_level(int *level)
{
  char buffer[128];
  FILE *fp;

  const char filename[] = "level";

  if ((fp = fopen(filename, "r")) == NULL)
    return 0;

  if (fgets(buffer, 128, fp)) {
    if (sscanf(buffer, "%d", level))
      return 1;
    else
      return 0;
  }
  else
    return 0;
}
  

/* ================================================================ */
/*       Set up fixed placement handicap stones for black side      */
/* ================================================================ */


/* Handicap stones are set up according to the following diagrams:
 *  
 * 2 stones:                    3 stones:           
 *
 *   A B C D E F G H J	  	  A B C D E F G H J  
 * 9 . . . . . . . . . 9  	9 . . . . . . . . . 9
 * 8 . . . . . . . . . 8  	8 . . . . . . . . . 8
 * 7 . . + . . . X . . 7  	7 . . X . . . X . . 7
 * 6 . . . . . . . . . 6  	6 . . . . . . . . . 6
 * 5 . . . . + . . . . 5  	5 . . . . + . . . . 5
 * 4 . . . . . . . . . 4  	4 . . . . . . . . . 4
 * 3 . . X . . . + . . 3  	3 . . X . . . + . . 3
 * 2 . . . . . . . . . 2  	2 . . . . . . . . . 2
 * 1 . . . . . . . . . 1  	1 . . . . . . . . . 1
 *   A B C D E F G H J	  	  A B C D E F G H J  
 *   
 * 4 stones:                    5 stones:           
 *						     
 *   A B C D E F G H J	          A B C D E F G H J  
 * 9 . . . . . . . . . 9 	9 . . . . . . . . . 9
 * 8 . . . . . . . . . 8 	8 . . . . . . . . . 8
 * 7 . . X . . . X . . 7 	7 . . X . . . X . . 7
 * 6 . . . . . . . . . 6 	6 . . . . . . . . . 6
 * 5 . . . . + . . . . 5 	5 . . . . X . . . . 5
 * 4 . . . . . . . . . 4 	4 . . . . . . . . . 4
 * 3 . . X . . . X . . 3 	3 . . X . . . X . . 3
 * 2 . . . . . . . . . 2 	2 . . . . . . . . . 2
 * 1 . . . . . . . . . 1 	1 . . . . . . . . . 1
 *   A B C D E F G H J	          A B C D E F G H J  
 *  
 * 6 stones:                    7 stones:           
 *						     
 *   A B C D E F G H J	          A B C D E F G H J  
 * 9 . . . . . . . . . 9 	9 . . . . . . . . . 9
 * 8 . . . . . . . . . 8 	8 . . . . . . . . . 8
 * 7 . . X . . . X . . 7 	7 . . X . . . X . . 7
 * 6 . . . . . . . . . 6 	6 . . . . . . . . . 6
 * 5 . . X . + . X . . 5 	5 . . X . X . X . . 5
 * 4 . . . . . . . . . 4 	4 . . . . . . . . . 4
 * 3 . . X . . . X . . 3 	3 . . X . . . X . . 3
 * 2 . . . . . . . . . 2 	2 . . . . . . . . . 2
 * 1 . . . . . . . . . 1 	1 . . . . . . . . . 1
 *   A B C D E F G H J	          A B C D E F G H J  
 *  
 * 8 stones:                    9 stones:           
 *						     
 *   A B C D E F G H J	          A B C D E F G H J  
 * 9 . . . . . . . . . 9   	9 . . . . . . . . . 9
 * 8 . . . . . . . . . 8   	8 . . . . . . . . . 8
 * 7 . . X . X . X . . 7   	7 . . X . X . X . . 7
 * 6 . . . . . . . . . 6   	6 . . . . . . . . . 6
 * 5 . . X . + . X . . 5   	5 . . X . X . X . . 5
 * 4 . . . . . . . . . 4   	4 . . . . . . . . . 4
 * 3 . . X . X . X . . 3   	3 . . X . X . X . . 3
 * 2 . . . . . . . . . 2   	2 . . . . . . . . . 2
 * 1 . . . . . . . . . 1   	1 . . . . . . . . . 1
 *   A B C D E F G H J	          A B C D E F G H J  
 *  
 * For odd-sized boards larger than 9x9, the same pattern is followed,
 * except that the edge stones are moved to the fourth line for 13x13
 * boards and larger.
 *
 * For even-sized boards at least 8x8, only the four first diagrams
 * are used, because there is no way to place the center stones
 * symmetrically. As for odd-sized boards, the edge stones are moved
 * to the fourth line for boards larger than 11x11.
 *
 * At most four stones are placed on 7x7 boards too (this size may or
 * may not be supported by the rest of the engine). No handicap stones
 * are ever placed on smaller boards.
 *
 * Notice that this function only deals with fixed handicap placement.
 * Larger handicaps can be added by free placement if the used
 * interface supports it.
 */


/* This table contains the (coded) positions of the stones.
 *  2 maps to 2 or 3, depending on board size
 *  0 maps to center
 * -ve numbers map to  board_size - number
 *
 * The stones are placed in this order, *except* if there are
 * 5 or 7 stones, in which case center ({0, 0}) is placed, and
 * then as for 4 or 6.
 */

static const int places[][2] = {

  {2, -2}, {-2, 2}, {2, 2}, {-2, -2}, /* first 4 are easy */
                                      /* for 5, {0,0} is explicitly placed */
  
  {0, 2}, {0, -2},                    /* for 6 these two are placed */
                                      /* for 7, {0,0} is explicitly placed */
  
  {2, 0}, {-2, 0},                    /* for 8, these two are placed */

  {0, 0},                             /* finally tengen for 9 */
};


/*
 * Sets up handicap stones, returning the number of placed handicap stones.
 */

int
placehand(int handicap)
{
  int x;
  int maxhand;
  int three = board_size > 11 ? 3 : 2;
  int mid = board_size/2;
  int retval = handicap;

  /* A handicap of 1 just means that B plays first, no komi.
   * Black is not told where to play the first stone so no handicap
   * is set. 
   */
  if (handicap < 2)
    return 0;
  if ((board_size % 2 == 1) && (board_size >= 9))
    maxhand = 9;
  else if (board_size >= 7)
    maxhand = 4;
  else
    maxhand = 0;

  /* It's up to the caller of this function to notice if the handicap
   * was too large for fixed placement and act upon that.
   */
  if (handicap > maxhand) {
    handicap = maxhand;
    retval = maxhand;
  }

  /* special cases: 5 and 7 */
  if (handicap == 5 || handicap == 7) {
    add_stone(POS(mid, mid), BLACK);
    handicap--;
  }

  for (x = 0; x < handicap; ++x) {
    int i = places[x][0];
    int j = places[x][1];

    /* translate the encoded values to board co-ordinates */
    if (i == 2)  i = three;	/* 2 or 3 */
    if (i == -2) i = -three;

    if (j == 2)  j = three;
    if (j == -2) j = -three;

    if (i == 0) i = mid;
    if (j == 0) j = mid;

    if (i < 0) i += board_size-1;
    if (j < 0) j += board_size-1;

    add_stone(POS(i, j), BLACK);
  }

  return retval;
}


/* revise_semeai(color) changes the status of any DEAD dragon of
 * OPPOSITE_COLOR(color) which occurs in a semeai to UNKNOWN.
 * It returns true if such a dragon is found.
 */

static int
revise_semeai(int color)
{
  int pos;
  int found_one = 0;
  int other = OTHER_COLOR(color);

  gg_assert(dragon2 != NULL);

  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (ON_BOARD(pos)
	&& dragon[pos].color == other
	&& DRAGON2(pos).semeai
	&& dragon[pos].matcher_status == DEAD) {
      found_one = 1;
      dragon[pos].matcher_status = UNKNOWN;
      if (dragon[pos].origin == pos)
	TRACE("revise_semeai: changed status of dragon %1m from DEAD to UNKNOWN\n",
	      pos);
    }
  }
  
  return found_one;
}


/* If the opponent's last move added a stone to a dead dragon,
 * revise it's status to UNKNOWN. This will cause genmove to
 * generate moves restraining the dragon. We only do this if
 * we are ahead by 'advantage', and no owl threat has been found.
 */

static int
revise_thrashing_dragon(int color, float advantage)
{
  int pos;

  /* Trust the owl code's opinion if we are behind. */
  if ((color == BLACK && score > -advantage)
      || (color == WHITE && score < advantage))
    return 0;

  /* If an owl threat has been found, a move reason has
   * probably been generated, so we skip this step. */
  if (dragon[thrashing_dragon].owl_threat_status == CAN_THREATEN_DEFENSE)
    return 0;

  if (disable_threat_computation
      || !thrashing_dragon 
      || dragon[thrashing_dragon].matcher_status != DEAD)
    return 0;
  
  for (pos = BOARDMIN; pos < BOARDMAX; pos++)
    if (ON_BOARD(pos)
	&& is_same_dragon(pos, thrashing_dragon))
      dragon[pos].matcher_status = UNKNOWN;
  return 1;
}




/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */


/* influence.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* #include <stdio.h> */
/* #include <stdlib.h> */
/* #include <string.h> */

/* #include "gnugo.h" */
/* #include "liberty.h" */
/* #include "gg_utils.h" */

/* #include "influence.h" */
/* #include "patterns.h" */


static void value_territory(struct influence_data *q);
static void add_influence_source(int pos, int color, float strength,
                                 float attenuation,
                                 struct influence_data *q);
static void segment_influence(struct influence_data *q);
static void print_influence(struct influence_data *q,
			    const char *info_string);
static void print_numeric_influence(struct influence_data *q,
				    float values[MAX_BOARD][MAX_BOARD],
				    const char *format, int draw_stones,
				    int mark_epsilon);
static void print_influence_areas(struct influence_data *q);
 
/* The following functions are used with experimental_influence is set. */
static void new_value_territory(struct influence_data *q,
				int m, int n, int color);
static void enter_intrusion_source(int source_pos, int strength_pos,
                                   float strength, float attenuation,
                                   struct influence_data *q);
static void add_marked_intrusions(struct influence_data *q, int color);
static void print_influence_territory(struct influence_data *q,
                                      const char *info_string);
 

/* Influence computed for the initial position, i.e. before making
 * some move.
 */
static struct influence_data initial_influence;
static struct influence_data initial_opposite_influence;

/* Influence computed after some move has been made. */
static struct influence_data move_influence;
static struct influence_data followup_influence;

/* Coordinates for the move influence was last computed for. */
static int influence_movei = -1;
static int influence_movej = -1;
static int influence_color = EMPTY;

/* Influence used for estimation of escape potential. */
static struct influence_data escape_influence;

/* Pointer to influence data used during pattern matching. */
static struct influence_data *current_influence = NULL;

/* Cache of delta_territory_values. */
static float delta_territory_cache[BOARDMAX];
static float followup_territory_cache[BOARDMAX];

/* If set, print influence map when computing this move. Purely for
 * debugging.
 */
static int debug_influence_i = -1;
static int debug_influence_j = -1;

/* This is the core of the influence function. Given the coordinates
 * and color of an influence source, it radiates the influence
 * outwards until it hits a barrier or the strength of the influence
 * falls under a certain threshold.
 *
 * The radiation is performed by a breadth first propagation,
 * implemented by means of an internal queue.
 *
 * Since this function has turned out be one of the bottlenecks, loop
 * unrolling makes a noticeable performance difference. It does,
 * however, make the code much harder to read and maintain. Therefore
 * we include both the original and the unrolled versions.
 */

#define EXPLICIT_LOOP_UNROLLING 1

#if EXPLICIT_LOOP_UNROLLING

#define code1(arg_di, arg_dj, arg_i, arg_j, arg_d) \
      if (q->p[arg_i][arg_j] == EMPTY \
	  && ((arg_di)*(i-m) + (arg_dj)*(j-n) > 0 \
	      || queue_start == 1)) { \
	permeability = permeability_array[i][j]; \
	if (arg_d) \
	  permeability *= gg_max(permeability_array[arg_i][j], \
			         permeability_array[i][arg_j]); \
	if (permeability == 0.0) \
	  continue; \
	damping = (arg_d) ? diagonal_attenuation : attenuation; \
	if (i == m && j == n) \
	  cos2phi = 1.0; \
	else { \
	  float a = (arg_di)*(i-m) + (arg_dj)*(j-n); \
	  float c = (arg_di)*(arg_di) + (arg_dj)*(arg_dj); \
	  gg_assert(a > 0.0); \
	  cos2phi = (a*a) / (b*c); \
	} \
	contribution = cos2phi * permeability * current_strength / damping; \
	if (contribution <= INFLUENCE_CUTOFF) { \
          if (permeability < 1.0 || q->w[arg_i][arg_j] != 0.0) \
	    continue; \
          else \
            contribution = 1.01 * INFLUENCE_CUTOFF; \
	} \
	if (q->w[arg_i][arg_j] == 0.0) { \
	  q->queuei[queue_end] = (arg_i); \
	  q->queuej[queue_end] = (arg_j); \
	  queue_end++; \
	} \
	q->w[arg_i][arg_j] += contribution; \
      }
#endif

static void
accumulate_influence(struct influence_data *q, int m, int n, int color)
{
  int i, j;
  int k;
#if !EXPLICIT_LOOP_UNROLLING
  int d;
#endif
  float damping;
  float b;
  float current_strength;
  float cos2phi;
  float permeability;
  float contribution;
  float attenuation;
  float diagonal_attenuation;
  float (*permeability_array)[MAX_BOARD];
  
  /* Clear the queue. */
  int queue_start = 0;
  int queue_end = 0;

  if (0)
    gprintf("Accumulating influence for %s at %m\n",
	    color_to_string(color), m, n);

  /* Attenuation only depends on the influence origin. */
  if (color == WHITE)
    attenuation = q->white_attenuation[m][n];
  else
    attenuation = q->black_attenuation[m][n];
  if (experimental_influence)
    diagonal_attenuation = attenuation * EXP_DIAGONAL_DAMPING;
  else
    diagonal_attenuation = attenuation * DIAGONAL_DAMPING;

  if (color == WHITE)
    permeability_array = q->white_permeability;
  else
    permeability_array = q->black_permeability;
    
  /* Put the influence origin on the stack. */
  if (color == WHITE)
    q->w[m][n] = q->white_strength[m][n];
  else
    q->w[m][n] = q->black_strength[m][n];
  q->queuei[queue_end] = m;
  q->queuej[queue_end] = n;
  queue_end++;

  /* Spread influence until the stack is empty. */
  while (queue_start < queue_end) {

    /* Pick first element in queue. */
    i = q->queuei[queue_start];
    j = q->queuej[queue_start];
    b = (i-m)*(i-m) + (j-n)*(j-n);
    if (0)
      gprintf("Picked %m from queue. w=%f start=%d end=%d\n",
	      i, j, q->w[i][j], queue_start, queue_end);
    current_strength = q->w[i][j];
    queue_start++;

#if !EXPLICIT_LOOP_UNROLLING
    /* Try to spread influence in each of the eight directions. */    
    for (d = 0; d < 8; d++) {
      int di = deltai[d];
      int dj = deltaj[d];

      /* Verify that (i+di, j+dj) is
       * 1. Inside the board.
       * 2. Not occupied.
       * 3. Directed outwards. For the origin all directions are outwards.
       */
      if (ON_BOARD2(i+di, j+dj)
	  && q->p[i+di][j+dj] == EMPTY
	  && (di*(i-m) + dj*(j-n) > 0
	      || queue_start == 1)) {

	/* Now compute the damping of the influence.
	 * First we have the permeability at the point we are
	 * spreading from. For diagonal movement we also take the
	 * permeability of the vertices we are "passing by" into
	 * account.
	 */
	permeability = permeability_array[i][j];
	if (d > 3) /* diagonal movement */
	  permeability *= gg_max(permeability_array[i+di][j],
				 permeability_array[i][j+dj]);

	if (permeability == 0.0)
	  continue;
	
	/* Then we have the distance dependent damping. */
	damping = 1.0;
	switch (d) {
	case 0: /* south */
	case 1: /* west */
	case 2: /* north */
	case 3: /* east */
	  damping = attenuation;
	  break;
	case 4: /* southwest */
	case 5: /* northwest */
	case 6: /* northeast */
	case 7: /* southeast */
	  damping = diagonal_attenuation;
	  break;
	}
	
	/* Finally direction dependent damping. */
	if (i == m && j == n)
	  cos2phi = 1.0;
	else {
	  float a = di*(i-m) + dj*(j-n);
	  float c = di*di + dj*dj;
	  gg_assert(a > 0.0);
	  cos2phi = (a*a) / (b*c);
	}

	contribution = cos2phi * permeability * current_strength / damping;

	/* Stop spreading influence if the contribution becomes too low. */
	if (contribution <= INFLUENCE_CUTOFF) {
          if (permeability < 1.0 || q->w[i+di][j+dj] != 0.0)
	    continue;
          else
            contribution = 1.01 * INFLUENCE_CUTOFF;
	}
	
	/* If no influence here before, add the point to the queue for
	 * further spreading.
	 */
	if (0)
	  gprintf("  Spreading %s influence from %m to %m, d=%d\n",
		  color_to_string(color), i, j, i+di, j+dj, d);
	if (q->w[i+di][j+dj] == 0.0) {
	  q->queuei[queue_end] = i + di;
	  q->queuej[queue_end] = j + dj;
	  queue_end++;
	}
	q->w[i+di][j+dj] += contribution;
      }
    }
#else
    if (i > 0)
      code1(-1, 0, i-1, j, 0);
    if (i < board_size-1)
      code1(1, 0, i+1, j, 0);
    if (j > 0)
      code1(0, -1, i, j-1, 0);
    if (j < board_size-1)
      code1(0, 1, i, j+1, 0);
    if (i > 0 && j > 0)
      code1(-1, -1, i-1, j-1, 1);
    if (i < board_size-1 && j > 0)
      code1(1, -1, i+1, j-1, 1);
    if (i < board_size-1 && j < board_size-1)
      code1(1, 1, i+1, j+1, 1);
    if (i > 0 && j < board_size-1)
      code1(-1, 1, i-1, j+1, 1);
 
#endif
  }
  
  /* Add the values in the working area to the accumulated influence
   * and simultaneously reset the working area. We know that all
   * influenced points were stored in the queue, so we just traverse
   * it.
   */
  for (k = 0; k < queue_end; k++) {
    i = q->queuei[k];
    j = q->queuej[k];

    if (color == WHITE) {
      if (q->w[i][j] > 1.01 * INFLUENCE_CUTOFF
	  || q->white_influence[i][j] == 0.0)
	q->white_influence[i][j] += q->w[i][j];
    }
    else {
      if (q->w[i][j] > 1.01 * INFLUENCE_CUTOFF
	  || q->black_influence[i][j] == 0.0)
	q->black_influence[i][j] += q->w[i][j];
    }
    
    q->w[i][j] = 0.0;
  }
}

/* Initialize the influence_data structure. If the dragons have been
 * computed, we weight the strength of the influence with the dragon
 * status.
 *
 * The saved_stones parameter tells which critical stones have been
 * defended (value INFLUENCE_SAVED_STONE) or attacked (value
 * INFLUENCE_CAPTURED_STONE) by the current move. If no move has been
 * done, it should only contain zeros (INFLUENCE_UNCHANGED_STONE).
 *
 * The name saved_stones is historic and should probably be changed
 * since it also includes captured stones.
 *
 */

static float strength_map[10] = {
  0.0,   /* DEAD            */
  0.9,   /* ALIVE           */
  0.5,   /* CRITICAL        */
  0.0,   /* INESSENTIAL     */
  0.0,   /* TACTICALLY DEAD */
  0.7,   /* WEAK            */
  0.8,   /* WEAKLY_ALIVE    */
  0.6,   /* ALIVE IN SEKI   */
  0.95,  /* STRONGLY ALIVE  */
  1.0    /* INVINCIBLE      */
};

static void
init_influence(struct influence_data *q, int color, int dragons_known,
	       char saved_stones[BOARDMAX])
{
  int i, j;
  float attenuation;

  gg_assert(saved_stones != NULL);
  
  if (q != &escape_influence) {
    q->color_to_move = color;
    if (experimental_influence)
      attenuation = EXP_DEFAULT_ATTENUATION;
    else
      attenuation = DEFAULT_ATTENUATION;
  }
  else {
    q->color_to_move = EMPTY;
    if (experimental_influence)
      attenuation = 2 * EXP_DEFAULT_ATTENUATION;
    else
      attenuation = 2 * DEFAULT_ATTENUATION;
  }
  
  q->intrusion_counter = 0;
  
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      int pos = POS(i, j);
      /* Initialize. */
      q->white_influence[i][j] = 0.0;
      q->black_influence[i][j] = 0.0;
      q->w[i][j] = 0.0;
      q->white_attenuation[i][j] = attenuation;
      q->black_attenuation[i][j] = attenuation;
      q->white_permeability[i][j] = 1.0;
      q->black_permeability[i][j] = 1.0;
      q->white_strength[i][j] = 0.0;
      q->black_strength[i][j] = 0.0;
      q->p[i][j] = board[pos];
      q->non_territory[i][j] = EMPTY;

      /* FIXME: Simplify the code below! */
      
      /* Dead stones (or critical ones for the color which will not
       * make the next move) count as empty space. However, influence
       * cannot flow through these for the owner of the stones.
       */
      if (IS_STONE(board[pos])) {
	if (saved_stones[pos] == INFLUENCE_CAPTURED_STONE
	    || (saved_stones[pos] == INFLUENCE_UNCHANGED_STONE
		&& ((worm[pos].attack_codes[0] != 0
		    && (OTHER_COLOR(q->p[i][j]) == color
			|| worm[pos].defend_codes[0] == 0))
		    || (dragons_known
			&& dragon[pos].id != -1
			&& (DRAGON2(pos).safety == DEAD
			    || DRAGON2(pos).safety == TACTICALLY_DEAD
			    || (DRAGON2(pos).safety == CRITICAL
				&& board[pos] == OTHER_COLOR(color))))))) {
	  if (q->p[i][j] == WHITE)
	    q->white_permeability[i][j] = 0.0;
	  else
	    q->black_permeability[i][j] = 0.0;
	  q->p[i][j] = EMPTY;
	}
	else if (saved_stones[pos] == INFLUENCE_SAVED_STONE
		 || !dragons_known
		 || dragon[pos].id == -1
		 || (DRAGON2(pos).safety != DEAD
		     && DRAGON2(pos).safety != TACTICALLY_DEAD
		     && DRAGON2(pos).safety != CRITICAL)
		 || (DRAGON2(pos).safety == CRITICAL
		     && board[pos] == color)) {
	  if (q->p[i][j] == WHITE)
	    q->black_permeability[i][j] = 0.0;
	  else
	    q->white_permeability[i][j] = 0.0;
	}

	/* We need to make an exception to the rules above for
         * INESSENTIAL stones. Instead of making the conditions above
         * still more complex we correct it here.
	 *
	 * If q->p[i][j] is allowed to be 0, the territory evaluation
	 * will think it's a prisoner for the opponent, and various
	 * territory corrections and interpolations will mess up.
	 */
	if (IS_STONE(board[pos])
	    && dragons_known
	    && dragon[pos].id != -1
	    && (DRAGON2(pos).safety == INESSENTIAL
	        || (worm[pos].inessential
		    && ((DRAGON2(pos).safety != DEAD
			 && DRAGON2(pos).safety != TACTICALLY_DEAD
		         && DRAGON2(pos).safety != CRITICAL)
		        || (DRAGON2(pos).safety == CRITICAL
		            && board[pos] == color)))) 
	    && q->p[i][j] == EMPTY)
	  q->p[i][j] = board[pos];
      }
      
      /* When evaluating influence after a move, the newly placed
       * stone will have the invalid dragon id -1.
       */
      if (IS_STONE(board[pos])) {
	if (!dragons_known || saved_stones[pos] == INFLUENCE_SAVED_STONE) {
	  if (q->p[i][j] == WHITE)
	    q->white_strength[i][j] = DEFAULT_STRENGTH;
	  else if (q->p[i][j] == BLACK)
	    q->black_strength[i][j] = DEFAULT_STRENGTH;
	}
	else if (saved_stones[pos] != INFLUENCE_CAPTURED_STONE) {
	  ASSERT1(dragon[pos].id != -1, pos);
	  if (q->p[i][j] == WHITE) {
	    if (color == BLACK && DRAGON2(pos).safety == CRITICAL)
	      q->white_strength[i][j] = 0.0;
	    else
	      q->white_strength[i][j] = (DEFAULT_STRENGTH
					 * strength_map[DRAGON2(pos).safety]);
	  }
	  else if (q->p[i][j] == BLACK) {
	    if (color == WHITE && DRAGON2(pos).safety == CRITICAL)
	      q->black_strength[i][j] = 0.0;
	    else
	      q->black_strength[i][j] = (DEFAULT_STRENGTH
					 * strength_map[DRAGON2(pos).safety]);
	  }
	}
      }
    }
}

/* Adds an influence source at position pos with prescribed strength
 * and attenuation. color can be BLACK, WHITE or both. If there
 * already exists an influence source of the respective color at pos
 * that is stronger than the new one, we do nothing.
 */
static void
add_influence_source(int pos, int color, float strength, float attenuation,
                     struct influence_data *q)
{
  int m = I(pos);
  int n = J(pos);
  
  if ((color & WHITE) && (q->white_strength[m][n] < strength)) {
    q->white_strength[m][n] = strength;
    q->white_attenuation[m][n] = attenuation;
  }
  
  if ((color & BLACK) && (q->black_strength[m][n] < strength)) {
    q->black_strength[m][n] = strength;
    q->black_attenuation[m][n] = attenuation;
  }
}

/* Experimental influence: Adds an intrusion as an entry in the list
 * q->intrusions.
 */
static void
enter_intrusion_source(int source_pos, int strength_pos,
                       float strength, float attenuation,
                       struct influence_data *q)
{
  if (q->intrusion_counter >= MAX_INTRUSIONS) {
    DEBUG(DEBUG_INFLUENCE, "intrusion list exhausted\n");
    return;
  }
  q->intrusions[q->intrusion_counter].source_pos = source_pos;
  q->intrusions[q->intrusion_counter].strength_pos = strength_pos;
  q->intrusions[q->intrusion_counter].strength = strength;
  q->intrusions[q->intrusion_counter].attenuation = attenuation;
  q->intrusion_counter++;
}

/* Experimental influence: Comparison of intrusions datas, to sort them. */
static int
compare_intrusions(const void *p1, const void *p2)
{
  const struct intrusion_data *intr1 = p1;
  const struct intrusion_data *intr2 = p2;
  if (intr1->source_pos - intr2->source_pos != 0) {
    return (intr1->source_pos - intr2->source_pos);
  }
  else if (intr1->strength_pos - intr2->strength_pos != 0) {
    return (intr1->strength_pos - intr2->strength_pos);
  }
  else if (intr1->strength > intr2->strength) {
    return 1;
  }
  else
    return -1;
}

/* Experimental influence: This function goes through the list of 
 * intrusion sources, and adds the intrusion as influence sources for color. 
 * The strength is corrected so that each stone's intrusions sources
 * can have total strength of at most 60%/100% of the strength of the stone.
 * (100% is if q=&followup_influence, 60% otherwise).
 */
static void
add_marked_intrusions(struct influence_data *q, int color)
{
  int i;
  int j = 0;
  int source_pos;
  float strength_sum;
  float correction;
  float source_strength;
  float allowed_strength;
  gg_sort(q->intrusions, q->intrusion_counter, sizeof(q->intrusions[0]),
          compare_intrusions);

  /* Go through all intrusion sources. */
  for (i = 0; i < q->intrusion_counter; i = j) {
    strength_sum = 0.0;
    source_pos = q->intrusions[i].source_pos;
    /* "Anonymous" intrusios go in uncorrected. */
    if (source_pos == NO_MOVE) {
      add_influence_source(q->intrusions[i].strength_pos, color,
                           q->intrusions[j].strength,
                           q->intrusions[j].attenuation, q);
      DEBUG(DEBUG_INFLUENCE, "Adding %s intrusion at %1m, value %f\n",
	    (color == BLACK) ? "black" : "white",
	    q->intrusions[j].strength_pos, q->intrusions[j].strength);
      j = i+1;
      continue;
    }
    if (color == BLACK) {
      source_strength = q->black_strength[I(source_pos)][J(source_pos)];
    }
    else {
      source_strength = q->white_strength[I(source_pos)][J(source_pos)];
    }

    /* First loop: Determine correction factor. */
    for (j = i; (j < q->intrusion_counter)
                 && (q->intrusions[j].source_pos == source_pos); j++) {
      /* Of identical strength positions, only take strongest value. */
      if (j == i
          || q->intrusions[j].strength_pos != q->intrusions[j-1].strength_pos)
        strength_sum += q->intrusions[j].strength;
    }
    if (q == &followup_influence)
      allowed_strength = source_strength;
    else
      allowed_strength = 0.6 * source_strength;
    if (strength_sum > allowed_strength)
      correction = (allowed_strength / strength_sum);
    else
      correction = 1.0;

    /* Second loop: Add influence sources. */
    for (j = i; (j < q->intrusion_counter)
                 && (q->intrusions[j].source_pos == source_pos); j++) {
      /* Of identical strenght positions, only take strongest value. */
      if (j == i || q->intrusions[j].strength_pos
                    != q->intrusions[j-1].strength_pos) {
        add_influence_source(q->intrusions[j].strength_pos, color,
                             correction * q->intrusions[j].strength,
                             q->intrusions[j].attenuation, q);
        DEBUG(DEBUG_INFLUENCE,
              "Adding %s intrusion for %1m at %1m, value %f (correction %f)\n",
              (color == BLACK) ? "black" : "white", source_pos,
              q->intrusions[j].strength_pos,
              correction * q->intrusions[j].strength, correction);
      }
    }
  }
}

/* Callback for the matched patterns in influence.db and barriers.db.
 * The pattern classes used here are:
 * A - Barrier pattern, where O plays first and X tries to block influence.
 * D - Barrier pattern, where O plays first and O tries to block influence.
 * B - Intrusion patterns, adding a low intensity influence source.
 * E - Enhance patterns, FIXME: document this one!
 * t - Non-territory patterns, marking vertices as not territory.
 * I - Invasion patterns, adding a low intensity influence source.
 * e - Escape bonus. Used together with I to increase the value substantially
 *     if escape influence is being computed.
 *
 * Classes A, D, and B are matched with color as O, and it is assumed
 * that O is in turn to move. Classes E and I are matched with either
 * color as O.
 */
static void
influence_callback(int m, int n, int color, struct pattern *pattern, int ll,
		   void *data)
{
  int pos;
  int k;
  struct influence_data *q = data;
  
  /* Patterns marked FY get ignored in experimental influence,
   * those marked Y in standard influence.
   */
  if (pattern->class & CLASS_Y) 
    if (((pattern->class & CLASS_F)
         && experimental_influence)
        || (!(pattern->class & CLASS_F) 
            && !experimental_influence))
    return;

  /* We currently ignore enhancement patterns in experimental influence. */
  if ((pattern->class & CLASS_E)
      && experimental_influence)
    return;

  /* Don't use invasion (I) patterns when scoring. */
  if (doing_scoring && (pattern->class & CLASS_I))
    return;
  
  /* Loop through pattern elements to see if an A or D pattern
   * can possibly have any effect. If not we can skip evaluating
   * constraint and/or helper. */
  if (pattern->class & (CLASS_A | CLASS_D)) {
    int something_to_do = 0;
    for (k = 0; k < pattern->patlen; ++k) { /* match each point */
      int x, y;
      int blocking_color;
      if (pattern->patn[k].att != ATT_comma
	  && (!experimental_influence || pattern->patn[k].att != ATT_not))
	break;  /* All commas are guaranteed to come first. */

      /* transform pattern real coordinate */
      TRANSFORM(pattern->patn[k].x, pattern->patn[k].y, &x, &y, ll);
      x += m;
      y += n;

      /* Territorial connection, making a barrier for opponent influence. */
      if (pattern->class & CLASS_D)
	blocking_color = color;
      else
	blocking_color = OTHER_COLOR(color);
      if ((blocking_color == WHITE
	   && q->black_permeability[x][y] != 0.0)
	  || (blocking_color == BLACK
	      && q->white_permeability[x][y] != 0.0)) {
	something_to_do = 1;
	break;
      }
    }
    if (!something_to_do)
      return;
  }

  /* FIXME: Integrate the following loop into the previous one. */
  
  /* Require that all O stones in the pattern are tactically safe for
   * territorial connection patterns of type D and X stones for type
   * A. Both colors must be tactically safe for patterns of class B.
   * For patterns of class B, t, D and E, O stones must have non-zero
   * influence strength. Similarly for patterns of class A and t, X
   * stones must have non-zero influence strength.
   *
   * Patterns also having class s are an exception from this rule.
   */
  if ((pattern->class & (CLASS_D | CLASS_A | CLASS_B | CLASS_E | CLASS_t))
      && !(pattern->class & CLASS_s)) {
    for (k = 0; k < pattern->patlen; ++k) { /* match each point */
      if ((pattern->patn[k].att == ATT_O
	   && (pattern->class & (CLASS_D | CLASS_B | CLASS_E | CLASS_t)))
	  || (pattern->patn[k].att == ATT_X
	      && (pattern->class & (CLASS_A | CLASS_B | CLASS_t)))) {
	/* transform pattern real coordinate */
	int x, y;
	TRANSFORM(pattern->patn[k].x, pattern->patn[k].y, &x, &y, ll);
	x += m;
	y += n;
	if (pattern->class & CLASS_E) {
	  if ((color == WHITE && q->white_strength[x][y] == 0.0)
	      || (color == BLACK && q->black_strength[x][y] == 0.0))
	    return; /* Match failed. */
	}
	/* FIXME: This test is probably not necessary any more. */
	else if (!(pattern->class & (CLASS_D | CLASS_B | CLASS_t))) {
	  if ((stackp == 0 && worm[POS(x, y)].attack_codes[0] != 0)
	      || attack(POS(x, y), NULL) != 0)
	    return; /* Match failed */
	}
	/* One test left for class B and t. */
	if ((pattern->class & (CLASS_B | CLASS_t))
	    && pattern->patn[k].att == ATT_O) {
	  if ((color == WHITE && q->white_strength[x][y] == 0.0)
	      || (color == BLACK && q->black_strength[x][y] == 0.0))
	    return; /* Match failed. */
	}
	
	if ((pattern->class & (CLASS_A | CLASS_t))
	    && pattern->patn[k].att == ATT_X) {
	  if ((color == BLACK && q->white_strength[x][y] == 0.0)
	      || (color == WHITE && q->black_strength[x][y] == 0.0))
	    return; /* Match failed. */
	}
	
	if (pattern->class & CLASS_D) {
	  gg_assert(pattern->patn[k].att == ATT_O);
	  if ((color == WHITE && q->white_strength[x][y] == 0.0)
	      || (color == BLACK && q->black_strength[x][y] == 0.0))
	    return; /* Match failed. */
	}
      }
    }
  }

  pos = AFFINE_TRANSFORM(pattern->movei, pattern->movej, ll, m, n);

  /* If the pattern has a constraint, call the autohelper to see
   * if the pattern must be rejected.
   */
  if (pattern->autohelper_flag & HAVE_CONSTRAINT) {
    if (!pattern->autohelper(pattern, ll, pos, color, 0))
      return;
  }

  /* If the pattern has a helper, call it to see if the pattern must
   * be rejected.
   */
  if (pattern->helper) {
    if (!pattern->helper(pattern, ll, pos, color)) {
      DEBUG(DEBUG_INFLUENCE,
	    "Influence pattern %s+%d rejected by helper at %1m\n",
	    pattern->name, ll, pos);
      return;
    }
  }

  DEBUG(DEBUG_INFLUENCE, "influence pattern '%s'+%d matched at %1m\n",
	pattern->name, ll, POS(m, n));

  /* For t patterns, everything happens in the action. */
  if ((pattern->class & CLASS_t)
      && (pattern->autohelper_flag & HAVE_ACTION)) {
    pattern->autohelper(pattern, ll, pos, color, INFLUENCE_CALLBACK);
  }
  
  
  /* For I patterns, add a low intensity, both colored, influence
   * source at *.
   */
  if (pattern->class & CLASS_I) {
    int this_color = EMPTY;
    if (q->color_to_move == EMPTY || (pattern->class & CLASS_s))
      this_color = BLACK | WHITE;
    else if (q->color_to_move != color)
      this_color = q->color_to_move;

    /* Increase strength if we're computing escape influence. */
    if (q == &escape_influence && (pattern->class & CLASS_e))
      add_influence_source(pos, this_color,
			   20 * pattern->value, 1.5, q);
    else
      add_influence_source(pos, this_color, pattern->value, 1.5, q);

    DEBUG(DEBUG_INFLUENCE,
	  "  low intensity influence source at %1m, strength %f, color %C\n",
	  pos, pattern->value, this_color);
    return;
  }
  
  /* For E patterns, add a new influence source of the same color and
   * pattern defined strength at *.
   */
  if (pattern->class & CLASS_E) {
    add_influence_source(pos, color,
			 pattern->value, DEFAULT_ATTENUATION, q);
    DEBUG(DEBUG_INFLUENCE,
	  "  extra %C source at %1m, strength %f\n", color,
	  pos, pattern->value);
    return;
  }
  
  /* Loop through pattern elements and perform necessary actions
   * for A, D, B, and t patterns.
   */
  for (k = 0; k < pattern->patlen; ++k) { /* match each point */
    if (((pattern->class & (CLASS_D | CLASS_A))
	 && (pattern->patn[k].att == ATT_comma
	     || (pattern->patn[k].att == ATT_not && experimental_influence)))
	|| ((pattern->class & CLASS_B)
	    && pattern->patn[k].att == ATT_not)) {
      /* transform pattern real coordinate */
      int x, y;
      TRANSFORM(pattern->patn[k].x, pattern->patn[k].y, &x, &y, ll);
      x += m;
      y += n;

      /* Territorial connection, making a barrier for opponent influence. */
      if (pattern->class & (CLASS_A | CLASS_D)) {
	int blocking_color;
	if (pattern->class & CLASS_D)
	  blocking_color = color;
	else
	  blocking_color = OTHER_COLOR(color);
	DEBUG(DEBUG_INFLUENCE, "  barrier for %s influence at %m\n",
	      color_to_string(OTHER_COLOR(blocking_color)), x, y);
	if (pattern->patn[k].att == ATT_comma) {
	  if (blocking_color == WHITE)
	    q->black_permeability[x][y] = 0.0;
	  else
	    q->white_permeability[x][y] = 0.0;
	}
	/* Weak barrier at !-marked points. */
	else {
	  if (blocking_color == WHITE)
	    q->black_permeability[x][y] *= 0.7;
	  else
	    q->white_permeability[x][y] *= 0.7;
	  
	}
      }
      
      /* Low intensity influence source for the color in turn to move. */
      if (pattern->class & CLASS_B) {
        if (experimental_influence)
          enter_intrusion_source(POS(m, n), POS(x, y), pattern->value,
	  		         EXP_DEFAULT_ATTENUATION, q);
        else
          add_influence_source(POS(x, y), color,
			       pattern->value, DEFAULT_ATTENUATION, q);
	DEBUG(DEBUG_INFLUENCE, "  intrusion at %m\n", x, y);
      }
    }
  }
}

/* Callback for matched barriers patterns in followup influence.
 * This adds an intrusion source for all B patterns in barriers.db for
 * the color that has made a move if all the following conditions are
 * fulfilled:
 * - the anchor ("Q") is adjacent (directly or diagonally) to a "saved stone"
 *  (this is ensured by matchpat before calling back here)
 * - at least one of the O stones in the pattern is a saved stone.
 * - the usual pattern constraint ("; oplay_attack_either(...)") is fulfilled
 * - the pattern action (typically ">return (!xplay_attack(...))") returns
 *   true if  called with parameter action = FOLLOWUP_INFLUENCE_CALLBACK.
 * "Saved stones" are: the move played + tactically rescued stones + stones
 *                     in a critcal dragon brought to life by this move
 */
static void
followup_influence_callback(int m, int n, int color, struct pattern *pattern,
                            int ll, void *data)
{
  int k;
  int t;
  int saved_stone_involved = 0;
  struct influence_data *q = data;
  UNUSED(color);
 
  /* We use only B  patterns in followup influence. */
  if (!(pattern->class & CLASS_B))
    return;

  /* We check first whether a saved stone is involved. */
  for (k = 0; k < pattern->patlen; ++k) /* match each point */
    if (pattern->patn[k].att == ATT_O) {
      /* transform pattern real coordinate */
      int x, y;
      TRANSFORM(pattern->patn[k].x, pattern->patn[k].y, &x, &y, ll);
      x += m;
      y += n;
      if (q->w[x][y] == MARKED)
        saved_stone_involved = 1;
    }
  
  if (!saved_stone_involved)
    return;


  t = AFFINE_TRANSFORM(pattern->movei, pattern->movej, ll, m, n);
  /* If the pattern has a constraint, call the autohelper to see
   * if the pattern must be rejected.
   */
  if (pattern->autohelper_flag & HAVE_CONSTRAINT) {
    if (!pattern->autohelper(pattern, ll, t, color, 0))
      return;
  }

  /* If the pattern has a helper, call it to see if the pattern must
   * be rejected.
   */
  if (pattern->helper) {
    if (!pattern->helper(pattern, ll, t, color)) {
      DEBUG(DEBUG_INFLUENCE,
            "Influence pattern %s+%d rejected by helper at %1m\n",
            pattern->name, ll, t);
      return;
    }
  }
 
 /* Actions in B patterns are used as followup specific constraints. */
 if ((pattern->autohelper_flag & HAVE_ACTION)
     && !pattern->autohelper(pattern, ll, t, color,
                             FOLLOWUP_INFLUENCE_CALLBACK))
    return;

  DEBUG(DEBUG_INFLUENCE, "influence pattern '%s'+%d matched at %1m\n",
	pattern->name, ll, POS(m, n));

  for (k = 0; k < pattern->patlen; ++k)  /* match each point */
    if (pattern->patn[k].att == ATT_not) {
      /* transform pattern real coordinate */
      int pos;
      pos = AFFINE_TRANSFORM(pattern->patn[k].x, pattern->patn[k].y,
			     ll, m, n);

      /* Low intensity influence source for the color in turn to move. */
      enter_intrusion_source(POS(m, n), pos, pattern->value,
			     EXP_DEFAULT_ATTENUATION, q);
      DEBUG(DEBUG_INFLUENCE, "  followup for %1m: intrusion at %1m\n",
            POS(m, n), pos);
    }
}

/* Called from actions for t patterns. Marks (pos) as not being
 * territory for (color).
 */
void
influence_mark_non_territory(int pos, int color)
{
  DEBUG(DEBUG_INFLUENCE, "  non-territory for %C at %1m\n", color, pos);
  current_influence->non_territory[I(pos)][J(pos)] |= color;
}

/* Match the patterns in influence.db and barriers.db in order to add:
 * - influence barriers,
 * - extra influence sources at possible invasion and intrusion points, and
 * - extra influence induced by strong positions.
 * Reduce permeability around each living stone.
 * Reset permeability to 1.0 at intrusion points.
 */
static void
find_influence_patterns(struct influence_data *q, int color)
{
  int m, n;

  current_influence = q;
  matchpat(influence_callback, ANCHOR_COLOR, &influencepat_db, q, NULL);
  if (color != EMPTY)
    matchpat(influence_callback, color, &barrierspat_db, q, NULL);

  if (experimental_influence)
    add_marked_intrusions(q, color);

  /* When color == EMPTY, we introduce a weaker kind of barriers
   * manually instead of searching for patterns.
   */
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++)
      if (IS_STONE(q->p[m][n])) {
	int k;
	for (k = 0; k < 8; k++) {
	  int dm = deltai[k];
	  int dn = deltaj[k];
	  if (ON_BOARD2(m+dm, n+dn) && q->p[m+dm][n+dn] == EMPTY) {
	    /* Reduce less diagonally. */
	    float reduction = (k < 4) ? 0.25 : 0.5;
	    if (q->p[m][n] == BLACK)
	      q->white_permeability[m+dm][n+dn] *= reduction;
	    else
	      q->black_permeability[m+dm][n+dn] *= reduction;
	  }
	}
      }
  
  /* It may happen that we have a low intensity influence source at a
   * blocked intersection (due to an intrusion). Reset the
   * permeability at this point.
   */
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      if (q->p[m][n] == EMPTY && q->white_strength[m][n] > 0.0
	  && q->white_permeability[m][n] != 1.0) {
	DEBUG(DEBUG_INFLUENCE, "  black block removed from %m\n", m, n);
	q->white_permeability[m][n] = 1.0;
      }
      if (q->p[m][n] == EMPTY && q->black_strength[m][n] > 0.0
	  && q->black_permeability[m][n] != 1.0) {
	DEBUG(DEBUG_INFLUENCE, "  white block removed from %m\n", m, n);
	q->black_permeability[m][n] = 1.0;
      }
    }
}

/* Compute the influence values for both colors, after having made a
 * move for OTHER_COLOR(color) at (m, n). If these coordinates are -1
 * no move is made. In any case it's assumed that color is in turn to
 * move. (This affects the barrier patterns (class A, D) and intrusions
 * (class B).
 */
static void
compute_influence(struct influence_data *q, int color, int m, int n,
		  int dragons_known, char no_influence[BOARDMAX],
		  char saved_stones[BOARDMAX])
{
  int i, j;
  char dummy_saved_stones[BOARDMAX];
  if (saved_stones != NULL)
    init_influence(q, color, dragons_known, saved_stones);
  else {
    memset(dummy_saved_stones, 0, sizeof(dummy_saved_stones));
    init_influence(q, color, dragons_known, dummy_saved_stones);
  }

#if 0
  /* This is used when computing escape influence to remove the
   * influence from the escaping dragon.
   */
  if (no_influence) {
    for (i = 0; i < board_size; i++)
      for (j = 0; j < board_size; j++)
	if (no_influence[i][j]) {
	  q->p[i][j] = EMPTY;
	  q->white_strength[i][j] = 0.0;
	  q->black_strength[i][j] = 0.0;
	  q->white_permeability[i][j] = 1.0;
	  q->black_permeability[i][j] = 1.0;
	}
  }
#else
  UNUSED(no_influence);
#endif
  
  if (q != &escape_influence)
    find_influence_patterns(q, color);
  else
    find_influence_patterns(q, EMPTY);
  
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      if (q->white_strength[i][j] > 0.0)
	accumulate_influence(q, i, j, WHITE);
      if (q->black_strength[i][j] > 0.0)
	accumulate_influence(q, i, j, BLACK);
    }
  segment_influence(q);
  
  if (((q == &initial_influence || q == &initial_opposite_influence)
       && (printmoyo & PRINTMOYO_INITIAL_INFLUENCE))
      || (m == debug_influence_i
	  && n == debug_influence_j && m >= 0)) {
    if (q == &initial_opposite_influence)
      print_influence(q, (dragons_known ? "dragons_known, opposite, color"
			  : "dragons_unknown, opposite, color"));
    else
      print_influence(q, dragons_known ? "dragons_known" : "dragons_unknown");
  }
}

/* Return the color of the territory at (m, n). If it's territory for
 * neither color, EMPTY is returned.
 * The definition of territory in terms of the influences is totally
 * ad hoc.
 */
static int
whose_territory(struct influence_data *q, int m, int n)
{
  float bi = q->black_influence[m][n];
  float wi = q->white_influence[m][n];

  ASSERT_ON_BOARD2(m, n);
  
  if (bi > 0.0 && wi == 0.0)
    return BLACK;

  if (wi > 0.0 && bi == 0.0)
    return WHITE;

  return EMPTY;
}

/* Return the color who has a moyo at (m, n). If neither color has a
 * moyo there, EMPTY is returned. The definition of moyo in terms of the
 * influences is totally ad hoc.
 */
static int
whose_moyo(struct influence_data *q, int m, int n)
{
  float bi = q->black_influence[m][n];
  float wi = q->white_influence[m][n];

  int territory_color = whose_territory(q, m, n);
  if (territory_color != EMPTY)
    return territory_color;
  
  if (bi > 7.0 * wi && bi > 5.0 && wi < 10.0)
    return BLACK;

  if (wi > 7.0 * bi && wi > 5.0 && bi < 10.0)
    return WHITE;
  
  return EMPTY;
}

/* Return the color who has a moyo at (m, n). If neither color has a
 * moyo there, EMPTY is returned.
 * The definition of moyo in terms of the influences is totally ad
 * hoc.
 *
 * This differs from whose_moyo() in that it never counts moyo for
 * tactically unstable stones, which is useful when the surrounding
 * moyo size is estimated. It also doesn't count moyo where there is
 * an eye space inhibition.
 */
static int
whose_moyo_restricted(struct influence_data *q, int m, int n)
{
  float bi = q->black_influence[m][n];
  float wi = q->white_influence[m][n];
  int color;

  int territory_color = whose_territory(q, m, n);

  if (worm[POS(m, n)].attack_codes[0] != 0
      && worm[POS(m, n)].defend_codes[0] != 0)
    return EMPTY;
  
  /* default */
  if (territory_color != EMPTY)
    color = territory_color;
  else if ((bi > 10.0 * wi && bi > 10.0 && wi < 10.0) || bi > 25.0 * wi)
    color = BLACK;
  else if ((wi > 10.0 * bi && wi > 10.0 && bi < 10.0) || wi > 25.0 * bi)
    color = WHITE;
  else
    color = EMPTY;
  
  if (color == WHITE && (white_eye[POS(m, n)].type & INHIBIT_CONNECTION))
    return EMPTY;
  
  if (color == BLACK && (black_eye[POS(m, n)].type & INHIBIT_CONNECTION))
    return EMPTY;
  
  return color;
}


/* Return the color who has dominating influence ("area") at (m, n).
 * If neither color dominates the influence there, EMPTY is returned.
 * The definition of area in terms of the influences is totally ad
 * hoc.
 */
static int
whose_area(struct influence_data *q, int m, int n)
{
  float bi = q->black_influence[m][n];
  float wi = q->white_influence[m][n];

  int moyo_color = whose_moyo(q, m, n);
  if (moyo_color != EMPTY)
    return moyo_color;
  
  if (bi > 3.0 * wi && bi > 1.0 && wi < 40.0)
    return BLACK;

  if (wi > 3.0 * bi && wi > 1.0 && bi < 40.0)
    return WHITE;
  
  return EMPTY;
}

#define MAX_INTERPOLATION_STEPS 20
struct interpolation_data
{
  int sections;
  float range_lowerbound;
  float range_upperbound;
  float values[MAX_INTERPOLATION_STEPS + 1];
};

static float
interpolate(struct interpolation_data *f, float x)
{
  int i;
  float ratio;
  float diff;
  if (x < f->range_lowerbound)
    return f->values[0];
  else if (x > f->range_upperbound)
    return f->values[f->sections];
  else {
    ratio = ((float) f->sections) * (x - f->range_lowerbound)
              /(f->range_upperbound - f->range_lowerbound);
    i = ratio;
    diff = ratio - ((float)i);
    return ((1-diff)*f->values[i] + diff* f->values[i+1]);
  }
}

/* This curve determines how much influence is needed at least to claim
 * an intersection as territory, in dependence of the "center value".
 * (In the center, more effort is needed to get territory!)
 * The center value is at the moment defined as follows:
 * If d1, d2 are the distance to vertical and horizontal border, resp.,
 * with d1<d2, then
 * central = 3 * d1 + min(d2, 4)
 * So this is mainly a function of the distance to the border; the
 * distance to the second-nearest border gives a small correction of at
 * most 4. This distinguishes edge and corner positions.
 *
 * The values for intersections close to a corner or to the edge have
 * to be consistent such that standard corner enclosure etc. are
 * sufficient to claim territory. The center values are more arbitrary
 * suspect to tuning.
 */
struct interpolation_data min_infl_for_territory =
  { 6,  0.0, 24.0, { 6.0, 15.0, 26.0, 36.0, 45.0, 50.0, 55.0 }};

/* Determines the territory correction factor in dependence of the ratio
 * ( influence of stronger color / min_infl_for_territory(intersection))
 */
struct interpolation_data territory_correction = 
  { 5, (float) 0.0, 1.0, {0.0, 0.25, 0.45, 0.65, 0.85, 1.0}};

static void
new_value_territory(struct influence_data *q, int m, int n, int color)
{
  int i, j;
  int dist_i, dist_j;
  float central;
  float first_guess[MAX_BOARD][MAX_BOARD];
  float ratio;
  float neighbor_val;
  int k;

  /* First loop: guess territory directly from influence. */
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      first_guess[i][j] = 0.0;

      if (q->p[i][j] == EMPTY) {
        float diff = 0.0;
        if (q->white_influence[i][j] + q->black_influence[i][j] > 0)
          diff = (q->white_influence[i][j] - q->black_influence[i][j])
                /(q->white_influence[i][j] + q->black_influence[i][j]);
        first_guess[i][j] = diff * diff * diff;

        dist_i = gg_min(i, board_size - i -1);
        dist_j = gg_min(j, board_size - j -1);
	if (dist_i > dist_j)
	  dist_i = gg_min(4, dist_i);
	else
	  dist_j = gg_min(4, dist_j);
	central = (float) 2 * gg_min(dist_i, dist_j) + dist_i + dist_j;
        ratio = gg_max(q->black_influence[i][j], q->white_influence[i][j])
                / interpolate(&min_infl_for_territory, central);
        first_guess[i][j] *= interpolate(&territory_correction, ratio);

	/* Dead stone, upgrade to territory. Notice that this is not
         * the point for a prisoner, which is added later. Instead
         * this is to make sure that the vertex is not regarded as
         * moyo or area. Also notice that the non-territory
         * degradation below may over-rule this decision.
	 */
	if (BOARD(i, j) == BLACK)
	  first_guess[i][j] = 1.0;
	else if (BOARD(i, j) == WHITE)
	  first_guess[i][j] = -1.0;
      }
      q->territory_value[i][j] = first_guess[i][j];
    }

  /* Second loop: Correct according to neighbour vertices. Each territory
   * value is degraded to the minimum value of its neighbors (unless this
   * neighbor has reduced permeability for the opponent's influence).
   */
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      /* Do not overrule dead stone territory above.
       * FIXME: This does not do what it claims to do. Correcting it
       * seems to break some tests, though.
       */
      if (q->p[i][j] == EMPTY) {
	/* Loop over all neighbors. */
        for (k = 0; k < 4; k++) {
          if (!ON_BOARD2(i+deltai[k],j+deltaj[k]))
            continue;
          if (q->territory_value[i][j] > 0.0) {
            /* White territory. */
            if (q->p[i+deltai[k]][j+deltaj[k]] != WHITE) {
	      neighbor_val =
		q->black_permeability[i+deltai[k]][j+deltaj[k]]
		  * first_guess[i+deltai[k]][j+deltaj[k]]
		+ (1 - q->black_permeability[i+deltai[k]][j+deltaj[k]])
		  * first_guess[i][j];
              q->territory_value[i][j]
                = gg_max(0, gg_min(q->territory_value[i][j], neighbor_val));
	    }
          }
          else {
            /* Black territory. */
            if (q->p[i+deltai[k]][j+deltaj[k]] != BLACK) {
	      neighbor_val =
		q->white_permeability[i+deltai[k]][j+deltaj[k]]
		  * first_guess[i+deltai[k]][j+deltaj[k]]
		+ (1 - q->white_permeability[i+deltai[k]][j+deltaj[k]])
		  * first_guess[i][j];
              q->territory_value[i][j]
                = gg_min(0, gg_max(q->territory_value[i][j], neighbor_val));
	    }
          }
        }
      }
    }

  /* Third loop: Nonterritory patterns, points for prisoners. */
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      if (q->p[i][j] == EMPTY) {
	/* If marked as non-territory for the color currently owning
         * it, reset the territory value.
	 */
	if (q->territory_value[i][j] > 0.0
	    && (q->non_territory[i][j] & WHITE))
	  q->territory_value[i][j] = 0.0;

	if (q->territory_value[i][j] < 0.0
	    && (q->non_territory[i][j] & BLACK))
	  q->territory_value[i][j] = 0.0;
	
	/* Dead stone, add one to the territory value. */
	if (BOARD(i, j) == BLACK)
	  q->territory_value[i][j] += 1.0;
	else if (BOARD(i, j) == WHITE)
	  q->territory_value[i][j] -= 1.0;
      }
    }

  /* Final correction. Never count the last played move as territory
   * for the color playing it. Ideally this should never happen, but
   * currently we need this workaround.
   */
  ASSERT2(color == EMPTY || ON_BOARD2(m, n), m, n);
  if (color == BLACK && q->territory_value[m][n] < 0.0)
    q->territory_value[m][n] = 0.0;
  else if (color == WHITE && q->territory_value[m][n] > 0.0)
    q->territory_value[m][n] = 0.0;
}

/* Give territorial value to each vertex.
 *
 * A vertex with a lively stone has territorial value of 0.
 * For other vertices the value is
 * 1 if the vertex is classified as territory.
 * 0.35 if it is classified as moyo
 * 0.13 if it is classified as area
 * 0.0 if it is classified as neutral
 * One point is added for a vertex with a dead stone.
 * Furthermore black points have a negative sign.
 *
 * The results are written to the territory_value[][] array of the
 * influence data.
 */
static void
value_territory(struct influence_data *q)
{
  int i, j;
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      q->territory_value[i][j] = 0.0;

      if (q->p[i][j] == EMPTY
	  || (q->black_strength[i][j] == 0 && q->white_strength[i][j] == 0)) {
	int owner = whose_territory(q, i, j);
	if (owner == BLACK)
	  q->territory_value[i][j] = -1.0;
	else if (owner == WHITE)
	  q->territory_value[i][j] = 1.0;
	else {
	  owner = whose_moyo(q, i, j);
	  if (owner == BLACK)
	    q->territory_value[i][j] = -0.35;
	  else if (owner == WHITE)
	    q->territory_value[i][j] = 0.35;
	  else {
           owner = whose_area(q, i, j);
	    if (owner == BLACK)
	      q->territory_value[i][j] = -0.13;
	    else if (owner == WHITE)
	      q->territory_value[i][j] = 0.13;
	  }
	}

	/* Dead stone, upgrade to territory. Notice that this is not
         * the point for a prisoner, which is added later. Instead
         * this is to make sure that the vertex is not regarded as
         * moyo or area. Also notice that the non-territory
         * degradation below may over-rule this decision.
	 */
	if (BOARD(i, j) == BLACK)
	  q->territory_value[i][j] = 1.0;
	else if (BOARD(i, j) == WHITE)
	  q->territory_value[i][j] = -1.0;

	/* If marked as non-territory for the color currently owning
         * it, reset the territory value.
	 */
	if (q->territory_value[i][j] > 0.0
	    && (q->non_territory[i][j] & WHITE))
	  q->territory_value[i][j] = 0.0;

	if (q->territory_value[i][j] < 0.0
	    && (q->non_territory[i][j] & BLACK))
	  q->territory_value[i][j] = 0.0;
	
	/* Dead stone, add one to the territory value. */
	if (BOARD(i, j) == BLACK)
	  q->territory_value[i][j] += 1.0;
	else if (BOARD(i, j) == WHITE)
	  q->territory_value[i][j] -= 1.0;
      }
    }
}


/* Segment the influence map into connected regions of territory,
 * moyo, or area. What to segment on is determined by the the function
 * pointer region_owner. The segmentation is performed for both
 * colors. The connected regions may include stones of the own color,
 * but only empty intersections (and dead opponent stones) count
 * toward the region size.
 */
static void
segment_region(struct influence_data *q, owner_function_ptr region_owner,
	       int type, int (*segmentation)[MAX_BOARD])
{
  int m, n;
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      if (q->w[m][n] == UNMARKED && region_owner(q, m, n) != EMPTY) {
	/* Found an unlabelled intersection. Use flood filling to find
         * the rest of the region.
	 */
	int size = 0;
	int queue_start = 0;
	int queue_end = 1;
	int color = region_owner(q, m, n);
	q->number_of_regions++;
	q->w[m][n] = MARKED;
	q->queuei[0] = m;
	q->queuej[0] = n;
	while (queue_start < queue_end) {
	  int i = q->queuei[queue_start];
	  int j = q->queuej[queue_start];
	  int k;
	  queue_start++;
	  if (q->p[i][j] != color)
	    size++;
	  segmentation[i][j] = q->number_of_regions;
	  for (k = 0; k < 4; k++) {
	    int di = deltai[k];
	    int dj = deltaj[k];
	    if (ON_BOARD2(i+di, j+dj)
		&& q->w[i+di][j+dj] == UNMARKED
		&& region_owner(q, i+di, j+dj) == color) {
	      q->queuei[queue_end] = i+di;
	      q->queuej[queue_end] = j+dj;
	      queue_end++;
	      q->w[i+di][j+dj] = MARKED;
	    }
	  }
	}
	if (color == WHITE)
	  q->region_type[q->number_of_regions] = WHITE_REGION | type;
	else
	  q->region_type[q->number_of_regions] = BLACK_REGION | type;
	q->region_size[q->number_of_regions] = size;
	if (0)
	  gprintf("Region %d of type %d (color %s) at %m. Size %d\n",
		  q->number_of_regions, q->region_type[q->number_of_regions],
		  color_to_string(color), m, n, size);
      }
    }
  /* Reset the working area w. */
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++)
      q->w[m][n] = UNMARKED;
}

/* Segment the influence map into connected regions of territory,
 * moyo, and area for both colors. The region numbers are stored in
 * the territory_segmentation, moyo_segmentation, and
 * area_segmentation arrays of the influence_data struct respectively.
 * All types of regions use the same numbering, with zero as a dummy
 * for nonregions. The region_type and region_size arrays hold
 * information about each region.
 */
static void
segment_influence(struct influence_data *q)
{
  int i, j;
  q->number_of_regions = 0;
  q->region_type[0] = 0;
  q->region_size[0] = 0;
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      q->territory_segmentation[i][j] = 0;
      q->moyo_segmentation[i][j] = 0;
      q->area_segmentation[i][j] = 0;
    }
  segment_region(q, whose_territory, IS_TERRITORY, q->territory_segmentation);
  segment_region(q, whose_moyo_restricted, IS_MOYO, q->moyo_segmentation);
  segment_region(q, whose_area,      IS_AREA,      q->area_segmentation);
}

/* Return the size of the moyo around (pos).
 */
int
influence_get_moyo_size(int pos, int color)
{
  int result1 = 0;
  int result2 = 0;
  struct influence_data *q;

  q = &initial_influence;

  /* Does the color match. */
  if ((q->region_type[q->moyo_segmentation[I(pos)][J(pos)]] == WHITE_MOYO)
      ^ (color == BLACK))
    result1 = q->region_size[q->moyo_segmentation[I(pos)][J(pos)]];

  q = &initial_opposite_influence;

  /* Does the color match. */
  if ((q->region_type[q->moyo_segmentation[I(pos)][J(pos)]] == WHITE_MOYO)
      ^ (color == BLACK))
    result2 = q->region_size[q->moyo_segmentation[I(pos)][J(pos)]];

  return gg_min(result1, result2);
}

/* Export the moyo segmentation. If (opposite) is true, then
 * initial_opposite_influence is used, otherwise initial_influence.
 */
void
influence_get_moyo_segmentation(int opposite, struct moyo_data *moyos)
{
  int m, n;
  int min_moyo_id;
  int max_moyo_id;
  int i;
  struct influence_data *q;

  min_moyo_id = MAX_REGIONS;
  max_moyo_id = 0;

  if (opposite)
    q = &initial_opposite_influence;
  else
    q = &initial_influence;

  /* Find out range of region ids used by moyos. */
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      if (q->moyo_segmentation[m][n] != 0) {
        min_moyo_id = gg_min(min_moyo_id, q->moyo_segmentation[m][n]);
        max_moyo_id = gg_max(max_moyo_id, q->moyo_segmentation[m][n]);
      }
    }
  moyos->number = max_moyo_id - min_moyo_id + 1;

  /* Export segmentation. */
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      if (q->moyo_segmentation[m][n] != 0) {
        moyos->segmentation[POS(m, n)]
	  = q->moyo_segmentation[m][n] - min_moyo_id + 1;
      }
      else
        moyos->segmentation[POS(m, n)] = 0;
    }
  
  /* Export size and owner info. */
  for (i = min_moyo_id; i <= max_moyo_id; i++) {
    moyos->size[i - min_moyo_id + 1] = q->region_size[i];
    if (q->region_type[i] & BLACK_REGION)
      moyos->owner[i - min_moyo_id + 1] = BLACK;
    else
      moyos->owner[i - min_moyo_id + 1] = WHITE;
  }
}

/* Export the territory valuation at an intersection from initial_influence;
 * it is given from (color)'s point of view.
 */
float
influence_initial_territory(int pos, int color)
{
  if (color == WHITE)
    return initial_influence.territory_value[I(pos)][J(pos)];
  else
    return -initial_influence.territory_value[I(pos)][J(pos)];
}

/* Compute the influence before a move has been made, which can
 * later be compared to the influence after a move. Assume that
 * the other color is in turn to move.
 */
void
compute_initial_influence(int color, int dragons_known)
{
  int i, j;
  int save_experimental_influence;

  save_experimental_influence = experimental_influence;
  if (!dragons_known)
    experimental_influence = 0;
  compute_influence(&initial_influence, OTHER_COLOR(color), -1, -1,
		    dragons_known, NULL, NULL);
  if (dragons_known) {
    if (experimental_influence)
      new_value_territory(&initial_influence, -1, -1, EMPTY);
    else
      value_territory(&initial_influence);
    if ((printmoyo & PRINTMOYO_VALUE_TERRITORY)
	&& (printmoyo & PRINTMOYO_INITIAL_INFLUENCE))
      print_influence_territory(&initial_influence,
				"territory (initial influence):\n");
  }

  compute_influence(&initial_opposite_influence, color, -1, -1,
		    dragons_known, NULL, NULL);
  /* Invalidate information in move_influence. */
  influence_movei = -1;
  influence_movej = -1;
  influence_color = EMPTY;
  /* Clear delta_territory cache. */
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      delta_territory_cache[POS(i, j)] = NOT_COMPUTED;
      followup_territory_cache[POS(i, j)] = NOT_COMPUTED;
    }

  experimental_influence = save_experimental_influence;
}

/* Redo the segmentation of the initial influence. */
void
resegment_initial_influence()
{
  segment_influence(&initial_influence);
  segment_influence(&initial_opposite_influence);
}

/* Experimental influence: Compute a followup influence for the move at
 * (m, n). Compute the territorial followup value.
 */
static void
compute_followup_influence(int m, int n, int color,
                           char saved_stones[BOARDMAX])
{
  int i, j;
  int ii;
  int k;
  char goal[BOARDMAX];

  UNUSED(m);
  UNUSED(n);  
  memcpy(&followup_influence, &move_influence, sizeof(move_influence));
 
  /* We mark the saved stones and their neighbors in the goal array
   * and in q->w.
   */
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      goal[POS(i,j)] = 0;
      followup_influence.w[i][j] = UNMARKED;
    }
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++)
      if (saved_stones[POS(i,j)]) {
	ii = POS(i, j);
        goal[ii] = 1;
	followup_influence.w[i][j] = MARKED;
	for (k = 0; k < 8; k++) 
	  if (board[ii] == board[ii+delta[k]])
	    goal[ii+delta[k]] = 1;
      }

  followup_influence.intrusion_counter = 0;

  current_influence = &followup_influence;
  /* Match B patterns for saved stones. */
  matchpat_goal_anchor(followup_influence_callback, color, &barrierspat_db, 
           	       &followup_influence, goal, 1);

  /* Reset the working area w. */
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++)
      followup_influence.w[i][j] = UNMARKED;
 
  /* Now add the intrusions. */
  add_marked_intrusions(&followup_influence, color);

  /* It may happen that we have a low intensity influence source at a
   * blocked intersection (due to an intrusion). Reset the
   * permeability at this point.
   */
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      if (followup_influence.p[i][j] == EMPTY
          && followup_influence.white_strength[i][j] > 0.0
	  && followup_influence.white_permeability[i][j] != 1.0) {
	DEBUG(DEBUG_INFLUENCE, "  black block removed from %m\n", i, j);
	followup_influence.white_permeability[i][j] = 1.0;
      }
      if (followup_influence.p[i][j] == EMPTY
          && followup_influence.black_strength[i][j] > 0.0
	  && followup_influence.black_permeability[i][j] != 1.0) {
	DEBUG(DEBUG_INFLUENCE, "  white block removed from %m\n", i, j);
	followup_influence.black_permeability[i][j] = 1.0;
      }
    }
  
  /* Spread influence for new influence sources. */
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++)
      if ((color == BLACK
          && followup_influence.black_strength[i][j]
             > move_influence.black_strength[i][j])
          || (color == WHITE
          && followup_influence.white_strength[i][j]
             > move_influence.white_strength[i][j]))
        accumulate_influence(&followup_influence, i, j, color);

}

/* Let color play at (m, n) and compute the influence after this move,
 * assuming that the other color is in turn to move next.
 */
static void
compute_move_influence(int m, int n, int color,
		       char saved_stones[BOARDMAX])
{
  /* Don't recompute if we already have the current values stored. */
  if (influence_movei == m
      && influence_movej == n
      && influence_color == color)
    return;

  if (tryko(POS(m, n), color, "compute_move_influence", EMPTY, NO_MOVE)) {
    increase_depth_values();
    compute_influence(&move_influence, OTHER_COLOR(color), m, n, 1,
		      NULL, saved_stones);
    if (experimental_influence)
      compute_followup_influence(m, n, color, saved_stones);
    decrease_depth_values();
    popgo();

    if (experimental_influence) {
      new_value_territory(&move_influence, m, n, color);
      new_value_territory(&followup_influence, m, n, color);
    }
    else
      value_territory(&move_influence);


    if (m == debug_influence_i
	&& n == debug_influence_j && m >= 0) {
      if (printmoyo & PRINTMOYO_VALUE_TERRITORY)
        print_influence_territory(&move_influence,
	    			  "territory (after move):\n");
      if (experimental_influence) {
        print_influence(&followup_influence, "followup influence");
        if (printmoyo & PRINTMOYO_VALUE_TERRITORY)
          print_influence_territory(&followup_influence,
                                    "territory (followup):\n");
      }
    }
  }
  else {
    gprintf("Computing influence for illegal move %m (move number %d)\n",
	    m, n, movenum+1);
    return;
  }

  influence_movei = m;
  influence_movej = n;
  influence_color = color;
}


/* Assume that the stones marked by the goal array do not generate
 * influence and compute influence. Influence based escape values are
 * returned in the escape_value array.  
 */

void
compute_escape_influence(char goal[BOARDMAX], int color,
			 int escape_value[BOARDMAX],
			 int dragons_known)
{
  int i, j;
  int k;
  int ii;
  int save_experimental_influence;

  /* IMPORTANT: This caching relies on the fact that the goal
   * parameter currently is not used.
   */
  static int cached_board[BOARDMAX];
  static int escape_values[BOARDMAX][4];
  static int active_caches[4];

  /* Encode the values of color and dragons_known into an integer
   * between 0 and 3.
   */
  int cache_number = 2 * (color == WHITE) + dragons_known;

  int board_was_cached = 1;

  /* Notice that we compare the out of board markers as well, in case
   * the board size should have changed between calls.
   */
  for (ii = BOARDMIN; ii < BOARDMAX; ii++) {
    if (cached_board[ii] != board[ii]) {
      cached_board[ii] = board[ii];
      board_was_cached = 0;
    }
  }

  if (!board_was_cached)
    for (k = 0; k < 4; k++)
      active_caches[k] = 0;
  
  if (active_caches[cache_number]) {
    for (ii = BOARDMIN; ii < BOARDMAX; ii++)
      if (ON_BOARD(ii))
	escape_value[ii] = escape_values[ii][cache_number];
    
    return;
  }

  
  /* Use traditional influence for escape influence. */
  save_experimental_influence = experimental_influence;
  experimental_influence = 0;
  compute_influence(&escape_influence, OTHER_COLOR(color), -1, -1,
		    dragons_known, goal, NULL);
  
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      ii = POS(i, j);

      if (whose_moyo(&escape_influence, i, j) == color)
       escape_value[ii] = 4;
      else if (whose_area(&escape_influence, i, j) == color)
       escape_value[ii] = 2;
      else if (whose_area(&escape_influence, i, j) == EMPTY)
       escape_value[ii] = 1;
      else
       escape_value[ii] = 0;
    }

  if (0 && (debug & DEBUG_ESCAPE) && verbose > 0) {
    print_numeric_influence(&escape_influence,
			    escape_influence.white_influence,
			    "%3.0f", 3, 1);
    print_numeric_influence(&escape_influence,
			    escape_influence.black_influence,
			    "%3.0f", 3, 1);
  }    
  experimental_influence = save_experimental_influence;

  /* Save the computed values in the cache. */
  for (ii = BOARDMIN; ii < BOARDMAX; ii++)
    if (ON_BOARD(ii))
      escape_values[ii][cache_number] = escape_value[ii];
  active_caches[cache_number] = 1;
}


/* Return the color who has territory at pos, or EMPTY. */
int
influence_territory_color(int pos)
{
  return whose_territory(&initial_influence, I(pos), J(pos));
}

/* Return the color who has moyo at pos, or EMPTY. */
int
influence_moyo_color(int pos)
{
  return whose_moyo(&initial_influence, I(pos), J(pos));
}

/* Return the color who has moyo at pos, or EMPTY, using influence
 * computed with the opposite color to move.
 */
int
influence_moyo_color_opposite(int pos)
{
  return whose_moyo(&initial_opposite_influence, I(pos), J(pos));
}

/* Return the color who has area at pos, or EMPTY. */
int
influence_area_color(int pos)
{
  return whose_area(&initial_influence, I(pos), J(pos));
}

/* Compute the difference in territory made by a move by color at (pos).
 * This also includes the changes in moyo and area.
 * In experimental-influence mode, followup_value must not be a NULL
 * pointer, and the followup_value will be returned there.
 */
float
influence_delta_territory(int pos, int color, char saved_stones[BOARDMAX],
                          float *followup_value)
{
  int i, j;
  float delta = 0.0;
  float followup_delta = 0.0;
  if (delta_territory_cache[pos] != NOT_COMPUTED) {
    if (experimental_influence) {
      gg_assert(followup_territory_cache[pos] != NOT_COMPUTED);
      gg_assert(followup_value != NULL);
      *followup_value = followup_territory_cache[pos];
    }
    return delta_territory_cache[pos];
  }
  if (0)
    gprintf("influence_delta_territory for %1m %s = ", pos,
	    color_to_string(color));
  compute_move_influence(I(pos), J(pos), color, saved_stones);

  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      float new_value = move_influence.territory_value[i][j];
      float old_value = initial_influence.territory_value[i][j];
      float followup_value = 0.0;
      if (experimental_influence)
        followup_value = followup_influence.territory_value[i][j];
      /* Negate values if we are black. */
      if (color == BLACK) {
	new_value = -new_value;
	old_value = -old_value;
        if (experimental_influence)
          followup_value = -followup_value;
      }
      
      if (new_value - old_value > 0.02
          || old_value - new_value > 0.02)
	DEBUG(DEBUG_TERRITORY, "  %1m:   - %m territory change %f (%f -> %f)\n",
	      pos, i, j, new_value - old_value, old_value, new_value);
      delta += new_value - old_value;
      if (experimental_influence)
        followup_delta += followup_value - new_value;
    }
  
  if (0)
    gprintf("%f\n", delta);
  delta_territory_cache[pos] = delta;
  if (experimental_influence) {
    gg_assert(followup_value != NULL);
    followup_territory_cache[pos] = followup_delta;
    *followup_value = followup_delta;
  }
  
  return delta;
}


/* Estimate the score. A positive value means white is ahead. The
 * score is estimated from the initial_influence, which must have been
 * computed in advance. The score estimate does not include captured
 * stones (i.e., the ones having been removed from the board) or komi.
 * moyo_coeff and area_coeff are the relative weights to be used for
 * the moyo and area difference respectively.
 */
#define DEBUG_INFLUENCE_SCORE 0
float
influence_estimate_score(float moyo_coeff, float area_coeff)
{
  int black_territory = 0;
  int white_territory = 0;
  int black_moyo = 0;
  int white_moyo = 0;
  int black_area = 0;
  int white_area = 0;
  float score;
  int i, j;

  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++)
      if (BOARD(i, j) == EMPTY) {
	if (whose_territory(&initial_influence, i, j) == BLACK) {
	  if (DEBUG_INFLUENCE_SCORE)
	    gprintf("%m black 1t\n", i, j);
	  black_territory++;
	}
	else if (whose_territory(&initial_influence, i, j) == WHITE) {
	  if (DEBUG_INFLUENCE_SCORE)
	    gprintf("%m white 1t\n", i, j);
	  white_territory++;
	}
	else if (whose_moyo(&initial_influence, i, j) == BLACK) {
	  if (DEBUG_INFLUENCE_SCORE)
	    gprintf("%m black 1m\n", i, j);
	  black_moyo++;
	}
	else if (whose_moyo(&initial_influence, i, j) == WHITE) {
	  if (DEBUG_INFLUENCE_SCORE)
	    gprintf("%m white 1m\n", i, j);
	  white_moyo++;
	}
	else if (whose_area(&initial_influence, i, j) == BLACK) {
	  if (DEBUG_INFLUENCE_SCORE)
	    gprintf("%m black 1a\n", i, j);
	  black_area++;
	}
	else if (whose_area(&initial_influence, i, j) == WHITE) {
	  if (DEBUG_INFLUENCE_SCORE)
	    gprintf("%m white 1a\n", i, j);
	  white_area++;
	}
      }
      else if (BOARD(i, j) == BLACK
	       && initial_influence.black_strength[i][j] == 0) {
	if (DEBUG_INFLUENCE_SCORE)
	  gprintf("%m white 2t\n", i, j);
	white_territory += 2;
      }
      else if (BOARD(i, j) == WHITE
	       && initial_influence.white_strength[i][j] == 0) {
	if (DEBUG_INFLUENCE_SCORE)
	  gprintf("%m black 2t\n", i, j);
	black_territory += 2;
      }

  DEBUG(DEBUG_SCORING, "black:%d %d %d, white: %d %d %d\n",
	black_territory, black_moyo,
	black_area, white_territory, white_moyo, white_area);
  
  score = (white_territory - black_territory
	   + moyo_coeff * (white_moyo - black_moyo)
	   + area_coeff * (white_area - black_area));
  
  return score;
}

/* Print the influence map when we have computed influence for the
 * move at (i, j).
 */
void
debug_influence_move(int i, int j)
{
  debug_influence_i = i;
  debug_influence_j = j;
}

/* Copy and encode influence data. */
static void
retrieve_influence(struct influence_data *q,
		   float white_influence[BOARDMAX],
		   float black_influence[BOARDMAX],
		   int influence_regions[BOARDMAX])
{
  int m, n;
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      white_influence[POS(m, n)] = q->white_influence[m][n];
      black_influence[POS(m, n)] = q->black_influence[m][n];
      if (whose_territory(q, m, n) == WHITE)
	influence_regions[POS(m, n)] = 3;
      else if (whose_territory(q, m, n) == BLACK)
	influence_regions[POS(m, n)] = -3;
      else if (whose_moyo(q, m, n) == WHITE)
	influence_regions[POS(m, n)] = 2;
      else if (whose_moyo(q, m, n) == BLACK)
	influence_regions[POS(m, n)] = -2;
      else if (whose_area(q, m, n) == WHITE)
	influence_regions[POS(m, n)] = 1;
      else if (whose_area(q, m, n) == BLACK)
	influence_regions[POS(m, n)] = -1;
      else
	influence_regions[POS(m, n)] = 0;
    }
}
  
/* Compute initial influence and export it. The color parameter tells
 * who is in turn to move.
 */
void
get_initial_influence(int color, int dragons_known,
		      float white_influence[BOARDMAX],
		      float black_influence[BOARDMAX],
		      int influence_regions[BOARDMAX])
{
  compute_initial_influence(color, dragons_known);
  retrieve_influence(&initial_influence, white_influence,
		     black_influence, influence_regions);
}

/* Compute influence after a move and export it.
 */
void
get_move_influence(int move, int color,
		   char saved_stones[BOARDMAX],
		   float white_influence[BOARDMAX],
		   float black_influence[BOARDMAX],
		   int influence_regions[BOARDMAX])
{
  compute_move_influence(I(move), J(move), color, saved_stones);
  retrieve_influence(&move_influence, white_influence,
		     black_influence, influence_regions);
}

/* Compute initial influence and print it. Notice that it's assumed
 * that the printmoyo global tells what information to print. The
 * color parameter tells who is in turn to move.
 */
void
print_initial_influence(int color, int dragons_known)
{
  compute_initial_influence(color, dragons_known);
  print_influence(&initial_influence, (dragons_known ? "dragons_known"
				       : "dragons_unknown"));

  print_influence(&initial_opposite_influence,
		  dragons_known ? "dragons_known, opposite color"
		  : "dragons_unknown, opposite color");
}

/* Compute influence after doing a move and print it. Notice that it's
 * assumed that the printmoyo global tells what information to print.
 */
void
print_move_influence(int pos, int color,
		     char saved_stones[BOARDMAX])
{
  compute_move_influence(I(pos), J(pos), color, saved_stones);
  print_influence(&move_influence, "after move, dragons known");

}

/* Print influence for debugging purposes. */
static void
print_influence(struct influence_data *q, const char *info_string)
{
  if (printmoyo & PRINTMOYO_ATTENUATION) {
    /* Print the attenuation values. */
    fprintf(stderr, "white attenuation (%s):\n", info_string);
    print_numeric_influence(q, q->white_attenuation, "%3.2f", 0, 0);
    fprintf(stderr, "black attenuation (%s):\n", info_string);
    print_numeric_influence(q, q->black_attenuation, "%3.2f", 0, 0);
  }

  if (printmoyo & PRINTMOYO_PERMEABILITY) {
    /* Print the white permeability values. */
    fprintf(stderr, "white permeability:\n");
    print_numeric_influence(q, q->white_permeability, "%3.1f", 0, 0);
    
    /* Print the black permeability values. */
    fprintf(stderr, "black permeability:\n");
    print_numeric_influence(q, q->black_permeability, "%3.1f", 0, 0);
  }

  if (printmoyo & PRINTMOYO_STRENGTH) {
    /* Print the strength values. */
    fprintf(stderr, "white strength:\n");
    if (experimental_influence)
      print_numeric_influence(q, q->white_strength, "%5.1f", 0, 0);
    else
      print_numeric_influence(q, q->white_strength, "%3.0f", 0, 1);
    fprintf(stderr, "black strength:\n");
    if (experimental_influence)
      print_numeric_influence(q, q->black_strength, "%5.1f", 0, 0);
    else
      print_numeric_influence(q, q->black_strength, "%3.0f", 0, 1);
  }

  if (printmoyo & PRINTMOYO_NUMERIC_INFLUENCE) {
    /* Print the white influence values. */
    fprintf(stderr, "white influence (%s):\n", info_string);
    if (experimental_influence)
      print_numeric_influence(q, q->white_influence, "%5.1f", 5, 0);
    else
      print_numeric_influence(q, q->white_influence, "%3.0f", 3, 1);
    /* Print the black influence values. */
    fprintf(stderr, "black influence (%s):\n", info_string);
    if (experimental_influence)
      print_numeric_influence(q, q->black_influence, "%5.1f", 5, 0);
    else
      print_numeric_influence(q, q->black_influence, "%3.0f", 3, 1);
  }

  if (printmoyo & PRINTMOYO_PRINT_INFLUENCE) {
    fprintf(stderr, "influence regions (%s):\n", info_string);
    print_influence_areas(q);
  }
}

/* Print the numerical territory valuation. */
static void
print_influence_territory(struct influence_data *q, const char *info_string)
{
  fprintf(stderr, info_string);
  print_numeric_influence(q, q->territory_value, "%5.2f", 5, 0);
}


char black_stone[8][10] = { "X", " X", "  X", "  X ", "  X  ", "   X  ",
                         "   X   ", "    X   "};
char white_stone[8][10] = { "O", " O", "  O", "  O ", "  O  ", "   O  ",
                         "   O   ", "    O   "};
/* Print numeric influence values.
 * If draw_stones is not zero, then it denotes the lenght (in characters)
 * of the numeric output fields.
 */ 
static void
print_numeric_influence(struct influence_data *q,
			float values[MAX_BOARD][MAX_BOARD],
			const char *format,
			int draw_stones,
			int mark_epsilon)
{
  int i, j;
  for (i = 0; i < board_size; i++) {
    for (j = 0; j < board_size; j++) {
      if (draw_stones && q->p[i][j] == WHITE)
	fprintf(stderr, white_stone[draw_stones]);
      else if (draw_stones && q->p[i][j] == BLACK)
	fprintf(stderr, black_stone[draw_stones]);
      else {
	if (mark_epsilon && values[i][j] > 0.0 && values[i][j] < 1.0)
	  fprintf(stderr, "eps");
	else
	  fprintf(stderr, format, values[i][j]);
	fprintf(stderr, " ");
      }
    }
    fprintf(stderr, "\n");
  }
  fprintf(stderr, "\n");
}

/* Draw colored board illustrating territory, moyo, and area. */
static void
print_influence_areas(struct influence_data *q)
{
  int i, j;
  start_draw_board();
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      int c = EMPTY;
      int color = GG_COLOR_BLACK;
      if (q->p[i][j] == WHITE) {
	c = 'O';
	color = GG_COLOR_BLACK;
      }
      else if (q->p[i][j] == BLACK) {
	c = 'X';
	color = GG_COLOR_BLACK;
      }
      else if (whose_territory(q, i, j) == WHITE) {
	c = 'o';
	color = GG_COLOR_CYAN;
      }
      else if (whose_territory(q, i, j) == BLACK) {
	c = 'x';
	color = GG_COLOR_CYAN;
      }
      else if (whose_moyo(q, i, j) == WHITE) {
	c = 'o';
	color = GG_COLOR_YELLOW;
      }
      else if (whose_moyo(q, i, j) == BLACK) {
	c = 'x';
	color = GG_COLOR_YELLOW;
      }
      else if (whose_area(q, i, j) == WHITE) {
	c = 'o';
	color = GG_COLOR_RED;
      }
      else if (whose_area(q, i, j) == BLACK) {
	c = 'x';
	color = GG_COLOR_RED;
      }
      draw_color_char(i, j, c, color);
    }
  end_draw_board();
}


/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */


/* interface.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* #include <stdlib.h> */
/* #include <string.h> */

/* #include "sgftree.h" */
/* #include "gnugo.h" */
/* #include "liberty.h" */
/* #include "gg_utils.h" */

/* #include "clock.h" */



/*
 * Initialize the gnugo engine. This needs to be called 
 * once only.
 */

void
init_gnugo(float memory)
{
  reading_cache_init(memory * 1024 * 1024);
  clear_board();

  dfa_match_init();
#if EXPERIMENTAL_READING
  tree_match_init();
#endif
}


/* ---------------------------------------------------------------- */

/*
 * Clear the board.
 */
void
gnugo_clear_board(int boardsize)
{
  gg_assert(MIN_BOARD <= boardsize && boardsize <= MAX_BOARD);
  board_size = boardsize;
  clear_board();
}

/* Set the komi */

void
gnugo_set_komi(float new_komi)
{
  komi = new_komi;
}

/* Place a stone on the board */

void
gnugo_add_stone(int i, int j, int color)
{
  add_stone(POS(i, j), color);
}

/* Remove a stone from the board */

void
gnugo_remove_stone(int i, int j)
{
  remove_stone(POS(i, j));
}

/* Return true if (i,j) is PASS_MOVE */

int
gnugo_is_pass(int i, int j)
{
  return is_pass(POS(i, j));
}

/* Play a move and start the clock */

void
gnugo_play_move(int i, int j, int color)
{
  play_move(POS(i, j), color);
  clock_push_button(color);
}

/* Undo n permanent moves. Returns 1 if successful and 0 if it fails.
 * If n moves cannot be undone, no move is undone.
 */

int
gnugo_undo_move(int n)
{
  return undo_move(n);
}


/*
 * Perform the moves and place the stones from the SGF node on the 
 * board. Return the color of the player whose turn it is to move.
 */

int
gnugo_play_sgfnode(SGFNode *node, int to_move)
{
  int i, j;
  SGFProperty *prop;

/*   emgena */
  int board_size = 19;

  for (prop = node->props; prop; prop = prop->next) {
    switch (prop->name) {
    case SGFAB:
      /* A black stone. */
      get_moveXY(prop, &i, &j, board_size);
      gnugo_add_stone(i, j, BLACK);
      break;

    case SGFAW:
      /* A white stone. */
      get_moveXY(prop, &i, &j, board_size);
      gnugo_add_stone(i, j, WHITE);
      break;

    case SGFPL:
      /* Player property - who is next to move? */
      if (prop->value[0] == 'w' || prop->value[0] == 'W')
	to_move = WHITE;
      else
	to_move = BLACK;
      break;

    case SGFW:
    case SGFB:
      /* An ordinary move. */
      to_move = (prop->name == SGFW) ? WHITE : BLACK;
      get_moveXY (prop, &i, &j, board_size);

      gnugo_play_move (i, j, to_move);
      to_move = OTHER_COLOR(to_move);
      break;
    }
  }

  return to_move;
}


/*
 * Play the moves in ROOT UNTIL movenumber is reached.
 * Return the color of the player whose turn it is to move.
 */
int
gnugo_play_sgftree(SGFNode *root, int *until, SGFNode **curnode)
{
  SGFNode *node;
  int next = BLACK;
  SGFProperty *prop;
  int i, j;
  int movenumber = 0;

  /* Start from the empty board. */
  gnugo_clear_board(board_size);

  for (node = root; node; node = node->child) {
    for (prop = node->props; prop; prop = prop->next) {
      switch (prop->name) {
      case SGFAB:
	get_moveXY(prop, &i, &j, board_size);
	gnugo_add_stone(i, j, BLACK);
	break;

      case SGFAW:
	get_moveXY(prop, &i, &j, board_size);
	gnugo_add_stone(i, j, WHITE);
	break;

      case SGFPL:
	if (prop->value[0] == 'w' || prop->value[0] == 'W')
	  next = WHITE;
	else
	  next = BLACK;
	break;

      case SGFW:
      case SGFB:
	next = prop->name == SGFW ? WHITE : BLACK;
	get_moveXY(prop, &i, &j, board_size);
	movenumber++;
	if (movenumber == *until) {
	  *curnode = node->parent;
	  return next;
	}
	gnugo_play_move(i, j, next);
	next = OTHER_COLOR(next);
	break;
      }
    }
  }
  *until = movenumber;

  return next;
}


/* Interface to is_legal(). */
int
gnugo_is_legal(int i, int j, int color)
{
  return is_legal(POS(i, j), color);
}


/* Interface to is_suicide(). */
int
gnugo_is_suicide(int i, int j, int color)
{
  return is_suicide(POS(i, j), color);
}


/* Interface to placehand. Sets up handicap pieces and
 * returns the number of placed handicap stones. */
int
gnugo_placehand(int handicap)
{
  return placehand(handicap);
}


/* Interface to sgffile_recordboard */
void
gnugo_recordboard(SGFNode *root)
{
  sgffile_recordboard(root);
}

/* Interface to placehand. Sets up handicap stones and
 * returns the number of placed handicap stones, updating the sgf file
 */
int
gnugo_sethand(int handicap, SGFNode *node)
{
  int stones = placehand(handicap);
  sgffile_recordboard(node);
  return stones;
}


/* Interface to genmove() */
int
gnugo_genmove(int *i, int *j, int color)
{
  return genmove(i, j, color);
}

/* Interface to attack() */
int
gnugo_attack(int m, int n, int *i, int *j)
{
  int retval;
  int move;

  retval = attack(POS(m, n), &move);

  if (i)
    *i = I(move);
  if (j)
    *j = J(move);
  
  return retval;
}


/* Interface to find_defense() */
int
gnugo_find_defense(int m, int n, int *i, int *j)
{
  int retval;
  int move;

  retval = find_defense(POS(m, n), &move);

  if (i)
    *i = I(move);
  if (j)
    *j = J(move);

  return retval;
}


/* Interface to who_wins */
void
gnugo_who_wins(int color, FILE *outfile)
{
  who_wins(color, outfile);
}


/* Put upper and lower score estimates into *upper, *lower and
 * return the average. A positive score favors white. In computing
 * the upper bound, CRITICAL dragons are awarded to white; in
 * computing the lower bound, they are awarded to black.
 */

float
gnugo_estimate_score(float *upper, float *lower)
{
  return estimate_score(lower, upper);
}


/* Interface to examine_position(). */

void
gnugo_examine_position(int color, int how_much)
{
  examine_position(color, how_much);
}

/* Accessor functions for internal board state. */

/* Report the komi. */

int 
gnugo_get_komi()
{
  return komi;
}

/* Place the board into the b array */

void
gnugo_get_board(int b[MAX_BOARD][MAX_BOARD])
{
  int i, j;
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++)
      b[i][j] = BOARD(i, j);
}

int
gnugo_get_boardsize()
{
  return board_size;
}

int
gnugo_get_move_number()
{
  return movenum;
}

/* ================================================================ */
/*                             Gameinfo                             */
/* ================================================================ */


/*
 * Initialize the structure.
 */

void
gameinfo_clear(Gameinfo *ginfo, int boardsize, float komi)
{
  ginfo->handicap = 0;
  
  gnugo_clear_board(boardsize);
  gnugo_set_komi(komi);
  ginfo->to_move = BLACK;
  sgftree_clear(&ginfo->game_record);

  /* Info relevant to the computer player. */
  ginfo->computer_player = WHITE; /* Make an assumption. */

  ginfo->outfilename[0] = '\0';
  ginfo->outfile = NULL;
}


/*
 * Print a gameinfo.
 */

void
gameinfo_print(Gameinfo *ginfo)
{
  printf("Board Size:   %d\n", board_size);
  printf("Handicap      %d\n", ginfo->handicap);
  printf("Komi:         %.1f\n", komi);
  printf("Move Number:  %d\n", movenum);

  printf("To Move:      %s\n", color_to_string(ginfo->to_move));

  printf("Computer player: ");
  if (ginfo->computer_player == WHITE)
    printf("White\n");
  else if (ginfo->computer_player == BLACK)
    printf("Black\n");
  else if (ginfo->computer_player == EMPTY)
    printf("Both (solo)\n");
  else
    printf("Nobody\n");
}


/*
 * Reads header info from sgf structure and sets the appropriate variables.
 */

void
gameinfo_load_sgfheader(Gameinfo *gameinfo, SGFNode *head)
{
  int bsize;
  int handicap;
  float komi;
  
  if (!sgfGetIntProperty(head, "SZ", &bsize))
    bsize = 19;
  if (!sgfGetFloatProperty(head, "KM", &komi))
    komi = 5.5;
  
  gnugo_clear_board(bsize);
  gnugo_set_komi(komi);
  
  if (!sgfGetIntProperty(head, "HA", &handicap) || handicap < 0)
    /* Handicap stones should appear as AW, AB properties in the sgf file. */
    handicap = 0;
  gameinfo->handicap = handicap;

  if (handicap > bsize * bsize - 1 || handicap < 0) {
    fprintf(stderr, " Handicap HA[%d] is unreasonable.\n", handicap);
    fprintf(stderr, " Modify SGF file.\n");
    exit (1);
  }
}


/*
 * Make a move in the game.  Return 1 if the move was legal. In that
 * case the move is actually done. Otherwise return 0.
 */

void
gameinfo_play_move(Gameinfo *ginfo, int i, int j, int color)
{
  gnugo_play_move(i, j, color);
  sgftreeAddPlay(&ginfo->game_record, 0, color, i, j);

  sgffile_move_made(i, j, color, 0);

  ginfo->to_move = OTHER_COLOR(color);
}


/*
 * Play the moves in an SGF tree. Walk the main variation, actioning
 * the properties into the playing board.
 *
 * Returns the color of the next move to be made.
 *
 * Head is a sgf tree. 
 * Untilstr is an optional string of the form either 'L12' or '120'
 * which tells it to stop playing at that move or move-number.
 * When debugging, this is the location of the move being examined.
 */

int
gameinfo_play_sgftree_rot(Gameinfo *gameinfo, SGFNode *head,
			  const char *untilstr, int orientation)
{
  int bs, handicap;
  float komi;
  int next = BLACK;
  
  int untilm = -1, untiln = -1;
  int until = 9999;
  int addstone = 0;          /* handicap stone detector */
  
  SGFNode *node;
  
  if (!sgfGetFloatProperty(head, "KM", &komi)) {
    if (gameinfo->handicap == 0)
      komi = 5.5;
    else
      komi = 0.5;
  }
  if (!sgfGetIntProperty(head, "SZ", &bs))
    bs = 19;
  gnugo_clear_board(bs);
  gnugo_set_komi(komi);

  /* Now we can safely parse the until string (which depends on board size). */
  if (untilstr) {
    if (*untilstr > '0' && *untilstr <= '9') {
      until = atoi(untilstr);
      DEBUG(DEBUG_LOADSGF, "Loading until move %d\n", until);
    }
    else {
      untiln = *untilstr - 'A';
      if (*untilstr >= 'I')
	--untiln;
	  
      untilm = board_size - atoi(untilstr+1);
      DEBUG(DEBUG_LOADSGF, "Loading until move at %d,%d (%m)\n", 
	    untilm, untiln, untilm, untiln);
    }
  }
  
  if (sgfGetIntProperty(head, "HA", &handicap) && handicap > 1) {
    gameinfo->handicap = handicap;
    next = WHITE;
  }
  
  /* Finally, we iterate over all the properties of all the
   * nodes, actioning them. We follow only the 'child' pointers,
   * as we have no interest in variations.
   *
   * The sgf routines map AB[aa][bb][cc] into AB[aa]AB[bb]AB[cc]
   */
  for (node = head; node; node = node->child) {
    SGFProperty *prop;
    int i, j;
      
    for (prop = node->props; prop; prop = prop->next) {
      DEBUG(DEBUG_LOADSGF, "%c%c[%s]\n", 
	    prop->name & 0xff, (prop->name >> 8), prop->value);
      switch (prop->name) {
      case SGFAB:
	get_moveXY(prop, &i, &j, board_size);
	/* Generally the last move is unknown when the AB or AW
	 * properties are encountered. These are used to set up
	 * a board position (diagram) or to place handicap stones
	 * without reference to the order in which the stones are
	 * placed on the board.
	 */
	rotate(i, j, &i, &j, board_size, orientation);
	gnugo_add_stone(i, j, BLACK);
	sgffile_put_stone(i, j, BLACK);
	addstone = 1;
	break;
	      
      case SGFAW:
	get_moveXY(prop, &i, &j, board_size);
	rotate(i, j, &i, &j, board_size, orientation);
	gnugo_add_stone(i, j, WHITE);
	sgffile_put_stone(i, j, WHITE);
	addstone = 1;
	break;
	      
      case SGFPL:
	/* following really should not be needed for proper sgf file */
	if (movenum != 0 && !addstone) {
	  gnugo_sethand(gameinfo->handicap, 0);
	  sgfOverwritePropertyInt(head, "HA", handicap);
	}

	/* Due to a bad comment in the SGF FF3 definition (in the
         * "Alphabetical list of properties" section) some
         * applications encode the colors with 1 for black and 2 for
         * white.
	 */
	if (prop->value[0] == 'w'
	    || prop->value[0] == 'W'
	    || prop->value[0] == '2')
	  next = WHITE;
	else
	  next = BLACK;
	break;
	      
      case SGFW:
      case SGFB:
	next = prop->name == SGFW ? WHITE : BLACK;
	/* following really should not be needed for proper sgf file */
	if (movenum != 0 && !addstone) {
	  gnugo_sethand(gameinfo->handicap, 0);
	  sgfOverwritePropertyInt(head, "HA", handicap);
	}

	if (movenum == until - 1) {
	  gameinfo->to_move = next;
	  return next;
	}
	      
	if (get_moveXY(prop, &i, &j, board_size))
	  if (i == untilm && j == untiln) {
	    gameinfo->to_move = next;
	    return next;
	  }

	rotate(i, j, &i, &j, board_size, orientation);
	gnugo_play_move(i, j, next);
	sgffile_move_made(i, j, next, 0);
	next = OTHER_COLOR(next);
	      
	break;

      case SGFIL:
	/* The IL property is not a standard SGF property but
	 * is used by GNU Go to mark illegal moves. If a move
	 * is found marked with the IL property which is a ko
	 * capture then that ko capture is deemed illegal and
	 * (board_ko_i, board_ko_j) is set to the location of
	 * the ko.
	 */
	get_moveXY(prop, &i, &j, board_size);
	rotate(i, j, &i, &j, board_size, orientation);
	{
	  int move_color;

	  if (!ON_BOARD2(i, j))
	    break;
	  if (i > 0)
	    move_color = OTHER_COLOR(BOARD(i-1, j));
	  else 
	    move_color = OTHER_COLOR(BOARD(i+1, j));
	  if (is_ko(POS(i, j), move_color, NULL))
	    board_ko_pos = POS(i, j);
	}
	break;
      }
    }
  }

  gameinfo->to_move = next;
  return next;
}

/* Same as previous function, using standard orientation */

int
gameinfo_play_sgftree(Gameinfo *gameinfo, SGFNode *head, const char *untilstr)
{
  return gameinfo_play_sgftree_rot(gameinfo, head, untilstr, 0);
}



/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */


/* life.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*
 * This file is about life & death.
 * 
 * For now, we only consider eye spaces.  Code for extending and
 * shrinking eye spaces is in owl.c. 
 *
 * We will only handle small to medium eye spaces for now (<= 16
 * during testing). At these small sizes, we make the simplifying
 * assumption that if any part of the surrounding wall is captured,
 * the resulting eye space will lead to 0 eyes. This assumption can be
 * dealt with later when the basic code works.
 *
 * Strategy:
 * Try to fill the entire eye space until there are only eyes of
 * size 1 left. Then nobody can play there, and we can count the eyes. */

/* FIXME: TODO
 *  - Handle ko
 *  - Handle seki
 *  - Try to find out how many outside liberties are needed for the optimal
 *    sequence.
 * - Try to find the optimal move. For example, consider this situation:
 *
 *      D E F G H J
 *      . . . X X X 9
 *      . . O X . O 8
 *      . O . X O . 7
 *      + O . X . O 6
 *      . O . X . X 5
 *      . . O X X . 4
 *      . . O O O X 3
 *      . . O . O . 2
 *      . . . . . . 1
 *
 *   In this situation, the current implementation suggests an X move at
 *   H8 as the defense move.  This works, but H6 is more efficient since 
 *   when the external liberties are filled in, we need to make at least
 *   one extra move if O plays H6.
 * - There is no need for all levels of the search to return attacking
 *   or defending moves. This is only needed at the top level. In fact,
 *   there is no need to store it into the hash table either, so the table
 *   could be halved in size (short instead of int).  However, I don't
 *   want to do this simplification yet.  Maybe handling of seki or ko
 *   will have to use some scheme like this.
 */

/* #include <stdio.h> */
/* #include <stdlib.h> */
/* #include <string.h> */

/* #include "gnugo.h" */
/* #include "liberty.h" */



#define DEBUG_LIMIT   10

#define MAX_EYE_SIZE  16
#define MAX_BOUNDARY_STRINGS 20

/* List of eye point coordinates. */
static int eye[MAX_EYE_SIZE+1];

/* Array with inverse mapping. The index MAX_EYE_SIZE is by convention
 * used to encode a pass move.
 */
static int eyeindex[BOARDMAX];

/* Proper eye points, i.e. not margins or external diagonals. */
static int proper_eye[BOARDMAX];

/* Eye point restrictions. */
static int eye_restrictions[BOARDMAX];
#define DEFENDER_NOT_PLAY         0x01
#define ATTACKER_PLAY_SAFE        0x02
#define DEFENDER_PLAY_IF_CAPTURE  0x04

/* List of boundary strings. */
static int boundary[MAX_BOUNDARY_STRINGS];

static int eyesize;
static int eye_color;
static int boundary_size;


static int minimize_eyes(struct eye_data eyedata[BOARDMAX],
			 struct half_eye_data heye[BOARDMAX],
			 int *min, int *ko_out, int ko_in, int ko_master,
			 int *attack_point, int cutoff_eyes, int cutoff_ko);
static int maximize_eyes(struct eye_data eyedata[BOARDMAX],
			 struct half_eye_data heye[BOARDMAX],
			 int *max, int *ko_out, int ko_in, int ko_master,
			 int *defense_point, int cutoff_eyes, int cutoff_ko);
static void life_showboard(void);

/* Used by life_showboard(). */
static int stackp_when_called = 0;

/* Statistics. */
static int life_node_counter = 0;

/* ================================================================ */
/*                   Hash table for recognize_eye.                  */
/* ================================================================ */

/* FIXME: Change to dynamic allocation. */

#define EYEHASH_NODE_TABLE_SIZE 75000
#define EYEHASH_TABLE_SIZE 24999

struct eyehash_node {
  unsigned int hash;
  int result;
  struct eyehash_node *next;
};

struct eyehash_node eyehash_node_table[EYEHASH_NODE_TABLE_SIZE];

static int next_eyehash_node;

struct eyehash_node *eyehash_table[EYEHASH_TABLE_SIZE];

/*
 * Layout of the result field:
 *
 *   Each result is one 32 bit integer. (FIXME: Don't waste 32 bits on 
 *   machines with 64 bit ints.) 
 *
 *   byte 0 (LSB):  Value byte (see below)
 *   byte 1:        Status byte (see below)
 *   byte 2:        Where the defender should play.
 *   byte 3:        Where the attacker should play.
 *
 *   The value byte:
 *   +-------------------------------+
 *   | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
 *   +-------------------------------+
 *   |   ko  |  eyes |   ko  |  eyes |
 *   +-------------------------------+
 *   |     attack    |     defense   |
 *   +-------------------------------+
 *
 *   The byte contains the same info twice, once for the attacker, 
 *   and once for the defender (the eye owner).
 *
 *   eyes:
 *     0:   0 eyes
 *     1:   1 eye
 *     2:   Local seki
 *     3:   2 eyes
 *
 *   ko: The komaster has ignored this number (0-3) ko threats to
 *       achieve the stated number of eyes. More than 3 ignored ko threats
 *       are never considered.
 *
 *   The status byte:
 *   +-------------------------------+
 *   | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
 *   +-------------------------------+
 *   |     Reserved  | AI| DI| AR| DR|
 *   +-------------------------------+
 *
 *   Currently four status bits are used. Being set to one has the
 *   following interpretations.
 *     DR:  Defense result is ready.
 *     AR:  Attack result is ready.
 *     DI:  Defense result is invalid because we're still searching.
 *     AI:  Attack result is invalid because we're still searching.
 *          These are used to detect loops other than basic ko.
 *
 */

#define GET_DEFENSE_EYES(x)  (((x)->result)             & 0x03)
#define GET_DEFENSE_KO(x)    (((x)->result >> 2)        & 0x03)
#define GET_ATTACK_EYES(x)   (((x)->result >> 4)        & 0x03)
#define GET_ATTACK_KO(x)     (((x)->result >> 6)        & 0x03)
#define DEFENSE_READY_BIT    0x0100
#define ATTACK_READY_BIT     0x0200
#define DEFENSE_INVALID_BIT  0x0400
#define ATTACK_INVALID_BIT   0x0800
#define GET_DEFENSE_POINT(x) (((x)->result >> 16)       & 0xff)
#define GET_ATTACK_POINT(x)  (((x)->result >> 24)       & 0xff)

#define SET_DEFENSE(x, ko, eyes, point)\
((x)->result &= ~0x00ff050f,\
 (x)->result |= (point<<16) | DEFENSE_READY_BIT | (ko<<2) | (eyes))

#define SET_ATTACK(x, ko, eyes, point)\
((x)->result &= ~0xff000af0,\
 (x)->result |= (point<<24) | ATTACK_READY_BIT | (ko<<6) | (eyes<<4))


/*
 * Clear the hash table.
 */

static void
eyehash_clear(void)
{
  memset(eyehash_table, 0, sizeof(eyehash_table));
  next_eyehash_node = 0;
}

/* FIXME: This should be possible to do incrementally. */
static unsigned int
compute_hashvalue(void)
{
  int k;
  unsigned int hash = 0;
  for (k=0; k<eyesize; k++)
    hash |= board[eye[k]] << 2*k;

  return hash;
}

/* Get a node from the eyehash table. NULL is returned if the node was
 * invalid or the table is out of space.
 */
static struct eyehash_node *
get_eyehash_node(int attack)
{
  unsigned int hash = compute_hashvalue();
  unsigned int key;
  struct eyehash_node *p;
  struct eyehash_node *last_p;
  int invalid_bit = (attack ? ATTACK_INVALID_BIT : DEFENSE_INVALID_BIT);

  /* Add the ko point to the hash value. */
  if (board_ko_pos != NO_MOVE && eyeindex[board_ko_pos] >= 0)
    hash |= 3 << (2 * eyeindex[board_ko_pos]);
  key = hash % EYEHASH_TABLE_SIZE;

  /* Search through the linked list for this entry. */
  for (last_p = NULL, p = eyehash_table[key]; p; last_p = p, p = p->next)
    if (p->hash == hash)
      break;

  /* Position found in the hash table. */
  if (p) {
    if (p->result & invalid_bit)
      return NULL; /* But the result was invalid. */
    else {
      int ready_bit = (attack ? ATTACK_READY_BIT : DEFENSE_READY_BIT);
      /* Mark the invalid bit before returning the node, unless the
       * result is ready.
       */
      if (!(p->result & ready_bit))
	p->result |= invalid_bit;
      return p;
    }
  }

  /* Check if we have node space left. */
  if (next_eyehash_node == EYEHASH_NODE_TABLE_SIZE)
    return NULL;

  p = &eyehash_node_table[next_eyehash_node++];
  p->hash = hash;
  p->result = invalid_bit;
  p->next = NULL;
  /* Link in the new node. */
  if (last_p)
    last_p->next = p;
  else
    eyehash_table[key] = p;

  return p;
}


/* ================================================================ */
/*                          Prepare the eyespace                    */
/* ================================================================ */


static void
clear_eyepoints(void)
{
  int i, j;
  int ii;

  eyesize = 0;
  for (i = 0; i < board_size; ++i)
    for (j = 0; j < board_size; ++j) {
      ii = POS(i, j);

      eyeindex[ii] = -1;
      proper_eye[ii] = 0;
      eye_restrictions[ii] = 0;
    }
}

static void
include_eyepoint(int pos, int proper, int restrictions)
{
  if (eyeindex[pos] == -1) {
    /* FIXME: This is only a temporary workaround to avoid a crash in
     * the assertion below.
     */
    if (eyesize > MAX_EYE_SIZE)
      return;
    /* FIXME:
     * Should this be < MAX_EYE_SIZE?
     * The list of points in eye[] is ended with (NO_MOVE)
     */
    ASSERT1(eyesize <= MAX_EYE_SIZE, pos);
    eyeindex[pos] = eyesize;
    eye[eyesize] = pos;
    eyesize++;
  }
  if (proper)
    proper_eye[pos] = 1;

  eye_restrictions[pos] |= restrictions;
}


/* Explanations can be found above the calls in prepare_eyespace(). */
static void
check_vulnerability(int marginal_eyepoint, int stone)
{
  if (!ON_BOARD(stone))
    return;
  
  if (board[stone] == EMPTY) {
    if (eyeindex[stone] == NO_MOVE)
      include_eyepoint(stone, 0, DEFENDER_PLAY_IF_CAPTURE);
    return;
  }
  
  /* Both eyespace and boundary are excluded. */
  if (eyeindex[stone] != -1)
    return;

  /* Play the opposite color of (m, n) on the margin and try to
   * capture (stone)
   */
  if (!trymove(marginal_eyepoint, OTHER_COLOR(board[stone]),
	       "check_vulnerability", stone, EMPTY, NO_MOVE))
    return;

  if (board[stone] && attack(stone, NULL)) {
    int liberties;
    int libs[2];
    /* Vulnerability found. First pick up its liberties. */
    liberties = findlib(stone, 2, libs);
    
    if (board[stone] == eye_color && liberties == 1) {
      /* Strategy (c). */
      include_eyepoint(stone, 0, 0);
      include_eyepoint(libs[0], 0, DEFENDER_NOT_PLAY);
    }
    else if (board[stone] == OTHER_COLOR(eye_color)) {
      if (liberties > 1
	  || countstones(stone) > 6
	  || eyesize + countstones(stone) + 1 > MAX_EYE_SIZE) {
	/* Strategy (b). */
	include_eyepoint(marginal_eyepoint, 0, ATTACKER_PLAY_SAFE);
      }
      else {
	/* Strategy (a) */
	int k;
	int stones[6];
	int size = findstones(stone, 6, stones);
	gg_assert(size <= 6);
	for (k=0; k<size; k++)
	  include_eyepoint(stones[k], 0, 0);
	include_eyepoint(libs[0], 0, DEFENDER_PLAY_IF_CAPTURE);
      }
    }
  }
  popgo();
}


static void
print_eyespace(struct eye_data eyedata[BOARDMAX],
	       struct half_eye_data heye[BOARDMAX])
{
  int m, n;
  int ii;
  int k;
  int mini, maxi;
  int minj, maxj;
  
  /* Determine the size of the eye. */
  mini = board_size;
  maxi = -1;
  minj = board_size;
  maxj = -1;
  for (k = 0; k < eyesize; k++) {
    m = I(eye[k]);
    n = J(eye[k]);
    if (m < mini) mini = m;
    if (m > maxi) maxi = m;
    if (n < minj) minj = n;
    if (n > maxj) maxj = n;
  }

  /* Prints the eye shape. A half eye is shown by h, if empty or H, if an
   * enemy is present. Note that each half eye has a marginal point which is 
   * not printed, so the representation here may have less points than the 
   * matching eye pattern in eyes.db. Printing a marginal for the half eye
   * would be nice, but difficult to implement.
   */
  for (m = mini; m <= maxi; m++) {
    gprintf(""); /* Get the indentation right. */
    for (n = minj; n <= maxj; n++) {
      ii = POS(m, n);

      if (eyeindex[ii] >= 0) {
	if (board[ii] == EMPTY) {
	  if (eyedata[ii].marginal)
	    gprintf("%o!");
	  else if (is_halfeye(heye, ii))
	    gprintf("%oh");
	  else
	    gprintf("%o.");
	}
	else if (is_halfeye(heye, ii))
	  gprintf("%oH");
	else
	  gprintf("%oX");
      }
      else
	gprintf("%o ");
    }
    gprintf("\n");
  }
}


static int
prepare_eyespace(int pos, struct eye_data eyedata[BOARDMAX],
		 struct half_eye_data heye[BOARDMAX])
{
  int i, j;
  int ii;
  int k;
  
  /* Set `eye_color' to the owner of the eye. */
  eye_color = eyedata[pos].color;
  if (eye_color == BLACK_BORDER)
    eye_color = BLACK;
  if (eye_color == WHITE_BORDER)
    eye_color = WHITE;

  clear_eyepoints();
  
  /* Collect all the points of the eye into the set. 
   * We must also include all diagonal points for half eyes.
   * FIXME: This won't work if diagonal attack and defense points differ.
   */
  for (i = 0; i < board_size; ++i)
    for (j = 0; j < board_size; ++j) {
      ii = POS(i, j);

      if (eyedata[ii].origin == pos) {
	include_eyepoint(ii, eyedata[ii].marginal == 0, 0);
	if (is_halfeye(heye, ii)) {
	  for (k=0; k<heye[ii].num_attacks; k++)
	    include_eyepoint(heye[ii].attack_point[k], 0, 0);
	  for (k=0; k<heye[ii].num_defends; k++)
	    include_eyepoint(heye[ii].defense_point[k], 0, 0);
	}
      }
    }

  /* Verify that the effective eyespace isn't too large. */
  if (eyesize > MAX_EYE_SIZE)
    return 0;

  /* Get the boundary. The boundary points are defined to have the
   * properties:
   * 1. The same color as the eyespace.
   * 2. Not itself part of the eyespace.
   * 3. Adjacent to a non-marginal point in the eyespace.
   *
   * We only store the origins of the boundary strings.
   */
  boundary_size = 0;
  for (i = 0; i < board_size; ++i)
    for (j = 0; j < board_size; ++j) {
      ii = POS(i, j);

      if (board[ii] != eye_color)
	continue;
      if (eyeindex[ii] >= 0)
	continue;
      if ((   i > 0	       && proper_eye[ii-NS])
	  || (i < board_size-1 && proper_eye[ii+NS])
	  || (j > 0	       && proper_eye[ii-1])
	  || (j < board_size-1 && proper_eye[ii+1])) {
	int origin = find_origin(ii);
	if (eyeindex[origin] != -2) {
	  eyeindex[origin] = -2;
	  boundary[boundary_size] = origin;
	  boundary_size++;
	  gg_assert(boundary_size <= MAX_BOUNDARY_STRINGS);
	}
      }
    }

  /* Go through the eyespace in search of vulnerable margins. These
   * are defined as having a neighbor outside the eyespace that can be
   * captured after the neighbor plays on the margin ('!' in the
   * examples below.
   *
   *            OOOXX
   * OOOOX   OOOOXX..   OOOXX
   * OX!X.   OX!XX...   ..!O.
   * -----   --------   -----
   *  (a)       (b)          (c)
   *
   * The solution to this problem is in (a) to add the vulnerable X
   * string and its liberty to the eyespace. We also add the
   * restriction that O may only play on this liberty if the move
   * captures at least one stone in the eyespace.
   *
   * In (b) this approach doesn't easily work so instead we leave the
   * eyespace unchanged but add the restriction that X must not play
   * on the margin if the stone can then be tactically captured. This
   * approach is also used in (a) if addition of the extra points
   * would make the eyespace too large.
   *
   * In (c) we require that the vulnerable stone has no more than two
   * liberties and then add the *stone* and its external liberty to the
   * eyespace. Only X may play on the external liberty.
   *
   * FIXME: This is not very exact. A better scheme would involve the
   * concept of moves that are sente against the outside, i.e. the
   * attacker is effectively forced to pass once when such moves are
   * played.
   */

  for (k=0; k<eyesize; k++) {
    ii = eye[k];
    if (!eyedata[ii].marginal)
      continue;
    /* Found a margin. Now look for a vulnerable stone outside the
     * eyespace.
     */
    check_vulnerability(ii, ii-NS);
    check_vulnerability(ii, ii+NS);
    check_vulnerability(ii, ii-1);
    check_vulnerability(ii, ii+1);
  }

  /* Verify that the effective eyespace still isn't too large. */
  if (eyesize > MAX_EYE_SIZE)
    return 0;

  /* Clear the hash table for this eye. */
  eyehash_clear();

  /* Add a pass move at the end of the eyespace list. */
  eye[MAX_EYE_SIZE] = NO_MOVE;

  if (debug & DEBUG_EYES) {
    gprintf("Prepared eyespace:\n");
    print_eyespace(eyedata, heye);
  }
    
  return 1;
}  

/* ================================================================ */
/*                          Eye recognition                         */
/* ================================================================ */

/*
 * Compute the maximum and minimum number of eyes reachable from the
 * eye space at (m, n). The maximum is defined for color to play
 * first, and the minimum is defined for other_color to play first.
 *
 * If max != min, (*attacki, *attackj) is set to the move which
 * reduces the eye and (*defendi, *defendj) is set to the move which
 * defends it. Most of the time the attack point and the defense point
 * will be the same.
 *
 * The function returns one on success and zero if the eyespace was
 * too large for analysis.
 */

int
recognize_eye2(int pos, int *attack_point, int *defense_point,
	       int *max, int *min, 
	       struct eye_data eyedata[BOARDMAX],
	       struct half_eye_data heye[BOARDMAX],
 	       int add_moves, int color)
{
  int result1a, result1b, result2a, result2b;
  int min1a, min1b, max2a, max2b;
  int ko1a, ko1b, ko2a, ko2b;
  int attack_point1a, attack_point1b;
  int defense_point2a, defense_point2b;
  int save_stackp;
  int m = I(pos);
  int n = J(pos);

  /* FIXME: Remove the unused parameter entirely if it's not needed. */
  UNUSED(color);
  UNUSED(add_moves);

  save_stackp = stackp;

  /* For use by debug outputs. */
  stackp_when_called = stackp;
  
  /* Set up all data structures necessary to analyze the eyespace. */
  if (!prepare_eyespace(POS(m, n), eyedata, heye))
    return 0;

  DEBUG(DEBUG_EYES, "================  MINIMIZE 1 ================\n");
  result1a = minimize_eyes(eyedata, heye, &min1a, &ko1a, 0,
			   eye_color, &attack_point1a, 0, 0);
  DEBUG(DEBUG_EYES, "================  MAXIMIZE 1 ================\n");
  result2a = maximize_eyes(eyedata, heye, &max2a, &ko2a, 0,
			   eye_color, &defense_point2a, 2, 0);

  /* The hash value currently doesn't include the komaster. As a
   * workaround we clear the cache before switching komaster.
   *
   * Q: The hash value now includes the komaster. Can we
   *    therefore skip this step? 
   *
   * A: No, the life code has its own cache, which doesn't
   *    include the komaster.
   */

  eyehash_clear();
  
  DEBUG(DEBUG_EYES, "================  MINIMIZE 2 ================\n");
  result1b = minimize_eyes(eyedata, heye, &min1b, &ko1b, 0,
			   OTHER_COLOR(eye_color), &attack_point1b, 0, 0);

  DEBUG(DEBUG_EYES, "================  MAXIMIZE 2 ================\n");
  result2b = maximize_eyes(eyedata, heye, &max2b, &ko2b, 0,
			   OTHER_COLOR(eye_color), &defense_point2b, 2, 0);

  if (!result1a)
    return 0;
  
  if (!result2b)
    return 0;

  DEBUG(DEBUG_EYES, "Min: ko_master %C, eyes=%d, ko=%d, attack: %1m\n",
	eye_color, min1a, ko1a,	eye[attack_point1a]);
  
  DEBUG(DEBUG_EYES, "Min: ko_master %C, eyes=%d, ko=%d, attack: %1m\n",
	OTHER_COLOR(eye_color), min1b, ko1b, eye[attack_point1b]);
  
  DEBUG(DEBUG_EYES, "Max: ko_master %C, eyes=%d, ko=%d, defense: %1m\n",
	eye_color, max2a, ko2a,	eye[defense_point2a]);
  
  DEBUG(DEBUG_EYES, "Max: ko_master %C, eyes=%d, ko=%d, defense: %1m\n",
	OTHER_COLOR(eye_color), max2b, ko2b, eye[defense_point2b]);
  
  *min = min1a;
  *max = max2b;

  /* Ignore the distinction between seki and two proper eyes for now. */
  if (*min == 3)
    *min = 2;
  if (*max == 3)
    *max = 2;
  
  if (*min != *max) {
    if (attack_point)
      *attack_point = eye[attack_point1a];
    if (defense_point)
      *defense_point = eye[defense_point2b];
    DEBUG(DEBUG_EYES, "  vital point (attack):  %1m\n", *attack_point);
    DEBUG(DEBUG_EYES, "  vital point (defense): %1m\n", *defense_point);
  }

  /* FIXME: Currently the rest of the life and death analysis can't
   * deal with chimeras. As a workaround we report the eyespace as one
   * and a half eye instead.
   */
  if (*max - *min == 2)
    *min = 1;
  
  gg_assert(stackp == save_stackp);

  return 1;
}


/* Return true if this is an eye of size one. Usually you would also
 * want to check that an opponent move here would be suicide.
 */
static int
is_small_eye(int pos)
{
  if (!(   (!ON_BOARD(pos-NS) || board[pos-NS] == eye_color)
	&& (!ON_BOARD(pos+NS) || board[pos+NS] == eye_color)
	&& (!ON_BOARD(pos-1)  || board[pos-1] == eye_color)
	&& (!ON_BOARD(pos+1)  || board[pos+1] == eye_color)))
    return 0;
  return 1;
}

/* Assuming that this is an eye of size one, return true if it's not
 * topologically false and not a marginal eye point.
 */
static int
is_true_eye(struct half_eye_data heye[BOARDMAX], int pos)
{
  int other = OTHER_COLOR(eye_color);
  
  /* False eyes and other marginal eye points do not yield eyes. */
  if (heye[pos].type == FALSE_EYE)
    return 0;
  
  /* If this is a halfeye, check the vital diagonals. */
  if (is_halfeye(heye, pos)) {
    int good = 0;
    int bad = 0;
    int k;
    /* This requires attack points and defense points to be identical. */
    for (k=0; k<heye[pos].num_attacks; k++) {
      int aa = heye[pos].attack_point[k];

      if (board[aa] == eye_color)
	good++;
      else if (board[aa] == other)
	bad++;
      else if (is_suicide(aa, eye_color))
	bad++;
      else
	good++;
    }
    if (bad > good)
      return 0;
  }

  /* This really looks like an eye. */
  return 1;
}


/* Returns 1 if at least one string in the eyespace is captured when
 * color plays at (pos).
 */
static int
life_does_capture_something(int pos, int color)
{
  int other = OTHER_COLOR(color);
  int k;

  for (k=0; k<4; k++) {
    int d = delta[k];

    if (board[pos+d] == other
	&& countlib(pos+d) == 1
	&& eyeindex[pos+d] >= 0)
      return 1;
  }

  return 0;
}


/* Compare two (eyes, ko) values from the point of view of
 * minimize_eyes (the attacker). Returns
 * -1    if the first value is considered better
 *  0    if the values are the same
 *  1    if the second value is considered better
 *
 * The general rule is that a smaller eye value is better than a
 * larger and if they are equal it's better to have a smaller ko
 * value. The exception is that seki without ko is considered worse
 * than two eyes with ko.
 */

static int
compare_min_eyes(int eyes1, int ko1, int eyes2, int ko2)
{
  /* Seki without ko against 2 eyes with ko. */
  if (eyes1 == 2 && eyes2 == 3 && ko1 < ko2)
    return 1;
  
  /* 2 eyes with ko against seki without ko. */
  if (eyes1 == 3 && eyes2 == 2 && ko1 > ko2)
    return -1;

  /* General case */
  if (eyes1 < eyes2)
    return -1;

  if (eyes1 > eyes2)
    return 1;
  
  /* Same number of eyes. */
  if (ko1 < ko2)
    return -1;

  if (ko1 > ko2)
    return 1;

  /* Same value. */
  return 0;
}
  

/* Compare two (eyes, ko) values from the point of view of
 * maximize_eyes (the defender). Returns
 * -1    if the first value is considered better
 *  0    if the values are the same
 *  1    if the second value is considered better
 *
 * The general rule is that a larger eye value is better than a
 * smaller and if they are equal it's better to have a smaller ko
 * value. The exception is that seki without ko is considered better
 * than two eyes with ko.
 */

static int
compare_max_eyes(int eyes1, int ko1, int eyes2, int ko2)
{
  /* Seki without ko against 2 eyes with ko. */
  if (eyes1 == 2 && eyes2 == 3 && ko1 < ko2)
    return -1;
  
  /* 2 eyes with ko against seki without ko. */
  if (eyes1 == 3 && eyes2 == 2 && ko1 > ko2)
    return 1;

  /* General case */
  if (eyes1 < eyes2)
    return 1;

  if (eyes1 > eyes2)
    return -1;
  
  /* Same number of eyes. */
  if (ko1 < ko2)
    return -1;

  if (ko1 > ko2)
    return 1;

  /* Same value. */
  return 0;
}
  


#define MINIMIZE_EYES_RETURN(eyes, ko, attack, message) do {\
  *min = (eyes);\
  *ko_out = (ko);\
  if (attack_point)\
    *attack_point = (attack);\
  SET_ATTACK(cache_entry, (ko), (eyes), (attack));\
  if (stackp - stackp_when_called < DEBUG_LIMIT)\
    DEBUG(DEBUG_LIFE,\
         "exiting minimize_eyes (%s) - result = %d, ko = %d, move %1m (%H)\n",\
	  (message), (eyes), (ko), eye[attack],\
	  hashdata.hashval);\
  return 1;\
  } while (0)

/*
 * We have a set of locations in eyepoints forming an eye shape.
 * Check min number of eyes we can get if the opponent moves first.
 * `eye_color' is the owner of the eye.
 *
 * Return values:
 *   1: Ok. Min eyes in *min.
 *   0: No result.  A cycle in the reading or hash table full.
 */

static int
minimize_eyes(struct eye_data eyedata[BOARDMAX],
	      struct half_eye_data heye[BOARDMAX],
	      int *min, int *ko_out, int ko_in, int ko_master,
	      int *attack_point, int cutoff_eyes, int cutoff_ko)
{
  int other = OTHER_COLOR(eye_color);
  int ii;
  int num_other;
  int num_moves;
  int num_eyes;
  int max1;
  int localmin;
  int localko;
  int ko1;
  int result;
  int attack_point1;
  int defense_point1;
  int localattack = MAX_EYE_SIZE;
     
  int move[MAX_EYE_SIZE+1];
  int move_score[MAX_EYE_SIZE+1];
  int k;
  int score;
     
  int save_stackp;

  struct eyehash_node *cache_entry;
  
  life_node_counter++;
  
  if (stackp - stackp_when_called < DEBUG_LIMIT)
    DEBUG(DEBUG_LIFE, "entering minimize_eyes: stackp = %d node number = %d\n",
	  stackp, life_node_counter);

  /* Check the hash table and see if we have been here before. */
  cache_entry = get_eyehash_node(1);
  if (!cache_entry) {
    /* Invalid result. We have come back to the same position again
     * within the searching. Just return and hope that we get a better
     * result on some other branch. */
    if (stackp - stackp_when_called < DEBUG_LIMIT)
      DEBUG(DEBUG_LIFE,
	    "exiting minimize_eyes directly because of a reading loop. (%H)\n",
	    hashdata.hashval);
    return 0;
  }

  if (cache_entry->result & ATTACK_READY_BIT) {
    *min = GET_ATTACK_EYES(cache_entry);
    *ko_out = GET_ATTACK_KO(cache_entry);
    attack_point1 = GET_ATTACK_POINT(cache_entry);
    
    if (attack_point)
      *attack_point = attack_point1;
    
    if (stackp - stackp_when_called < DEBUG_LIMIT)
      DEBUG(DEBUG_LIFE, "exiting minimize_eyes - got result %d eyes, %d ko (move %1m) from the cache. (%H)\n",
	    *min, *ko_out, eye[attack_point1], hashdata.hashval);
    return 1;
  }

  
  /* Check whether any part of the boundary is in atari.  If so, we assume
   * capturing it guarantees no eyes.
   *
   * FIXME: This is too simplified.
   */
  for (k=0; k<boundary_size; k++) {
    int libs[2];
    if (findlib(boundary[k], 2, libs) == 1) {
      int index = eyeindex[libs[0]];
      /* If the move is outside the eyespace, return a pass.
       * FIXME: This is of course just a workaround.
       */
      if (index < 0)
	index = MAX_EYE_SIZE;
      MINIMIZE_EYES_RETURN(0, 0, index, "boundary captured");
    }
  }
  
  
  if (verbose
      && stackp - stackp_when_called < DEBUG_LIMIT
      && (debug & DEBUG_EYES))
    life_showboard();

  /* Collect how many moves the attacking color can do and how many stones
   * he has within the eye.
   */
  num_other = 0;
  num_moves = 0;
  num_eyes = 0;
  for (k=0; k<eyesize; k++) {
    int ii = eye[k];

    if (board[ii] == eye_color)
      continue;

    if (board[ii] == other) {
      if (proper_eye[ii])
	num_other++;
      continue;
    } 

    if (!is_suicide(ii, other)) {
      score = 0;
      move[num_moves] = k;
      /* Score the move. We give (preliminarily)
       * 1 point for each empty neighbor
       * 1 point for each friendly neighbor
       * 2 points if the intersection is marginal
       *
       * Assuming this is a legal move, we will get a score larger
       * than zero. The score can obviously not become larger than
       * six, but it seems unlikely we would ever exceed four.
       *
       * Looking closer, the score can actually become zero below, but
       * only if the move is fully surrounded by opponent stones and
       * captures at least one of them. This is likely to be good, so
       * we give a high score.
       */
      if (I(ii) > 0            && board[ii-NS] != eye_color)
	score++;
      if (I(ii) < board_size-1 && board[ii+NS] != eye_color)
	score++;
      if (J(ii) > 0            && board[ii-1] != eye_color)
	score++;
      if (J(ii) < board_size-1 && board[ii+1] != eye_color)
	score++;
      if (eyedata[ii].marginal)
	score += 2;
      if (score == 0)
	score = 5;
      move_score[num_moves] = score;
      num_moves++;
    }
    else {
      if (is_small_eye(ii) && is_true_eye(heye, ii))
	num_eyes++;
    }
  }

  /* Check if we are done. This means that there are no stones of
   * the attacking color and that all the eye points are suicide
   * to move into. The only way this could happen is that they are
   * of size 1 and without possibility to capture anything.
   *
   * This test is hard to get both robust and efficient. Currently
   * disabled.
   */
#if 0
  if (num_other == 0 && num_moves == 0) {
    if (num_eyes >= 2)
      num_eyes = 3;
    MINIMIZE_EYES_RETURN(num_eyes, 0, MAX_EYE_SIZE, "end of search");
  }
#endif
  if (num_moves == 0 && num_eyes >= 2)
    MINIMIZE_EYES_RETURN(3, 0, MAX_EYE_SIZE, "end of search");

  localmin = 9999;
  localko = 9999;

  /* Check against array overflow below.*/
  gg_assert(num_moves < (int) (sizeof(move)/sizeof(move[0])));
  
  /* Add a pass move with score 2 to be tested. We refrain from
   * increasing the num_legal_moves value because it's needed again
   * later
   */
  move[num_moves] = MAX_EYE_SIZE;
  move_score[num_moves] = 2;
  
  /* Now try all legal moves and see what we get. We order the moves
   * by score.
   */
  for (score=6; score>0; score--) {
    for (k=0; k<num_moves+1; k++) {
      int is_ko = 0;
      int index = move[k];
      
      if (move_score[k] != score)
	continue;

      ii = eye[index];

      gg_assert(ii == NO_MOVE || board[ii] == EMPTY);

      /* Try the move and see if we can reduce the eyes. */
      save_stackp = stackp;
      if (stackp - stackp_when_called < DEBUG_LIMIT)
	DEBUG(DEBUG_LIFE, "minimize_eyes: trymove %s %1m score %d\n",
	      color_to_string(other), ii, score);
      if (index == MAX_EYE_SIZE
	  || trymove(ii, other, "minimize_eyes", NO_MOVE, EMPTY, NO_MOVE)
	  || (ko_master == other
	      && (ko_in < 3)
	      && (is_ko = 1)   /* Intentional assignment. */
	      && tryko(ii, other, "minimize_eyes", EMPTY, NO_MOVE))) {

	/* The attacker has made his move. Now let's answer him and
	 * see how many eyes we can get.
	 */
	  
	/* But first we must check a restriction. */
	if (index != MAX_EYE_SIZE
	    && (eye_restrictions[ii] & ATTACKER_PLAY_SAFE)
	    && attack(ii, NULL))
	  result = 0;
	else
	  result = maximize_eyes(eyedata, heye, &max1, &ko1, ko_in + is_ko,
				 ko_master, &defense_point1,
				 localmin, localko);
	
	if (result == 1) {
	  /* Is this result an improvement of what we already have?
	   * Seki without ko is worse than two eyes with ko.
	   * Otherwise we primarily try to minimize the eye value.
	   */
	  if (compare_min_eyes(localmin, localko, max1, ko1 + is_ko) == 1) {
	    localmin = max1;
	    localko = ko1 + is_ko;
	    localattack = index;
	  }
	}
	
	if (index != MAX_EYE_SIZE)
	  popgo();
      }
      else {
	/* Illegal ko capture. */
	if (stackp - stackp_when_called < DEBUG_LIMIT)
	  DEBUG(DEBUG_LIFE,
		"  illegal ko capture: %s %1m ko master %s ko level %d\n",
		color_to_string(eye_color), ii, color_to_string(ko_master),
		ko_in);
      }

      gg_assert(stackp == save_stackp);

      /* Check if the the move yielded 0 eyes.
       * If so, we can as well return here. 
       */
      if (localmin == 0 && localko == 0)
	MINIMIZE_EYES_RETURN(0, 0, index, "cutoff");

      /* Check if we have reached to cutoff value. In that case we can
       * also return here since the maximizer won't be interested in a
       * smaller value anyway. We use compare_max_eyes to evaluate the
       * value from the maximizer's point of view.
       */
#if 1
      if (compare_max_eyes(localmin, localko, cutoff_eyes, cutoff_ko) == 1)
	MINIMIZE_EYES_RETURN(localmin, localko, index, "cutoff");
#endif
    }
  }

  /* If we didn't find anywhere to play, see how many eye spaces there were. */
  if (localmin == 9999) {
    if (num_moves > 0) {
      /* We didn't get a result even though there were legal moves.
       * This has to be because of a reading loop. Propagate the
       * non-result further up.
       *
       * FIXME: Not sure this is correct anymore.
       */
      return 0;
    }

    gg_assert(0);			/* Shouldn't get here. */
  }

  if (localmin > 3)
    localmin = 3;

  MINIMIZE_EYES_RETURN(localmin, localko, localattack, "all moves tested");
}


/*
 * We have a set of locations in eyepoints forming an eye shape.
 * Check max number of eyes we can get if the opponent moves first.
 * `eye_color' is the owner of the eye.
 *
 * Return values:
 *   1: Ok. Max eyes in *max.
 *   0: No result. A cycle in the reading.
 */

static int
maximize_eyes(struct eye_data eyedata[BOARDMAX],
	      struct half_eye_data heye[BOARDMAX],
	      int *max, int *ko_out, int ko_in, int ko_master,
	      int *defense_point, int cutoff_eyes, int cutoff_ko)
{
  int other = OTHER_COLOR(eye_color);
  int ii;
  int min1;
  int localmax;
  int localko;
  int local_defense = MAX_EYE_SIZE;
  int num_eyes;
  int result;
  int defense_point1;
  int ko1;
     
  int move[MAX_EYE_SIZE];
  int move_score[MAX_EYE_SIZE];
  int num_moves = 0;
  int k;
  int score;
     
  int save_stackp;

  struct eyehash_node *cache_entry;

  life_node_counter++;
  
  if (stackp - stackp_when_called < DEBUG_LIMIT)
    DEBUG(DEBUG_LIFE, "entering maximize_eyes: stackp = %d node number = %d\n",
	  stackp, life_node_counter);

  /* Check the hash table and see if we have been here before. */
  cache_entry = get_eyehash_node(0);
  if (!cache_entry) {
    /* Invalid result. We have come back to the same position again
     * within the searching or run out of cache space. Just return and
     * hope that we get a better result on some other branch.
     *
     * This should actually never happen here since maximize_eyes() is
     * always called first.
     */
    gg_assert(1);
    if (stackp - stackp_when_called < DEBUG_LIMIT)
      DEBUG(DEBUG_LIFE,
	    "exiting maximize_eyes directly because of a reading loop. (%H)\n",
	    hashdata.hashval);
    return 0;
  }

  if (cache_entry->result & DEFENSE_READY_BIT) {
    *max = GET_DEFENSE_EYES(cache_entry);
    *ko_out = GET_DEFENSE_KO(cache_entry);
    defense_point1 = GET_DEFENSE_POINT(cache_entry);
    
    if (defense_point)
      *defense_point = defense_point1;
    
    if (stackp - stackp_when_called < DEBUG_LIMIT)
      DEBUG(DEBUG_LIFE, "exiting maximize_eyes - got result %d eyes, %d ko (move %1m) from the cache. (%H)\n",
	    *max, *ko_out, eye[defense_point1], hashdata.hashval);
    return 1;
  }

  if (verbose
      && stackp - stackp_when_called < DEBUG_LIMIT
      && (debug & DEBUG_EYES))
    life_showboard();


  localmax = -1;
  localko  = 4;
  num_eyes = 0;

  /* Collect all possible moves and see what we get. */
  for (k=0; k<eyesize; k++) {
    int ii = eye[k];
    
    if (board[ii] != EMPTY)
      continue;

    /* If the eye is of size 1, of the eye owners color, and 
     * none of the neighbouring strings is in atari, then this
     * is a proper eye. Don't play there.
     *
     * gf: Actually it may be a false eye. We can replace this
     * condition with the requirement that it's suicide for the
     * opponent to play there and that all neighbors are our stones.
     *
     * FIXME: Add diagonal test here.
     */
    if (is_suicide(ii, other) && is_small_eye(ii)) {
      if (is_true_eye(heye, ii))
	num_eyes++;
      continue;
    }

    /* Check for own suicide. */
    if (is_suicide(ii, eye_color))
      continue;
    
    /* Check certain move restrictions. */
    if (eye_restrictions[ii] & DEFENDER_NOT_PLAY)
      continue;

    if ((eye_restrictions[ii] & DEFENDER_PLAY_IF_CAPTURE)
	&& !life_does_capture_something(ii, eye_color))
      continue;

    /* Score the move and save it in a list for later testing.
     * We give (preliminarily)
     * 1 point for each empty neighbor
     * 1 point for each opponent neighbor
     * 2 points if the intersection is marginal
     *
     * Assuming this is a legal move, we will get a score larger
     * than zero. The score can obviously not become larger than
     * six, but it seems unlikely we would ever exceed four.
     */
    move[num_moves] = k;
    score = 0;
    
    if (I(ii) > 0) {
      if (board[ii-NS] == other)
	score += 2;
      else if (board[ii-NS] == EMPTY)
	score++;
    }
    if (I(ii) < board_size-1) {
      if (board[ii+NS] == other)
	score += 2;
      else if (board[ii+NS] == EMPTY)
	score++;
    }
    if (J(ii) > 0) {
      if (board[ii-1] == other)
	score += 2;
      else if (board[ii-1] == EMPTY)
	score++;
    }
    if (J(ii) < board_size-1) {
      if (board[ii+1] == other)
	score += 2;
      else if (board[ii+1] == EMPTY)
	score++;
    }
    
    if (eyedata[ii].marginal)
      score += 2;
    
    if (score == 0)
      score = 1;

    if (score > 6)
      score = 6;
    
    move_score[num_moves] = score;
    num_moves++;
  }

  /* Now try all listed moves and see what we get. We order the moves
   * by score.
   */
  for (score=6; score>0; score--) {
    for (k=0; k<num_moves; k++) {
      int is_ko = 0;
      int index = move[k];
      
      if (move_score[k] != score)
	continue;
      
      ii = eye[index];

      gg_assert(board[ii] == EMPTY);
      
      /* Try the move and see if we can keep the eyes. */
      save_stackp = stackp;
      if (stackp - stackp_when_called < DEBUG_LIMIT)
	DEBUG(DEBUG_LIFE, "maximize_eyes: trymove %s %1m score %d\n",
	      color_to_string(eye_color), ii, score);
      if (trymove(ii, eye_color, "maximize_eyes", NO_MOVE, EMPTY, NO_MOVE)
	  || (ko_master == eye_color
	      && (ko_in < 3)
	      && (is_ko = 1)   /* Intentional assignment. */
	      && tryko(ii, eye_color, "maximize_eyes", EMPTY, NO_MOVE))) {
	
	/* Ok, we made our move.  Now let the opponent do his, and see
	 * how many eyes we can get. 
	 */
	result = minimize_eyes(eyedata, heye, &min1, &ko1,
			       ko_in + is_ko, ko_master,
			       &defense_point1, localmax, localko);
	if (result == 1) {
	  /* Is this result an improvement of what we already have?
	   * Seki without ko is better than two eyes with ko.
	   * Otherwise we primarily try to minimize the eye value.
	   */
	  if (compare_max_eyes(localmax, localko, min1, ko1 + is_ko) == 1) {
	    localmax = min1;
	    localko = ko1 + is_ko;
	    local_defense = index;
	  }

	  /* If we have two certain eyes and are not collecting all
           * defense moves, we break out of the loop immediately. We
           * set score to -1 to shortcut the outer loop as well.
	   */
	  if (localmax == 3 && localko == 0) {
	    popgo();
	    score = -1;
	    break;
	  }

	  /* Check if we have reached to cutoff value. In that case we can
	   * also return here since the minimizer won't be interested in a
	   * higher value anyway. We use compare_min_eyes to evaluate the
	   * value from the minimizer's point of view.
	   */
#if 1
	  if (compare_min_eyes(localmax, localko,
			       cutoff_eyes, cutoff_ko) == 1) {
	    popgo();
	    score = -1;
	    break;
	  }
#endif
	}
	
	popgo();
      }
      else {
	/* Illegal ko capture. */
	if (stackp - stackp_when_called < DEBUG_LIMIT)
	  DEBUG(DEBUG_LIFE,
		"  illegal ko capture: %s %1m ko master %s ko level %d\n",
		color_to_string(eye_color), ii, color_to_string(ko_master),
		ko_in);
      }
      gg_assert(stackp == save_stackp);
    }
  }
  
  /* If there were nowhere to play, get number of eyes */
  if (localmax == -1) {
    if (num_eyes >= 2)
      localmax = 3;
    else
      localmax = num_eyes;
    localko = 0;
    local_defense = MAX_EYE_SIZE;
  }

  *max = localmax;
  *ko_out = localko;
  
  if (defense_point)
    *defense_point = local_defense;

  SET_DEFENSE(cache_entry, localko, localmax, local_defense);
  
  if (stackp - stackp_when_called < DEBUG_LIMIT)
    DEBUG(DEBUG_LIFE,
	  "exiting maximize_eyes (1) - result = %d, ko = %d, move %1m (%H)\n", 
	  localmax, localko, eye[local_defense], hashdata.hashval);

  return 1;
}


/*
 * Show the board in a form suitable for debugging life code.
 * This is also callable from GDB.
 */

static void
life_showboard()
{
  int i, j;

  start_draw_board();
  for (i=0; i<board_size; i++) {
    for (j=0; j<board_size; j++) {
      int c;
      int ii = POS(i, j);
      int color = board[ii];

      if (color == WHITE) {
	if (move_in_stack(ii, stackp_when_called))
	  c = 'o';
	else
	  c = 'O';
      }
      else if (color == BLACK) {
	if (move_in_stack(ii, stackp_when_called))
	  c = 'x';
	else
	  c = 'X';
      }
      else
	c = EMPTY;
      draw_char(I(ii), J(ii), c);
    }
  }
  end_draw_board();
}


/* Clear statistics. */
void
reset_life_node_counter()
{
  life_node_counter = 0;
}


/* Retrieve statistics. */
int
get_life_node_counter()
{
  return life_node_counter;
}

/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */


/* matchpat.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* #include <stdio.h> */
/* #include <stdlib.h> */
/* #include <string.h> */
/* #include <assert.h> */

/* #include "gnugo.h" */
/* #include "liberty.h" */
/* #include "gg_utils.h" */

/* #include "patterns.h" */
/* #include "dfa.h" */


/**************************************************************************/
/* Pattern profiling functions:                                           */
/**************************************************************************/

/* define this to see how each phase of pattern rejection is performing */
/* #define PROFILE_MATCHER */


#ifdef PROFILE_MATCHER
static int totals[6];
#endif


#if PROFILE_PATTERNS
/* Initialize pattern profiling fields in one pattern struct array. */
static void
clear_profile(struct pattern *pattern)
{

  for (; pattern->patn; ++pattern) {
    pattern->hits = 0;
    pattern->reading_nodes = 0;
    pattern->dfa_hits = 0;
  }
}
#endif

#if PROFILE_PATTERNS
/* Print profiling information for one pattern struct array. */
static void
print_profile(struct pattern *pattern, int *total_hits,
			   int *total_nodes, int *total_dfa_hits)
{
  for (; pattern->patn; ++pattern)
    if (pattern->hits > 0) {
      *total_hits += pattern->hits;
      *total_nodes += pattern->reading_nodes;
      *total_dfa_hits += pattern->dfa_hits;
      fprintf(stderr, "%6d ", pattern->dfa_hits);
      fprintf(stderr, "%6d %9d %8.1f %s\n", 
	      pattern->hits,
	      pattern->reading_nodes,
	      pattern->reading_nodes / (float) pattern->hits, 
	      pattern->name);
    }
}
#endif /* PROFILE_PATTERNS */


/* Initialize pattern profiling fields in pattern struct arrays. */
void
prepare_pattern_profiling()
{
#if PROFILE_PATTERNS
  clear_profile(pat_db.patterns);
  clear_profile(attpat_db.patterns);
  clear_profile(defpat_db.patterns);
  clear_profile(endpat_db.patterns);
  clear_profile(conn_db.patterns);
  clear_profile(influencepat_db.patterns);
  clear_profile(barrierspat_db.patterns);
  clear_profile(aa_attackpat_db.patterns);
  clear_profile(owl_attackpat_db.patterns);
  clear_profile(owl_vital_apat_db.patterns);
  clear_profile(owl_defendpat_db.patterns);
  clear_profile(fusekipat_db.patterns);
#else
  fprintf(stderr,
	  "Warning, no support for pattern profiling in this binary.\n");
#endif
}


/* Report result of pattern profiling. Only patterns with at least one
 * match are listed.
 */
void
report_pattern_profiling()
{
#if PROFILE_PATTERNS
  int hits = 0;
  int dfa_hits = 0;
  int nodes = 0;

  print_profile(pat_db.patterns, &hits, &nodes, &dfa_hits);
  print_profile(attpat_db.patterns, &hits, &nodes, &dfa_hits);
  print_profile(defpat_db.patterns, &hits, &nodes, &dfa_hits);
  print_profile(endpat_db.patterns, &hits, &nodes, &dfa_hits);
  print_profile(conn_db.patterns, &hits, &nodes, &dfa_hits);
  print_profile(influencepat_db.patterns, &hits, &nodes, &dfa_hits);
  print_profile(barrierspat_db.patterns, &hits, &nodes, &dfa_hits);
  print_profile(aa_attackpat_db.patterns, &hits, &nodes, &dfa_hits);
  print_profile(owl_attackpat_db.patterns, &hits, &nodes, &dfa_hits);
  print_profile(owl_vital_apat_db.patterns, &hits, &nodes, &dfa_hits);
  print_profile(owl_defendpat_db.patterns, &hits, &nodes, &dfa_hits);
  print_profile(fusekipat_db.patterns, &hits, &nodes, &dfa_hits);
  fprintf(stderr, "------ ---------\n");
  fprintf(stderr, "%6d, %6d %9d\n", dfa_hits, hits, nodes);
#endif
}



/**************************************************************************/
/* Standard matcher:                                                      */
/**************************************************************************/


/* Forward declarations. */

static void fixup_patterns_for_board_size(struct pattern *pattern);
static void prepare_for_match(int color);
static void do_matchpat(int m, int n, matchpat_callback_fn_ptr callback,
			int color, struct pattern *database,
			void *callback_data, char goal[BOARDMAX]);
static void matchpat_loop(matchpat_callback_fn_ptr callback, 
			  int color, int anchor,
			  struct pattern_db *pdb, void *callback_data,
			  char goal[BOARDMAX], int anchor_in_goal);
void transform(int i, int j, int *ti, int *tj, int trans);

/* The pattern matcher still works in 2D and has a private copy of the
 * board here.
 */
static Intersection p[MAX_BOARD][MAX_BOARD];
static void board_to_p(void);

static int matchpat_call_level = 0;
static Intersection saved_p[MAX_BOARD][MAX_BOARD];

/* Precomputed tables to allow rapid checks on the piece at
 * the board. This table relies on the fact that color is
 * 1 or 2.
 *
 * For pattern element i,  require  (p[m][n] & andmask[i]) == valmask[i]
 *
 * .XO) For i=0,1,2,  p[m][n] & 3 is a no-op, so we check p[][] == valmask
 * x)   For i=3, we are checking that p[][] is not color, so AND color and
 *      we get 0 for either empty or OTHER_COLOR, but color if it contains
 *      color
 * o)   Works the other way round for checking it is not X.
 *
 *
 *  gcc allows the entries to be computed at run-time, but that is not ANSI.
 */
 
static const int and_mask[2][8] = {
  /*  .      X      O     x      o      ,      a      !         color */ 
  {   3,     3,     3,  WHITE, BLACK,   3,     3,     3   }, /* BLACK */
  {   3,     3,     3,  BLACK, WHITE,   3,     3,     3   }  /* WHITE */
};

static const int val_mask[2][8] = {
  { EMPTY, BLACK, WHITE,  0,     0,   EMPTY, EMPTY, EMPTY},  /* BLACK */ 
  { EMPTY, WHITE, BLACK,  0,     0,   EMPTY, EMPTY, EMPTY}   /* WHITE */
};


/* and a table for checking classes quickly
 * class_mask[status][color] contains the mask to look for in class.
 * ie. if  pat[r].class & class_mask[dragon[x][y].status][p[x][y]]
 * is not zero then we reject it
 * Most elements if class_mask[] are zero - it is a sparse
 * matrix containing
 *  CLASS_O in [DEAD][color]
 *  CLASS_O in [CRITICAL][color]
 *  CLASS_o in [ALIVE][color]
 *  CLASS_X in [DEAD][other]
 *  CLASS_x in [ALIVE][other]
 *
 * so eg. if we have a dead white dragon, and we
 * are checking a pattern for black, then
 *  class_mask[DEAD][other]  will contain CLASS_X
 * Then we reject any patterns which have CLASS_X
 * set in the class bits.
 *
 * Making it static guarantees that all fields are
 * initially set to 0, and we overwrite the ones
 * we care about each time.
 */
  
static unsigned int class_mask[MAX_DRAGON_STATUS][3];


/* In the current implementation, the edge constraints depend on
 * the board size, because we pad width or height out to the
 * board size. (This is because it is easy to find the corners
 * of the rotated pattern, but it is harder to transform the
 * bitmask of edge constraints.)
 *
 * But since version 1.103, board size is variable. Thus we
 * make a first pass through the table once we know the board
 * size.
 *
 * This should be called once for each pattern database.
 */

static void
fixup_patterns_for_board_size(struct pattern *pattern)
{

  for (; pattern->patn; ++pattern)
    if (pattern->edge_constraints != 0) {

      /* If the patterns have been fixed up for a different board size
       * earlier, we need to undo the modifications that were done
       * below before we do them anew. The first time this function is
       * called, this step is effectively a no-op.
       */
      
      if (pattern->edge_constraints & NORTH_EDGE)
	pattern->maxi = pattern->mini + pattern->height;
	
      if (pattern->edge_constraints & SOUTH_EDGE)
	pattern->mini = pattern->maxi - pattern->height;
	
      if (pattern->edge_constraints & WEST_EDGE)
	pattern->maxj = pattern->minj + pattern->width;
      
      if (pattern->edge_constraints & EAST_EDGE)
	pattern->minj = pattern->maxj - pattern->width;
      
      /* we extend the pattern in the direction opposite the constraint,
       * such that maxi (+ve) - mini (-ve) = board_size-1
       * Note : the pattern may be wider than the board, so
       * we need to be a bit careful !
       */
      
      if (pattern->edge_constraints & NORTH_EDGE)
	if (pattern->maxi < (board_size-1) + pattern->mini)
	  pattern->maxi = (board_size-1) + pattern->mini;
      
      if (pattern->edge_constraints & SOUTH_EDGE)
	if (pattern->mini > pattern->maxi - (board_size-1))
	  pattern->mini = pattern->maxi - (board_size-1);
      
      if (pattern->edge_constraints & WEST_EDGE)
	if (pattern->maxj <  (board_size-1) + pattern->minj)
	  pattern->maxj = (board_size-1) + pattern->minj;
      
      if (pattern->edge_constraints & EAST_EDGE)
	if (pattern->minj > pattern->maxj - (board_size-1))
	  pattern->minj = pattern->maxj - (board_size-1);
    }

}


/* 
 * prepare a pattern matching for color point of view
 */
static void
prepare_for_match(int color)
{
  int other = OTHER_COLOR(color);

  /* Basic sanity checks. */
  gg_assert(color != EMPTY);

  /* If we set one of class_mask[XXX][color] and
   * class_mask[XXX][other], we have to explicitly set or reset the
   * other as well, since 'color' may change between calls.
   */
  class_mask[DEAD][color]     = CLASS_O;
  class_mask[DEAD][other]     = CLASS_X;
  class_mask[CRITICAL][color] = CLASS_O;
  class_mask[CRITICAL][other] = 0;       /* Need to reset this. */
  class_mask[ALIVE][color]    = CLASS_o;
  class_mask[ALIVE][other]    = CLASS_x;
}



/* Compute the transform of (i, j) under transformation number trans.
 * *ti and *tj point to the transformed coordinates.
 * ORDER MATTERS : see texinfo documentation for details
 *
 * There is a copy of this table in mkpat.c
 */

const int transformations[8][2][2] = {
  {{ 1,  0}, { 0,  1}}, /* a - identity transformation matrix */
  {{ 0,  1}, {-1,  0}}, /* g - rotate 270 counter-clockwise */
  {{-1,  0}, { 0, -1}}, /* d - rotate 180 */
  {{ 0, -1}, { 1,  0}}, /* f - rotate 90 counter-clockwise */
  {{ 0, -1}, {-1,  0}}, /* h - rotate 90 and invert */
  {{-1,  0}, { 0,  1}}, /* b - flip left */
  {{ 0,  1}, { 1,  0}}, /* e - rotate 90 and flip left */
  {{ 1,  0}, { 0, -1}}  /* c - invert */
};


/* Functional version for completeness. Prefer the TRANSFORM macro
 * in patterns.h.
 */

void 
transform(int i, int j, int *ti, int *tj, int trans)
{
  TRANSFORM(i, j, ti, tj, trans);
}


/* Compute the point offset by (di, dj), relative to a base point (basepos), 
 * taking into account a transformation.
 */

int
offset(int i, int j, int basepos, int trans)
{
  int ui, uj;
  TRANSFORM(i, j, &ui, &uj, trans);
  return basepos + DELTA(ui, uj);
}


/*
 * Try all the patterns in the given array at (m, n). Invoke the
 * callback for any that matches. Classes X,O,x,o are checked here. It
 * is up to the callback to process the other classes, and any helper
 * or autohelper functions.
 *
 * If the support of goal[MAX_BOARD][MAX_BOARD] is a subset of the board,
 * patterns are rejected which do not involve this dragon. If goal is a 
 * null pointer, this parameter is ignored.
 */

static void
do_matchpat(int m, int n, matchpat_callback_fn_ptr callback, int color,
	    struct pattern *pattern, void *callback_data,
	    char goal[BOARDMAX]) 
{
  const int anchor_test = p[m][n] ^ color;  /* see below */
  int merged_val;

  /* Basic sanity checks. */
  ASSERT_ON_BOARD2(m, n);

  /* calculate the merged value around [m][n] for the grid opt */
  {
    int i, j;
    int shift = 30;

    merged_val = 0;
    for (i = m-1; i <= m+2; ++i)
      for (j = n-1; j <= n+2; shift -= 2, ++j) {
	unsigned int this;
	if (!ON_BOARD2(i, j))
	  this = 3;
	else if ((this = p[i][j]) == 0)
	  continue;
	else if (color == 2)
	  this = OTHER_COLOR(this);
	merged_val |= (this << shift);
      }
  }

  /* Try each pattern - NULL pattern marks end of list. Assume at least 1 */
  gg_assert(pattern->patn);

  do {
    /*
     * These days we always match all patterns.
     */
    {
      int end_transformation;
      int ll;   /* Iterate over transformations (rotations or reflections)  */
      int k;    /* Iterate over elements of pattern */
      int found_goal, found_nongoal;
  
      /* We can check the color of the anchor stone now.
       * Roughly half the patterns are anchored at each
       * color, and since the anchor stone is invariant under
       * rotation, we can reject all rotations of a wrongly-anchored
       * pattern in one go.
       *
       * Patterns are always drawn from O perspective in .db,
       * so p[m][n] is 'color' if the pattern is anchored
       * at O, or 'other' for X.
       * Since we require that this flag contains 3 for
       * anchored_at_X, we can check that
       *   p[m][n] == (color ^ anchored_at_X)
       * which is equivalent to
       *   (p[m][n] ^ color) == anchored_at_X)
       * and the LHS is something we precomputed.
       */

      if (anchor_test != pattern->anchored_at_X)
      {
#ifdef PROFILE_MATCHER
	/* oops - need to work out something we deferred */
        totals[0] += (pattern->trfno == 5 ? 4 : pattern->trfno);
#endif
	continue;  /* does not match the anchor */
      }

      ll = 0;  /* first transformation number */
      end_transformation = pattern->trfno;

      /* Ugly trick for dealing with 'O' symmetry. */
      if (pattern->trfno == 5) {
	ll = 2;
	end_transformation = 6;
      }
      
#ifdef PROFILE_MATCHER
      totals[0] += end_transformation - ll;
#endif

      /* try each orientation transformation. Assume at least 1 */

      do {

#if PROFILE_PATTERNS
	int nodes_before;
#endif
	
#ifdef PROFILE_MATCHER
	++totals[1];
#endif

#if GRID_OPT == 1

	/* We first perform the grid check : this checks up to 16
	 * elements in one go, and allows us to rapidly reject
	 * patterns which do not match.  While this check invokes a
	 * necessary condition, it is not a sufficient test, so more
	 * careful checks are still required, but this allows rapid
	 * rejection. merged_val should contain a combination of
	 * 16 board positions around m, n.  The colours have been fixed
	 * up so that stones which are 'O' in the pattern are
	 * bit-pattern %01.
	 */
	if ((merged_val & pattern->and_mask[ll]) != pattern->val_mask[ll])
	  continue;  /* large-scale match failed */

#endif /* GRID_OPT == 1 */

#ifdef PROFILE_MATCHER
	++totals[2];
#endif
	/* Next, we do the range check. This applies the edge
	 * constraints implicitly.
	 */
	{
	  int mi, mj, xi, xj;
	  
	  TRANSFORM(pattern->mini, pattern->minj, &mi, &mj, ll);
	  TRANSFORM(pattern->maxi, pattern->maxj, &xi, &xj, ll);

	  /* {min,max}{i,j} are the appropriate corners of the original
	   * pattern, Once we transform, {m,x}{i,j} are still corners,
	   * but we don't know *which* corners.
	   * We could sort them, but it turns out to be cheaper
	   * to just test enough cases to be safe.
	   */

	  DEBUG(DEBUG_MATCHER, "---\nconsidering pattern '%s', rotation %d at %m. Range %d,%d -> %d,%d\n",
		pattern->name, ll, m, n, mi, mj, xi, xj);

	  /* now do the range-check */
	  if (!ON_BOARD2(m+mi, n+mj) || !ON_BOARD2(m+xi, n+xj))
	    continue;  /* out of range */
	}

#ifdef PROFILE_MATCHER	 
	++totals[3];
#endif

	/* Now iterate over the elements of the pattern. */
	found_goal = 0;
	found_nongoal = 0;
	for (k = 0; k < pattern->patlen; ++k) { /* match each point */
	  int x, y; /* absolute coords of (transformed) pattern element */

	  int att = pattern->patn[k].att;  /* what we are looking for */


	  /* Work out the position on the board of this pattern element. */

	  /* transform pattern real coordinate... */
	  TRANSFORM(pattern->patn[k].x, pattern->patn[k].y, &x, &y, ll);
	  x += m;
	  y += n;

	  ASSERT_ON_BOARD2(x, y);

	  /* ...and check that p[x][y] matches (see above). */
	  if ((p[x][y] & and_mask[color-1][att]) != val_mask[color-1][att])
	    goto match_failed;

	  if (goal != NULL && p[x][y] != EMPTY) {
	    if (goal[POS(x, y)])
	      found_goal = 1;
	    else if (p[x][y] == color)
	      found_nongoal = 1;
	  }
	  
	  /* Check out the class_X, class_O, class_x, class_o
	   * attributes - see patterns.db and above.
	   */
	  if ((pattern->class
	       & class_mask[dragon[POS(x, y)].matcher_status][p[x][y]]) != 0)
	    goto match_failed; 
	  
	} /* loop over elements */


#if GRID_OPT == 2

	/* Make sure the grid optimisation wouldn't have 
           rejected this pattern */
	ASSERT2((merged_val & pattern->and_mask[ll])
	       == pattern->val_mask[ll], m, n);

#endif /* we don't trust the grid optimisation */


#ifdef PROFILE_MATCHER
	++totals[4];
#endif


	/* Make it here ==> We have matched all the elements to the board. */
	if ((goal != NULL) && !found_goal)
	  goto match_failed;
	if ((goal != NULL) && ((pattern->class) & CLASS_C) && !found_nongoal)
	  goto match_failed;
	


#ifdef PROFILE_MATCHER
	++totals[5];
#endif

#if PROFILE_PATTERNS
	pattern->hits++;
	nodes_before = stats.nodes;
#endif
	
	/* A match!  - Call back to the invoker to let it know. */
	callback(m, n, color, pattern, ll, callback_data);

#if PROFILE_PATTERNS
	pattern->reading_nodes += stats.nodes - nodes_before;
#endif
	
	/* We jump to here as soon as we discover a pattern has failed. */
      match_failed:
	DEBUG(DEBUG_MATCHER, 
	      "end of pattern '%s', rotation %d at %m\n---\n", 
	      pattern->name, ll, m, n);
	 
      } while (++ll < end_transformation); /* ll loop over symmetries */
    } /* if not rejected by maxwt */
  } while ((++pattern)->patn);  /* loop over patterns */


#ifdef PROFILE_MATCHER
  fprintf(stderr, 
	  "total %d, anchor=%d, grid=%d, edge=%d, matched=%d, accepted=%d\n",
	  totals[0], totals[1], totals[2], totals[3], totals[4], totals[5]);
#endif

}


/*
 * Scan the board to get patterns anchored by anchor from color
 * point of view.
 * the board must be prepared by dfa_prepare_for_match(color) !
 */
static void
matchpat_loop(matchpat_callback_fn_ptr callback, int color, int anchor,
	      struct pattern_db *pdb, void *callback_data,
	      char goal[BOARDMAX], int anchor_in_goal) 
{
  int i, j;

  for (i = 0; i != board_size; i++)
    for (j = 0; j != board_size; j++)
      if (p[i][j] == anchor
          && (!anchor_in_goal || goal[POS(i,j)] != 0))
	do_matchpat(i, j, callback, color, 
		    pdb->patterns, callback_data, goal);
}

#if EXPERIMENTAL_READING

/**************************************************************************/
/* Tree matcher:                                                           */
/**************************************************************************/
static void tree_prepare_for_match(int color);
static void tree_matchpat_loop(matchpat_callback_fn_ptr callback, 
			       int color, int anchor,
			       struct pattern_db *pdb, void *callback_data,
			       char goal[BOARDMAX], int anchor_in_goal);
static void tree_do_matchpat(int m, int n, matchpat_callback_fn_ptr callback,
			     int color, struct pattern_db *database,
			     void *callback_data, char goal[BOARDMAX],
                             int anchor_in_goal);


void
tree_match_init(void)
{
  init_tree_read_attack();
  init_tree_read_defend();
  init_tree_owl_attackpat();
  init_tree_owl_defendpat();
  init_tree_owl_vital_apat();
}


static void 
tree_prepare_for_match(int color)
{
  UNUSED(color);
  /* Nothing to prepare! */
}

static void 
tree_matchpat_loop(matchpat_callback_fn_ptr callback, 
		   int color, int anchor,
		   struct pattern_db *pdb, void *callback_data,
		   char goal[BOARDMAX], int anchor_in_goal)
{
  int i, j;

  for (i = 0; i != board_size; i++)
    for (j = 0; j != board_size; j++)
      if (board[POS(i,j)] == anchor
          && (!anchor_in_goal || goal[POS(i,j)] != 0))
	tree_do_matchpat(i, j, callback, color, 
			 pdb, callback_data, goal, anchor_in_goal);

}

/* possibly cheeper to pass a little less recursively.
 * Note: This could even just be static data, unless the
 * tree pattern matcher is itself used recursively.*/
struct rec_data {
  matchpat_callback_fn_ptr callback;
  struct pattern_db *database;
  void *callback_data;
};


/* Recursively walks the tree data structure, calling the callback
 * for all patterns matched at location (m,n).
 */
static void 
do_tree_matchpat_rec(int color, int m, int n, int goal_found,
                     char goal[BOARDMAX], 
                     struct tree_node_list *tnl, 
                     struct rec_data *pdata)
{
  if (0 && !tnl) {
    return;
  }
  tnl = tnl->next;
  while (tnl) {
    struct tree_node *node = &(tnl->node);
    int x = m + node->x;
    int y = n + node->y;;
    if (ON_BOARD2(x,y)) {
      int att = node->att;
      int point_color = BOARD(x,y);
      if ((att == EMPTY && point_color == EMPTY)
          || (att == ATT_X && point_color == OTHER_COLOR(color))
          || (att == ATT_O && point_color == color)) {
        goal_found = goal_found || goal[POS(x,y)];
        if (node->matches) {
          struct match_node *match = node->matches->next;
          while (match) {
            struct pattern *pattern =
	      &(pdata->database->patterns[match->patnum]);
            int ll = match->orientation;
	    int mi, mj, xi, xj;
	    TRANSFORM(pattern->mini, pattern->minj, &mi, &mj, ll);
	    TRANSFORM(pattern->maxi, pattern->maxj, &xi, &xj, ll);
	    /* now do the range-check */
            if (!goal_found
                || !ON_BOARD2(m+mi, n+mj) 
                || !ON_BOARD2(m+xi, n+xj)) {
	      ;/* goal not found, or out of range */
            }
	    else {
              if (0) {
                gprintf("  P[%s, %d] matches at %m)\n",
			pattern->name, 
			match->orientation, x, y);
              }
              /* A match! */
              pdata->callback(m, n, color, pattern, ll, pdata->callback_data);
            }

            match = match->next;
          }
        }
        if (node->next_list && node->next_list->next) {
          do_tree_matchpat_rec(color, m, n, goal_found, goal,
			       node->next_list, pdata);
        }
      }
    }
    tnl = tnl->next;
  }
}

/* Stub for matchpat function.  Work done in recursive helper. */
static void 
tree_do_matchpat(int m, int n, matchpat_callback_fn_ptr callback,
		 int color, struct pattern_db *database,
		 void *callback_data, char goal[BOARDMAX],
		 int anchor_in_goal)
{
  struct tree_node_list *tree = database->tnl;
  struct rec_data data;

  if (0) {
    if (0)
      showboard(0);
    gprintf("Trying to match at %m\n", m, n);
  }
  data.callback = callback;
  data.callback_data = callback_data;
  data.database = database;

  /* note: If anchor_in_goal is 0, then the goal_found parameter is
   *   always trivially true.  This will short-circuit some array
   *   lookups in the recursive version.
   */
  do_tree_matchpat_rec(color, m, n, !anchor_in_goal, goal, tree, &data);
}

/**************************************************************************/
/* Tree initialization helper                                             */
/**************************************************************************/

/* The tree data structure is output with raw integer offsets
 * relative to a single array of tree_node_list and match_node
 * elements.  These offsets need to added to the actual base
 * address of the list of elements for the pointers to be
 * meaningful.
 */
void 
tree_initialize_pointers(struct tree_node_list *tnl,
                         struct match_node *matches,
                         int tnl_size,
                         int matches_size)
{
  struct tree_node_list *tnl_walk = tnl;
  struct match_node *matches_walk = matches;

  do {
    if (tnl_walk->next)
      tnl_walk->next = tnl + (int)(tnl_walk->next);
    if (tnl_walk->node.matches)
      tnl_walk->node.matches = matches + (int)(tnl_walk->node.matches);
    if (tnl_walk->node.next_list)
      tnl_walk->node.next_list = tnl + (int)(tnl_walk->node.next_list);
  } while (++tnl_walk < tnl + tnl_size);


  do {
    if (matches_walk->next)
      matches_walk->next = matches + (int)(matches_walk->next);
  } while (++matches_walk < matches + matches_size);  
}

#endif

#

/**************************************************************************/
/* DFA matcher:                                                           */
/**************************************************************************/

/* If DFA_SORT, all matched patterns are sorted and checked 
 * in the same order as the standard scheme */
#define DFA_SORT 0

/* Set this to show the dfa board in action */
/* #define DFA_TRACE 1 */

/* data */
extern int board_size;
static int dfa_board_size = -1;
extern int dfa_p[DFA_MAX_BOARD * 4 * DFA_MAX_BOARD * 4];
extern int spiral[8][MAX_ORDER];
const int convert[3][4];

/* Forward declarations. */
static void dfa_prepare_for_match(int color);
static int scan_for_patterns(dfa_t *pdfa, int l, int m, int n, 
			     int *pat_list);
#if DFA_SORT
static int compare_int(const void *a, const void *b);
#endif
static void do_dfa_matchpat(dfa_t *pdfa,
			    int m, int n, matchpat_callback_fn_ptr callback,
			    int color, struct pattern *database,
			    void *callback_data, char goal[BOARDMAX]);
static void check_pattern_light(int m, int n, 
				matchpat_callback_fn_ptr callback,
				int color, struct pattern *pattern, int ll,
				void *callback_data,
				char goal[BOARDMAX]);
static void dfa_matchpat_loop(matchpat_callback_fn_ptr callback,
			      int color, int anchor,
			      struct pattern_db *pdb, void *callback_data,
			      char goal[BOARDMAX], int anchor_in_goal);


/***********************************************************************/



/* prepare the dfa board (gnugo initialization) */
void
dfa_match_init(void)
{
  /* Copy the board to the p array.
   * FIXME: Check whether this is needed here.
   */
  board_to_p();

  buildSpiralOrder(spiral);

  if (owl_vital_apat_db.pdfa != NULL)
    DEBUG(DEBUG_MATCHER, "owl_vital_apat --> using dfa\n");
  if (owl_attackpat_db.pdfa != NULL)
    DEBUG(DEBUG_MATCHER, "owl_attackpat --> using dfa\n");
  if (owl_defendpat_db.pdfa != NULL)
    DEBUG(DEBUG_MATCHER, "owl_defendpat --> using dfa\n");
  if (pat_db.pdfa != NULL)
    DEBUG(DEBUG_MATCHER, "pat --> using dfa\n");
  if (attpat_db.pdfa != NULL)
    DEBUG(DEBUG_MATCHER, "attpat --> using dfa\n");
  if (defpat_db.pdfa != NULL)
    DEBUG(DEBUG_MATCHER, "defpat --> using dfa\n");
  if (endpat_db.pdfa != NULL)
    DEBUG(DEBUG_MATCHER, "endpat --> using dfa\n");
  if (conn_db.pdfa != NULL)
    DEBUG(DEBUG_MATCHER, "conn --> using dfa\n");
  if (influencepat_db.pdfa != NULL)
    DEBUG(DEBUG_MATCHER, "influencepat --> using dfa\n");
  if (barrierspat_db.pdfa != NULL)
    DEBUG(DEBUG_MATCHER, "barrierspat --> using dfa\n");
  if (fusekipat_db.pdfa != NULL)
    DEBUG(DEBUG_MATCHER, "barrierspat --> using dfa\n");

  /* force out_board initialization */
  dfa_board_size = -1;
}

/* 
 * copy the board on a private board with adapted colors 
 * and adapted size 
 */
static void
dfa_prepare_for_match(int color)
{
  int i, j;
  int ii;
    
  if (dfa_board_size != board_size) {
    dfa_board_size = board_size;
    /* clean up the board */
    for (ii = 0; ii < 4 * DFA_MAX_BOARD * 4 * DFA_MAX_BOARD; ii++)
      dfa_p[ii] = OUT_BOARD;
  }

  /* copy the board */
  for (i = 0; i < dfa_board_size; i++)
    for (j = 0; j < dfa_board_size; j++)
      dfa_p[DFA_POS(i, j) + DFA_OFFSET] = 
	EXPECTED_COLOR(color, p[i][j]);

  prepare_for_match(color);
}

#if 0
/* debug function */
static void
dump_dfa_board(int m, int n)
{
  int i, j;

  for (i = DFA_MAX_BOARD / 2; i < DFA_MAX_BOARD*1.5 ; i++) {
    for (j = DFA_MAX_BOARD / 2 ; j < DFA_MAX_BOARD*1.5 ; j++)
      if (i != (m+DFA_MAX_BOARD) || j != (n+DFA_MAX_BOARD))
	fprintf(stderr, "%1d", dfa_p[DFA_PSO(i, j)]);
      else
	fprintf(stderr, "*");
    fprintf(stderr, "\n");
  }
}
#endif


/* 
 * Scan the board with a dfa to get 
 * all patterns matching at (m, n) with transformation l.
 * Store patterns indexes + transformation in pat_list.
 * Return the number of patterns found.
 */
static int
scan_for_patterns(dfa_t *pdfa, int l, int m, int n, int *pat_list)
{
  int state, att, id, row;
  int dfa_pos;

  dfa_pos = DFA_POS(m, n) + DFA_OFFSET;
  state = 1; /* initial state */
  row = 0; /* initial row */
  id = 0; /* position in id_list */ 
  
  while (state != 0) {/* while not on error state */
    /* collect patterns indexes */
    att = pdfa->states[state].att;
    while (att != 0) {
      pat_list[id] = l + 8 * pdfa->indexes[att].val;
      id++;
      att = pdfa->indexes[att].next;
    }
      
    /* go to next state */
    state = pdfa->states[state].next[dfa_p[dfa_pos + spiral[l][row]]];
    row++;
  }

  ASSERT2(row < MAX_ORDER, m, n);
  return id;
}


#if DFA_SORT
/* used to sort patterns */
static int
compare_int(const void *a, const void *b)
{
  const int *da = (const int *) a;
  const int *db = (const int *) b;
     
  return (*da > *db) - (*da < *db);
}
#endif


/* perform pattern matching with dfa filtering */
static void 
do_dfa_matchpat(dfa_t *pdfa,
		int m, int n, matchpat_callback_fn_ptr callback,
		int color, struct pattern *database,
		void *callback_data, char goal[BOARDMAX])
{
  int ll;      /* Iterate over transformations (rotations or reflections)  */
  int matched; /* index in database[] of the matched pattern */

  int reorder[DFA_MAX_MATCHED];
  int *preorder = reorder;
  int maxr = 0, k;

  /* Basic sanity checks. */
  ASSERT_ON_BOARD2(m, n);

  /* Geometrical pattern matching */
  maxr = 0;

  /* one scan by transformation */
  for (ll = 0; ll != 8; ll++) {
    maxr += scan_for_patterns(pdfa, ll, m, n, preorder);
    preorder = reorder + maxr;
  }

  ASSERT2(maxr < DFA_MAX_MATCHED, m, n);

  /* Sorting patterns keep the same order as 
   * standard pattern matching algorithm */
#if DFA_SORT
  gg_sort(reorder, maxr, sizeof(int), compare_int);
#endif /* DFA_SORT */


  /* Constraints and other tests */

  for (k = 0; k != maxr ; k++) {
    matched = reorder[k] / 8;
    ll = reorder[k] % 8;

#if PROFILE_PATTERNS
    database[matched].dfa_hits++;
#endif
    
    check_pattern_light(m, n, callback, color, database+matched, 
			ll, callback_data, goal);
  }
}


/*
 * Do the pattern matching for a given pattern and a given 
 * transformation ll. 
 * (does not recompute what dfa filtering has already done)
 */

static void
check_pattern_light(int m, int n, matchpat_callback_fn_ptr callback, int color,
	      struct pattern *pattern, int ll, void *callback_data,
	      char goal[BOARDMAX])
{
  int k;			/* Iterate over elements of pattern */
  int found_goal, found_nongoal;
  
#if PROFILE_PATTERNS
  int nodes_before;
#endif
  
#ifdef PROFILE_MATCHER
  ++totals[1];
#endif
 
  /* Now iterate over the elements of the pattern. */
  found_goal = 0;
  found_nongoal = 0;
  for (k = 0; k < pattern->patlen; k++) {
  				/* match each point */
    int x, y;			/* absolute (board) co-ords of 
  				   (transformed) pattern element */

    /* transform pattern real coordinate... */
    TRANSFORM(pattern->patn[k].x, pattern->patn[k].y, &x, &y, ll);
    x += m;
    y += n;
    ASSERT_ON_BOARD2(x, y);

    /* goal check */
    if (goal != NULL) {
      if (goal[POS(x, y)])
	found_goal = 1;
      else if (p[x][y] == color)
	found_nongoal = 1;
    }

   /* class check */
    ASSERT2(dragon[POS(x,y)].matcher_status < 4, x, y);
    if ((pattern->class
	 & class_mask[dragon[POS(x, y)].matcher_status][p[x][y]]) != 0)
      goto match_failed;
    
  }/* loop over elements */
  
  /* Make it here ==> We have matched all the elements to the board. */
  if (goal != NULL && !found_goal)
    goto match_failed;
  if (goal != NULL && (pattern->class & CLASS_C) && !found_nongoal)
    goto match_failed;

#ifdef PROFILE_MATCHER
  ++totals[4];
#endif

#if PROFILE_PATTERNS
  pattern->hits++;
  nodes_before = stats.nodes;
#endif
  
  /* A match!  - Call back to the invoker to let it know. */
  callback(m, n, color, pattern, ll, callback_data);
  
#if PROFILE_PATTERNS
  pattern->reading_nodes += stats.nodes - nodes_before;
#endif
  
  /* We jump to here as soon as we discover a pattern has failed. */
 match_failed:
  DEBUG(DEBUG_MATCHER, "end of pattern '%s', rotation %d at %m\n---\n",
	pattern->name, ll, m, n);
  
} /* check_pattern_light */


/*
 * Scan the board to get patterns anchored by anchor from color
 * point of view.
 * the board must be prepared by dfa_prepare_for_match(color) !
 */
static void
dfa_matchpat_loop(matchpat_callback_fn_ptr callback, int color, int anchor,
		  struct pattern_db *pdb, void *callback_data,
		  char goal[BOARDMAX], int anchor_in_goal) 
{
  int i, j;

  for (i = 0; i != board_size; i++)
    for (j = 0; j != board_size; j++)
      if (p[i][j] == anchor
          && (!anchor_in_goal || goal[POS(i,j)] != 0))
	do_dfa_matchpat(pdb->pdfa, i, j, callback, color, pdb->patterns, 
			callback_data, goal);
}



/**************************************************************************/
/* Main functions:                                                        */
/**************************************************************************/


typedef void (*loop_fn_ptr_t)(matchpat_callback_fn_ptr callback, 
			      int color, int anchor,
			      struct pattern_db *pdb, void *callback_data,
			      char goal[BOARDMAX], int anchor_in_goal);

typedef void (*prepare_fn_ptr_t)(int color);

/* same as the old matchpat but for all the board with
 * preparation.
 *
 * 4 possible values for color argument:
 * WHITE or BLACK: matchpat is called from this color point of view.
 * ANCHOR_COLOR  : matchpat is called from the anchor's point of view.
 * ANCHOR_OTHER  : matchpat is called from the opposite color of the 
 *                 anchor's point of view.
 */

void
matchpat(matchpat_callback_fn_ptr callback, int color,
	 struct pattern_db *pdb, void *callback_data,
	 char goal[BOARDMAX]) 
{
  matchpat_goal_anchor(callback, color, pdb, callback_data, goal, 0);
}

void 
matchpat_goal_anchor(matchpat_callback_fn_ptr callback, int color,
	 struct pattern_db *pdb, void *callback_data,
	 char goal[BOARDMAX], int anchor_in_goal) 
{
  loop_fn_ptr_t loop = matchpat_loop;
  prepare_fn_ptr_t prepare = prepare_for_match;

  /*
   * Caution, dangerous workaround ahead.
   *
   * It's almost certainly not safe to make recursive calls to this
   * function, but if we just make sure that we don't corrupt the
   * contents of the p[][] array because of this, it seems to work
   * anyway.
   *
   * Therefore we backup p[][] to saved_p[][] when we are called
   * recursively and restore it when we are ready.
   *
   * FIXME: This is not a proper solution. In any case this
   * implementation can only handle one level of recursion, which on
   * the other hand is all we need.
   */

  /* Don't accept a second recursive call. */
  gg_assert(matchpat_call_level <= 1);

  if (matchpat_call_level == 1)
    memcpy(saved_p, p, sizeof(p));

  matchpat_call_level++;

  /* Copy the board to the p array. */
  board_to_p();

  /* check board size */
  if (pdb->fixed_for_size != board_size) {
    fixup_patterns_for_board_size(pdb->patterns);
    pdb->fixed_for_size = board_size;
  }

  /* select pattern matching strategy */
  if (pdb->pdfa != NULL) { 
    loop = dfa_matchpat_loop;
    prepare = dfa_prepare_for_match;
  }

#if EXPERIMENTAL_READING
  if (pdb->tnl) {
    loop = tree_matchpat_loop;
    prepare = tree_prepare_for_match;
  }
#endif

  /* select strategy */
  switch (color) {
    case ANCHOR_COLOR:
      { /* match pattern for the color of their anchor */
	prepare(WHITE);
	loop(callback, WHITE, WHITE, pdb, callback_data, goal, anchor_in_goal);
	prepare(BLACK);
	loop(callback, BLACK, BLACK, pdb, callback_data, goal, anchor_in_goal);
      }
      break;
    case ANCHOR_OTHER:
      { /* match pattern for the opposite color of their anchor */
	prepare(WHITE);
	loop(callback, WHITE, BLACK, pdb, callback_data, goal, anchor_in_goal);
	prepare(BLACK);
	loop(callback, BLACK, WHITE, pdb, callback_data, goal, anchor_in_goal);
      }
      break;
    default:
      { /* match all patterns for color */
	prepare(color);
	loop(callback, color, WHITE, pdb, callback_data, goal, anchor_in_goal);
	loop(callback, color, BLACK, pdb, callback_data, goal, anchor_in_goal);
      }
  }

  matchpat_call_level--;
  if (matchpat_call_level == 1)
    memcpy(p, saved_p, sizeof(p));
}


/* A dedicated matcher which can only do fullboard matching on
 * odd-sized boards, optimized for fuseki patterns.
 */
void
fullboard_matchpat(fullboard_matchpat_callback_fn_ptr callback, int color,
		   struct fullboard_pattern *pattern)
{
  int other = OTHER_COLOR(color);
  int ll;   /* Iterate over transformations (rotations or reflections)  */
  int k;    /* Iterate over elements of pattern */
  int mid = (board_size-1)/2; /* We transform around the center point. */
  int m, n;
  int number_of_stones_on_board = 0;
  
  /* Basic sanity check. */
  gg_assert(color != EMPTY);
  gg_assert(board_size%2 == 1);
  
  /* Copy the board to the p array. */
  board_to_p();

  /* Count the number of stones on the board. */
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++)
      if (p[m][n] != EMPTY)
	number_of_stones_on_board++;
  
  /* Try each pattern - NULL pattern marks end of list. */
  for (; pattern->patn; pattern++) { 
    /* The number of stones on the board must be right. This is not
     * only an optimization because we never even look at the
     * intersections which are empty in the pattern.
     */
    if (pattern->patlen != number_of_stones_on_board)
      continue;
    
    /* try each orientation transformation */
    for (ll = 0; ll < 8; ll++) {
      /* Now iterate over the elements of the pattern. */
      for (k = 0; k < pattern->patlen; k++) { /* match each point */
	int x, y; /* board co-ords of transformed pattern element */
	int att = pattern->patn[k].att;  /* what we are looking for */

	/* Work out the position on the board of this pattern element. */
	TRANSFORM(pattern->patn[k].x, pattern->patn[k].y, &x, &y, ll);
	x += mid;
	y += mid;

        ASSERT_ON_BOARD2(x, y);

	if ((att == ATT_O && p[x][y] != color)
	    || (att == ATT_X && p[x][y] != other))
	  break;
	
      } /* loop over elements */
	
      if (k == pattern->patlen) {
	/* A match!  - Call back to the invoker to let it know. */
	int x, y;
	TRANSFORM(pattern->movei, pattern->movej, &x, &y, ll);
	x += mid;
	y += mid;
	callback(x, y, pattern, ll);
      }
    }
  }
}

/* Copy the 1D board array to the 2D p array. */
static void
board_to_p(void)
{
  int m, n;
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++)
      p[m][n] = BOARD(m, n);
}

/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */



/* move_reasons */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* #include <stdio.h> */
/* #include <stdlib.h> */
/* #include <string.h> */
/* #include <math.h> */

/* #include "gnugo.h" */
/* #include "liberty.h" */
/* #include "gg_utils.h" */

/* #include "random.h" */
/* #include "move_reasons.h" */


/* All these data structures are declared in move_reasons.h */

struct move_data move[BOARDMAX];
struct move_reason move_reasons[MAX_MOVE_REASONS];
int next_reason;

/* Worms */
int worms[MAX_WORMS];
int next_worm;

/* Dragons */
int dragons[MAX_DRAGONS];
int next_dragon;

/* Connections */
int conn_dragon1[MAX_CONNECTIONS];
int conn_dragon2[MAX_CONNECTIONS];
int next_connection;

/* Unordered worm pairs */
int worm_pair1[MAX_WORM_PAIRS];
int worm_pair2[MAX_WORM_PAIRS];
int next_worm_pair;

/* Unordered sets (currently pairs) of move reasons / targets */
Reason_set either_data[MAX_EITHER];
int        next_either;
Reason_set all_data[MAX_ALL];
int        next_all;

/* Eye shapes */
int eyes[MAX_EYES];
int eyecolor[MAX_EYES];
int next_eye;

/* Lunches */
int lunch_dragon[MAX_LUNCHES]; /* eater */
int lunch_worm[MAX_LUNCHES];   /* food */
int next_lunch;

/* Point redistribution */
int replacement_map[BOARDMAX];

/* Helper functions to check conditions in discard rules. */
typedef int (*discard_condition_fn_ptr)(int pos, int what);

struct discard_rule {
  int reason_type[MAX_REASONS];
  discard_condition_fn_ptr condition;
  int flags;
  char trace_message[MAX_TRACE_LENGTH];
};


/* Initialize move reason data structures. */
void
clear_move_reasons(void)
{
  int i;
  int j;
  int ii;
  int k;
  next_reason = 0;
  next_worm = 0;
  next_dragon = 0;
  next_connection = 0;
  next_worm_pair = 0;
  next_either = 0;
  next_all = 0;
  next_eye = 0;
  next_lunch = 0;
  
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      ii = POS(i, j);

      move[ii].value                  = 0.0;
      move[ii].final_value            = 0.0;
      move[ii].additional_ko_value    = 0.0;
      move[ii].territorial_value      = 0.0;
      move[ii].strategical_value      = 0.0;
      move[ii].maxpos_shape           = 0.0;
      move[ii].numpos_shape           = 0;
      move[ii].maxneg_shape           = 0.0;
      move[ii].numneg_shape           = 0;
      move[ii].followup_value         = 0.0;
      move[ii].influence_followup_value = 0.0;
      move[ii].reverse_followup_value = 0.0;
      move[ii].secondary_value        = 0.0;
      move[ii].min_value              = 0.0;
      move[ii].max_value              = HUGE_MOVE_VALUE;
      move[ii].min_territory          = 0.0;
      move[ii].max_territory          = HUGE_MOVE_VALUE;
      for (k = 0; k < MAX_REASONS; k++)     
	move[ii].reason[k]            = -1;
      move[ii].move_safety            = 0;
      move[ii].worthwhile_threat      = 0;
      /* The reason we assign a random number to each move immediately
       * is to avoid dependence on which moves are evaluated when it
       * comes to choosing between multiple moves of the same value.
       * In this way we can get consistent results for use in the
       * regression tests.
       */
      move[ii].random_number          = gg_drand();

      /* Do not send away the points (yet). */
      replacement_map[ii] = NO_MOVE;
    }
}

/*
 * Find the index of a worm in the list of worms. If necessary,
 * add a new entry. (str) must point to the origin of the worm.
 */
int
find_worm(int str)
{
  int k;

  ASSERT_ON_BOARD1(str);
  for (k = 0; k < next_worm; k++)
    if (worms[k] == str)
      return k;
  
  /* Add a new entry. */
  gg_assert(next_worm < MAX_WORMS);
  worms[next_worm] = str;
  next_worm++;
  return next_worm - 1;
}

/*
 * Find the index of a dragon in the list of dragons. If necessary,
 * add a new entry. (str) must point to the origin of the dragon.
 */
int
find_dragon(int str)
{
  int k;
  ASSERT_ON_BOARD1(str);
  for (k = 0; k < next_dragon; k++)
    if (dragons[k] == str)
      return k;
  
  /* Add a new entry. */
  gg_assert(next_dragon < MAX_DRAGONS);
  dragons[next_dragon] = str;
  next_dragon++;
  return next_dragon - 1;
}

/*
 * Find the index of a connection in the list of connections.
 * If necessary, add a new entry.
 */
static int
find_connection(int dragon1, int dragon2)
{
  int k;
  
  if (dragon1 > dragon2) {
    /* Swap to canonical order. */
    int tmp = dragon1;
    dragon1 = dragon2;
    dragon2 = tmp;
  }
  
  for (k = 0; k < next_connection; k++)
    if ((conn_dragon1[k] == dragon1) && (conn_dragon2[k] == dragon2))
      return k;
  
  /* Add a new entry. */
  gg_assert(next_connection < MAX_CONNECTIONS);
  conn_dragon1[next_connection] = dragon1;
  conn_dragon2[next_connection] = dragon2;
  next_connection++;
  return next_connection - 1;
}


#if 0

/*
 * Find the index of an unordered pair of worms in the list of worm pairs.
 * If necessary, add a new entry.
 */
static int
find_worm_pair(int worm1, int worm2)
{
  int k;
  
  /* Make sure the worms are ordered canonically. */
  if (worm1 > worm2) {
    int tmp = worm1;
    worm1 = worm2;
    worm2 = tmp;
  }
  
  for (k = 0; k < next_worm_pair; k++)
    if ((worm_pair1[k] == worm1) && (worm_pair2[k] == worm2))
      return k;
  
  /* Add a new entry. */
  gg_assert(next_worm_pair < MAX_WORM_PAIRS);
  worm_pair1[next_worm_pair] = worm1;
  worm_pair2[next_worm_pair] = worm2;
  next_worm_pair++;
  return next_worm_pair - 1;
}

#endif

static int
find_either_data(int reason1, int what1, int reason2, int what2)
{
  int k;
  
  /* Make sure the worms are ordered canonically. */
  if (what1 > what2) {
    int tmp = what1;
    what1 = what2;
    what2 = tmp;
  }

  for (k = 0; k < next_either; k++)
    if (either_data[k].reason1    == reason1
	&& either_data[k].what1   == what1
	&& either_data[k].reason2 == reason2
	&& either_data[k].what2   == what2)
      return k;
  
  /* Add a new entry. */
  gg_assert(next_either < MAX_EITHER);
  either_data[next_either].reason1 = reason1;
  either_data[next_either].what1   = what1;
  either_data[next_either].reason2 = reason2;
  either_data[next_either].what2   = what2;
  next_either++;
  return next_either - 1;
}

static int
find_all_data(int reason1, int what1, int reason2, int what2)
{
  int k;
  
  /* Make sure the worms are ordered canonically. */
  if (what1 > what2) {
    int tmp = what1;
    what1 = what2;
    what2 = tmp;
  }

  for (k = 0; k < next_all; k++)
    if (all_data[k].reason1    == reason1
	&& all_data[k].what1   == what1
	&& all_data[k].reason2 == reason2
	&& all_data[k].what2   == what2)
      return k;
  
  /* Add a new entry. */
  gg_assert(next_all < MAX_ALL);
  all_data[next_all].reason1 = reason1;
  all_data[next_all].what1   = what1;
  all_data[next_all].reason2 = reason2;
  all_data[next_all].what2   = what2;
  next_all++;
  return next_all - 1;
}

/*
 * Find the index of an eye space in the list of eye spaces.
 * If necessary, add a new entry.
 */
static int
find_eye(int eye, int color)
{
  int k;
  ASSERT_ON_BOARD1(eye);
  
  for (k = 0; k < next_eye; k++)
    if (eyes[k] == eye && eyecolor[k] == color)
      return k;
  
  /* Add a new entry. */
  gg_assert(next_eye < MAX_EYES);
  eyes[next_eye] = eye;
  eyecolor[next_eye] = color;
  next_eye++;
  return next_eye - 1;
}

/* Interprets the object of a reason and returns its position.
 * If the object is a pair (of worms or dragons), the position of the first
 * object is returned. (This is only used for trace outputs.) Returns
 * NO_MOVE if move does not point to a location.
 * FIXME: This new function produces some code duplication with other
 * trace output function. Do some code cleanup here.
 */
static int
get_pos(int reason, int what)
{
  switch (reason) {
  case ATTACK_MOVE:
  case DEFEND_MOVE:
  case ATTACK_THREAT:
  case DEFEND_THREAT:
  case ATTACK_MOVE_GOOD_KO:
  case ATTACK_MOVE_BAD_KO:
  case DEFEND_MOVE_GOOD_KO:
  case DEFEND_MOVE_BAD_KO:
    return worms[what];
  case SEMEAI_MOVE:
  case SEMEAI_THREAT:
  case VITAL_EYE_MOVE:
  case STRATEGIC_ATTACK_MOVE:
  case STRATEGIC_DEFEND_MOVE:
  case OWL_ATTACK_MOVE:
  case OWL_DEFEND_MOVE:
  case OWL_ATTACK_THREAT:
  case OWL_DEFEND_THREAT:
  case OWL_PREVENT_THREAT:
  case UNCERTAIN_OWL_ATTACK:
  case UNCERTAIN_OWL_DEFENSE:
  case OWL_ATTACK_MOVE_GOOD_KO:
  case OWL_ATTACK_MOVE_BAD_KO:
  case OWL_DEFEND_MOVE_GOOD_KO:
  case OWL_DEFEND_MOVE_BAD_KO:
    return dragons[what];
  case EITHER_MOVE:
    /* FIXME: What should we return here? */
    return worms[either_data[what].what1];
  case ALL_MOVE:
    /* FIXME: What should we return here? */
    return worms[all_data[what].what1];
  case CONNECT_MOVE:
  case CUT_MOVE:
    return dragons[conn_dragon1[what]];
  case ANTISUJI_MOVE:
  case BLOCK_TERRITORY_MOVE:
  case EXPAND_TERRITORY_MOVE:
  case EXPAND_MOYO_MOVE:
  case MY_ATARI_ATARI_MOVE:
  case YOUR_ATARI_ATARI_MOVE:
    return NO_MOVE;
  }
  /* We shoud never get here: */
  gg_assert(1>2);
  return 0; /* To keep gcc happy. */
}

/*
 * See if a lunch is already in the list of lunches, otherwise add a new
 * entry. A lunch is in this context a pair of eater (a dragon) and food
 * (a worm).
 */
void
add_lunch(int eater, int food)
{
  int k;
  int dragon1 = find_dragon(dragon[eater].origin);
  int worm1   = find_worm(worm[food].origin);
  ASSERT_ON_BOARD1(eater);
  ASSERT_ON_BOARD1(food);
  
  for (k = 0; k < next_lunch; k++)
    if ((lunch_dragon[k] == dragon1) && (lunch_worm[k] == worm1))
      return;
  
  /* Add a new entry. */
  gg_assert(next_lunch < MAX_LUNCHES);
  lunch_dragon[next_lunch] = dragon1;
  lunch_worm[next_lunch] = worm1;
  next_lunch++;
  return;
}

/*
 * Remove a lunch from the list of lunches.  A lunch is in this context a pair
 * of eater (a dragon) and food (a worm).  
 */
void
remove_lunch(int eater, int food)
{
  int k;
  int dragon1 = find_dragon(dragon[eater].origin);
  int worm1   = find_worm(worm[food].origin);
  ASSERT_ON_BOARD1(eater);
  ASSERT_ON_BOARD1(food);
  
  for (k = 0; k < next_lunch; k++)
    if ((lunch_dragon[k] == dragon1) && (lunch_worm[k] == worm1))
      break;
  
  if (k == next_lunch)
    return; /* Not found */
  
  /* Remove entry k. */
  lunch_dragon[k] = lunch_dragon[next_lunch - 1];
  lunch_worm[k] = lunch_worm[next_lunch - 1];
  next_lunch--;
}


/* ---------------------------------------------------------------- */


/*
 * Add a move reason for (pos) if it's not already there or the
 * table is full.
 */ 
static void
add_move_reason(int pos, int type, int what)
{
  int k;

  ASSERT_ON_BOARD1(pos);
  if (stackp == 0) {
    ASSERT1(board[pos] == EMPTY, pos);
  }

  for (k = 0; k < MAX_REASONS; k++) {
    int r = move[pos].reason[k];
    if (r < 0)
      break;
    if (move_reasons[r].type == type
	&& move_reasons[r].what == what)
      return;  /* Reason already listed. */
  }

  /* Reason not found, add it if there is place left in both lists. */
  gg_assert(k<MAX_REASONS);
  gg_assert(next_reason < MAX_MOVE_REASONS);
  /* Add a new entry. */
  move[pos].reason[k] = next_reason;
  move_reasons[next_reason].type = type;
  move_reasons[next_reason].what = what;
  move_reasons[next_reason].status = ACTIVE;
  next_reason++;
}

/*
 * Remove a move reason for (pos). Ignore silently if the reason
 * wasn't there.
 */ 
static void
remove_move_reason(int pos, int type, int what)
{
  int k;
  int n = -1; /* Position of the move reason to be deleted. */

  ASSERT_ON_BOARD1(pos);
  for (k = 0; k < MAX_REASONS; k++) {
    int r = move[pos].reason[k];
    if (r < 0)
      break;
    if (move_reasons[r].type == type
	&& move_reasons[r].what == what)
      n = k;
  }
  
  if (n == -1)
    return; /* Move reason wasn't there. */
  
  /* Now move the last move reason to position n, thereby removing the
   * one we were looking for.
   */
  k--;
  move[pos].reason[n] = move[pos].reason[k];
  move[pos].reason[k] = -1;
}


/*
 * Check whether a move reason already is recorded for a move.
 * A negative value for 'what' means only match 'type'.
 */
int
move_reason_known(int pos, int type, int what)
{
  int k;
  int r;

  ASSERT_ON_BOARD1(pos);
  for (k = 0; k < MAX_REASONS; k++) {
    r = move[pos].reason[k];
    if (r < 0)
      break;
    if (move_reasons[r].type == type
	&& (what < 0
	    || move_reasons[r].what == what))
      return 1;
  }
  return 0;
}

/* ---------------------------------------------------------------- */

/* Functions used in discard_rules follow below. */

/*
 * Check whether an attack move reason already is recorded for a move.
 * A negative value for 'what' means only match 'type'.
 */
int
attack_move_reason_known(int pos, int what)
{
  return (move_reason_known(pos, ATTACK_MOVE, what)
	  || move_reason_known(pos, ATTACK_MOVE_GOOD_KO, what)
	  || move_reason_known(pos, ATTACK_MOVE_BAD_KO, what));
}

/*
 * Check whether a defense move reason already is recorded for a move.
 * A negative value for 'what' means only match 'type'.
 */
int
defense_move_reason_known(int pos, int what)
{
  return (move_reason_known(pos, DEFEND_MOVE, what)
	  || move_reason_known(pos, DEFEND_MOVE_GOOD_KO, what)
	  || move_reason_known(pos, DEFEND_MOVE_BAD_KO, what));
}

/* Check whether a dragon consists of only one worm. If so, check
 * whether we know of a tactical attack or defense move.
 */
static int
tactical_move_vs_whole_dragon_known(int pos, int what)
{
  int aa = dragons[what];
  return ((worm[aa].size == dragon[aa].size)
	  && (attack_move_reason_known(pos, find_worm(aa))
	      || defense_move_reason_known(pos, find_worm(aa))));
}

/*
 * Check whether an owl attack move reason already is recorded for a move.
 * A negative value for 'what' means only match 'type'.
 */
int
owl_attack_move_reason_known(int pos, int what)
{
  return (move_reason_known(pos, OWL_ATTACK_MOVE, what)
	  || move_reason_known(pos, OWL_ATTACK_MOVE_GOOD_KO, what)
	  || move_reason_known(pos, OWL_ATTACK_MOVE_BAD_KO, what));
}

/*
 * Check whether an owl defense move reason already is recorded for a move.
 * A negative value for 'what' means only match 'type'.
 */
int
owl_defense_move_reason_known(int pos, int what)
{
  return (move_reason_known(pos, OWL_DEFEND_MOVE, what)
	  || move_reason_known(pos, OWL_DEFEND_MOVE_GOOD_KO, what)
	  || move_reason_known(pos, OWL_DEFEND_MOVE_BAD_KO, what));
}

/*
 * Check whether an owl attack/defense move reason is recorded for a move.
 * A negative value for 'what' means only match 'type'.
 */
static int
owl_move_reason_known(int pos, int what)
{
  return (owl_attack_move_reason_known(pos, what)
          || owl_defense_move_reason_known(pos, what));
}

/*
 * Check whether we have an owl attack/defense reason for a move that
 * involves a specific worm.
 */
static int
owl_move_vs_worm_known(int pos, int what)
{
  return owl_move_reason_known(pos, find_dragon(dragon[worms[what]].origin));
}

/* Check whether a worm listed in worms[] is inessential */
static int
concerns_inessential_worm(int pos, int what)
{
  UNUSED(pos);
  return DRAGON2(worms[what]).safety == INESSENTIAL
        || worm[worms[what]].inessential;
}

/* Check whether a dragon listed in dragons[] is inessential */
static int
concerns_inessential_dragon(int pos, int what)
{
  UNUSED(pos);
  return DRAGON2(dragons[what]).safety == INESSENTIAL; 
}

static int
move_is_marked_unsafe(int pos, int what)
{
  UNUSED(what);
  return !move[pos].move_safety;
}

static int
either_move_redundant(int pos, int what)
{
  return ((either_data[what].reason1 == ATTACK_STRING
	   && attack_move_reason_known(pos, either_data[what].what1))
	  || (either_data[what].reason2 == ATTACK_STRING
	      && attack_move_reason_known(pos, either_data[what].what2)));
}

#if 0

static int
all_move_redundant(int pos, int what)
{
  return ((all_data[what].reason1 == DEFEND_STRING
	   && defense_move_reason_known(pos, all_data[what].what1))
	  || (all_data[what].reason2 == DEFEND_STRING
	      && defense_move_reason_known(pos, all_data[what].what2)));
}

#endif

/* ---------------------------------------------------------------- */


/*
 * Add to the reasons for the move at (pos) that it attacks the worm
 * at (ww).
 */
void
add_attack_move(int pos, int ww, int code)
{
  int worm_number = find_worm(worm[ww].origin);

  ASSERT_ON_BOARD1(ww);
  if (code == WIN)
    add_move_reason(pos, ATTACK_MOVE, worm_number);
  else if (code == KO_A)
    add_move_reason(pos, ATTACK_MOVE_GOOD_KO, worm_number);
  else if (code == KO_B)
    add_move_reason(pos, ATTACK_MOVE_BAD_KO, worm_number);
}

/*
 * Add to the reasons for the move at (pos) that it defends the worm
 * at (ww).
 */
void
add_defense_move(int pos, int ww, int code)
{
  int worm_number = find_worm(worm[ww].origin);

  ASSERT_ON_BOARD1(ww);
  if (code == WIN)
    add_move_reason(pos, DEFEND_MOVE, worm_number);
  else if (code == KO_A)
    add_move_reason(pos, DEFEND_MOVE_GOOD_KO, worm_number);
  else if (code == KO_B)
    add_move_reason(pos, DEFEND_MOVE_BAD_KO, worm_number);
}

/*
 * Add to the reasons for the move at (pos) that it threatens to
 * attack the worm at (ww). 
 */
void
add_attack_threat_move(int pos, int ww, int code)
{
  int worm_number = find_worm(worm[ww].origin);
  UNUSED(code);
  
  ASSERT_ON_BOARD1(ww);
  add_move_reason(pos, ATTACK_THREAT, worm_number);
}

/* Remove an attack threat move reason. */

void
remove_attack_threat_move(int pos, int ww)
{
  int worm_number = find_worm(worm[ww].origin);

  ASSERT_ON_BOARD1(ww);
  remove_move_reason(pos, ATTACK_THREAT, worm_number);
}

/*
 * Add to the reasons for the move at (pos) that it defends the worm
 * at (ww).
 */
void
add_defense_threat_move(int pos, int ww, int code)
{
  int worm_number = find_worm(worm[ww].origin);
  UNUSED(code);

  ASSERT_ON_BOARD1(ww);
  add_move_reason(pos, DEFEND_THREAT, worm_number);
}


/* Report all, or up to max_strings, strings that are threatened 
 * at (pos).
 */
int
get_attack_threats(int pos, int max_strings, int strings[])
{
  int k;
  int num_strings;

  num_strings = 0;
  for (k = 0; k < MAX_REASONS; k++) {
    int r = move[pos].reason[k];
    if (r < 0)
      break;

    if (move_reasons[r].type == ATTACK_THREAT)
      strings[num_strings++] = worms[move_reasons[r].what];

    if (num_strings == max_strings)
      break;
  }

  return num_strings;
}

/* Report all, or up to max_strings, strings that might be defended 
 * at (pos).
 */
int
get_defense_threats(int pos, int max_strings, int strings[])
{
  int k;
  int num_strings;

  num_strings = 0;
  for (k = 0; k < MAX_REASONS; k++) {
    int r = move[pos].reason[k];
    if (r < 0)
      break;

    if (move_reasons[r].type == DEFEND_THREAT)
      strings[num_strings++] = worms[move_reasons[r].what];

    if (num_strings == max_strings)
      break;
  }

  return num_strings;
}

/* Report the biggest dragon that is owl-affected (possibily with ko)
 * by a move at (pos).
 */
int
get_biggest_owl_target(int pos)
{
  int k;
  int biggest_target = -1;
  float target_size = 0.0;
  for (k = 0; k < MAX_REASONS; k++) {
    int r = move[pos].reason[k];
    if (r < 0)
      break;

    switch (move_reasons[r].type) {
    case OWL_ATTACK_MOVE:
    case OWL_ATTACK_MOVE_GOOD_KO:
    case OWL_ATTACK_MOVE_BAD_KO:
    case OWL_ATTACK_THREAT:
    case OWL_DEFEND_MOVE:
    case OWL_DEFEND_MOVE_GOOD_KO:
    case OWL_DEFEND_MOVE_BAD_KO:
    case OWL_DEFEND_THREAT:
    case OWL_PREVENT_THREAT:
      if (dragon[dragons[move_reasons[r].what]].effective_size
          > target_size) {
        biggest_target = move_reasons[r].what;
        target_size = dragon[dragons[move_reasons[r].what]].effective_size;
      }
    }
  }
  return biggest_target;
}

/*
 * Add to the reasons for the move at (pos) that it connects the
 * dragons at (dr1) and (dr2). Require that the dragons are
 * distinct.
 */
void
add_connection_move(int pos, int dr1, int dr2)
{
  int dragon1 = find_dragon(dragon[dr1].origin);
  int dragon2 = find_dragon(dragon[dr2].origin);
  int connection;

  ASSERT_ON_BOARD1(dr1);
  ASSERT_ON_BOARD1(dr2);
  gg_assert(dragon[dr1].color == dragon[dr2].color);
  if (dragon1 == dragon2)
    return;
  connection = find_connection(dragon1, dragon2);
  add_move_reason(pos, CONNECT_MOVE, connection);
}

/*
 * Add to the reasons for the move at (pos) that it cuts the
 * dragons at (dr1) and (dr2). Require that the dragons are
 * distinct.
 */
void
add_cut_move(int pos, int dr1, int dr2)
{
  int dragon1 = find_dragon(dragon[dr1].origin);
  int dragon2 = find_dragon(dragon[dr2].origin);
  int connection;

  ASSERT_ON_BOARD1(dr1);
  ASSERT_ON_BOARD1(dr2);
  gg_assert(dragon[dr1].color == dragon[dr2].color);
  if (dragon1 == dragon2)
    return;
  connection = find_connection(dragon1, dragon2);
  
  /*
   * Ignore the cut or connection if either (dr1) or (dr2)
   * points to a tactically captured worm.
   */
  if ((worm[dr1].attack_codes[0] != 0 && worm[dr1].defend_codes[0] == 0)
      || (worm[dr2].attack_codes[0] != 0 && worm[dr2].defend_codes[0] == 0))
    return;
  
  add_move_reason(pos, CUT_MOVE, connection);
}

/*
 * Add to the reasons for the move at (pos) that it is an anti-suji.
 * This means that it's a locally inferior move or for some other reason
 * must *not* be played.
 */
void
add_antisuji_move(int pos)
{
  add_move_reason(pos, ANTISUJI_MOVE, 0);
}

/*
 * Add to the reasons for the move at (pos) that it wins the
 * dragon (friendly or not) at (dr) in semeai. Since it is
 * possible that in some semeai one player can kill but the
 * other can only make seki, it is possible that one dragon
 * is already alive in seki. Therefore separate move reasons
 * must be added for the two dragons.
 */
void
add_semeai_move(int pos, int dr)
{
  int the_dragon = find_dragon(dragon[dr].origin);

  ASSERT_ON_BOARD1(dr);
  add_move_reason(pos, SEMEAI_MOVE, the_dragon);
}

/*
 * Add to the reasons for the move at (pos) that given two
 * moves in a row a move here can win the dragon (friendly or
 * not) at (dr) in semeai. Such a move can be used as a 
 * ko threat, and it is also given some value due to uncertainty
 * in the counting of liberties.
 */
void
add_semeai_threat(int pos, int dr)
{
  int the_dragon = find_dragon(dragon[dr].origin);

  ASSERT_ON_BOARD1(dr);
  add_move_reason(pos, SEMEAI_THREAT, the_dragon);
}

/*
 * Add to the reasons for the move at (pos) that it's the vital
 * point for the eye space at (eyespace) of color.
 */
void
add_vital_eye_move(int pos, int eyespace, int color)
{
  int eye;

  ASSERT_ON_BOARD1(eyespace);
  if (color == WHITE)
    eye = find_eye(white_eye[eyespace].origin, color);
  else
    eye = find_eye(black_eye[eyespace].origin, color);
  add_move_reason(pos, VITAL_EYE_MOVE, eye);
}

/*
 * Add to the reasons for the move at (pos) that it will accomplish
 * one of two things: either (reason1) on (target1) or (reason2) on 
 * (target2).  
 *
 * At this time, (reason) can only be ATTACK_STRING.
 * However, more reasons will be implemented in the future.
 *
 * FIXME: Implement at least ATTACK_MOVE_GOOD_KO, ATTACK_MOVE_BAD_KO,
 *         DEFEND_MOVE and associates, CONNECT_MOVE, OWL_ATTACK_MOVE,
 *         OWL_DEFEND_MOVE, and possibly more.
 *
 * FIXME: Generalize to more than 2 parameters.
 *        When that is done, this will be a good way to add 
 *        atari_atari moves.
 */
void
add_either_move(int pos, int reason1, int target1, int reason2, int target2)
{
  int  what1 = 0;
  int  what2 = 0;
  int  index;

  ASSERT_ON_BOARD1(target1);
  ASSERT_ON_BOARD1(target2);
  if (reason1 == reason2 && target1 == target2)
    return;
  
  /* For now. */
  gg_assert(reason1 == ATTACK_STRING);
  gg_assert(reason2 == ATTACK_STRING);

  switch (reason1) {
  case ATTACK_STRING:
    {
      what1 = find_worm(worm[target1].origin);

      /* If this string is already attacked, and with no defense, then
       * there is no additional value of this move reason. */
      if (worm[target1].attack_codes[0] != 0
	  && worm[target1].defend_codes[0] == 0)
	return;
    }
    break;

  default:
    break;
  }

  switch (reason2) {
  case ATTACK_STRING:
    {
      what2 = find_worm(worm[target2].origin);

      /* If this string is already attacked, and with no defense, then
       * there is no additional value of this move reason. */
      if (worm[target2].attack_codes[0] != 0 
	  && worm[target2].defend_codes[0] == 0)
	return;
    }
    break;

  default:
    break;
  }

  index = find_either_data(reason1, what1, reason2, what2);
  add_move_reason(pos, EITHER_MOVE, index);
}


/*
 * Add to the reasons for the move at (pos) that it will accomplish
 * both of two things: (reason1) on (target1) and (reason2) on 
 * (target2).  
 *
 * At this time, (reason) can only be DEFEND_STRING.
 * However, more reasons will be implemented in the future.
 *
 * FIXME: Implement at least ATTACK_MOVE_GOOD_KO, ATTACK_MOVE_BAD_KO,
 *         DEFEND_MOVE and associates, CONNECT_MOVE, OWL_ATTACK_MOVE,
 *         OWL_DEFEND_MOVE, and possibly more.
 *
 * FIXME: Generalize to more than 2 parameters.
 *        When that is done, this will be a good way to add 
 *        atari_atari moves.
 */
void
add_all_move(int pos, int reason1, int target1, int reason2, int target2)
{
  int  what1 = 0;
  int  what2 = 0;
  int  index;

  ASSERT_ON_BOARD1(target1);
  ASSERT_ON_BOARD1(target2);
  if (reason1 == reason2 && target1 == target2)
    return;
  
  /* For now. */
  gg_assert(reason1 == DEFEND_STRING);
  gg_assert(reason2 == DEFEND_STRING);

  switch (reason1) {
  case DEFEND_STRING:
    what1 = find_worm(worm[target1].origin);
    break;

  default:
    break;
  }

  switch (reason2) {
  case DEFEND_STRING:
    what2 = find_worm(worm[target2].origin);
    break;

  default:
    break;
  }

  index = find_all_data(reason1, what1, reason2, what2);
  add_move_reason(pos, ALL_MOVE, index);
}


/*
 * Add to the reasons for the move at (pos) that it secures
 * territory by blocking.
 */
void
add_block_territory_move(int pos)
{
  add_move_reason(pos, BLOCK_TERRITORY_MOVE, 0);
}

/*
 * Add to the reasons for the move at (pos) that it expands
 * territory.
 */
void
add_expand_territory_move(int pos)
{
  add_move_reason(pos, EXPAND_TERRITORY_MOVE, 0);
}

/*
 * Add to the reasons for the move at (pos) that it expands
 * moyo.
 */
void
add_expand_moyo_move(int pos)
{
  add_move_reason(pos, EXPAND_MOYO_MOVE, 0);
}

/*
 * This function is called when a shape value for the move at (pos)
 * is found. 
 * 
 * We keep track of the largest positive shape value found, and the
 * total number of positive contributions, as well as the largest
 * negative shape value found, and the total number of negative
 * shape contributions.
 */
void
add_shape_value(int pos, float value)
{
  ASSERT_ON_BOARD1(pos);
  if (value > 0.0) {
    if (value > move[pos].maxpos_shape)
      move[pos].maxpos_shape = value;
    move[pos].numpos_shape += 1;
  }
  else if (value < 0.0) {
    value = -value;
    if (value > move[pos].maxneg_shape)
      move[pos].maxneg_shape = value;
    move[pos].numneg_shape += 1;
  }
}

/*
 * Flag that this move is worthwhile to play as a pure threat move.
 */
void
add_worthwhile_threat_move(int pos)
{
  move[pos].worthwhile_threat = 1;
}

/* 
 * This function computes the shape factor, which multiplies
 * the score of a move. We take the largest positive contribution
 * to shape and add 1 for each additional positive contribution found.
 * Then we take the largest negative contribution to shape, and
 * add 1 for each additional negative contribution. The resulting
 * number is raised to the power 1.05.
 *
 * The rationale behind this complicated scheme is that every
 * shape point is very significant. If two shape contributions
 * with values (say) 5 and 3 are found, the second contribution
 * should be devalued to 1. Otherwise the engine is too difficult to
 * tune since finding multiple contributions to shape can cause
 * significant overvaluing of a move.
 */

float
compute_shape_factor(int pos)
{
  float exponent = move[pos].maxpos_shape - move[pos].maxneg_shape;

  ASSERT_ON_BOARD1(pos);
  if (move[pos].numpos_shape > 1)
    exponent += move[pos].numpos_shape - 1;
  if (move[pos].numneg_shape > 1)
    exponent -= move[pos].numneg_shape - 1;
  return pow(1.05, exponent);
}


/*
 * Add to the reasons for the move at (pos) that it attacks
 * the dragon (dr) on a strategical level.
 */
void
add_strategical_attack_move(int pos, int dr)
{
  int dragon1 = find_dragon(dragon[dr].origin);

  ASSERT_ON_BOARD1(dr);
  add_move_reason(pos, STRATEGIC_ATTACK_MOVE, dragon1);
}

/*
 * Add to the reasons for the move at (pos) that it defends
 * the dragon (dr) on a strategical level.
 */
void
add_strategical_defense_move(int pos, int dr)
{
  int dragon1 = find_dragon(dragon[dr].origin);

  ASSERT_ON_BOARD1(dr);
  add_move_reason(pos, STRATEGIC_DEFEND_MOVE, dragon1);
}

/*
 * Add to the reasons for the move at (pos) that the owl
 * code reports an attack on the dragon (dr).
 */
void
add_owl_attack_move(int pos, int dr, int code)
{
  int dragon1 = find_dragon(dragon[dr].origin);

  ASSERT_ON_BOARD1(dr);
  if (code == WIN)
    add_move_reason(pos, OWL_ATTACK_MOVE, dragon1);
  else if (code == KO_A)
    add_move_reason(pos, OWL_ATTACK_MOVE_GOOD_KO, dragon1);
  else if (code == KO_B)
    add_move_reason(pos, OWL_ATTACK_MOVE_BAD_KO, dragon1);
}

/*
 * Add to the reasons for the move at (pos) that the owl
 * code reports a defense of the dragon (dr).
 */
void
add_owl_defense_move(int pos, int dr, int code)
{
  int dragon1 = find_dragon(dragon[dr].origin);

  ASSERT_ON_BOARD1(dr);
  if (code == WIN)
    add_move_reason(pos, OWL_DEFEND_MOVE, dragon1);
  else if (code == KO_A)
    add_move_reason(pos, OWL_DEFEND_MOVE_GOOD_KO, dragon1);
  else if (code == KO_B)
    add_move_reason(pos, OWL_DEFEND_MOVE_BAD_KO, dragon1);
}

/*
 * Add to the reasons for the move at (pos) that the owl
 * code reports a move threatening to attack the dragon enemy (dr).
 * That is, if the attacker is given two moves in a row, (pos)
 * can be the first move.
 */
void
add_owl_attack_threat_move(int pos, int dr, int code)
{
  int dragon1 = find_dragon(dragon[dr].origin);
  UNUSED(code);
  
  ASSERT_ON_BOARD1(dr);
  add_move_reason(pos, OWL_ATTACK_THREAT, dragon1);
  add_worthwhile_threat_move(pos);
}

/* The owl code found the friendly dragon alive, or the unfriendly dragon
 * dead, and an extra point of attack or defense was found, so this might be a
 * good place to play.  
 */
void
add_owl_uncertain_defense_move(int pos, int dr)
{
  int dragon1 = find_dragon(dragon[dr].origin);

  ASSERT_ON_BOARD1(dr);
  add_move_reason(pos, UNCERTAIN_OWL_DEFENSE, dragon1);
}

/* The owl code found the opponent dragon alive, or the friendly
 * dragon dead, but was uncertain, and this move reason propose
 * an attack or defense which is expected to fail but might succeed.
 */
void
add_owl_uncertain_attack_move(int pos, int dr)
{
  int dragon1 = find_dragon(dragon[dr].origin);

  ASSERT_ON_BOARD1(dr);
  add_move_reason(pos, UNCERTAIN_OWL_ATTACK, dragon1);
}

/*
 * Add to the reasons for the move at (pos) that the owl
 * code reports a move threatening to rescue the dragon (dr).
 * That is, if the defender is given two moves in a row, (pos)
 * can be the first move.
 */
void
add_owl_defense_threat_move(int pos, int dr, int code)
{
  int dragon1 = find_dragon(dragon[dr].origin);
  UNUSED(code);

  ASSERT_ON_BOARD1(dr);
  add_move_reason(pos, OWL_DEFEND_THREAT, dragon1);
  add_worthwhile_threat_move(pos);
}

/* Add to the reasons for the move at (pos) that it captures
 * at least one of a set of worms which individually are tactically
 * safe (such as a double atari). Only one such move reason is
 * permitted per move.
 */
void
add_my_atari_atari_move(int pos, int size)
{
  add_move_reason(pos, MY_ATARI_ATARI_MOVE, size);
}

/* Add to the reasons for the move at (pos) that it stops a
 * combination attack for the opponent.
 */
void
add_your_atari_atari_move(int pos, int size)
{
  add_move_reason(pos, YOUR_ATARI_ATARI_MOVE, size);
}


/*
 * Add to the reasons for the move at (pos) that the owl
 * code reports a move threatening to defend the dragon enemy (dr),
 * and that (pos) is a move which attacks the dragon. 
 * That is, if the defender is given two moves in a row, (pos)
 * can be the first move. Hopefully playing at (pos) makes it harder 
 * for the dragon to live.
 */
void
add_owl_prevent_threat_move(int pos, int dr)
{
  int dragon1 = find_dragon(dragon[dr].origin);

  ASSERT_ON_BOARD1(dr);
  add_move_reason(pos, OWL_PREVENT_THREAT, dragon1);
}

/*
 * Add value of followup moves. 
 */
void
add_followup_value(int pos, float value)
{
  ASSERT_ON_BOARD1(pos);
  if (value > move[pos].followup_value)
    move[pos].followup_value = value;
}

/*
 * Add value of reverse followup moves. 
 */
void
add_reverse_followup_value(int pos, float value)
{
  ASSERT_ON_BOARD1(pos);
  if (value > move[pos].reverse_followup_value)
    move[pos].reverse_followup_value = value;
}

/*
 * Set a minimum allowed value for the move.
 */
int
set_minimum_move_value(int pos, float value)
{
  ASSERT_ON_BOARD1(pos);
  if (value > move[pos].min_value) {
    move[pos].min_value = value;
    return 1;
  }
  return 0;
}

/*
 * Set a maximum allowed value for the move.
 */
void
set_maximum_move_value(int pos, float value)
{
  ASSERT_ON_BOARD1(pos);
  if (value < move[pos].max_value)
    move[pos].max_value = value;
}

/*
 * Set a minimum allowed territorial value for the move.
 */
void
set_minimum_territorial_value(int pos, float value)
{
  ASSERT_ON_BOARD1(pos);
  if (value > move[pos].min_territory)
    move[pos].min_territory = value;
}

/*
 * Set a maximum allowed territorial value for the move.
 */
void
set_maximum_territorial_value(int pos, float value)
{
  ASSERT_ON_BOARD1(pos);
  if (value < move[pos].max_territory)
    move[pos].max_territory = value;
}

/* 
 * Add a point redistribution rule, sending the points from (from)
 * to (to). 
 */
void
add_replacement_move(int from, int to)
{
  int cc;
  int m, n;
  int ii;

  ASSERT_ON_BOARD1(from);
  ASSERT_ON_BOARD1(to);

  if (board[from] != EMPTY)
    return;
  ASSERT1(board[to] == EMPTY, to);

  cc = replacement_map[to];

  /* First check for an incompatible redistribution rule. */
  if (replacement_map[from] != NO_MOVE) {
    int dd = replacement_map[from];
    /* Abort if the old rule isn't compatible with the new one.
     * (But not in the stable release.)
     */
    if (0) {
      ASSERT1(dd == to || to == replacement_map[dd], from);
    }
    /* There already is a redistribution in effect so we
     * have nothing more to do.
     */
    return;
  }

  TRACE("Move at %1m is replaced by %1m.\n", from, to);    

  /* Verify that we don't introduce a cyclic redistribution. */
  if (cc == from) {
    gprintf("Cyclic point redistribution detected.\n");
    ASSERT1(0, from);
  }

  /* Update the replacement map. Make sure that all replacements
   * always are directed immediately to the final destination.
   */
  if (cc != NO_MOVE)
    replacement_map[from] = cc;
  else
    replacement_map[from] = to;
  
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      ii = POS(m, n);
      if (replacement_map[ii] == from)
	replacement_map[ii] = replacement_map[from];
    }
}


/* Find worms rescued by a move at (pos). */
void
get_saved_worms(int pos, int saved[BOARDMAX])
{
  int k;
  memset(saved, 0, sizeof(saved[0]) * BOARDMAX);
  
  for (k = 0; k < MAX_REASONS; k++) {
    int r = move[pos].reason[k];
    int what;

    if (r < 0)
      break;
    
    what = move_reasons[r].what;
    /* We exclude the ko contingent defenses, to avoid that the
     * confirm_safety routines spot an attack with ko and thinks the
     * move is unsafe.
     */
    if (move_reasons[r].type == DEFEND_MOVE) {
      int origin = worm[worms[what]].origin;
      int ii;
      for (ii = BOARDMIN; ii < BOARDMAX; ii++)
	if (IS_STONE(board[ii]) && worm[ii].origin == origin)
	  saved[ii] = 1;
    }
  }    
}


/* Find dragons rescued by a move at (pos). */
void
get_saved_dragons(int pos, int saved[BOARDMAX])
{
  int k;
  memset(saved, 0, sizeof(saved[0]) * BOARDMAX);
  
  for (k = 0; k < MAX_REASONS; k++) {
    int r = move[pos].reason[k];
    int what;

    if (r < 0)
      break;
    
    what = move_reasons[r].what;
    /* We exclude the ko contingent defenses, to avoid that the
     * confirm_safety routines spot an attack with ko and thinks the
     * move is unsafe.
     */
    if (move_reasons[r].type == OWL_DEFEND_MOVE) {
      int origin = dragon[dragons[what]].origin;
      int ii;
      for (ii = BOARDMIN; ii < BOARDMAX; ii++)
	if (IS_STONE(board[ii]) && dragon[ii].origin == origin)
	  saved[ii] = 1;
    }
  }    
}


/* List the move reasons for (color). */
void
list_move_reasons(int color)
{
  int m;
  int n;
  int pos;
  int k;
  int reason1;
  int reason2;
  int aa = NO_MOVE;
  int bb = NO_MOVE;
  int dragon1 = -1;
  int dragon2 = -1;
  int worm1 = -1;
  int worm2 = -1;
  int ecolor = 0;
  
  gprintf("\nMove reasons:\n");
  
  for (n = 0; n < board_size; n++)
    for (m = board_size-1; m >= 0; m--) {
      pos = POS(m, n);

      for (k = 0; k < MAX_REASONS; k++) {
	int r = move[pos].reason[k];

	if (r < 0)
	  break;
	
	switch (move_reasons[r].type) {
	case ATTACK_MOVE:
	  aa = worms[move_reasons[r].what];
	  gprintf("Move at %1m attacks %1m%s\n", pos, aa,
		  (worm[aa].defend_codes[0] == 0) ? " (defenseless)" : "");
	  break;
	case ATTACK_MOVE_GOOD_KO:
	  aa = worms[move_reasons[r].what];
	  gprintf("Move at %1m attacks %1m%s with good ko\n", pos, aa,
		  (worm[aa].defend_codes[0] == 0) ? " (defenseless)" : "");
	  break;
	case ATTACK_MOVE_BAD_KO:
	  aa = worms[move_reasons[r].what];
	  gprintf("Move at %1m attacks %1m%s with bad ko\n", pos, aa,
		  (worm[aa].defend_codes[0] == 0) ? " (defenseless)" : "");
	  break;
	  
	case DEFEND_MOVE:
	  aa = worms[move_reasons[r].what];
	  gprintf("Move at %1m defends %1m\n", pos, aa);
	  break;
	case DEFEND_MOVE_GOOD_KO:
	  aa = worms[move_reasons[r].what];
	  gprintf("Move at %1m defends %1m with good ko\n", pos, aa);
	  break;
	case DEFEND_MOVE_BAD_KO:
	  aa = worms[move_reasons[r].what];
	  gprintf("Move at %1m defends %1m with bad ko\n", pos, aa);
	  break;
	  
	case ATTACK_THREAT:
	case DEFEND_THREAT:
	  aa = worms[move_reasons[r].what];
	  
	  if (move_reasons[r].type == ATTACK_THREAT)
	    gprintf("Move at %1m threatens to attack %1m\n", pos, aa);
	  else if (move_reasons[r].type == DEFEND_THREAT)
	    gprintf("Move at %1m threatens to defend %1m\n", pos, aa);
	  break;

	case UNCERTAIN_OWL_DEFENSE:
	  aa = dragons[move_reasons[r].what];
	  if (board[aa] == color)
	    gprintf("%1m found alive but not certainly, %1m defends it again\n",
		    aa, pos);
	  else
	    gprintf("%1m found dead but not certainly, %1m attacks it again\n",
		    aa, pos);
	  break;	  

	case CONNECT_MOVE:
	case CUT_MOVE:
	  dragon1 = conn_dragon1[move_reasons[r].what];
	  dragon2 = conn_dragon2[move_reasons[r].what];
	  aa = dragons[dragon1];
	  bb = dragons[dragon2];
	  if (move_reasons[r].type == CONNECT_MOVE)
	    gprintf("Move at %1m connects %1m and %1m\n", pos, aa, bb);
	  else
	    gprintf("Move at %1m cuts %1m and %1m\n", pos, aa, bb);
	  break;
	  
	case ANTISUJI_MOVE:
	  gprintf("Move at %1m is an antisuji\n", pos);
	  break;
	  
	case SEMEAI_MOVE:
	  aa = dragons[move_reasons[r].what];
	  gprintf("Move at %1m wins semeai for %1m\n", pos, aa);
	  break;
	  
	case SEMEAI_THREAT:
	  aa = dragons[move_reasons[r].what];
	  gprintf("Move at %1m threatens to win semeai for %1m\n", pos, aa);
	  break;
	  
	case VITAL_EYE_MOVE:
	  aa = eyes[move_reasons[r].what];
	  ecolor = eyecolor[move_reasons[r].what];
	  if (ecolor == WHITE)
	    gprintf("Move at %1m vital eye point for dragon %1m (eye %1m)\n",
		    pos, white_eye[aa].dragon, aa);
	  else
	    gprintf("Move at %1m vital eye point for dragon %1m (eye %1m)\n",
		    pos, black_eye[aa].dragon, aa);
	  break;
	  
	case EITHER_MOVE:
	  reason1 = either_data[move_reasons[r].what].reason1;
	  reason2 = either_data[move_reasons[r].what].reason2;
	  worm1 = either_data[move_reasons[r].what].what1;
	  worm2 = either_data[move_reasons[r].what].what2;
	  aa = worms[worm1];
	  bb = worms[worm2];
	  gprintf("Move at %1m either %s %1m or %s %1m\n", pos, 
		  reason1 == ATTACK_STRING ? "attacks" : "defends", aa, 
		  reason2 == ATTACK_STRING ? "attacks" : "defends", bb);
	  break;

	case ALL_MOVE:
	  reason1 = all_data[move_reasons[r].what].reason1;
	  reason2 = all_data[move_reasons[r].what].reason2;
	  worm1 = all_data[move_reasons[r].what].what1;
	  worm2 = all_data[move_reasons[r].what].what2;
	  aa = worms[worm1];
	  bb = worms[worm2];
	  gprintf("Move at %1m both %s %1m or %s %1m\n", pos, 
		  reason1 == ATTACK_STRING ? "attacks" : "defends", aa, 
		  reason2 == ATTACK_STRING ? "attacks" : "defends", bb);
	  break;

	case OWL_ATTACK_MOVE:
	  aa = dragons[move_reasons[r].what];
	  gprintf("Move at %1m owl-attacks %1m\n", pos, aa);
	  break;
	case OWL_ATTACK_MOVE_GOOD_KO:
	  aa = dragons[move_reasons[r].what];
	  gprintf("Move at %1m owl-attacks %1m with good ko\n", pos, aa);
	  break;
	case OWL_ATTACK_MOVE_BAD_KO:
	  aa = dragons[move_reasons[r].what];
	  gprintf("Move at %1m owl-attacks %1m with bad ko\n", pos, aa);
	  break;
	  
	case OWL_DEFEND_MOVE:
	  aa = dragons[move_reasons[r].what];
	  gprintf("Move at %1m owl-defends %1m\n", pos, aa);
	  break;
	case OWL_DEFEND_MOVE_GOOD_KO:
	  aa = dragons[move_reasons[r].what];
	  gprintf("Move at %1m owl-defends %1m with good ko\n", pos, aa);
	  break;
	case OWL_DEFEND_MOVE_BAD_KO:
	  aa = dragons[move_reasons[r].what];
	  gprintf("Move at %1m owl-defends %1m with bad ko\n", pos, aa);
	  break;
	  
	case OWL_ATTACK_THREAT:
	  aa = dragons[move_reasons[r].what];
	  gprintf("Move at %1m owl-threatens to attack %1m\n", pos, aa);
	  break;
	  
	case OWL_DEFEND_THREAT:
	  aa = dragons[move_reasons[r].what];
	  gprintf("Move at %1m owl-threatens to defend %1m\n", pos, aa);
	  break;
	  
	case OWL_PREVENT_THREAT:
	  aa = dragons[move_reasons[r].what];
	  gprintf("Move at %1m owl-prevents a threat to attack or defend %1m\n", 
		  pos, aa);
	  break;

	case BLOCK_TERRITORY_MOVE:
	  gprintf("Move at %1m blocks territory\n", pos);
	  break;
	  
	case EXPAND_TERRITORY_MOVE:
	  gprintf("Move at %1m expands territory\n", pos);
	  break;
	  
	case EXPAND_MOYO_MOVE:
	  gprintf("Move at %1m expands moyo\n", pos);
	  break;
	  
	case STRATEGIC_ATTACK_MOVE:
	case STRATEGIC_DEFEND_MOVE:
	  aa = dragons[move_reasons[r].what];
	  
	  if (move_reasons[r].type == STRATEGIC_ATTACK_MOVE)
	    gprintf("Move at %1m strategically attacks %1m\n", pos, aa);
	  else
	    gprintf("Move at %1m strategically defends %1m\n", pos, aa);
	  break;
	  
	case MY_ATARI_ATARI_MOVE:
	  gprintf("Move at %1m captures something\n", pos);

	case YOUR_ATARI_ATARI_MOVE:
	  gprintf("Move at %1m defends threat to capture something\n", pos);
	}
      }
      if (k > 0 && move[pos].move_safety == 0)
	gprintf("Move at %1m strategically or tactically unsafe\n", pos);
    }
}




/* This array lists rules according to which we set the status
 * flags of a move reasons.
 * The format is:
 * { List of reasons to which the rule applies, condition of the rule,
 * flags to be set, trace message }
 * The condition must be of type discard_condition_fn_ptr, that is a pointer
 * to a function with parameters (pos, what).
 */

static struct discard_rule discard_rules[] =
{
  { { ATTACK_MOVE, ATTACK_MOVE_GOOD_KO,
      ATTACK_MOVE_BAD_KO, ATTACK_THREAT,
      DEFEND_MOVE, DEFEND_MOVE_GOOD_KO,
      DEFEND_MOVE_BAD_KO, DEFEND_THREAT, -1 },
    owl_move_vs_worm_known, TERRITORY_REDUNDANT,
    "  %1m: 0.0 - (threat of) attack/defense of %1m (owl attack/defense as well)\n" },
  { { SEMEAI_MOVE, SEMEAI_THREAT, -1 },
    owl_move_reason_known, REDUNDANT,
    "  %1m: 0.0 - (threat to) win semai involving %1m (owl move as well)\n"},
  { { SEMEAI_MOVE, SEMEAI_THREAT, -1 },
    tactical_move_vs_whole_dragon_known, REDUNDANT,
    "  %1m: 0.0 - (threat to) win semai involving %1m (tactical move as well)\n"},
  { { EITHER_MOVE, -1 },
    either_move_redundant, REDUNDANT,
    "  %1m: 0.0 - either move is redundant at %1m (direct att./def. as well)\n"},
  /* FIXME: Add handling of ALL_MOVE: All single attacks/defenses should
   *        be removed when there is also a corresponding ALL_MOVE.
   */
  /* FIXME: Add handling of ALL and EITHER moves for inessential worms. */
  { { ATTACK_MOVE, ATTACK_MOVE_GOOD_KO,
      ATTACK_MOVE_BAD_KO, ATTACK_THREAT,
      DEFEND_MOVE, DEFEND_MOVE_GOOD_KO,
      DEFEND_MOVE_BAD_KO, DEFEND_THREAT, -1 },
    concerns_inessential_worm, TERRITORY_REDUNDANT,
    "  %1m: 0.0 - attack/defense of %1m (inessential)\n"},
  { { OWL_ATTACK_MOVE, OWL_ATTACK_MOVE_GOOD_KO,
      OWL_ATTACK_MOVE_BAD_KO, OWL_ATTACK_THREAT,
      OWL_DEFEND_MOVE, OWL_DEFEND_MOVE_GOOD_KO,
      OWL_DEFEND_MOVE_BAD_KO, UNCERTAIN_OWL_DEFENSE, -1 },
    concerns_inessential_dragon, REDUNDANT,
    "  %1m: 0.0 - (uncertain) owl attack/defense of %1m (inessential)\n"},
  { { ATTACK_MOVE, ATTACK_MOVE_GOOD_KO, ATTACK_MOVE_BAD_KO,
      DEFEND_MOVE, DEFEND_MOVE_GOOD_KO, DEFEND_MOVE_BAD_KO, -1},
    move_is_marked_unsafe, REDUNDANT,
    "  %1m: 0.0 - tactical move vs %1m (unsafe move)\n"},
  { { -1 }, NULL, 0, ""}  /* Keep this entry at end of the list. */
};

/* This function checks the list of move reasons for redundant move
 * reasons and marks them accordingly in their status field.
 */
void
discard_redundant_move_reasons(int pos)
{
  int k1, k2;
  int l;
  for (k1 = 0; !(discard_rules[k1].reason_type[0] == -1); k1++) {
    for (k2 = 0; !(discard_rules[k1].reason_type[k2] == -1); k2++) {
      for (l = 0; l < MAX_REASONS; l++) {

        int r = move[pos].reason[l];
        if (r < 0)
          break;
        if ((move_reasons[r].type == discard_rules[k1].reason_type[k2])
            && (discard_rules[k1].condition(pos, move_reasons[r].what))) {
          DEBUG(DEBUG_MOVE_REASONS, discard_rules[k1].trace_message,
                pos, get_pos(move_reasons[r].type, move_reasons[r].what)); 
          move_reasons[r].status |= discard_rules[k1].flags;
        }
      } 
    }
  }
}


/* Look through the move reasons to see whether (pos) is an antisuji move. */
int
is_antisuji_move(int pos)
{
  int k;
  for (k = 0; k < MAX_REASONS; k++) {
    int r = move[pos].reason[k];
    if (r < 0)
      break;
    if (move_reasons[r].type == ANTISUJI_MOVE)
      return 1; /* This move must not be played. End of story. */
  }

  return 0;
}


/* Count how many distinct strings are (solidly) connected by the move
 * at (pos). Add a bonus for strings with few liberties. Also add
 * bonus for opponent strings put in atari or removed.
 */
int
move_connects_strings(int pos, int color)
{
  int ss[4];
  int strings = 0;
  int own_strings = 0;
  int k, l;
  int fewlibs = 0;

  for (k = 0; k < 4; k++) {
    int ii = pos + delta[k];
    int origin;

    if (!ON_BOARD(ii) || board[ii] == EMPTY)
      continue;

    origin = find_origin(ii);

    for (l = 0; l < strings; l++)
      if (ss[l] == origin)
	break;

    if (l == strings) {
      ss[strings] = origin;
      strings++;
    }
  }

  for (k = 0; k < strings; k++) {
    if (board[ss[k]] == color) {
      int newlibs = approxlib(pos, color, MAXLIBS, NULL);
      own_strings++;
      if (newlibs >= countlib(ss[k])) {
	if (countlib(ss[k]) <= 4)
	  fewlibs++;
	if (countlib(ss[k]) <= 2)
	  fewlibs++;
      }
    }
    else {
      if (countlib(ss[k]) <= 2)
	fewlibs++;
      if (countlib(ss[k]) <= 1)
	fewlibs++;
    }
  }

  /* Do some thresholding. */
  if (fewlibs > 4)
    fewlibs = 4;
  if (fewlibs == 0 && own_strings == 1)
    own_strings = 0;

  return own_strings + fewlibs;
}


/* Find saved dragons and worms, then call confirm_safety(). */
int
move_reasons_confirm_safety(int move, int color, int minsize)
{
  int saved_dragons[BOARDMAX];
  int saved_worms[BOARDMAX];

  get_saved_dragons(move, saved_dragons);
  get_saved_worms(move, saved_worms);
  
  return confirm_safety(move, color, minsize, NULL,
			saved_dragons, saved_worms);
}


/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */


/* movelist.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* #include <stdio.h> */
/* #include <stdlib.h> */
/* #include <string.h> */

/* #include "gnugo.h" */
/* #include "liberty.h" */


static void movelist_sort_points(int max_points, int points[], int codes[]);
static void swap_points_and_codes(int points[], int codes[], int m, int n);


/* Return the code for the move if it is known.
 */
int
movelist_move_known(int move, int max_points, int points[], int codes[])
{
  int k;

  for (k = 0; k < max_points; k++) {
    if (codes[k] == 0)
      return 0;
    if (points[k] == move)
      return codes[k];
  }
  return 0;
}


/*
 * This function does the real work for change_attack(),
 * change_defense(), change_attack_threat(), and
 * change_defense_threat().
 */

void
movelist_change_point(int move, int code, int max_points,
		      int points[], int codes[])
{
  int k;

  /* First see if we already know about this point. */
  for (k = 0; k < max_points; k++)
    if (points[k] == move)
      break;

  /* Yes, we do. */
  if (k < max_points) {
    if (codes[k] <= code)
      return; /* Old news. */

    codes[k] = code;
    movelist_sort_points(max_points, points, codes);
    return;
  }

  /* This tactical point is new to us. */
  if (code > codes[max_points - 1]) {
    points[max_points - 1] = move;
    codes[max_points - 1] = code;
    movelist_sort_points(max_points, points, codes);
  }
}


/* Sort the tactical points so we have it sorted in falling order on
 * the code values.
 *
 * We use shaker sort because we prefer a stable sort and in all use
 * cases we can expect it to suffice with one turn through the outer
 * loop.
 */

static void
movelist_sort_points(int max_points, int points[], int codes[])
{
  int start = 0;
  int end = max_points - 1;
  int new_start;
  int new_end;
  int k;
  
  while (start < end) {
    new_start = end;
    for (k = end; k > start; k--)
      if (codes[k] > codes[k-1]) {
	swap_points_and_codes(points, codes, k, k-1);
	new_start = k;
      }
    start = new_start;
    new_end = start;
    for (k = start; k < end - 1; k++)
      if (codes[k] < codes[k+1]) {
	swap_points_and_codes(points, codes, k, k+1);
	new_end = k;
      }
    end = new_end;
  }
}

static void
swap_points_and_codes(int points[], int codes[], int m, int n)
{
  int tmp = points[m];
  points[m] = points[n];
  points[n] = tmp;
  tmp = codes[m];
  codes[m] = codes[n];
  codes[n] = tmp;
}



/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */


/* optics.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* #include <stdio.h> */
/* #include <stdlib.h> */
/* #include <string.h> */

/* #include "gnugo.h" */
/* #include "liberty.h" */
/* #include "gg_utils.h" */

/* #include "eyes.h" */


/* This macro is not fully generalized. It works because it is used only where
 * c, d match the first vital attack/defend point of the the half eye or none
 * at all.
 */
#define hadj(heye, apos, bpos) \
     (heye[apos].type == HALF_EYE \
      && (heye[apos].attack_point[0] == (bpos) \
          || (heye[apos].defense_point[0] == (bpos))))

/*
 * Two eye points are defined to be adjacent if they are either
 * next to each other or if one vertex is a half eye and the
 * other one is the point making it a real eye.
 */

#define adjacent(heye, apos, bpos) (   (apos) == SOUTH(bpos) \
				    || (apos) == WEST(bpos) \
				    || (apos) == NORTH(bpos) \
				    || (apos) == EAST(bpos) \
 				    || hadj(heye, apos, bpos) \
				    || hadj(heye, bpos, apos))

#define MAXEYE 20

static void
compute_primary_domains(int color, int domain[BOARDMAX],
			int lively[BOARDMAX],
			int false_margins[BOARDMAX],
			int first_time);
static void count_neighbours(struct eye_data eyedata[BOARDMAX]);
static int is_lively(int owl_call, int pos);
static int false_margin(int pos, int color, int lively[BOARDMAX]);
static void originate_eye(int origin, int pos,
			  int *esize, int *msize,
			  struct eye_data eye[BOARDMAX]);
static int recognize_eye(int pos, int *attack_point, int *defense_point,
			 int *max, int *min, 
			 struct eye_data eye[BOARDMAX],
			 struct half_eye_data heye[BOARDMAX],
			 int add_moves, int color);
static void guess_eye_space(int pos, int effective_eyesize, int margins,
			    struct eye_data eye[BOARDMAX],
			    int *max, int *min, int *pessimistic_min);
static void first_map(int q, int map[MAXEYE]);
static int next_map(int *q, int map[MAXEYE], int esize);
static void print_eye(struct eye_data eye[BOARDMAX],
		      struct half_eye_data heye[BOARDMAX], int pos);
static float 
evaluate_diagonal_intersection(int m, int n, int color,
			       int *attack_point, int *defense_point,
			       struct eye_data b_eye[BOARDMAX],
			       struct eye_data w_eye[BOARDMAX]);


/* These are used during the calculations of eye spaces. */
static int black_domain[BOARDMAX];
static int white_domain[BOARDMAX];


/*
 * Clear a struct eye_data.
 */

static void
clear_eye(struct eye_data *eye)
{
  eye->color = 0;
  eye->esize = 0;
  eye->msize = 0;
  eye->origin = NO_MOVE;
  eye->maxeye = 0;
  eye->mineye = 0;
  eye->attack_point = NO_MOVE;
  eye->defense_point = NO_MOVE;
  eye->dragon = NO_MOVE;
  eye->marginal = 0;
  eye->type = 0;
  eye->neighbors = 0;
  eye->marginal_neighbors = 0;
  eye->cut = 0;
}


/*
 * make_domains() is called from make_dragons() and from
 * owl_determine_life(). It marks the black and white domains
 * (eyeshape regions) and collects some statistics about each one.
 */

void
make_domains(struct eye_data b_eye[BOARDMAX],
	     struct eye_data w_eye[BOARDMAX],
	     int owl_call)
{
  int i, j;
  int k;
  int pos;
  int lively[BOARDMAX];
  int false_margins[BOARDMAX];
  
  memset(black_domain, 0, sizeof(black_domain));
  memset(white_domain, 0, sizeof(white_domain));
  memset(false_margins, 0, sizeof(false_margins));

  /* Initialize eye data and compute the lively array. */
  for (pos = BOARDMIN; pos < BOARDMAX; pos++)
    if (ON_BOARD(pos)) {
      clear_eye(&(b_eye[pos]));
      clear_eye(&(w_eye[pos]));
      lively[pos] = is_lively(owl_call, pos);
    }

  /* Compute the domains of influence of each color. */
  compute_primary_domains(BLACK, black_domain, lively, false_margins, 1);
  compute_primary_domains(WHITE, white_domain, lively, false_margins, 0);

  /* Now we fill out the arrays b_eye and w_eye with data describing
   * each eye shape.
   */

  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      pos = POS(i, j);
      if (board[pos] == EMPTY || !lively[pos]) {
	if (black_domain[pos] == 0 && white_domain[pos] == 0) {
	  w_eye[pos].color = GRAY;
	  b_eye[pos].color = GRAY;
	}
	else if (black_domain[pos] == 1 && white_domain[pos] == 0) {
	  b_eye[pos].color = BLACK_BORDER;
	  for (k = 0; k < 4; k++) {
	    int apos = pos + delta[k];
	    if (ON_BOARD(apos) && white_domain[apos] && !black_domain[apos]) {
	      b_eye[pos].marginal = 1;
	      break;
	    }
	  }
	}
	else if (black_domain[pos] == 0 && white_domain[pos] == 1) {
	  w_eye[pos].color = WHITE_BORDER;
	  for (k = 0; k < 4; k++) {
	    int apos = pos + delta[k];
	    if (ON_BOARD(apos) && black_domain[apos] && !white_domain[apos]) {
	      w_eye[pos].marginal = 1;
	      break;
	    }
	  }
	}
	else if (black_domain[pos] == 1 && white_domain[pos] == 1) {
	  for (k = 0; k < 4; k++) {
	    int apos = pos + delta[k];
	    if (ON_BOARD(apos) && black_domain[apos] && !white_domain[apos]) {
	      b_eye[pos].marginal = 1;
	      b_eye[pos].color = BLACK_BORDER;
	      break;
	    }
	  }
	  if (k == 4)
	    b_eye[pos].color = GRAY;
	  
	  for (k = 0; k < 4; k++) {
	    int apos = pos + delta[k];
	    if (ON_BOARD(apos) && white_domain[apos] && !black_domain[apos]) {
	      w_eye[pos].marginal = 1;
	      w_eye[pos].color = WHITE_BORDER;
	      break;
	    }
	  }
	  if (k == 4)
	    w_eye[pos].color = GRAY;
	}
      }
    }

  /* 
   * If called from make_dragons, search connection database for cutting
   * points, which may modify the eyespace in order to avoid amalgamation and
   * reflect the weakness in the position. The following test fails
   * if called from the owl code.
   */
  if (b_eye == black_eye)
    find_cuts();
  
 /* The eye spaces are all found. Now we need to find the origins. */
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      pos = POS(i, j);
      if (b_eye[pos].origin == NO_MOVE 
	  && b_eye[pos].color == BLACK_BORDER)
      {
	int esize = 0;
	int msize = 0;

	originate_eye(pos, pos, &esize, &msize, b_eye);
	b_eye[pos].esize = esize;
	b_eye[pos].msize = msize;
      }
    }

  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      pos = POS(i, j);
      if (w_eye[pos].origin == NO_MOVE
	  && w_eye[pos].color == WHITE_BORDER)
      {
	int esize = 0;
	int msize = 0;

	originate_eye(pos, pos, &esize, &msize, w_eye);
	w_eye[pos].esize = esize;
	w_eye[pos].msize = msize;
      }
    }

  /* Now we count the number of neighbors and marginal neighbors
   * of each vertex.
   */
  count_neighbours(b_eye);
  count_neighbours(w_eye);
}


/* Compute the domains of influence of each color, used in determining
 * eye shapes. NOTE: the term influence as used here is distinct from the
 * influence in influence.c.
 * 
 * For this algorithm the strings which are not lively are invisible. Ignoring
 * these, the algorithm assigns friendly influence to:
 *
 * (1) every vertex which is occupied by a (lively) friendly stone, 
 * (2) every empty vertex adjoining a (lively) friendly stone,
 * (3) every empty vertex for which two adjoining vertices (not
 *     on the first line) in the (usually 8) surrounding ones have friendly
 *     influence, with two CAVEATS explained below.
 *
 * Thus in the following diagram, e would be assigned friendly influence
 * if a and b have friendly influence, or a and d. It is not sufficent
 * for b and d to have friendly influence, because they are not adjoining.
 * 
 *        uabc
 *         def
 *         ghi
 * 
 * The constraint that the two adjoining vertices not lie on the first
 * line prevents influence from leaking under a stone on the third line.
 * 
 * The first CAVEAT alluded to above is that even if a and b have friendly
 * influence, this does not cause e to have friendly influence if there
 * is a lively opponent stone at d. This constraint prevents 
 * influence from leaking past knight's move extensions.
 *
 * The second CAVEAT is that even if a and b have friendly influence
 * this does not cause e to have influence if there are lively opponent
 * stones at u and at c. This prevents influence from leaking past
 * nikken tobis (two space jumps).  
 *
 * The corner vertices are handled slightly different.
 * 
 *    +---
 *    |ab
 *    |cd
 * 
 * We get friendly influence at a if we have friendly influence
 * at b or c and no lively unfriendly stone at b, c or d. 
 *
 */

#define lively_stone(pos, color) (board[pos] == color && lively[pos])
#define has_inf(color, pos) (domain[pos] || lively_stone(pos, color))
#define sufficient_influence(pos, apos, bpos) \
 (ON_BOARD(bpos) \
  && (domain[apos] + domain[bpos]) \
      > (inhibit[pos] > 1) + (inhibit[apos] > 0) + (inhibit[bpos] > 0))

static void
compute_primary_domains(int color, int domain[BOARDMAX],
			int lively[BOARDMAX],
			int false_margins[BOARDMAX],
			int first_time)
{
  int other = OTHER_COLOR(color);
  int found_one;
  int i, j;
  int pos;
  int inhibit[BOARDMAX];
  memset(inhibit, 0, sizeof(inhibit));

  /* In the first pass we
   * 1. Give influence to lively own stones and their neighbors.
   *    (Cases (1) and (2) above.)
   * 2. Set inhibit for lively opponent stones and their neighbors.
   */
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      pos = POS(i, j);
      if (lively_stone(pos, color))
	domain[pos] = 1; /* Case (1) above. */
      else if (lively_stone(pos, other))
	inhibit[pos] = 1;
      else {
	if (lively_stone(SOUTH(pos), color)
	    || lively_stone(WEST(pos), color)
	    || lively_stone(NORTH(pos), color)
	    || lively_stone(EAST(pos), color)) {
	  /* Case (2) above.
	   *
	   * To explain the asymmetry between the first time around
	   * this loop and subsequent ones, a false margin is adjacent
	   * to both B and W lively stones, so it's found on the first
	   * pass through the loop.
	   */
	  if (first_time) {
	    if (board[pos] == EMPTY && false_margin(pos, color, lively))
	      false_margins[pos] = 1;
	    else if (board[pos] == EMPTY
		     && false_margin(pos, other, lively))
	      false_margins[pos] = 1;
	    else
	      domain[pos] = 1;
	  }
	  else {
	    if (IS_STONE(board[pos]) || false_margins[pos] != 1)
	      domain[pos] = 1;
	  }
	}
	
	if (lively_stone(SOUTH(pos), other)
	    || lively_stone(WEST(pos), other)
	    || lively_stone(NORTH(pos), other)
	    || lively_stone(EAST(pos), other))
	  inhibit[pos] = 2;
	else if (is_edge_vertex(pos))
	  inhibit[pos] = 1;
      }
    }

  /* Now we loop over the board until no more vertices can be added to
   * the domain through case (3) above.
   */
  do {
    found_one = 0;
    for (i = 0; i < board_size; i++)
      for (j = 0; j < board_size; j++) {
	pos = POS(i, j);
	
	/* First we handle the trivial cases. */
	if (domain[pos] || lively_stone(pos, other) || false_margins[pos])
	  continue;

	/* Case (3) above. */
	if (sufficient_influence(pos, SOUTH(pos), SE(pos))
	    || sufficient_influence(pos, SOUTH(pos), SW(pos))
	    || sufficient_influence(pos, WEST(pos), SW(pos))
	    || sufficient_influence(pos, WEST(pos), NW(pos))
	    || sufficient_influence(pos, NORTH(pos), NW(pos))
	    || sufficient_influence(pos, NORTH(pos), NE(pos))
	    || sufficient_influence(pos, EAST(pos), NE(pos))
	    || sufficient_influence(pos, EAST(pos), SE(pos))) {
	  domain[pos] = 1;
	  found_one = 1;
	}
      }
  } while (found_one);
  
  if (0 && (debug & DEBUG_EYES)) {
    int i, j;
    start_draw_board();
    for (i = 0; i < board_size; i++)
      for (j = 0; j < board_size; j++) {
	draw_color_char(i, j, domain[POS(i, j)] ? '1' : '0', GG_COLOR_BLACK);
      }
    end_draw_board();
  }
}



static void
count_neighbours(struct eye_data eyedata[BOARDMAX])
{
  int pos;
  int k;

  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (!ON_BOARD(pos) || eyedata[pos].origin == NO_MOVE) 
      continue;

    eyedata[pos].esize = eyedata[eyedata[pos].origin].esize;
    eyedata[pos].msize = eyedata[eyedata[pos].origin].msize;
    eyedata[pos].neighbors = 0;
    eyedata[pos].marginal_neighbors = 0;
    
    for (k = 0; k < 4; k++) {
      int pos2 = pos + delta[k];
      if (ON_BOARD(pos2) && eyedata[pos2].origin == eyedata[pos].origin) {
	eyedata[pos].neighbors++;
	if (eyedata[pos2].marginal)
	  eyedata[pos].marginal_neighbors++;
      }
    }
  }
}


static int
is_lively(int owl_call, int pos)
{
  int result;

  if (owl_call)
    result = owl_lively(pos);
  else
    result = (!worm[pos].inessential
	      && (worm[pos].attack_codes[0] == 0
		  || worm[pos].defend_codes[0] != 0));

  return result;
}


/* In the following situation, we do not wish the vertex at 'a'
 * included in the O eye space:
 * 
 * OOOOXX
 * OXaX..
 * ------
 *
 * This eyespace should parse as (X), not (X!). Thus the vertex
 * should not be included in the eyespace if it is adjacent to
 * an X stone which is alive, yet X cannot play safely at a.
 * The function returns 1 if this situation is found at 
 * (pos) for color O.
 *
 * The condition above is true, curiously enough, also for the
 * following case:
 *   A group has two eyes, one of size 1 and one which is critical 1/2.
 *   It also has to have less than 4 external liberties, since the
 *   reading has to be able to capture the group tactically. In that 
 *   case, the eye of size one will be treated as a false marginal.
 * Thus we have to exclude this case, which is done by requiring (pos)
 * to be adjacent to both white and black stones. Since this test is
 * least expensive, we start with it.
 *
 * As a second optimization we require that one of the other colored
 * neighbors is not lively. This should cut down on the number of
 * calls to attack() and safe_move().
 */

static int
false_margin(int pos, int color, int lively[BOARDMAX])
{
  int other = OTHER_COLOR(color);
  int neighbors = 0;
  int k;
  int all_lively;
  int potential_false_margin;
  
  /* The life code needs the false margins to remain in the eyespace. */
  if (life)
    return 0;
  
  /* Require neighbors of both colors. */
  for (k = 0; k < 4; k++)
    if (ON_BOARD(pos + delta[k]))
	neighbors |= board[pos + delta[k]];	

  if (neighbors != (WHITE | BLACK))
    return 0;

  /* At least one opponent neighbor should be not lively. */
  all_lively = 1;
  for (k = 0; k < 4; k++)
    if (board[pos + delta[k]] == other && !lively[pos + delta[k]])
      all_lively = 0;

  if (all_lively)
    return 0;

  potential_false_margin = 0;
  for (k = 0; k < 4; k++) {
    int apos = pos + delta[k];
    if (board[apos] != other || !lively[apos])
      continue;
    
    if (stackp == 0 && worm[apos].attack_codes[0] == 0)
      potential_false_margin = 1;
    
    if (stackp > 0 && !attack(apos, NULL))
      potential_false_margin = 1;
  }
  
  if (potential_false_margin && safe_move(pos, other) == 0) {
    DEBUG(DEBUG_EYES, "False margin for %C at %1m.\n", color, pos);
    return 1;
  }

  return 0;
}


/*
 * originate_eye(pos, pos, *size) creates an eyeshape with origin (pos).
 * the last variable returns the size. The repeated variables (pos) are due
 * to the recursive definition of the function.
 */
static void
originate_eye(int origin, int pos,
	      int *esize, int *msize, 
	      struct eye_data eye[BOARDMAX])
{
  int k;
  ASSERT_ON_BOARD1(origin);
  ASSERT_ON_BOARD1(pos);
  gg_assert(esize != NULL);
  gg_assert(msize != NULL);
  
  eye[pos].origin = origin;
  (*esize)++;
  if (eye[pos].marginal)
    (*msize)++;
  if (eye[pos].type & INHIBIT_CONNECTION)
    return;

  for (k = 0; k < 4; k++) {
    int pos2 = pos + delta[k];
    if (ON_BOARD(pos2)
	&& eye[pos2].color == eye[pos].color
	&& eye[pos2].origin == NO_MOVE
	&& (!eye[pos2].marginal || !eye[pos].marginal))
      originate_eye(origin, pos2, esize, msize, eye);
  }
}


/* 
 * propagate_eye(origin) copies the data at the (origin) to the
 * rest of the eye (invariant fields only).
 */

void
propagate_eye(int origin, struct eye_data eye[BOARDMAX])
{
  int pos;

  for (pos = BOARDMIN; pos < BOARDMAX; pos++)
    if (ON_BOARD(pos) && eye[pos].origin == origin) {
      eye[pos].color         = eye[origin].color;
      eye[pos].esize         = eye[origin].esize;
      eye[pos].msize         = eye[origin].msize;
      eye[pos].origin        = eye[origin].origin;
      eye[pos].maxeye        = eye[origin].maxeye;
      eye[pos].mineye        = eye[origin].mineye;
      eye[pos].attack_point  = eye[origin].attack_point;
      eye[pos].defense_point = eye[origin].defense_point;
      eye[pos].dragon        = eye[origin].dragon;
    }
}


/* Print debugging data for the eyeshape at (i,j). Useful with GDB.
 */

static void
print_eye(struct eye_data eye[BOARDMAX], struct half_eye_data heye[BOARDMAX],
	  int pos)
{
  int m, n;
  int mini, maxi;
  int minj, maxj;
  int origin = eye[pos].origin;

  gprintf("Eyespace at %1m: color=%C, esize=%d, msize=%d\n",
	  pos, eye[pos].color, eye[pos].esize, eye[pos].msize);
  
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      int pos2 = POS(m, n);
      if (eye[pos2].origin != pos) 
	continue;
      
      if (eye[pos2].marginal && IS_STONE(board[pos2]))
	gprintf("%1m (X!)\n", pos2);
      else if (is_halfeye(heye, pos2) && IS_STONE(board[pos2])) {
	if (heye[pos2].value == 3.0)
	  gprintf("%1m (XH)\n", pos2);
	else
	  gprintf("%1m (XH) (topological eye value = %f)\n", pos2,
		  heye[pos2].value);
      }
      else if (!eye[pos2].marginal && IS_STONE(board[pos2]))
	gprintf("%1m (X)\n", pos2);
      else if (eye[pos2].marginal && board[pos2] == EMPTY)
	gprintf("%1m (!)\n", pos2);
      else if (is_halfeye(heye, pos2) && board[pos2] == EMPTY) {
	if (heye[pos2].value == 3.0)
	  gprintf("%1m (H)\n", pos2);
	else
	  gprintf("%1m (H) (topological eye value = %f)\n", pos2,
		  heye[pos2].value);
      }
      else
	gprintf("%1m\n", pos2);
    }
  gprintf("\n");
  
  /* Determine the size of the eye. */
  mini = board_size;
  maxi = -1;
  minj = board_size;
  maxj = -1;
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      if (eye[POS(m, n)].origin != origin)
	continue;

      if (m < mini) mini = m;
      if (m > maxi) maxi = m;
      if (n < minj) minj = n;
      if (n > maxj) maxj = n;
    }

  /* Prints the eye shape. A half eye is shown by h, if empty or H, if an
   * enemy is present. Note that each half eye has a marginal point which is 
   * not printed, so the representation here may have less points than the 
   * matching eye pattern in eyes.db. Printing a marginal for the half eye
   * would be nice, but difficult to implement.
   */
  for (m = mini; m <= maxi; m++) {
    gprintf(""); /* Get the indentation right. */
    for (n = minj; n <= maxj; n++) {
      int pos2 = POS(m, n);
      if (eye[pos2].origin == origin) {
	if (board[pos2] == EMPTY) {
	  if (eye[pos2].marginal)
	    gprintf("%o!");
	  else if (is_halfeye(heye, pos2))
	    gprintf("%oh");
	  else
	    gprintf("%o.");
	}
	else if (is_halfeye(heye, pos2))
	  gprintf("%oH");
	else
	  gprintf("%oX");
      }
      else
	gprintf("%o ");
    }
    gprintf("\n");
  }
}


/* 
 * Given an eyespace with origin (pos), this function computes the
 * minimum and maximum numbers of eyes the space can yield. If max and
 * min are different, then vital points of attack and defense are also
 * generated.
 * 
 * If add_moves == 1, this function may add a move_reason for (color) at
 * a vital point which is found by the function. If add_moves == 0,
 * set color == EMPTY.
 */

void
compute_eyes(int pos, int *max, int *min,
	     int *attack_point, int *defense_point,
	     struct eye_data eye[BOARDMAX],
	     struct half_eye_data heye[BOARDMAX],
	     int add_moves, int color)
{
  if (attack_point)
    *attack_point = NO_MOVE;
  if (defense_point)
    *defense_point = NO_MOVE;

  if (debug & DEBUG_EYES) {
    print_eye(eye, heye, pos);
    DEBUG(DEBUG_EYES, "\n");
  }
  
  /* First we try to let the life code evaluate the eye space. */
  if (life && eye[pos].esize <= life_eyesize) {
    int max1, min1;
    int attack_point1;
    int defense_point1;
    int status;

    if (recognize_eye2(pos, attack_point, defense_point, max, min,
		       eye, heye, add_moves, color)) {

      /* made these printouts contingent on DEBUG_EYES /gf */
      if (debug & DEBUG_EYES) {
	fprintf(stderr, "\n");
	showboard(2);
	
	status = recognize_eye(pos, &attack_point1, &defense_point1,
			       &max1, &min1, eye, heye, 0, EMPTY);
	
	if (status) {
	  gprintf("Number of eyes:  --life: (%d, %d)  old: (%d, %d) at %1m\n", 
		  *max, *min, max1, min1, pos);
	  if (*min != *max) {
	    gprintf("  vital point:     attack: %1m   defense: %1m\n",
		    *attack_point, *defense_point);
	    gprintf("  old vital point: attack: %1m   defense: %1m\n",
		    attack_point1, defense_point1);
	  }
	}
	else {
	  gprintf("Number of eyes:  new: (%d, %d) at %1m\n", *max, *min, pos);
	  if (*min != *max)
	    gprintf("  vital point:   attack: %1m   defense: %1m\n",
		    *attack_point, *defense_point);
	}
      }
      
      return;
    }
  }

  /* Fall back on the graphs database if the eye is too big or the
   * life code is disabled.
   */
  if (recognize_eye(pos, attack_point, defense_point, max, min,
		    eye, heye, add_moves, color))
    return;

  if (eye[pos].esize < 6) {
    /* made these printouts contingent on DEBUG_EYES /gf */
    if (debug & DEBUG_EYES) {
      gprintf("===========================================================\n");
      gprintf("Unrecognized eye of size %d shape at %1m\n", 
	      eye[pos].esize, pos);
      print_eye(eye, heye, pos);
    }
  }

  /* Ideally any eye space that hasn't been matched yet should be two
   * secure eyes. Until the database becomes more complete we have
   * some additional heuristics to guess the values of unknown
   * eyespaces.
   */
  if (eye[pos].esize-2*eye[pos].msize > 3) {
    *min = 2;
    *max = 2;
  }
  else if (eye[pos].esize-2*eye[pos].msize > 0) {
    *min = 1;
    *max = 1;
  }
  else {
    *min = 0;
    *max = 0;
  }
}


/*
 * This function works like compute_eyes(), except that it also gives
 * a pessimistic view of the chances to make eyes. Since it is intended
 * to be used from the owl code, the option to add move reasons has
 * been removed.
 */
void
compute_eyes_pessimistic(int pos, int *max, int *min,
			 int *pessimistic_min,
			 int *attack_point, int *defense_point,
			 struct eye_data eye[BOARDMAX],
			 struct half_eye_data heye[BOARDMAX])
{
  int m, n;
  int margins = 0;
  int halfeyes = 0;
  int margins_adjacent_to_margin = 0;
  int effective_eyesize;

  /* Stones inside eyespace which do not coincide with a false eye or
   * a halfeye.
   */
  int interior_stones = 0;

  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      int pos2 = POS(m, n);
      if (eye[pos2].origin != pos)
	continue;
      if (eye[pos2].marginal || is_halfeye(heye, pos2)) {
	margins++;
	if (eye[pos2].marginal && eye[pos2].marginal_neighbors > 0)
	  margins_adjacent_to_margin++;
	if (is_halfeye(heye, pos2))
	  halfeyes++;
      }
      else if (IS_STONE(board[pos2]))
	interior_stones++;
    }

  /* This is a measure based on the simplified assumption that both
   * players only cares about playing the marginal eye spaces. It is
   * used later to guess the eye value for unidentified eye shapes.
   */
  effective_eyesize = (eye[pos].esize + halfeyes - 2*margins
		       - margins_adjacent_to_margin);

  if (attack_point)
    *attack_point = NO_MOVE;
  if (defense_point)
    *defense_point = NO_MOVE;

  if (debug & DEBUG_EYES) {
    print_eye(eye, heye, pos);
    DEBUG(DEBUG_EYES, "\n");
  }
  
  /* First we try to let the life code evaluate the eye space. */
  if (life
      && eye[pos].esize <= life_eyesize
      && recognize_eye2(pos, attack_point, defense_point, max, min,
			eye, heye, 0, EMPTY)) {
    *pessimistic_min = *min - margins;

    DEBUG(DEBUG_EYES, "  life - max=%d, min=%d, pessimistic_min=%d\n",
	  *max, *min, *pessimistic_min);
  }
  /* Fall back on the graphs database if the eye is too big or the
   * life code is disabled.
   */
  else if (recognize_eye(pos, attack_point, defense_point, max, min,
			 eye, heye, 0, EMPTY)) {
    *pessimistic_min = *min - margins;

    /* A single point eye which is part of a ko can't be trusted. */
    if (eye[pos].esize == 1
	&& is_ko(pos, eye[pos].color == WHITE_BORDER ? BLACK : WHITE, NULL))
      *pessimistic_min = 0;

    DEBUG(DEBUG_EYES, "  graph matching - max=%d, min=%d, pessimistic_min=%d\n",
	  *max, *min, *pessimistic_min);
  }
  
  /* Ideally any eye space that hasn't been matched yet should be two
   * secure eyes. Until the database becomes more complete we have
   * some additional heuristics to guess the values of unknown
   * eyespaces.
   */
  else {
    guess_eye_space(pos, effective_eyesize, margins, eye,
		    max, min, pessimistic_min); 
    DEBUG(DEBUG_EYES, "  guess_eye - max=%d, min=%d, pessimistic_min=%d\n",
	  *max, *min, *pessimistic_min);
  }

  if (*pessimistic_min < 0) {
    *pessimistic_min = 0;
    DEBUG(DEBUG_EYES, "  pessimistic min revised to 0\n");
  }
  
  /* An eyespace with at least two interior stones is assumed to be
   * worth at least one eye, regardless of previous considerations.
   */
  if (*pessimistic_min < 1 && interior_stones >= 2) {
    *pessimistic_min = 1;
    DEBUG(DEBUG_EYES, "  pessimistic min revised to 1 (interior stones)\n");
  }
  
  if (attack_point
      && *attack_point == NO_MOVE
      && *max != *pessimistic_min) {
    /* Find one marginal vertex and set as attack and defense point.
     *
     * We make some effort to find the best marginal vertex by giving
     * priority to ones with more than one neighbor in the eyespace.
     * We prefer non-halfeye margins and ones which are not self-atari
     * for the opponent. Margins not on the edge are also favored.
     */
    int best_attack_point = NO_MOVE;
    int best_defense_point = NO_MOVE;
    float score = 0.0;
    int pos2;
    
    for (pos2 = BOARDMIN; pos2 < BOARDMAX; pos2++) {
      if (ON_BOARD(pos2) && eye[pos2].origin == pos) {
	float this_score = 0.0;
	int this_attack_point = NO_MOVE;
	int this_defense_point = NO_MOVE;
	if (eye[pos2].marginal && board[pos2] == EMPTY) {
	  this_score = eye[pos2].neighbors;
	  this_attack_point = pos2;
	  this_defense_point = pos2;

	  if (is_self_atari(pos2,
			    eye[pos].color == WHITE_BORDER ? BLACK : WHITE))
	    this_score -= 0.5;
	  
	  if (is_edge_vertex(pos2))
	    this_score -= 0.1;
	}
	else if (is_halfeye(heye, pos2)) {
	  this_score = 0.75;
	  this_defense_point = heye[pos2].defense_point[0];
	  this_attack_point = heye[pos2].attack_point[0];
	}
	else
	  continue;
	
	if (gg_normalize_float2int(this_score, 0.01)
	    > gg_normalize_float2int(score, 0.01)) {
	  best_attack_point = this_attack_point;
	  best_defense_point = this_defense_point;
	  score = this_score;
	}
      }
    }
    
    if (score > 0.0) {
      if (defense_point)
	*defense_point = best_defense_point;
      if (attack_point)
	*attack_point = best_attack_point;
    }
  }

  if (defense_point && *defense_point != NO_MOVE) {
    ASSERT_ON_BOARD1(*defense_point);
  }
  if (attack_point && *attack_point != NO_MOVE) {
    ASSERT_ON_BOARD1(*attack_point);
  }
}


static void
guess_eye_space(int pos, int effective_eyesize, int margins,
		struct eye_data eye[BOARDMAX],
		int *max, int *min, int *pessimistic_min)
{
  if (effective_eyesize > 3) {
    *min = 2;
    *max = 2;
    if ((margins == 0 && effective_eyesize > 7)
	|| (margins > 0 && effective_eyesize > 9))
      *pessimistic_min = 2;
    else
      *pessimistic_min = 1;
  }
  else if (effective_eyesize > 0) {
    *min = 1;
    *max = 1;
    if (margins > 0)
      *pessimistic_min = 0;
    else
      *pessimistic_min = 1;
  }
  else {
    *min = 0;
    if (eye[pos].esize - margins > 2)
      *max = 1;
    else
      *max = 0;
    *pessimistic_min = 0;
  }
}


/* recognize_eye(pos, *attack_point, *defense_point, *max, *min, eye_data, 
 * half_eye_data, add_moves, color), where pos is the origin of an eyespace,
 * returns 1 if there is a pattern in eyes.db matching the eyespace, or
 * 0 if no match is found. If there is a key point for attack, (*attack_point)
 * is set to its location, or NO_MOVE if there is none.
 * Similarly (*defense_point) is the location of a vital defense point. *min
 * and *max are the minimum and maximum number of eyes that can be
 * made in this eyespace respectively. Vital attack/defense points
 * exist if and only if *min != *max.
 *
 * If add_moves==1, this function may add a move_reason for (color) at
 * a vital point which is found by the function. If add_moves==0,
 * set color==EMPTY.
 */

static int
recognize_eye(int pos, int *attack_point, int *defense_point,
	      int *max, int *min, 
	      struct eye_data eye[BOARDMAX], 
	      struct half_eye_data heye[BOARDMAX], 
	      int add_moves, int color)
{
  int m, n;
  int k;
  int eye_size = 0;
  int vpos[MAXEYE], marginal[MAXEYE], neighbors[MAXEYE];
  int edge[MAXEYE];
  int graph;
  int q;
  int map[MAXEYE];
  int ok, contin;
  int eye_color;
  int kpos;
  int num_marginals = 0;

  gg_assert(attack_point != NULL);
  gg_assert(defense_point != NULL);
    
  /* Set `eye_color' to the owner of the eye. */
  eye_color = eye[pos].color;
  if (eye_color == BLACK_BORDER)
    eye_color = BLACK;
  if (eye_color == WHITE_BORDER)
    eye_color = WHITE;


  if (eye[pos].esize-eye[pos].msize > 7)
    return 0;

  if (eye[pos].msize > MAXEYE)
    return 0;

  /* Create list of eye vertices */
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      int pos2 = POS(m, n);
      if (eye[pos2].origin == pos) {
	vpos[eye_size] = pos2;
	marginal[eye_size] = eye[pos2].marginal;
	if (marginal[eye_size])
	  num_marginals++;
	neighbors[eye_size] = eye[pos2].neighbors;
	if (0) {
	  if (marginal[eye_size])
	    TRACE("(%1m)", vpos[eye_size]);
	  else
	    TRACE(" %1m ", vpos[eye_size]);
	  TRACE("\n");
	}

	edge[eye_size] = 0;
	if (m == 0 || m == board_size-1)
	  edge[eye_size]++;
	if (n == 0 || n == board_size-1)
	  edge[eye_size]++;
	
	eye_size++;
	if (is_halfeye(heye, pos2)) {

	  /* Use one of the diagonals as a marginal for mapping purposes.
	   * The whole set of diagonals is isomorphic to a marginal.
	   * Note that the half eye preceedes the diagonal in the list.
	   */
	  neighbors[eye_size-1]++;       /* increase neighbors of half eye */
	  if (eye_color == color)
	    kpos = heye[pos2].defense_point[0];
	  else
	    kpos = heye[pos2].attack_point[0];
	  ASSERT_ON_BOARD1(kpos);
	  vpos[eye_size] = kpos;
	  marginal[eye_size] = 1;
	  edge[eye_size] = 0;
	  num_marginals++;
	  neighbors[eye_size] = 1;
	  eye_size++;
	}
      }
    }

  /* We attempt to construct a map from the graph to the eyespace
   * preserving the adjacency structure. If this can be done, we've
   * identified the eyeshape.
   */

  for (graph = 0; graphs[graph].vertex != NULL; graph++) {
    if (graphs[graph].esize != eye_size
	|| graphs[graph].msize != num_marginals)
      continue;


    q = 0;
    first_map(q, map);

    contin = 1;
    while (contin && q >= 0 && q < eye_size) {
      ok = 1;

      if (0)
	TRACE("q=%d: %d %d %d %d %d %d\n", 
	      q, map[0], map[1], map[2], map[3], map[4], map[5]);

      if (neighbors[map[q]] != graphs[graph].vertex[q].neighbors)
	ok = 0;

      if (ok && marginal[map[q]]
	  && graphs[graph].vertex[q].type != '!'
	  && graphs[graph].vertex[q].type != '@'
	  && graphs[graph].vertex[q].type != '$'
	  && graphs[graph].vertex[q].type != ')'
	  && graphs[graph].vertex[q].type != '(')
	ok = 0;
      
      if (ok && !marginal[map[q]]
	  && (graphs[graph].vertex[q].type == '!'
	      || graphs[graph].vertex[q].type == '('
	      || graphs[graph].vertex[q].type == ')'
	      || graphs[graph].vertex[q].type == '@'
	      || graphs[graph].vertex[q].type == '$'))
	ok = 0;
      
      if (ok && IS_STONE(board[vpos[map[q]]])
	  && graphs[graph].vertex[q].type != 'X'
	  && graphs[graph].vertex[q].type != 'x'
	  && graphs[graph].vertex[q].type != '$')
	ok = 0;
      
      if (ok && board[vpos[map[q]]] == EMPTY
	  && (graphs[graph].vertex[q].type == 'X'
	      || graphs[graph].vertex[q].type == '$'))
	ok = 0;

      if (ok && edge[map[q]] < graphs[graph].vertex[q].edge)
	ok = 0;
      
      if (ok && graphs[graph].vertex[q].n1 < q
	  && graphs[graph].vertex[q].n1 != -1)
	{
	  if (!adjacent(heye, vpos[map[q]], 
			vpos[map[graphs[graph].vertex[q].n1]]))
	    ok = 0;
	}
      if (ok && graphs[graph].vertex[q].n2 < q
	  && graphs[graph].vertex[q].n2 != -1)
	{
	  if (!adjacent(heye, vpos[map[q]], 
			vpos[map[graphs[graph].vertex[q].n2]]))
	    ok = 0;
	}
      if (ok && graphs[graph].vertex[q].n3 < q
	  && graphs[graph].vertex[q].n3 != -1)
	{
	  if (!adjacent(heye, vpos[map[q]],
			vpos[map[graphs[graph].vertex[q].n3]]))
	    ok = 0;
	}
      if (ok && graphs[graph].vertex[q].n4 < q
	  && graphs[graph].vertex[q].n4 != -1)
	{
	  if (!adjacent(heye, vpos[map[q]],
			vpos[map[graphs[graph].vertex[q].n4]]))
	    ok = 0;
	}

      if (!ok) {
	contin = next_map(&q, map, eye_size);
	if (0)
	  gprintf("  q=%d, esize=%d: %d %d %d %d %d\n",
		  q, eye_size, 
		  map[0], map[1], map[2], map[3], map[4]);
      }
      else {
	q++;
	first_map(q, map);
      }
    }

    /* We have found a match! Now sort out the vital moves. */
    if (q == eye_size) {
      *max = graphs[graph].max;
      *min = graphs[graph].min;
      if (*max != *min) {
	/* Collect all attack and defense points in the pattern. */
	int attack_points[4 * MAXEYE];
	int defense_points[4 * MAXEYE];
	int num_attacks = 0;
	int num_defenses = 0;

	for (k = 0; k < graphs[graph].esize; k++) {
	  if (graphs[graph].vertex[k].type == '*'
	      || graphs[graph].vertex[k].type == '<')
	    attack_points[num_attacks++] = vpos[map[k]];
	  else if (graphs[graph].vertex[k].type == '@'
		   || graphs[graph].vertex[k].type == '(') {
	    /* check for marginal matching half eye diagonal
	     * If it is a half eye diagonal, the half eye preceeds
	     * the diagonal in the list of vertices
	     */
	    if (map[k] > 0 && is_halfeye(heye, vpos[map[k]-1])) {
	      /* Add all diagonals as vital. */
	      int ix;
	      struct half_eye_data *this_half_eye = &heye[vpos[map[k]-1]];
	      
	      for (ix = 0; ix < this_half_eye->num_attacks; ix++)
		attack_points[num_attacks++] = this_half_eye->attack_point[ix];
	    }
	    else
	      attack_points[num_attacks++] = vpos[map[k]];
	  }
	  
	  if (graphs[graph].vertex[k].type == '*'
	      || graphs[graph].vertex[k].type == '>')
	    defense_points[num_defenses++] = vpos[map[k]];
	  else if (graphs[graph].vertex[k].type == '@'
		   || graphs[graph].vertex[k].type == ')') {
	    /* Check for marginal matching half eye diagonal. */
	    if (map[k] > 0 && is_halfeye(heye, vpos[map[k]-1])) {
	      /* Add all diagonals as vital. */
	      int ix;
	      struct half_eye_data *this_half_eye = &heye[vpos[map[k]-1]];

	      for (ix = 0; ix < this_half_eye->num_defends; ix++)
		defense_points[num_defenses++] 
		  = this_half_eye->defense_point[ix];
	    }
	    else
	      defense_points[num_defenses++] = vpos[map[k]];
	  }
	}
	
	gg_assert(num_attacks > 0 && num_defenses > 0);

	*attack_point = attack_points[0];
	/* If possible, choose a non-sacrificial defense point.
         * Compare white T8 and T6 in lazarus:21.
	 */
	*defense_point = defense_points[0];
	for (k = 0; k < num_defenses; k++) {
	  if (safe_move(defense_points[k], eye_color) == WIN) {
	    *defense_point = defense_points[k];
	    break;
	  }
	}
	
	DEBUG(DEBUG_EYES, "  vital points: %1m (attack) %1m (defense)\n",
	      *attack_point, *defense_point);
	DEBUG(DEBUG_EYES, "  pattern matched:  %s\n", graphs[graph].patname);

	if (add_moves) {
	  if (eye_color != color) {
	    for (k = 0; k < num_attacks; k++)
	      add_vital_eye_move(attack_points[k], pos, eye_color);
	  }
	  else {
	    for (k = 0; k < num_defenses; k++)
	      add_vital_eye_move(defense_points[k], pos, eye_color);
	  }
	}
      }
      TRACE("eye space at %1m of type %s\n", pos, graphs[graph].patname);

      return 1;
    }
  }

  return 0;
}


/* a MAP is a map of the integers 0,1,2, ... ,q into 
 * 0,1, ... , esize-1 where q < esize. This determines a 
 * bijection of the first q+1 elements of the graph into the 
 * eyespace. The function first_map finds the smallest valid
 * value of element q, assuming the previous elements are ok.
 */

static void
first_map(int q, int map[MAXEYE])
{
  int k;
  int r;
  
  for (k = 0; k <= q; k++) {
    for (r = 0; r < q; r++)
      if (map[r] == k)
	break;

    if (r == q) {
      map[q] = k;
      break;
    }
  }
}     


/* a MAP is a map of the integers 0,1,2, ... ,q into 
 * 0,1, ... , esize-1 where q < esize. This determines a 
 * bijection of the first q+1 elements of the graph into the 
 * eyespace. The function next_map produces the next map when
 * these are ordered lexicographically. If no next map can
 * be found, q is decremented, then we try again. If q==0
 * and no next map can be found, the function returns false.
 */

static int
next_map(int *q, int map[MAXEYE], int esize)
{
  int mapok = 0;
  int r;

  if (0)
    gprintf("  q=%d, esize=%d: %d %d %d %d %d\n",
	    *q, esize, map[0], map[1], map[2], map[3], map[4]);

  if (*q == 0 && map[*q] == esize - 1)
    return 0;

  map[*q]++;
  while (!mapok) {
    mapok = 1;
    for (r = 0; r < *q; r++) {
      if (map[r] == map[*q]) {
	map[*q]++;
	mapok = 0;
      }
    }
  }

  if (map[*q] >= esize) {
    map[*q] = 0;
    (*q)--;
    return next_map(q, map, esize);
  }
  else
    return 1;
}     


/* add_false_eye() turns a proper eyespace into a margin. */

void
add_false_eye(int pos, struct eye_data eye[BOARDMAX],
	      struct half_eye_data heye[BOARDMAX])
{
  int k;
  ASSERT1(heye[pos].type == FALSE_EYE, pos);
  DEBUG(DEBUG_EYES, "false eye found at %1m\n", pos);

  if (eye[pos].color == GRAY || eye[pos].marginal != 0)
    return;
  
  eye[pos].marginal = 1;
  eye[eye[pos].origin].msize++;
  for (k = 0; k < 4; k++)
    if (ON_BOARD(pos + delta[k])
	&& eye[pos + delta[k]].origin == eye[pos].origin)
      eye[pos + delta[k]].marginal_neighbors++;
  propagate_eye(eye[pos].origin, eye);
}


/* These functions are used from constraints to identify eye spaces,
 * primarily for late endgame moves.
 */
int
is_eye_space(int pos)
{
  return (white_eye[pos].color == WHITE_BORDER
	  || black_eye[pos].color == BLACK_BORDER);
}

int
is_proper_eye_space(int pos)
{
  return ((white_eye[pos].color == WHITE_BORDER
	   && !white_eye[pos].marginal)
	  || (black_eye[pos].color == BLACK_BORDER
	      && !black_eye[pos].marginal));
}

/* Return the maximum number of eyes that can be obtained from the
 * eyespace at (i, j). This is most useful in order to determine
 * whether the eyespace can be assumed to produce any territory at
 * all.
 */
int
max_eye_value(int pos)
{
  int max_white = 0;
  int max_black = 0;
  
  if (white_eye[pos].color == WHITE_BORDER)
    max_white = white_eye[pos].maxeye;

  if (black_eye[pos].color == BLACK_BORDER)
    max_black = black_eye[pos].maxeye;

  return gg_max(max_white, max_black);
}

int
is_marginal_eye_space(int pos)
{
  return (white_eye[pos].marginal || black_eye[pos].marginal);
}

int
is_halfeye(struct half_eye_data heye[BOARDMAX], int pos)
{
  return heye[pos].type == HALF_EYE;
}

/* See Texinfo documentation (Eyes:Eye Topology). Returns:
 * - 2 or less if (pos) is a proper eye for (color);
 * - between 2 and 3 if the eye can be made false only by ko
 * - 3 if (pos) is a half eye;
 * - between 3 and 4 if the eye can be made real only by ko
 * - 4 or more if (pos) is a false eye.
 *
 * Attack and defense points for control of the diagonals are stored
 * in the heye[] array.
 */

float
topological_eye(int pos, int color,
		struct eye_data b_eye[BOARDMAX],
		struct eye_data w_eye[BOARDMAX],
		struct half_eye_data heye[BOARDMAX])
{
  float sum = 0.0;
  float val;
  int num_attacks = 0;
  int num_defenses = 0;
  int attack_values[4];
  int defense_values[4];
  int k;
  int r;
  int attack_point;
  int defense_point;
  int attack_value;
  int defense_value;

  memset(attack_values, 0, sizeof(attack_values));
  memset(defense_values, 0, sizeof(defense_values));
  
  /* Loop over the diagonal directions. */
  for (k = 4; k < 8; k++) {
    val = evaluate_diagonal_intersection(I(pos) + deltai[k],
					 J(pos) + deltaj[k], color,
					 &attack_point, &defense_point, 
					 b_eye, w_eye);
    sum += val;
    if (val > 0.0 && val < 2.0) {
      /* Diagonals off the edge has value 1.0 but no attack or defense
       * point.
       */
      if (attack_point != NO_MOVE && defense_point != NO_MOVE) {
	ASSERT_ON_BOARD1(attack_point);
	ASSERT_ON_BOARD1(defense_point);
	/* Store these in sorted (descending) order. We remap val
         * differently for attack and defense points according to:
	 *
	 * val    attack_value     defense_value
	 * ---    ------------     -------------
	 * 1.0    3                3
	 * <1.0   2                1
	 * >1.0   1                2
	 *
	 * This means that we primarily want to take control of
	 * diagonals without ko and secondarily of diagonals we can
	 * take unconditionally but not the opponent.
	 */
	if (val == 1.0) {
	  attack_value = 3;
	  defense_value = 3;
	}
	else if (val < 1.0) {
	  attack_value = 2;
	  defense_value = 3;
	}
	else {
	  attack_value = 3;
	  defense_value = 2;
	}

	for (r = 0; r < 4; r++) {
	  if (attack_values[r] < attack_value) {
	    int tmp_value = attack_values[r];
	    int tmp_point = heye[pos].attack_point[r];
	    attack_values[r] = attack_value;
	    heye[pos].attack_point[r] = attack_point;
	    attack_value = tmp_value;
	    attack_point = tmp_point;
	  }
	
	  if (defense_values[r] < defense_value) {
	    int tmp_value = defense_values[r];
	    int tmp_point = heye[pos].defense_point[r];
	    defense_values[r] = defense_value;
	    heye[pos].defense_point[r] = defense_point;
	    defense_value = tmp_value;
	    defense_point = tmp_point;
	  }
	}
	
	num_attacks++;
	num_defenses++;
      }
    }
  }

  heye[pos].num_attacks = num_attacks;
  heye[pos].num_defends = num_defenses;
  heye[pos].value = sum;
  
  return sum;
}



/* Evaluate an intersection (m, n) which is diagonal to an eye space,
 * as described in the Texinfo documentation (Eyes/Eye Topology).
 *
 * Returns:
 *
 * 0 if both coordinates are off the board
 * 1 if one coordinate is off the board
 *
 * 0    if (color) has control over the vertex
 * a    if (color) can take control over the vertex unconditionally and
 *      the opponent can take control by winning a ko.
 * 1    if both (color) and the opponent can take control of the vertex
 *      unconditionally
 * b    if (color) can take control over the vertex by winning a ko and
 *      the opponent can take control unconditionally.
 * 2    if the opponent has control over the vertex
 *
 * The values a and b are discussed in the documentation. We are
 * currently using a = 0.75 and b = 1.25.
 *
 * Notice that it's necessary to pass the coordinates separately
 * instead of as a 1D coordinate. The reason is that the 1D mapping
 * can't uniquely identify "off the corner" points.
 */
static float
evaluate_diagonal_intersection(int m, int n, int color,
			       int *attack_point, int *defense_point,
			       struct eye_data b_eye[BOARDMAX],
			       struct eye_data w_eye[BOARDMAX])
{
  float value = 0;
  int other = OTHER_COLOR(color);
  int pos = POS(m, n);
  int acode = 0;
  int apos = NO_MOVE;
  int dcode = 0;
  int dpos = NO_MOVE;
  int off_edge = 0;
  const float a = 0.75;
  const float b = 2 - a;

  *attack_point = NO_MOVE;
  *defense_point = NO_MOVE;
  
  /* Check whether intersection is off the board. We must do this for
   * each board coordinate separately because points "off the corner"
   * are special cases.
   */
  if (m < 0 || m >= board_size)
    off_edge++;

  if (n < 0 || n >= board_size)
    off_edge++;

  /* Must return 0 if both coordinates out of bounds. */
  if (off_edge > 0)
    return (float) (off_edge % 2);

  /* Discard points within own eyespace, unless marginal or ko point.
   *
   * Comment: For some time discardment of points within own eyespace
   * was contingent on this being the same eyespace as that of the
   * examined vertex. This caused problems, e.g. in this position,
   *
   * |........
   * |XXXXX...
   * |OOOOX...
   * |aO.OX...
   * |OXXOX...
   * |.XXOX...
   * +--------
   *
   * where the empty vertex at a was evaluated as a false eye and the
   * whole group as dead (instead of living in seki).
   *
   * The reason for the requirement of less than two marginal
   * neighbors is this position:
   *
   * |.XXXX...
   * |.OOOX...
   * |O..OX...
   * |aOO.X...
   * |O..XX...
   * |..O.X...
   * |.X..X...
   * |..XXX...
   *
   * where the empty vertex at a should not count as a solid eye.
   * (The eyespace diagonally below a looks like this:
   *   .!
   *   !
   * so we can clearly see why having two marginal vertices makes a
   * difference.)
   */
  if (color == BLACK
      && b_eye[pos].color == BLACK_BORDER
      && !b_eye[pos].marginal
      && b_eye[pos].marginal_neighbors < 2
      && !(board[pos] == EMPTY && does_capture_something(pos, WHITE)))
    return 0.0;
  if (color == WHITE
      && w_eye[pos].color == WHITE_BORDER
      && !w_eye[pos].marginal
      && w_eye[pos].marginal_neighbors < 2
      && !(board[pos] == EMPTY && does_capture_something(pos, BLACK)))
    return 0.0;

  if (board[pos] == EMPTY) {
    /* We should normally have a safe move, but occasionally it may
     * happen that it's not safe. There are complications, however,
     * with a position like this
     *
     * .XXXX|
     * XXOO.|
     * XO.O.|
     * XXO.O|
     * -----+
     *
     */

    int our_safety = safe_move(pos, color);
    int your_safety = safe_move(pos, other);
    
    if (your_safety == 0)
      value = 0.0;
    else if (our_safety == 0 && your_safety == WIN)
      value = 2.0;
    else if (our_safety == WIN && your_safety == WIN)
      value = 1.0;
    else if (our_safety == WIN && your_safety != WIN)
      value = a;
    else if (our_safety != WIN && your_safety == WIN)
      value = b;
    else
      value = 1.0; /* Both contingent on ko. Probably can't happen. */

    apos = pos;
    dpos = pos;
  }
  else if (board[pos] == color) {
    /* This stone had better be safe, otherwise we wouldn't have an
     * eyespace in the first place.
     */
    value = 0.0;
  }
  else if (board[pos] == other) {
    if (stackp == 0) {
      acode = worm[pos].attack_codes[0];
      apos  = worm[pos].attack_points[0];
      dcode = worm[pos].defend_codes[0];
      dpos  = worm[pos].defense_points[0];
    }
    else
      attack_and_defend(pos, &acode, &apos, &dcode, &dpos);

    /* Must test acode first since dcode only is reliable if acode is
     * non-zero.
     */
    if (acode == 0)
      value = 2.0;
    else if (dcode == 0)
      value = 0.0;
    else if (acode == WIN && dcode == WIN)
      value = 1.0;
    else if (acode == WIN && dcode != WIN)
      value = a;
    else if (acode != WIN && dcode == WIN)
      value = b;
    else if (acode != WIN && dcode != WIN)
      value = 1.0; /* Both contingent on ko. Probably can't happen. */
  }
  
  if (value > 0.0 && value < 2.0) {
    /* FIXME:
     * Usually there are several attack and defense moves that would
     * be equally valid. It's not good that we make an arbitrary
     * choice at this point.
     */
    ASSERT_ON_BOARD1(apos);
    ASSERT_ON_BOARD1(dpos);
    /* Notice:
     * The point to ATTACK the half eye is the point which DEFENDS
     * the stones on the diagonal intersection and vice versa. Thus
     * we must switch attack and defense points here.
     * If the vertex is empty, dpos == apos and it doesn't matter
     * whether we switch.
     */
    *attack_point = dpos;
    *defense_point = apos;
  }

  return value;
}


/* Test whether the optics code evaluates an eyeshape consistently. */
void
test_eyeshape(int eyesize, int *eye_vertices)
{
  int k;
  int n, N;
  int mx[BOARDMAX];
  int pos;
  int str = NO_MOVE;
  int attack_code;
  int attack_point;
  int defense_code;
  int defense_point;
  int save_verbose;
  struct board_state starting_position;

  /* Clear the board and initialize the engine properly. */
  clear_board();
  reset_engine();

  /* Mark the eyespace in the mx array. */
  memset(mx, 0, sizeof(mx));
  for (k = 0; k < eyesize; k++) {
    ASSERT_ON_BOARD1(eye_vertices[k]);
    mx[eye_vertices[k]] = 1;
  }

  /* Play white stones surrounding the eyespace, including diagonals. */
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (!ON_BOARD(pos) || mx[pos] == 1)
      continue;
    for (k = 0; k < 8; k++) {
      if (ON_BOARD(pos + delta[k]) && mx[pos + delta[k]] == 1) {
	play_move(pos, WHITE);
	str = pos;
	break;
      }
    }
  }

  /* Play black stones surrounding the white group, but leaving all
   * liberties empty.
   */
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (mx[pos] == 1 || board[pos] != EMPTY || liberty_of_string(pos, str))
      continue;
    for (k = 0; k < 8; k++) {
      if (ON_BOARD(pos + delta[k])
	  && liberty_of_string(pos + delta[k], str)) {
	play_move(pos, BLACK);
	break;
      }
    }
  }

  /* Show the board if verbose is on. Then turn off traces so we don't
   * get any from make_worms(), make_dragons(), or the owl reading.
   */
  if (verbose)
    showboard(0);
  save_verbose = verbose;
  verbose = 0;
  
  
  /* Store this position so we can come back to it. */
  store_board(&starting_position);

  /* Loop over all configurations of black stones inserted in the
   * eyeshape. There are N = 2^(eyesize) configurations and we can
   * straightforwardly use binary representation to enumerate them.
   */
  N = 1 << eyesize;
  for (n = 0; n < N; n++) {
    int valid = 1;
    int internal_stones = 0;
    
    restore_board(&starting_position);
    /* Play the stones for this configuration. */
    for (k = 0; k < eyesize; k++) {
      if (n & (1 << k)) {
	if (!is_legal(eye_vertices[k], BLACK)) {
	  valid = 0;
	  break;
	}
	play_move(eye_vertices[k], BLACK);
	internal_stones++;
      }
    }

    if (!valid)
      continue;

    if (save_verbose > 1)
      showboard(0);

    /* Now we are ready to test the consistency. This is most easily
     * done with help from the owl code. First we must prepare for
     * this though.
     */
    examine_position(WHITE, EXAMINE_DRAGONS_WITHOUT_OWL);

    attack_code = owl_attack(str, &attack_point, NULL);

    if (attack_code == 0) {
      /* The owl code claims there is no attack. We test this by
       * trying to attack on all empty spaces in the eyeshape.
       */
      for (k = 0; k < eyesize; k++) {
	if (board[eye_vertices[k]] == EMPTY
	    && is_legal(eye_vertices[k], BLACK)
	    && owl_does_attack(eye_vertices[k], str)) {
	  gprintf("%1m alive, but %1m attacks:\n",
		  str, eye_vertices[k]);
	  showboard(0);
	  gprintf("\n");
	}
      }

      /* Furthermore, if the eyespace is almost filled, white should
       * be able to play on the remaining eyespace point and still be
       * alive.
       */
      if (internal_stones == eyesize - 1) {
	for (k = 0; k < eyesize; k++) {
	  if (board[eye_vertices[k]] == EMPTY
	      && !owl_does_defend(eye_vertices[k], str)) {
	    gprintf("%1m alive, but almost filled with nakade:\n",
		    str);
	    showboard(0);
	  }
	}
      }
    }
    else {
      defense_code = owl_defend(str, &defense_point, NULL);
      if (defense_code == 0) {
	/* The owl code claims there is no defense. We test this by
	 * trying to defend on all empty spaces in the eyeshape.
	 */
	for (k = 0; k < eyesize; k++) {
	  if (board[eye_vertices[k]] == EMPTY
	      && is_legal(eye_vertices[k], WHITE)
	      && owl_does_defend(eye_vertices[k], str)) {
	    gprintf("%1m dead, but %1m defends:\n",
		    str, eye_vertices[k]);
	    showboard(0);
	    gprintf("\n");
	  }
	}
      }
      else {
	/* The owl code claims the dragon is critical. Verify the
         * attack and defense points.
	 */
	if (board[attack_point] != EMPTY
		 || !is_legal(attack_point, BLACK)) {
	  gprintf("Bad attack point %1m:\n", attack_point);
	  showboard(0);
	}
	else if (!owl_does_attack(attack_point, str)) {
	  gprintf("Attack point %1m failed:\n", attack_point);
	  showboard(0);
	}

	if (board[defense_point] != EMPTY
		 || !is_legal(defense_point, WHITE)) {
	  gprintf("Bad defense point %1m:\n", defense_point);
	  showboard(0);
	}
	else if (!owl_does_defend(defense_point, str)) {
	  gprintf("Defense point %1m failed:\n", defense_point);
	  showboard(0);
	}
      }
    }
  }
  verbose = save_verbose;
}


/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */


/* owl.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*
 * The code in this file implements "Optics With Limit-negotiation (OWL)."
 *
 * The life and death code in optics.c, works reasonably well as long as the
 * position is in a *terminal position*, which we define to be one where there
 * are no moves left which can expand the eye space, or limit it. In
 * situations where the dragon is surrounded, yet has room to thrash around a
 * bit making eyes, a simple application of the graph-based analysis will not
 * work. Instead, a bit of reading is needed to reach a terminal position.
 * The defender tries to expand his eyespace, the attacker to limit it, and
 * when neither finds an effective move, the position is evaluated. We call
 * this type of life and death reading *Optics With Limit-negotiation* (OWL).
 *
 *                             (|__|)
 *                            (@)(@))
 *                            |:v:: |
 *                           (       )
 *                            \|   |/
 *                            =#===#=
 *                            /___/
 * 
 *                The owl is noted for its keen vision 
 *                       and (purported) wisdom.
 */

/* #include <stdio.h> */
/* #include <stdlib.h> */
/* #include <string.h> */
/* #include <time.h> */

/* #include "sgftree.h" */
/* #include "gnugo.h" */
/* #include "liberty.h" */
/* #include "gg_utils.h" */

/* #include "patterns.h" */
/* #include "cache.h" */


#define MAX_MOVES 3           /* maximum number of branches at each node */
#define MAX_SEMEAI_MOVES 2    /* semeai branch factor--must be <= MAX_MOVES */
#define MAX_SEMEAI_DEPTH 100  /* Don't read below this depth */

/* emgena */
#undef MAX_LUNCHES
#undef MAX_WORMS
/* emgena */
#define MAX_LUNCHES 10
#define MAX_WORMS 10          /* maximum number of worms in a dragon to be cataloged */

/* If set, pattern constraint are only checked if the pattern might produce
 * a candidate move.
 */
#define PATTERN_CHECK_ON_DEMAND 1

/* #include <stdio.h> */
/* #include <stdlib.h> */
/* #include <string.h> */
/* #include <time.h> */

/* #include "liberty.h" */
/* #include "patterns.h" */
/* #include "cache.h" */
/* #include "sgftree.h" */
/* #include "gg_utils.h" */

struct local_owl_data {
  char goal[BOARDMAX];
  char boundary[BOARDMAX];
  int escape_values[BOARDMAX];
  int color;

  struct eye_data black_eye[BOARDMAX];
  struct eye_data white_eye[BOARDMAX];
  /* array of half-eye data for use during owl reading */
  struct half_eye_data half_eye[BOARDMAX];
  
  int lunch[MAX_LUNCHES];
  int lunch_attack_code[MAX_LUNCHES];
  int lunch_attack_point[MAX_LUNCHES];
  int lunch_defend_code[MAX_LUNCHES];
  int lunch_defense_point[MAX_LUNCHES];
  int inessential[BOARDMAX];
  
  int lunches_are_current; /* If true, owl lunch data is current */  

  /* Node limitation. */
  int local_owl_node_counter;

  char safe_move_cache[BOARDMAX];
};

static int result_certain;

/* Statistics. */
static int global_owl_node_counter = 0;

static struct local_owl_data *current_owl_data;
static struct local_owl_data *other_owl_data;

struct owl_move_data {
  int pos;          /* move coordinate */
  int value;        /* value */
  const char *name; /* name of the pattern suggesting the move */
  int same_dragon;  /* whether the move extends the dragon or not */
};

#if PATTERN_CHECK_ON_DEMAND
struct matched_pattern_data {
  int move;
  int ll;
  struct pattern *pattern;
};
  
struct matched_patterns_list_data {
  int initialized;
  int counter; 		/* Number of patterns in the list. */
  int used;		/* How many patterns have already been used?*/
  int ordered_up_to;	/* How far the list has been ordered. */
  int list_size;	
  struct matched_pattern_data *pattern_list;
};

void dump_pattern_list(struct matched_patterns_list_data *list);

#endif

/* Persistent owl result cache to reuse owl results between moves. */
struct owl_cache {
  int boardsize;
  char board[BOARDMAX];
  int movenum;
  int tactical_nodes;
  int routine;
  int apos;  /* first input coordinate */
  int bpos;  /* second input coordinate */
  int cpos;  /* third input coordinate */
  int result;
  int result_certain;
  int move;  /* first result coordinate */
  int move2;  /* second result coordinate */
};

#define MAX_OWL_CACHE_SIZE 150
static struct owl_cache persistent_owl_cache[MAX_OWL_CACHE_SIZE];
static int persistent_owl_cache_size = 0;

#define OWL_THREATEN_ATTACK    0
#define OWL_THREATEN_DEFENSE   1
#define OWL_DOES_DEFEND        2
#define OWL_DOES_ATTACK        3
#define OWL_CONNECTION_DEFENDS 4
#define OWL_SUBSTANTIAL        5
#define OWL_CONFIRM_SAFETY     6
/* The following two are defined in cache.h */
/* #define OWL_ATTACK    8 */
/* #define OWL_DEFEND    9 */

static int verify_stored_board(char board[BOARDMAX]);
static int search_persistent_owl_cache(int routine, int apos,
				       int bpos, int cpos,
				       int *result, int *move,
				       int *move2, int *certain);
static void store_persistent_owl_cache(int routine, int apos,
				       int bpos, int cpos,
				       int result, int move,
				       int move2, int certain,
				       int tactical_nodes,
				       char goal[BOARDMAX],
				       int goal_color);
static void print_persistent_owl_cache_entry(int k);
static void mark_dragon_hotspot_values(float values[BOARDMAX], int pos,
				       float contribution,
				       char active_board[BOARDMAX]);


static int do_owl_attack(int str, int *move, 
			 struct local_owl_data *owl,
			 int komaster, int kom_pos);
static int do_owl_defend(int str, int *move,
			 struct local_owl_data *owl,
			 int komaster, int kom_pos);
#if PATTERN_CHECK_ON_DEMAND
static int owl_shapes(struct matched_patterns_list_data *list,
                      struct owl_move_data moves[MAX_MOVES], int color,
		      struct local_owl_data *owl, struct pattern_db *type);
static void collect_owl_shapes_callbacks(int m, int n, int color,
	  			         struct pattern *pattern_db,
				         int ll, void *data);
static int get_next_move_from_list(struct matched_patterns_list_data *list,
                                   int color, struct owl_move_data *moves,
				   int cutoff);
static void  init_pattern_list(struct matched_patterns_list_data *list);
static void close_pattern_list(struct matched_patterns_list_data *list);
#else
static int owl_shapes(struct owl_move_data moves[MAX_MOVES], int color,
		      struct local_owl_data *owl,
		      struct pattern_db *type);
#endif
static void owl_shapes_callback(int m, int n, int color,
				struct pattern *pattern_db,
				int ll, void *data);
static void owl_add_move(struct owl_move_data *moves, int move, int value,
			 const char *reason, int same_dragon);
static int owl_determine_life(struct local_owl_data *owl,
			      struct local_owl_data *second_owl,
			      struct eye_data eye[BOARDMAX],
			      int color, int komaster, int does_attack,
			      struct owl_move_data *moves, int *probable_min,
			      int *probable_max);
static int modify_stupid_eye_vital_point(int *vital_point);
static void owl_mark_dragon(int apos, int bpos,
			    struct local_owl_data *owl);
static void owl_mark_worm(int apos, int bpos,
			  struct local_owl_data *owl);
static void owl_mark_boundary(struct local_owl_data *owl);
static void owl_update_goal(int pos, int same_dragon,
			    struct local_owl_data *owl);
static void owl_update_boundary_marks(int pos, struct local_owl_data *owl);
static void owl_find_lunches(struct local_owl_data *owl);
static void owl_make_domains(struct local_owl_data *owla,
			     struct local_owl_data *owlb);
static int owl_safe_move(int move, int color);
static void sniff_lunch(int lunch, int *min, int *probable, int *max,
			struct local_owl_data *owl);
static void compute_owl_escape_values(struct local_owl_data *owl);
static int owl_escape_route(struct local_owl_data *owl);
static void do_owl_analyze_semeai(int apos, int bpos, 
		      struct local_owl_data *owla,
		      struct local_owl_data *owlb, int komaster,
		      int *resulta, int *resultb,
		      int *move, int pass);
static int semeai_move_value(int move, struct local_owl_data *owla,
			     struct local_owl_data *owlb,
			     int raw_value);
static int find_semeai_backfilling_move(int worm, int liberty);
static int liberty_of_goal(int pos, struct local_owl_data *owl);
static int matches_found;
static char found_matches[BOARDMAX];

static void reduced_init_owl(struct local_owl_data **owl);
static void init_owl(struct local_owl_data **owl, int target1, int target2,
		     int move, int use_stack);

static struct local_owl_data *owl_stack = NULL;
static int owl_stack_size = 0;
static int owl_stack_pointer = 0;
static void push_owl(struct local_owl_data **owl);
static void pop_owl(struct local_owl_data **owl);
static int catalog_goal(struct local_owl_data *owl, int goal_worm[MAX_WORMS]);


/* Called when (apos) and (bpos) point to adjacent dragons
 * of the opposite color, both with matcher_status DEAD or
 * CRITICAL, analyzes the semeai, assuming that the player
 * of the (apos) dragon moves first.
 *
 * owl_phase determines whether owl moves are being generated
 * or simple liberty filling is taking place.
 *
 * semeai_focus can be either owla, owlb or EMPTY. If it is an owl,
 * then owl attack and defense moves for that owl are given
 * priority.
 */
static int owl_phase;

void
owl_analyze_semeai(int apos, int bpos, int *resulta, int *resultb, int *move,
		   int owl)
{
  int semeai_focus;

  static struct local_owl_data owla;
  static struct local_owl_data owlb;
  
  gg_assert(board[apos] == OTHER_COLOR(board[bpos]));
  owl_phase = owl;
  count_variations = 1;
  TRACE("owl_analyze_semeai: %1m vs. %1m\n", apos, bpos);
  if (owl) {
    struct local_owl_data *owla_ptr = &owla;
    struct local_owl_data *owlb_ptr = &owlb;
    init_owl(&owla_ptr, apos, NO_MOVE, NO_MOVE, 0);
    init_owl(&owlb_ptr, bpos, NO_MOVE, NO_MOVE, 0);
    owl_make_domains(&owla, &owlb);
  }
  else {
    owla.local_owl_node_counter	= 0;
    owlb.local_owl_node_counter	= 0;
    owl_mark_worm(apos, NO_MOVE, &owla);
    owl_mark_worm(bpos, NO_MOVE, &owlb);
  }
  if (stackp > 0)
    semeai_focus = NO_MOVE;
  else if (dragon[bpos].matcher_status == CRITICAL)
    semeai_focus = bpos;
  else if (dragon[apos].matcher_status == CRITICAL)
    semeai_focus = apos;
  else
    semeai_focus = NO_MOVE;
  
  do_owl_analyze_semeai(apos, bpos, &owla, &owlb, EMPTY,
			resulta, resultb, move, 0);
}

/* It is assumed that the 'a' player moves first, and
 * determines the best result for both players. The
 * parameter "pass" is 1 if the opponent's last move is
 * pass. In this case, if no move is found but the genus
 * is less than 2, then the position is declared seki.
 *
 * If a move is needed to get this result, then (*move) is
 * the location, otherwise this field returns PASS.
 *
 * semeai_focus can be either owla, owlb or EMPTY. If it is an owl,
 * then owl attack and defense moves for that owl are given
 * priority.
 */

static void
do_owl_analyze_semeai(int apos, int bpos, 
		      struct local_owl_data *owla,
		      struct local_owl_data *owlb, int komaster,
		      int *resulta, int *resultb,
		      int *move, int pass)
{
  int color = board[apos];
  int other = OTHER_COLOR(color);
  int wormsa, wormsb;
  int goal_wormsa[MAX_WORMS], goal_wormsb[MAX_WORMS];
  struct owl_move_data vital_defensive_moves[MAX_MOVES];
  struct owl_move_data vital_offensive_moves[MAX_MOVES];
  struct owl_move_data shape_defensive_moves[MAX_MOVES];
  struct owl_move_data shape_offensive_moves[MAX_MOVES];
#if PATTERN_CHECK_ON_DEMAND
  struct matched_patterns_list_data shape_offensive_patterns;
  struct matched_patterns_list_data shape_defensive_patterns;
#endif
  struct owl_move_data moves[2*MAX_SEMEAI_MOVES+2];
  struct owl_move_data outside_liberty;
  struct owl_move_data common_liberty;
  struct owl_move_data backfilling_move;
  char saved_goal[BOARDMAX];
  int safe_outside_liberty_found = 0;
  int unsafe_outside_liberty_found = 0;
  int safe_common_liberty_found = 0;
  int unsafe_common_liberty_found = 0;
  int backfilling_move_found = 0;
  char mw[BOARDMAX];  
  int k;
  int m, n;
  int same_dragon;
  int save_owl_phase = owl_phase;
  SGFTree *save_sgf_dumptree = sgf_dumptree;
  int save_count_variations = count_variations;
  int move_value;
  int best_resulta = UNKNOWN;
  int best_resultb = UNKNOWN;
  int best_move = 0;
  int this_resulta = UNKNOWN;
  int this_resultb = UNKNOWN;
  int best_move_k = -1;
  int found_read_result;
  Read_result *read_result;
  int this_variation_number = count_variations - 1;
  
  SETUP_TRACE_INFO2("do_owl_analyze_semeai", apos, bpos);

#if PATTERN_CHECK_ON_DEMAND
  shape_offensive_patterns.initialized = 0;
  shape_defensive_patterns.initialized = 0;
#endif
  
  global_owl_node_counter++;
  owla->local_owl_node_counter++;

  if ((stackp <= owl_branch_depth) && (hashflags & HASH_SEMEAI)
      && (!pass) && owl_phase) {
    found_read_result = get_read_result2(SEMEAI, EMPTY, 0,
					&apos, &bpos, &read_result);
    if (found_read_result) {
      TRACE_CACHED_RESULT2(*read_result);
      if (rr_get_result1(*read_result) != 0) {
	if (move)
	  *move = rr_get_move(*read_result);
      }
      if (rr_get_result1(*read_result) == ALIVE)
	TRACE("%oVariation %d: %1m ALIVE (cached)\n", 
	      this_variation_number, apos);
      else
	if (rr_get_result1(*read_result) == DEAD)
	  TRACE("%oVariation %d: %1m DEAD (cached)\n", 
		this_variation_number, apos);
      else
	if (rr_get_result1(*read_result) == ALIVE_IN_SEKI)
	  TRACE("%oVariation %d: %1m ALIVE_IN_SEKI (cached)\n",
		this_variation_number, apos);
      if (rr_get_result2(*read_result) == ALIVE)
	TRACE("%oVariation %d: %1m ALIVE (cached)\n", 
	      this_variation_number, bpos);
      else
	if (rr_get_result2(*read_result) == DEAD)
	  TRACE("%oVariation %d: %1m DEAD (cached)\n", 
		this_variation_number, bpos);
      else
	if (rr_get_result2(*read_result) == ALIVE_IN_SEKI)
	  TRACE("%oVariation %d: %1m ALIVE_IN_SEKI (cached)\n",
		this_variation_number, bpos);

      SGFTRACE2(rr_get_move(*read_result), 
		rr_get_result1(*read_result),
	       "cached");
      *resulta = rr_get_result1(*read_result);
      *resultb = rr_get_result2(*read_result);
      return;
    }
  }
  else
    read_result = NULL;

  wormsa = catalog_goal(owla, goal_wormsa);
  wormsb = catalog_goal(owlb, goal_wormsb);
  
  outside_liberty.pos = 0;
  common_liberty.pos = 0;
  backfilling_move.pos = 0;
  /* turn off the sgf file and variation counting */
  sgf_dumptree = NULL;
  count_variations = 0;
  for (k = 0; k < 2*MAX_SEMEAI_MOVES+2; k++) {
    moves[k].pos = 0;
    moves[k].value = -1;
    moves[k].name = NULL;
    moves[k].same_dragon = 2;
  }
  gg_assert(other == board[bpos]);
  memset(mw, 0, sizeof(mw));
  /* 
   * We generate the candidate moves. During the early stages of
   * the semeai, there may be moves to expand or shrink the
   * eyespaces of the two dragons. During the later stages, the
   * picture is simplified and reading the semeai is a matter 
   * of filling liberties until one of the dragons may be removed,
   * or a seki results. The first stage we call the owl phase.
   */
  if (owl_phase) {
    /* First the vital moves. These include moves to attack or
     * defend the eyespace (e.g. nakade, or hane to reduce the
     * number of eyes) or moves to capture a lunch. 
     */
    int probable_mina, probable_maxa, probable_minb, probable_maxb;
    
    /* We do not wish for any string of the 'b' dragon to be 
     * counted as a lunch of the 'a' dragon since owl_determine_life 
     * can give a wrong result in the case of a semeai. So we eliminate 
     * such lunches.
     */
    
    owl_find_lunches(owla);
    owl_find_lunches(owlb);
    for (k = 0; k < MAX_LUNCHES; k++) {
      if (owla->lunch[k] != NO_MOVE 
	  && owlb->goal[owla->lunch[k]]) {
	owla->lunch[k] = NO_MOVE;
      }
    }
#if 0
    for (k = 0; k < MAX_LUNCHES; k++) {
      if (owlb->lunch[k] != NO_MOVE 
	  && owla->goal[owlb->lunch[k]]) {
	owlb->lunch[k] = NO_MOVE;
      }
    }
#endif
    if (color == BLACK)
      owl_determine_life(owla, owlb, owla->black_eye,
			 BLACK, komaster, 1, 
			 vital_defensive_moves,
			 &probable_mina, &probable_maxa);
    else
      owl_determine_life(owla, owlb, owla->white_eye,
			 WHITE, komaster, 1, 
			 vital_defensive_moves,
			 &probable_mina, &probable_maxa);
    if (other == BLACK)
      owl_determine_life(owlb, owla, owlb->black_eye,
			 BLACK, komaster, 1,
			 vital_offensive_moves,
			 &probable_minb, &probable_maxb);
    else
      owl_determine_life(owlb, owla, owlb->white_eye,
			 WHITE, komaster, 1, 
			 vital_offensive_moves,
			 &probable_minb, &probable_maxb);
    
    /* Certain cases can be handled immediately. */
    /* I live, you die, no move needed. */
    if ((probable_mina >= 2) && (probable_maxb < 2)) {
      *resulta = ALIVE;
      *resultb = DEAD;
      if (move)
	*move = PASS_MOVE;
      sgf_dumptree = save_sgf_dumptree;
      count_variations =   save_count_variations;
      if (probable_maxb == 0) {
	SGFTRACE2(PASS_MOVE, ALIVE, "Two eyes versus none");
      }
      else
	SGFTRACE2(PASS_MOVE, ALIVE, "Two eyes versus one");
      READ_RETURN_SEMEAI(read_result, move, PASS_MOVE, ALIVE, DEAD);
    }
    /* I am alive */
    if (probable_mina >= 2
	|| (stackp > 2 && owl_escape_route(owla) >= 5)) {
      if (probable_maxb < 2) {
	/* you are already dead */
	*resulta = ALIVE;
	*resultb = DEAD;
	if (move) *move = PASS_MOVE;
	sgf_dumptree = save_sgf_dumptree;
	count_variations = save_count_variations;
	if (probable_maxb == 0) {
	  SGFTRACE2(PASS_MOVE, ALIVE, "Two eyes or escape versus none");
	}
	else
	  SGFTRACE2(PASS_MOVE, ALIVE, "Two eyes or escape versus one");
	READ_RETURN_SEMEAI(read_result, move, PASS_MOVE, ALIVE, DEAD);
      }
      else if (probable_minb < 2) {
	/* I can kill */
	gg_assert(vital_offensive_moves[0].pos != NO_MOVE);
	*resulta = ALIVE;
	*resultb = DEAD;
	if (move)
	  *move = vital_offensive_moves[0].pos;
	sgf_dumptree = save_sgf_dumptree;
	count_variations = save_count_variations;
	if (probable_minb == 0) {
	  SGFTRACE2(vital_offensive_moves[0].pos,
		    ALIVE, "Two eyes or escape versus none");
	}
	else
	  SGFTRACE2(vital_offensive_moves[0].pos, 
		    ALIVE, "Two eyes or escape versus one");
	READ_RETURN_SEMEAI(read_result, move, vital_offensive_moves[0].pos,
			   ALIVE, DEAD);
      }
      else {
	/* both live */
	*resulta = ALIVE;
	*resultb = ALIVE;
	if (move) *move = PASS_MOVE;
	sgf_dumptree = save_sgf_dumptree;
	count_variations = save_count_variations;
	SGFTRACE2(PASS_MOVE, ALIVE, "Both live");
	READ_RETURN_SEMEAI(read_result, move, PASS_MOVE, ALIVE, ALIVE);
      }
    }
    if ((probable_minb >= 2) || owl_escape_route(owlb) >= 5) {
      /* you are alive */
      if (probable_maxa < 2) {
	/* I am dead */
	*resulta = DEAD;
	*resultb = ALIVE;
	if (move) *move = PASS_MOVE;
	sgf_dumptree = save_sgf_dumptree;
	count_variations = save_count_variations;
	SGFTRACE2(PASS_MOVE, DEAD, "You live, I die");
	READ_RETURN_SEMEAI(read_result, move, PASS_MOVE, DEAD, ALIVE);
      }
      else if (probable_mina < 2) {
	/* I can live */
	gg_assert(vital_defensive_moves[0].pos != NO_MOVE);
	*resulta = ALIVE;
	*resultb = ALIVE;
	if (move) *move = vital_defensive_moves[0].pos;
	sgf_dumptree = save_sgf_dumptree;
	count_variations = save_count_variations;
	SGFTRACE2(vital_defensive_moves[0].pos, ALIVE,
		  "Both live");
	READ_RETURN_SEMEAI(read_result, move, vital_defensive_moves[0].pos,
			   ALIVE, ALIVE);
      }
      else {
	/* I am already alive */
	*resulta = ALIVE;
	*resultb = ALIVE;
	if (move) *move = PASS_MOVE;
	sgf_dumptree = save_sgf_dumptree;
	count_variations = save_count_variations;
	SGFTRACE2(PASS_MOVE, ALIVE, "Both live");
	READ_RETURN_SEMEAI(read_result, move, PASS_MOVE, ALIVE, ALIVE);
      }
    }
    
    /* Next the shape moves. */
#if PATTERN_CHECK_ON_DEMAND
    owl_shapes(&shape_defensive_patterns, shape_defensive_moves, color, owla, 
	       &owl_defendpat_db);
    for (k = 0; k < MAX_SEMEAI_MOVES; k++)
      if (!get_next_move_from_list(&shape_defensive_patterns, color,
	                           shape_defensive_moves, 1))
	break;
    owl_shapes(&shape_offensive_patterns, shape_offensive_moves, color, owlb, 
	       &owl_attackpat_db);
    for (k = 0; k < MAX_SEMEAI_MOVES; k++)
      if (!get_next_move_from_list(&shape_offensive_patterns, color,
	                           shape_offensive_moves, 1))
	break;
#else
    /* FIXME: We generate more moves than we use if
     * MAX_SEMEAI_MOVE < MAX_MOVES.  
     */
    owl_shapes(shape_defensive_moves, color, owla, 
	       &owl_defendpat_db);
    owl_shapes(shape_offensive_moves, color, owlb, 
	       &owl_attackpat_db);
#endif
    
    /* Now we review the moves already considered, while collecting
     * them into a single list. If no owl moves are found, we end the owl
     * phase. If no owl move of value > 30 is found, we want to be sure that we
     * have included a move that fills a liberty. If no such move is found, we
     * will have to add it later.
     */
    
    for (k = 0; 
	 k < MAX_SEMEAI_MOVES && vital_defensive_moves[k].pos != NO_MOVE;
	 k++) {
      if (liberty_of_goal(vital_defensive_moves[k].pos, owlb)) {
	if (!liberty_of_goal(vital_defensive_moves[k].pos, owla)) {
	  if (safe_move(vital_defensive_moves[k].pos, color))
	    safe_outside_liberty_found = 1;
	  else
	    unsafe_outside_liberty_found = 1;
	}
	else {
	  if (safe_move(vital_defensive_moves[k].pos, color))
	    safe_common_liberty_found = 1;
	  else
	    unsafe_common_liberty_found = 1;
	}
      }
      mw[vital_defensive_moves[k].pos] = 1;
      move_value = semeai_move_value(vital_defensive_moves[k].pos,
				     owla, owlb,
				     vital_defensive_moves[k].value);
      owl_add_move(moves, vital_defensive_moves[k].pos,
		   move_value, "vital defensive move", 
		   vital_defensive_moves[k].same_dragon);
    }
    for (k = 0; 
	 k < MAX_SEMEAI_MOVES && vital_offensive_moves[k].pos != NO_MOVE;
	 k++) {
      if (liberty_of_goal(vital_offensive_moves[k].pos, owlb)) {
	if (!liberty_of_goal(vital_offensive_moves[k].pos, owla)) {
	  if (safe_move(vital_offensive_moves[k].pos, color))
	    safe_outside_liberty_found = 1;
	  else
	    unsafe_outside_liberty_found = 1;
	}
	else {
	  if (safe_move(vital_offensive_moves[k].pos, color))
	    safe_common_liberty_found = 1;
	  else
	    unsafe_common_liberty_found = 1;
	}
      }
      mw[vital_offensive_moves[k].pos] = 1;
      if (liberty_of_goal(vital_offensive_moves[k].pos, owla))
	same_dragon = 2;
      else
	same_dragon = 0;
      move_value = semeai_move_value(vital_offensive_moves[k].pos,
				     owla, owlb,
				     vital_offensive_moves[k].value);
      owl_add_move(moves, vital_offensive_moves[k].pos,
		      move_value, vital_offensive_moves[k].name, same_dragon);
    }
    for (k = 0; 
	 k < MAX_SEMEAI_MOVES && shape_defensive_moves[k].pos != NO_MOVE;
	 k++) {
      if (liberty_of_goal(shape_defensive_moves[k].pos, owlb)) {
	if (!liberty_of_goal(shape_defensive_moves[k].pos, owla)) {
	  if (safe_move(shape_defensive_moves[k].pos, color))
	    safe_outside_liberty_found = 1;
	  else
	    unsafe_outside_liberty_found = 1;
	}
	else {
	  if (safe_move(shape_defensive_moves[k].pos, color))
	    safe_common_liberty_found = 1;
	  else
	    unsafe_common_liberty_found = 1;
	}
      }
      mw[shape_defensive_moves[k].pos] = 1;
      move_value = semeai_move_value(shape_defensive_moves[k].pos,
				     owla, owlb,
				     shape_defensive_moves[k].value);
      owl_add_move(moves, shape_defensive_moves[k].pos,
		      move_value,
		      shape_defensive_moves[k].name,
		      shape_defensive_moves[k].same_dragon);
    }
    for (k = 0; 
	 k < MAX_SEMEAI_MOVES && shape_offensive_moves[k].pos != NO_MOVE;
	 k++) {
      if (liberty_of_goal(shape_offensive_moves[k].pos, owlb)) {
	if (!liberty_of_goal(shape_offensive_moves[k].pos, owla)) {
	  if (safe_move(shape_offensive_moves[k].pos, color))
	    safe_outside_liberty_found = 1;
	  else
	    unsafe_outside_liberty_found = 1;
	}
	else {
	  if (safe_move(shape_offensive_moves[k].pos, color))
	    safe_common_liberty_found = 1;
	  else
	    unsafe_common_liberty_found = 1;
	}
      }
      mw[shape_offensive_moves[k].pos] = 1;
      if (liberty_of_goal(shape_offensive_moves[k].pos, owla))
	same_dragon = 2;
      else
	same_dragon = 0;
      move_value = semeai_move_value(shape_offensive_moves[k].pos,
				     owla, owlb,
				     shape_offensive_moves[k].value);
      owl_add_move(moves, shape_offensive_moves[k].pos,
		      move_value,
		      shape_offensive_moves[k].name,
		      same_dragon);
    }
    /* If no owl moves were found, turn off the owl phase */
    if (moves[0].pos == 0)
      owl_phase = 0;
  }
  /* now we look for a move to fill a liberty.
   */

  if (!safe_outside_liberty_found && moves[0].value < 100) {
    for (m = 0; !safe_outside_liberty_found && m < board_size; m++)
      for (n = 0; !safe_outside_liberty_found && n < board_size; n++) {
	int pos = POS(m, n);
	if (board[pos] == EMPTY && !mw[pos]) {
	  if (liberty_of_goal(pos, owlb)) {
	    if (!liberty_of_goal(pos, owla)) {
	      /* outside liberty */
	      if (safe_move(pos, color)) {
		safe_outside_liberty_found = 1;
		outside_liberty.pos = pos;
	      }
	      else if (!safe_outside_liberty_found) {
		if (!backfilling_move_found) {
		  backfilling_move.pos =
		    find_semeai_backfilling_move(bpos, pos);
		  if (backfilling_move.pos)
		    backfilling_move_found = 1;
		}
	      }
	    }
	    else {
	      /* common liberty */
	      if (safe_move(pos, color)) {
		safe_common_liberty_found = 1;
		common_liberty.pos = pos;
	      }
	      else
		unsafe_common_liberty_found = 1;
	    }
	  }
	}
      }
  }
  /* Look for a tactical attack. We seek a worm of owlb which adjoins 
   * a worm of owla and which can be attacked. If such exists, we 
   * declare victory. We limit the search to strings with two or 
   * fewer liberties to avoid having to increase the depth parameters.
   */
  {
    int ma[BOARDMAX];
    int origin;
    int upos;
    
    memset(ma, 0, sizeof(ma));
    for (m = 0; m < board_size; m++)
      for (n = 0; n < board_size; n++) {
	int pos = POS(m, n);
	if (owlb->goal[pos] && board[pos] == other) {
	  origin = find_origin(pos);
	  if (!ma[origin]
	      && ((ON_BOARD(SOUTH(pos)) && owla->goal[SOUTH(pos)])
		  || (ON_BOARD(WEST(pos)) && owla->goal[WEST(pos)])
		  || (ON_BOARD(NORTH(pos)) && owla->goal[NORTH(pos)])
		  || (ON_BOARD(EAST(pos)) && owla->goal[EAST(pos)]))) {
	    if (countlib(origin) < 3 && attack(origin, &upos)) {
	      *resulta = ALIVE;
	      *resultb = DEAD;
	      if (move)
		*move = upos;
	      sgf_dumptree = save_sgf_dumptree;
	      count_variations = save_count_variations;
	      SGFTRACE2(upos, ALIVE, "tactical win found");
#if PATTERN_CHECK_ON_DEMAND
	      close_pattern_list(&shape_defensive_patterns);
	      close_pattern_list(&shape_offensive_patterns);
#endif
	      READ_RETURN_SEMEAI(read_result, move, upos, ALIVE, DEAD);
	    }
	    /* we mark the strings we've tried and failed to prevent 
	     * duplicate reading.
	     */
	    else
	      ma[origin] = 1;
	  }
	}
      }
  }
  
  if (safe_outside_liberty_found
      && outside_liberty.pos != NO_MOVE) {
    move_value = semeai_move_value(outside_liberty.pos,
				   owla, owlb, 50);
    owl_add_move(moves, outside_liberty.pos, move_value,
		 "safe outside liberty", 0);
  }
  else if (backfilling_move_found && backfilling_move.pos != NO_MOVE) {
    move_value = semeai_move_value(backfilling_move.pos,
				   owla, owlb, 50);
    owl_add_move(moves, backfilling_move.pos, move_value,
		 "backfilling move", 0);
  }
  else if (safe_common_liberty_found
	   && common_liberty.pos != NO_MOVE) {
    move_value = semeai_move_value(common_liberty.pos,
				   owla, owlb, 10);
    owl_add_move(moves, common_liberty.pos, move_value,
		 "safe common liberty", 1);
  }
  /* Now we are ready to try moves. Turn on the sgf output ... */
  sgf_dumptree = save_sgf_dumptree;
  count_variations = save_count_variations;
  memcpy(saved_goal, owla->goal, sizeof(saved_goal));
  for (k = 0; k < 2*MAX_SEMEAI_MOVES+2; k++) {
    int mpos = moves[k].pos;

    if (k > 2
	|| (stackp > 6 && k > 1)
	|| (stackp > 12 && k > 0))
      continue;

    if (mpos != NO_MOVE 
	&& count_variations < semeai_variations
	&& stackp < MAX_SEMEAI_DEPTH
	&& semeai_trymove(mpos, color, moves[k].name, apos, bpos,
			  owl_phase, moves[k].value)) {
      if (1)
	if (debug & DEBUG_SEMEAI)
	  dump_stack();
      if (board[bpos] == EMPTY) {
	this_resultb = DEAD;
	this_resulta = ALIVE;
      }
      else {
	if (moves[k].same_dragon)
	  mark_string(mpos, owla->goal, 1);
	owla->lunches_are_current = 0;
	owl_update_boundary_marks(mpos, owla);
	if (liberty_of_goal(mpos, owla))
	  owla->goal[mpos] = 1;
	do_owl_analyze_semeai(bpos, apos, owlb, owla, komaster,
			      &this_resultb, &this_resulta, NULL, 0);
      }
      
      if (this_resultb == DEAD && this_resulta == ALIVE) {
	memcpy(owla->goal, saved_goal, sizeof(saved_goal));
	popgo();
	owl_phase = save_owl_phase;
	*resulta = ALIVE;
	*resultb = DEAD;
	if (move) *move = mpos;
	SGFTRACE2(mpos, ALIVE, moves[k].name);
#if PATTERN_CHECK_ON_DEMAND
	close_pattern_list(&shape_defensive_patterns);
	close_pattern_list(&shape_offensive_patterns);
#endif
	READ_RETURN_SEMEAI(read_result, move, mpos, ALIVE, DEAD);
      }
      if (this_resulta == ALIVE_IN_SEKI
	  && this_resultb == ALIVE_IN_SEKI
	  && best_resulta != ALIVE) {
	best_resulta = ALIVE_IN_SEKI;
	best_resultb = ALIVE_IN_SEKI;
	best_move = mpos;
	best_move_k = k;
      }
      if (this_resulta == DEAD
	  && this_resultb == ALIVE
	  && best_resulta == UNKNOWN) {
	best_resulta = DEAD;
	best_resultb = ALIVE;
	best_move = mpos;
	best_move_k = k;
      }
      memcpy(owla->goal, saved_goal, sizeof(saved_goal));
      popgo();
      owl_phase = save_owl_phase;
    }
  }

#if PATTERN_CHECK_ON_DEMAND
  close_pattern_list(&shape_defensive_patterns);
  close_pattern_list(&shape_offensive_patterns);
#endif
  /* If we can't find a move and opponent passed, it's seki */
  if (best_resulta == UNKNOWN && pass == 1) {
    *resulta = ALIVE_IN_SEKI;
    *resultb = ALIVE_IN_SEKI;
    if (move) *move = PASS_MOVE;
    SGFTRACE2(PASS_MOVE, ALIVE_IN_SEKI, "Seki");
    READ_RETURN_SEMEAI(read_result, move, PASS_MOVE, 
		       ALIVE_IN_SEKI, ALIVE_IN_SEKI);
  }
  /* If no move was found, then pass */
  if (best_resulta == UNKNOWN) {
    do_owl_analyze_semeai(bpos, apos, owlb, owla, komaster,
			  resultb, resulta, NULL, 1);
    SGFTRACE2(PASS_MOVE, UNKNOWN, "No move found");
    if (move) *move = PASS_MOVE;
    READ_RETURN_SEMEAI(read_result, move, PASS_MOVE, *resulta, *resultb);
  }

  *resulta = best_resulta;
  *resultb = best_resultb;
  if (best_resulta == DEAD)
    best_move = PASS_MOVE;
  if (move) *move = best_move;
  SGFTRACE2(best_move, best_resulta, moves[best_move_k].name);
  READ_RETURN_SEMEAI(read_result, move, best_move, best_resulta, best_resultb);
}
				   
/* Returns the number of liberties gained by the first goal minus the
 * number of liberties lost by the second goal when a move is played
 * at move (if positive, zero otherwise). Used for sorting the moves.
 */

static int
semeai_move_value(int move, struct local_owl_data *owla,
		  struct local_owl_data *owlb,
		  int raw_value)
{
  int pos;
  int net = 0;
  int color = owla->color;
  int save_verbose = verbose;

  gg_assert(board[move] == EMPTY);
  verbose = 0;
  if (safe_move(move, color)) {
    for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
      if (ON_BOARD(pos)
	  && board[pos] != EMPTY) {
	int origin = find_origin(pos);
	
	if (origin != pos)
	  continue;
	if (owla->goal[pos])
	  net -= 75*countlib(pos);
	if (owlb->goal[pos])
	  net += 100*countlib(pos);	  
      }
    }
    if (!trymove(move, color, NULL, 0, 0, NO_MOVE)) {
      verbose = save_verbose;
      return 0;
    }
    for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
      if (ON_BOARD(pos)
	  && board[pos] != EMPTY) {
	int origin = find_origin(pos);
	
	if (origin != pos)
	  continue;
	if (owla->goal[pos]
	    || (pos == move && liberty_of_goal(move, owla)))
	  net += 75*countlib(pos);
	if (owlb->goal[pos])
	  net -= 100*countlib(pos);
      }
    }
    popgo();
    verbose = save_verbose;
  }
  if (net < 0)
    net = 0;
#if 0
  if (semeai_focus != EMPTY 
      && move_focus == semeai_focus)
    return raw_value + net + 50;
#endif
  return raw_value + net;
}



/* If (pos) points to an empty intersection, returns true if
 * this spot is adjacent to an element of the owl goal.
 */

static int
liberty_of_goal(int pos, struct local_owl_data *owl)
{
  if ((ON_BOARD(SOUTH(pos)) && owl->goal[SOUTH(pos)])
      || (ON_BOARD(WEST(pos)) && owl->goal[WEST(pos)])
      || (ON_BOARD(NORTH(pos)) && owl->goal[NORTH(pos)])
      || (ON_BOARD(EAST(pos)) && owl->goal[EAST(pos)]))
    return 1;
  
  return 0;
}


/* 'liberty' is a liberty of 'worm' which we would like to fill.
 * However it is not safe to play there, so we look for a
 * backfilling move. For example in this situation:
 *
 *   ------+
 *   O.OaXc|
 *   OOOOOX|
 *   XXXXXb|
 *   ......|
 *
 * If 'worm' is the O string and 'liberty' is 'a', the
 * function returns 'b'. To fill at 'a', X must first
 * fill 'b' and 'c' and it is better to fill at 'b' first
 * since that will sometimes leave fewer or smaller ko threats.
 *
 * Returns NO_MOVE if no move is found.
 */

static int
find_semeai_backfilling_move(int worm, int liberty)
{
  int color = board[worm];
  int other = OTHER_COLOR(color);
  int result = NO_MOVE;

  if (stackp > backfill_depth)
    return NO_MOVE;

  if (safe_move(liberty, other))
    return liberty;
  if (is_self_atari(liberty, other)) {
    int fill;
    if (approxlib(liberty, other, 1, &fill) > 0
	&& trymove(fill, other, "find_semeai_backfilling_move", worm, 
		   EMPTY, NO_MOVE)) {
      if (safe_move(liberty, other))
	result = fill;
      else
	result = find_semeai_backfilling_move(worm, liberty);
      popgo();
    }
  }
  if (ON_BOARD(result) && safe_move(result, other))
    return result;
  else
    return NO_MOVE;
}



/* Returns true if a move can be found to attack the dragon
 * at (target), in which case (*attack_point) is the recommended move.
 * (attack_point) can be a null pointer if only the result is needed.
 *
 * The array goal marks the extent of the dragon. This must
 * be maintained during reading. Call this function only when
 * stackp==0; otherwise you can call do_owl_attack but you must
 * set up the goal and boundary arrays by hand first.
 *
 * Returns KO_A or KO_B if the position is ko:
 *
 * - Returns KO_A if the attack prevails provided attacker is willing to
 *   ignore any ko threat (the attacker makes the first ko capture).
 *
 * - Returns KO_B if attack succeeds provided attacker has a ko threat
 *   which must be answered (the defender makes the first ko capture).
 * */

int
owl_attack(int target, int *attack_point, int *certain)
{
  int result;
  struct local_owl_data *owl;
  int reading_nodes_when_called = get_reading_node_counter();
  double start = 0;
  int tactical_nodes;
  int move = NO_MOVE;

  result_certain = 1;
  if (worm[target].unconditional_status == DEAD) {
    if (attack_point)
      *attack_point = NO_MOVE;
    if (certain)
      *certain = 1;
    return 1;
  }

  if (search_persistent_owl_cache(OWL_ATTACK, target, 0, 0, &result,
				  attack_point, NULL, certain))
    return result;

  if (debug & DEBUG_OWL_PERFORMANCE)
    start = gg_cputime();
  
  TRACE("owl_attack %1m\n", target);
  init_owl(&owl, target, NO_MOVE, NO_MOVE, 1);
  owl_make_domains(owl, NULL);
  result = do_owl_attack(target, &move, owl, EMPTY, 0);
  tactical_nodes = get_reading_node_counter() - reading_nodes_when_called;

  DEBUG(DEBUG_OWL_PERFORMANCE,
    "owl_attack %1m, result %d %1m (%d, %d nodes, %f seconds)\n",
    target, result, move, owl->local_owl_node_counter,
    tactical_nodes, gg_cputime() - start);

  store_persistent_owl_cache(OWL_ATTACK, target, 0, 0,
			     result, move, 0,
			     result_certain, tactical_nodes,
			     owl->goal, board[target]);

  if (attack_point)
    *attack_point = move;
  if (certain)
    *certain = result_certain;

  return result;
}


/* Static function containing the main recursive code for 
 * owl_attack.
 */

static int
do_owl_attack(int str, int *move, struct local_owl_data *owl,
	      int komaster, int kom_pos)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  struct owl_move_data vital_moves[MAX_MOVES];
  struct owl_move_data shape_moves[MAX_MOVES];
  struct owl_move_data *moves;
#if PATTERN_CHECK_ON_DEMAND
  struct matched_patterns_list_data shape_patterns;
#endif
  char mw[BOARDMAX];
  int number_tried_moves = 0;
  int pass;
  int k;
  int savemove = 0;
  int savecode = 0;
  int true_genus = -1;
  int probable_min = -1;
  int probable_max = -1;
  int move_cutoff;
  int dcode;
  int found_read_result;
  Read_result *read_result = NULL;
  int this_variation_number = count_variations - 1;
  
  SETUP_TRACE_INFO("owl_attack", str);

#if PATTERN_CHECK_ON_DEMAND
  shape_patterns.initialized = 0;
#endif

  if ((stackp <= owl_branch_depth) && (hashflags & HASH_OWL_ATTACK)) {
    found_read_result = get_read_result(OWL_ATTACK, komaster, kom_pos,
					&str, &read_result);
    if (found_read_result) {
      TRACE_CACHED_RESULT(*read_result);
      if (rr_get_result(*read_result) != 0) {
	if (move)
	  *move = rr_get_move(*read_result);
      }

      if (rr_get_result(*read_result) == WIN)
	TRACE("%oVariation %d: DEAD (cached)\n", this_variation_number);
      else
	TRACE("%oVariation %d: ALIVE (cached)\n", this_variation_number);

      SGFTRACE(rr_get_move(*read_result), rr_get_result(*read_result),
	       "cached");
      return rr_get_result(*read_result);
    }
  }

  /* If we're deeper than owl_reading_depth, assume the dragon has
   * managed to escape.
   */
  if (stackp > owl_reading_depth) {
    TRACE("%oVariation %d: ALIVE (maximum reading depth reached)\n",
	  this_variation_number);
    SGFTRACE(0, 0, "max reading depth reached");
    READ_RETURN0(read_result);
  }
  
  /* If the owl node limit has been reached, assume the dragon has
   * managed to escape.
   */
  if (owl->local_owl_node_counter >= owl_node_limit) {
    result_certain = 0;
    TRACE("%oVariation %d: ALIVE (owl node limit reached)\n",
	  this_variation_number);
    SGFTRACE(0, 0, "owl node limit reached");
    READ_RETURN0(read_result);
  }

  memset(mw, 0, sizeof(mw));
  global_owl_node_counter++;
  owl->local_owl_node_counter++;

  /* Always start with picking up the vital moves so we can see if
   * there is any chance to kill.
   */
  {
    SGFTree *save_sgf_dumptree = sgf_dumptree;
    int save_count_variations = count_variations;
    
    sgf_dumptree = NULL;
    count_variations = 0;
    if (color == BLACK)
      true_genus = owl_determine_life(owl, NULL, owl->black_eye,
				      BLACK, komaster, 1, vital_moves,
				      &probable_min, &probable_max);
    else 
      true_genus = owl_determine_life(owl, NULL, owl->white_eye,
				      WHITE, komaster, 1, vital_moves,
				      &probable_min, &probable_max);
    
    current_owl_data = owl;
    memset(owl->safe_move_cache, 0, sizeof(owl->safe_move_cache));

    matches_found = 0;
    memset(found_matches, 0, sizeof(found_matches));
    if (level >= 9)
      matchpat(owl_shapes_callback, other, 
	       &owl_vital_apat_db, vital_moves, owl->goal);
    
    sgf_dumptree = save_sgf_dumptree;
    count_variations = save_count_variations;

    DEBUG(DEBUG_EYES, "owl: true_genus=%d matches_found=%d\n",
	  true_genus, matches_found);
    true_genus -= matches_found;

    if (true_genus >= 2
	|| (true_genus == 1 && probable_min >= 4)
	|| (stackp > owl_distrust_depth
	    && probable_min >= 2
	    && !matches_found)) {
      const char *live_reason = "";
      if (true_genus >= 2) 
	live_reason = "2 or more secure eyes";
      else if (true_genus == 1 && probable_min >= 4)
	live_reason = "1 secure eye, likely >= 4";
      else if (stackp > owl_distrust_depth 
	       && probable_min >= 2
	       && !matches_found)
	live_reason = "getting deep, looks lively";
      else
	gg_assert(0); /* This should never happen */

      TRACE("%oVariation %d: ALIVE (%s)\n",
	    this_variation_number, live_reason);
      SGFTRACE(0, 0, live_reason);
      READ_RETURN(read_result, move, 0, 0);
    }
  }

  /* We try moves in five passes.
   *                                stackp==0   stackp>0
   * 0. Vital moves in the interval  [70..]      [45..]
   * 1. Shape moves
   * 2. Vital moves in the interval  [..69]      [..44]
   * 3. Tactical attack moves
   * 4. Moves found by the defender
   */
  for (pass = 0; pass < 5; pass++) {
    moves = NULL;
    move_cutoff = 1;
    
    current_owl_data = owl;
    /* Get the shape moves if we are in the right pass. */
    if (pass == 1) {

      if (stackp > owl_branch_depth && number_tried_moves > 0)
	continue;
      
#if PATTERN_CHECK_ON_DEMAND
      owl_shapes(&shape_patterns, shape_moves, other, owl, &owl_attackpat_db);
      /* A move of value 100 is considered a win */
      if (get_next_move_from_list(&shape_patterns, other, shape_moves, 100)) {
#else
      owl_shapes(shape_moves, other, owl, &owl_attackpat_db);
      /* A move of value 100 is considered a win */
      if (shape_moves[0].value >= 100) {
#endif
	/* to make sure this move is recorded in the sgf file */
	if (trymove(shape_moves[0].pos, other,
		    shape_moves[0].name, str, komaster, kom_pos))
	  popgo();
	TRACE("%oVariation %d: DEAD (Winning owl_attackpat)\n",
	      this_variation_number);
	SGFTRACE(shape_moves[0].pos, WIN, "winning attack pattern");
#if PATTERN_CHECK_ON_DEMAND
	close_pattern_list(&shape_patterns);
#endif
	READ_RETURN(read_result, move, shape_moves[0].pos, WIN);
      }

#if !PATTERN_CHECK_ON_DEMAND
      /* A move of value 99 is considered a forced move. No other move need
       * be considered. If there are two of these on the board, we lose.
       */
      if (shape_moves[0].value == 99) {
	if (shape_moves[1].value == 99) {
	  TRACE("%oVariation %d: ALIVE (multiple forced moves)\n",
		this_variation_number);
	  SGFTRACE(0, 0, "multiple forced moves");
	  READ_RETURN0(read_result);
	}
	move_cutoff = 99;
      }
#endif

      moves = shape_moves;
    }
    else if (pass == 0 || pass == 2) {
      
      if (stackp > owl_branch_depth && number_tried_moves > 0)
	continue;
      
      moves = vital_moves;
      if (pass == 0 || stackp > owl_distrust_depth) {
	if (stackp == 0)
	  move_cutoff = 70;
	else
	  move_cutoff = 45;
      }
      if (probable_max < 2 && stackp > 2)
	move_cutoff = 99; /* Effectively disable vital moves. */
    }
    else if (pass == 3) {
      /* Look for a tactical attack. This is primarily intended for
       * the case where the whole dragon is a single string, therefore
       * we only look at the string at the "origin".
       *
       * We must be wary with attacks giving ko. Unless the dragon
       * otherwise looks alive, this may turn a dead dragon into one
       * which can live by ko.
       */
      int apos;
      int result;
      SGFTree *save_sgf_dumptree = sgf_dumptree;
      int save_count_variations = count_variations;
      
      sgf_dumptree = NULL;
      count_variations = 0;
      result = attack(str, &apos);
      if (result == WIN || (result != 0 && probable_min >= 2)) {
	shape_moves[0].pos         = apos;
	shape_moves[0].value       = 25;
	shape_moves[0].name        = "tactical attack";
	shape_moves[0].same_dragon = 1;
	shape_moves[1].value       = 0;
	moves = shape_moves;
      }
      sgf_dumptree = save_sgf_dumptree;
      count_variations = save_count_variations;
    }

    /* If we found no move in the first four passes we ask the defender
     * for a move suggestion.
     */
    if (pass == 4 && number_tried_moves == 0) {
      int dpos;
      dcode = do_owl_defend(str, &dpos, owl, komaster, kom_pos);
      /* No defense, we won. */
      if (dcode == 0) {
	TRACE("%oVariation %d: DEAD (no defense)\n",
	      this_variation_number);
	SGFTRACE(0, WIN, "no defense");
#if PATTERN_CHECK_ON_DEMAND
	close_pattern_list(&shape_patterns);
#endif
	READ_RETURN(read_result, move, 0, WIN);
      }
      else if (dpos != NO_MOVE) {
	/* The dragon could be defended by another move. Try to attack
         * with this move.
	 */
	shape_moves[0].pos         = dpos;
	shape_moves[0].value       = 25;
	shape_moves[0].name        = "defense move";
	shape_moves[0].same_dragon = 1;
	shape_moves[1].value       = 0;
	moves = shape_moves;
      }
    }
      
    /* FIXME: This block probably should reappear somewhere in this
     * function.
     */
#if 0
    /* First test whether the dragon has escaped. */
    if (owl_escape_route(owl) >= 5) {
      /* FIXME: We probably should make distinction in the returned
       * result whether the dragon lives by making two eyes or by
       * escaping.
       */
      TRACE("%oVariation %d: ALIVE (escaped)\n", this_variation_number);
      SGFTRACE(0, 0, "escaped");
#if PATTERN_CHECK_ON_DEMAND
      close_pattern_list(&shape_patterns);
#endif
      READ_RETURN0(read_result);
    }
#endif

    if (!moves)
      continue;
    
    /* For the up to MAX_MOVES best moves with value equal to
     * move_cutoff or higher, try to attack the dragon and see if it
     * can then be defended.
     */
    for (k = 0; k < MAX_MOVES; k++) {
      int mpos;
      int ko_move = -1;
      int new_komaster;
      int new_kom_pos;
      int origin = 0;

      /* Consider only the highest scoring move if we're deeper than
       * owl_branch_depth.
       */
      if (stackp > owl_branch_depth && k > 0)
	break;

    current_owl_data = owl;

#if PATTERN_CHECK_ON_DEMAND
      /* Shape moves are selected on demand. */
      if (pass == 1) {
        if (!get_next_move_from_list(&shape_patterns, other,
	                             shape_moves, move_cutoff))
          break;
	/* A move of value 99 is considered a forced move. No other move
	 * needs to be considered. If there are two of them, we loose.
	 */
	if (moves[k].value == 99) {
	  gg_assert(k == 0);
          if (get_next_move_from_list(&shape_patterns, other,
	                              shape_moves, 99)) {
	    TRACE("%oVariation %d: ALIVE (multiple forced moves)\n",
		  this_variation_number);
	    SGFTRACE(0, 0, "multiple forced moves");
	    close_pattern_list(&shape_patterns);
	    READ_RETURN0(read_result);
	  }
	  move_cutoff = 99;
	}
      }
      else
#endif
      if (moves[k].value < move_cutoff)
	break;

      mpos = moves[k].pos;
      ASSERT_ON_BOARD1(mpos);
      gg_assert(mpos != NO_MOVE);
    
      /* Have we already tested this move? */
      if (mw[mpos])
	continue;

      /* Try to make the move. */
      if (!komaster_trymove(mpos, other, moves[k].name, str,
			    komaster, kom_pos, &new_komaster, &new_kom_pos,
			    &ko_move, savecode == 0))
	continue;

      TRACE("Trying %C %1m.  Current stack: ", other, mpos);
      if (verbose)
	dump_stack();

      /* We have now made a move. Analyze the new position. */
      push_owl(&owl);
      mw[mpos] = 1;
      number_tried_moves++;
      owl->lunches_are_current = 0;
      owl_update_boundary_marks(mpos, owl);
      
      /* If the origin of the dragon has been captured, we look
       * for another string which was part of the original dragon,
       * marked when stackp==0, which has not been captured. If no
       * such string is found, owl_attack declares victory.
       */
      if (IS_STONE(board[str]))
	origin = str;
      else {
	int found_string = 0;
	int oi, oj;
	for (oi = 0; oi < board_size && !found_string; oi++)
	  for (oj = 0; oj < board_size && !found_string; oj++) {
	    if (BOARD(oi, oj) == color && owl->goal[POS(oi, oj)] == 1) {
	      origin = find_origin(POS(oi, oj));
	      found_string = 1;
	    }
	  }
	
	if (!found_string)
	  origin = 0;
      }

      if (origin == 0)
	dcode = 0;
      else
	dcode = do_owl_defend(origin, NULL, owl, new_komaster, new_kom_pos);

      if (!ko_move) {
	if (dcode == 0) {
	  pop_owl(&owl);
	  popgo();
  	  if (sgf_dumptree) {
	    const char *wintxt;
	    char winstr[192];
	    if (origin == 0)
	      wintxt = "all original stones captured";
	    else
	      wintxt = "attack effective";
	    sprintf(winstr, "%s)\n  (%d variations", wintxt,
	  		    count_variations - this_variation_number);
	    SGFTRACE(mpos, WIN, winstr);
	  }
#if PATTERN_CHECK_ON_DEMAND
          close_pattern_list(&shape_patterns);
#endif
	  READ_RETURN(read_result, move, mpos, WIN);
	}
	UPDATE_SAVED_KO_RESULT(savecode, savemove, dcode, mpos);
      }
      else { /* ko_move */
	if (dcode != WIN) {
	  if (mpos == 0) {
	    SGFTRACE(mpos, KO_B, "all original stones captured with ko");
	  }
	  else {
	    SGFTRACE(mpos, KO_B, "attack effective - ko");
	  }
	  /* We already know the savecode was previously 0. */
	  savemove = mpos;
	  savecode = KO_B;

	  /* It's possible that the defender has no defense even if we
           * give up the ko. In order to force a test of this,
           * assuming this was our only move, we decrease the number
           * of tried moves counter, disregarding this move.
	   */
	  number_tried_moves--;
	}
      }
    
      pop_owl(&owl);
      popgo();
    }
  }
  
  if (savecode) {
    SGFTRACE(savemove, savecode, "attack effective (ko) - E");
#if PATTERN_CHECK_ON_DEMAND
    close_pattern_list(&shape_patterns);
#endif
    READ_RETURN(read_result, move, savemove, savecode);
  }

  if (sgf_dumptree) {
    char winstr[128];
    sprintf(winstr, "attack failed)\n  (%d variations",
	  	    count_variations - this_variation_number);
    SGFTRACE(0, 0, winstr);
  }
#if PATTERN_CHECK_ON_DEMAND
  close_pattern_list(&shape_patterns);
#endif
  READ_RETURN0(read_result);
}


/* Returns true if the dragon at (target) can be captured given
 * two moves in a row. The first two moves to capture the
 * dragon are given as (*attack1) and (*attack2).
 */

int
owl_threaten_attack(int target, int *attack1, int *attack2)
{
  struct owl_move_data moves[MAX_MOVES];
  int k;
  int other = OTHER_COLOR(board[target]);
  struct local_owl_data *owl;
  int result = 0;
  int reading_nodes_when_called = get_reading_node_counter();
  char saved_boundary[BOARDMAX];
  double start = 0;
  int tactical_nodes;
  int move = 0;
  int move2 = 0;
#if PATTERN_CHECK_ON_DEMAND
  struct matched_patterns_list_data shape_patterns;

  shape_patterns.initialized = 0;
#endif
  result_certain = 1;
  if (search_persistent_owl_cache(OWL_THREATEN_ATTACK, target, 0, 0,
				  &result, attack1, attack2, NULL))
    return result;

  if (debug & DEBUG_OWL_PERFORMANCE)
    start = gg_cputime();
  
  gg_assert(stackp == 0);
  TRACE("owl_threaten_attack %1m\n", target);
  init_owl(&owl, target, NO_MOVE, NO_MOVE, 1);
  memcpy(saved_boundary, owl->boundary, sizeof(saved_boundary));
  owl_make_domains(owl, NULL);
#if PATTERN_CHECK_ON_DEMAND
  owl_shapes(&shape_patterns, moves, other, owl, &owl_attackpat_db);
  for (k = 0; k < MAX_MOVES; k++) {
    current_owl_data = owl;
    if (!get_next_move_from_list(&shape_patterns, other, moves, 1))
      break;
    else {
#else
  if (owl_shapes(moves, other, owl, &owl_attackpat_db)) {
    for (k = 0; k < MAX_MOVES; k++) {
#endif
      int mpos = moves[k].pos;

      if (mpos != NO_MOVE && moves[k].value > 0)
	if (trymove(mpos, other, moves[k].name, target, EMPTY, 0)) {
	  int oi, oj;
	  int origin = 0;
	  owl->lunches_are_current = 0;
	  owl_update_boundary_marks(mpos, owl);
	  
	  /* If the origin of the dragon has been captured, we look
	   * for another string which was part of the original dragon,
	   * marked when stackp==0, which has not been captured. If no
	   * such string is found, owl_attack declares victory.
	   */
	  
	  if (board[target] == EMPTY) {
	    int found_string = 0;
	    for (oi = 0; oi < board_size && !found_string; oi++)
	      for (oj = 0; oj < board_size && !found_string; oj++) {
		if (IS_STONE(BOARD(oi, oj)) 
		    && owl->goal[POS(oi, oj)] == 1) {
		  origin = find_origin(POS(oi, oj));
		  found_string = 1;
		}
	      }
	    if (!found_string 
		|| do_owl_attack(origin, NULL, owl, EMPTY, 0)) {
	      /* probably this can't happen */
	      popgo();
	      gg_assert(stackp == 0);
	      result = 1;
	      break;
	    }
	  }
	  else if (do_owl_attack(target, &move2, owl, EMPTY, 0) == WIN) {
	    move = moves[k].pos;
	    popgo();
	    gg_assert(stackp == 0);
	    result = 1;
	    break;
	  }
	  popgo();
	  memcpy(owl->boundary, saved_boundary, sizeof(saved_boundary));
	}
    }
  }
  tactical_nodes = get_reading_node_counter() - reading_nodes_when_called;
  gg_assert(stackp == 0);

  DEBUG(DEBUG_OWL_PERFORMANCE,
    "owl_threaten_attack %1m %1m %1m, result %d (%d, %d nodes, %f seconds)\n",
    target, move, move2, result, owl->local_owl_node_counter,
    tactical_nodes, gg_cputime() - start);

  store_persistent_owl_cache(OWL_THREATEN_ATTACK, target, 0, 0,
			     result, move, move2, 0,
			     tactical_nodes, owl->goal, board[target]);

  if (attack1)
    *attack1 = move;
  if (attack2)
    *attack2 = move2;

#if PATTERN_CHECK_ON_DEMAND
  close_pattern_list(&shape_patterns);
#endif
  return result;
}


/* Returns true if a move can be found to defend the dragon
 * at (target), in which case (*defense_point) is the recommended move.
 * (defense_point) can be a null pointer if the result is not needed.
 *
 * The array goal marks the extent of the dragon. This must
 * be maintained during reading. Call this function only when
 * stackp==0; otherwise you can call do_owl_attack but you must
 * set up the goal and boundary arrays by hand first.
 *
 * Returns KO_A or KO_B if the position is ko:
 *
 * - Returns KO_A if the defendse succeeds provided the defender is willing to
 *   ignore any ko threat (the defender makes the first ko capture).
 * - Returns KO_B if the defense succeeds provided the defender has a ko threat
 *   which must be answered (the attacker makes the first ko capture).
 *
 * The array goal marks the extent of the dragon. This must
 * be maintained during reading.  */

int
owl_defend(int target, int *defense_point, int *certain)
{
  int result;
  static struct local_owl_data *owl;
  int reading_nodes_when_called = get_reading_node_counter();
  double start = 0;
  int tactical_nodes;
  int move = 0;

  result_certain = 1;
  if (worm[target].unconditional_status == DEAD)
    return 0;

  if (search_persistent_owl_cache(OWL_DEFEND, target, 0, 0,
				  &result, defense_point, NULL, certain))
    return result;

  if (debug & DEBUG_OWL_PERFORMANCE)
    start = gg_cputime();

  TRACE("owl_defend %1m\n", target);
  init_owl(&owl, target, NO_MOVE, NO_MOVE, 1);
  owl_make_domains(owl, NULL);
  result = do_owl_defend(target, &move, owl, EMPTY, 0);
  tactical_nodes = get_reading_node_counter() - reading_nodes_when_called;

  DEBUG(DEBUG_OWL_PERFORMANCE,
    "owl_defend %1m, result %d %1m (%d, %d nodes, %f seconds)\n",
	    target, result, move, owl->local_owl_node_counter,
	    tactical_nodes, gg_cputime() - start);

  store_persistent_owl_cache(OWL_DEFEND, target, 0, 0, result, move, 0,
			     result_certain, tactical_nodes, owl->goal,
			     board[target]);
  if (defense_point)
    *defense_point = move;
  if (certain)
    *certain = result_certain;
  
  return result;
}


/* Static function containing the main recursive code for owl_defend.
 */

static int
do_owl_defend(int str, int *move, struct local_owl_data *owl,
	      int komaster, int kom_pos)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  struct owl_move_data shape_moves[MAX_MOVES];
  struct owl_move_data vital_moves[MAX_MOVES];
  struct owl_move_data *moves;
#if PATTERN_CHECK_ON_DEMAND
  struct matched_patterns_list_data shape_patterns;
#endif 
  char mw[BOARDMAX];
  int number_tried_moves = 0;
  int pass;
  int k;
  int savemove = 0;
  int savecode = 0;
  int true_genus = -1;
  int probable_min = -1;
  int probable_max = -1;
  int move_cutoff;
  int acode;
  int found_read_result;
  Read_result *read_result = NULL;
  int this_variation_number = count_variations - 1;

  SETUP_TRACE_INFO("owl_defend", str);

#if PATTERN_CHECK_ON_DEMAND
  shape_patterns.initialized = 0;
#endif
  
  if ((stackp <= owl_branch_depth) && (hashflags & HASH_OWL_DEFEND)) {
    found_read_result = get_read_result(OWL_DEFEND, komaster, kom_pos,
					&str, &read_result);
    if (found_read_result) {
      TRACE_CACHED_RESULT(*read_result);
      if (rr_get_result(*read_result) != 0) {
	if (move)
	  *move = rr_get_move(*read_result);
      }

      if (rr_get_result(*read_result) == WIN)
	TRACE("%oVariation %d: ALIVE (cached)\n", this_variation_number);
      else
	TRACE("%oVariation %d: DEAD (cached)\n", this_variation_number);

      SGFTRACE(rr_get_move(*read_result), rr_get_result(*read_result),
	       "cached");
      return rr_get_result(*read_result);
    }
  }

  /* In order to get a defense move even if we seem to already have
   * escaped and to reduce the impact of overestimated escape
   * possibilities, we don't declare escape victory on the first move.
   *
   * FIXME: Should introduce a new owl depth value rather than having
   *        this hardwired value.
   */
  if (stackp > 2 && owl_escape_route(owl) >= 5) {
    /* FIXME: We probably should make distinction in the returned
     * result whether the dragon lives by making two eyes or by
     * escaping.
     */
    TRACE("%oVariation %d: ALIVE (escaped)\n", this_variation_number);
    SGFTRACE(0, WIN, "escaped");
    READ_RETURN(read_result, move, 0, WIN);
  }

  /* If (stackp > owl_reading_depth), interpret deep reading 
   * conservatively as escape.
   */
  if (stackp > owl_reading_depth) {
    TRACE("%oVariation %d: ALIVE (maximum reading depth reached)\n",
	  this_variation_number);
    SGFTRACE(0, WIN, "max reading depth reached");
    READ_RETURN(read_result, move, 0, WIN);
  }
  
  /* If the owl node limit has been reached, assume the dragon has
   * managed to escape.
   */
  if (owl->local_owl_node_counter >= owl_node_limit) {
    result_certain = 0;
    TRACE("%oVariation %d: ALIVE (owl node limit reached)\n",
	  this_variation_number);
    SGFTRACE(0, WIN, "owl node limit reached");
    READ_RETURN(read_result, move, 0, WIN);
  }

  memset(mw, 0, sizeof(mw));
  owl->local_owl_node_counter++;
  global_owl_node_counter++;

  /* Always start with picking up the vital moves so we can see if
   * we already are safe.
   */
  {
    SGFTree *save_sgf_dumptree = sgf_dumptree;
    int save_count_variations = count_variations;
    
    sgf_dumptree = NULL;
    count_variations = 0;
    if (color == BLACK)
      true_genus = owl_determine_life(owl, NULL, owl->black_eye,
				      BLACK, komaster, 0, vital_moves,
				      &probable_min, &probable_max);
    else 
      true_genus = owl_determine_life(owl, NULL, owl->white_eye,
				      WHITE, komaster, 0, vital_moves,
				      &probable_min, &probable_max);
    
    current_owl_data = owl;
    memset(owl->safe_move_cache, 0, sizeof(owl->safe_move_cache));

    /* We don't care about the moves, just whether matches are found.
     * The content of shape_moves[] will be discarded when we call
     * owl_shapes().
     */
    for (k = 0; k < MAX_MOVES; k++) {
      shape_moves[k].pos = 0;
      shape_moves[k].value = -1;
      shape_moves[k].name = NULL;
      shape_moves[k].same_dragon = 2;
    }

    matches_found = 0;
    memset(found_matches, 0, sizeof(found_matches));
    if (level >= 9) 
      matchpat(owl_shapes_callback, other, 
	       &owl_vital_apat_db, shape_moves, owl->goal);

    DEBUG(DEBUG_EYES, "owl: true_genus=%d matches_found=%d\n",
	  true_genus, matches_found);
    true_genus -= matches_found;

    sgf_dumptree = save_sgf_dumptree;
    count_variations = save_count_variations;
    
    if (true_genus >= 2
	|| (true_genus == 1 && probable_min >= 4)
	|| (stackp > owl_distrust_depth
	    && probable_min >= 2
	    && !matches_found)) {
      const char *live_reason = "";
      if (true_genus >= 2) 
	live_reason = "2 or more secure eyes";
      else if (true_genus == 1 && probable_min >= 4)
	live_reason = "1 secure eye, likely >= 4";
      else if (stackp > owl_distrust_depth 
	       && probable_min >= 2
	       && !matches_found)
	live_reason = "getting deep, looks lively";
      else
	gg_assert(0); /* This should never happen */

      TRACE("%oVariation %d: ALIVE (%s)\n",
	    this_variation_number, live_reason);
      SGFTRACE(0, WIN, live_reason);
      READ_RETURN(read_result, move, 0, WIN);
    }
  }

  /* We try moves in four passes.
   *                                stackp==0   stackp>0
   * 0. Vital moves in the interval  [70..]      [45..]
   * 1. Shape moves
   * 2. Vital moves in the interval  [..69]      [..44]
   * 3. Tactical defense moves
   */
  for (pass = 0; pass < 4; pass++) {
    moves = NULL;
    move_cutoff = 1;
    
    current_owl_data = owl;
    /* Get the shape moves if we are in the right pass. */
    if (pass == 1) {
      
      if (stackp > owl_branch_depth && number_tried_moves > 0)
	continue;
      
#if PATTERN_CHECK_ON_DEMAND
      owl_shapes(&shape_patterns, shape_moves, color, owl, &owl_defendpat_db);
      /* A move of value 100 is considered a win */
      if (get_next_move_from_list(&shape_patterns, color, shape_moves, 100)) {
#else
      owl_shapes(shape_moves, color, owl, &owl_defendpat_db);
      /* A move of value 100 is considered a win */
      if (shape_moves[0].value >= 100) {
#endif
	/* to make sure this move is recorded in the sgf file */
	if (trymove(shape_moves[0].pos, color, shape_moves[0].name, str,
		    komaster, kom_pos))
	  popgo();
	TRACE("%oVariation %d: ALIVE (Winning owl_defendpat)\n", 
	      this_variation_number);
	SGFTRACE(shape_moves[0].pos, WIN, "winning defense pattern");
#if PATTERN_CHECK_ON_DEMAND
	close_pattern_list(&shape_patterns);
#endif
	READ_RETURN(read_result, move, shape_moves[0].pos, WIN);
      }
      moves = shape_moves;
    }
    else if (pass == 0 || pass == 2) {

      if (stackp > owl_branch_depth && number_tried_moves > 0)
	continue;
      
      moves = vital_moves;
      if (pass == 0 || stackp > owl_distrust_depth) {
	if (stackp == 0)
	  move_cutoff = 70;
	else if (true_genus + probable_min > 3)
	  move_cutoff = 25;
	else if (true_genus + probable_min >= 3)
	  move_cutoff = 35;
	else
	  move_cutoff = 45;
      }
      if (probable_max < 2 && stackp > 2)
	move_cutoff = 99; /* Effectively disable vital moves. */
    }
    else {
#if 1
      int goalcount = 0;

      /* If the goal is small, try a tactical defense. */

      for (k = BOARDMIN; k < BOARDMAX; k++) {
	if (ON_BOARD(k))
	  goalcount += owl->goal[k];
      }

      if (goalcount < 5) {

	/* Look for a tactical defense. This is primarily intended for
	 * the case where the whole dragon is a single string, therefore
	 * we only look at the string at the "origin".
	 *
	 * We only accept clearly effective tactical defenses here,
	 * using a liberty heuristic. The reason for this is problems
	 * with ineffective self ataris which do defend tactically but
	 * have no strategical effect other than wasting owl nodes or
	 * confusing the eye analysis.  */
	int dpos;
	SGFTree *save_sgf_dumptree = sgf_dumptree;
	int save_count_variations = count_variations;
      
	sgf_dumptree = NULL;
	count_variations = 0;
	if (attack_and_defend(str, NULL, NULL, NULL, &dpos)
	    && (approxlib(dpos, color, 2, NULL) > 1
		|| does_capture_something(dpos, color))) {
	  TRACE("Found tactical defense for %1m at %1m.\n", str, dpos);
	  shape_moves[0].pos         = dpos;
	  shape_moves[0].value       = 25;
	  shape_moves[0].name        = "tactical defense";
	  shape_moves[0].same_dragon = 1;
	  shape_moves[1].value       = 0;
	  moves = shape_moves;
	}
	sgf_dumptree = save_sgf_dumptree;
	count_variations = save_count_variations;
      }
#endif
    }

    if (!moves)
      continue;
    
    /* For the up to MAX_MOVES best moves with value equal to
     * move_cutoff or higher, try to defend the dragon and see if it
     * can then be attacked.
     */
    for (k = 0; k < MAX_MOVES; k++) {
      int mpos;
      int new_komaster, new_kom_pos;
      int ko_move = -1;

      /* Consider only the highest scoring move if we're deeper than
       * owl_branch_depth.
       */
      if (stackp > owl_branch_depth && k > 0)
	break;
      
    current_owl_data = owl;

#if PATTERN_CHECK_ON_DEMAND
      if (pass == 1) {
        if (!get_next_move_from_list(&shape_patterns, color, shape_moves,
	                             move_cutoff))
	  break;
      }
      else
#endif
      if (moves[k].value < move_cutoff)
	break;

      mpos = moves[k].pos;
      ASSERT_ON_BOARD1(mpos);
      gg_assert(mpos != NO_MOVE);

      /* Have we already tested this move? */
      if (mw[mpos])
	continue;

      /* Try to make the move. */
      if (!komaster_trymove(mpos, color, moves[k].name, str,
			    komaster, kom_pos, &new_komaster, &new_kom_pos,
			    &ko_move, savecode == 0))
	continue;

      TRACE("Trying %C %1m.  Current stack: ", color, mpos);
      if (verbose)
	dump_stack();

      /* We have now made a move. Analyze the new position. */
      push_owl(&owl);
      mw[mpos] = 1;
      number_tried_moves++;
      owl->lunches_are_current = 0;

      /* Add the stone just played to the goal dragon, unless the
       * pattern explicitly asked for not doing this.
       */
      owl_update_goal(mpos, moves[k].same_dragon, owl);

      if (!ko_move) {
	acode = do_owl_attack(str, NULL, owl, new_komaster, new_kom_pos);
	if (!acode) {
	  pop_owl(&owl);
	  popgo();
	  if (sgf_dumptree) {
	    char winstr[192];
	    sprintf(winstr, "defense effective)\n  (%d variations",   
	  		    count_variations - this_variation_number);
	    SGFTRACE(mpos, WIN, winstr);
	  }
#if PATTERN_CHECK_ON_DEMAND
	  close_pattern_list(&shape_patterns);
#endif
	  READ_RETURN(read_result, move, mpos, WIN);
	}
	UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, mpos);
      }
      else {
	if (do_owl_attack(str, NULL, owl, new_komaster, new_kom_pos) != WIN) {
	  savemove = mpos;
	  savecode = KO_B;
	}
      }
      
      /* Undo the tested move. */
      pop_owl(&owl);
      popgo();
    }
  }

#if PATTERN_CHECK_ON_DEMAND
  close_pattern_list(&shape_patterns);
#endif
  
  if (savecode) {
    SGFTRACE(savemove, savecode, "defense effective (ko) - B");
    READ_RETURN(read_result, move, savemove, savecode);
  }

  if (number_tried_moves == 0 && probable_min >= 2) {
    SGFTRACE(0, WIN, "genus probably >= 2");
    READ_RETURN(read_result, move, 0, WIN);
  }
  

  if (sgf_dumptree) {
    char winstr[196];
    int print_genus = true_genus == 1 ? 1 : 0;
    sprintf(winstr, "defense failed - genus %d)\n  (%d variations",
	  	    print_genus, count_variations - this_variation_number);
    SGFTRACE(0, 0, winstr);
  }

  READ_RETURN0(read_result);
}


/* Returns true if the dragon at (target) can be defended given
 * two moves in a row. The first two moves to defend the
 * dragon are given as (*defend1) and (*defend2).
 */

int
owl_threaten_defense(int target, int *defend1, int *defend2)
{
  struct owl_move_data moves[MAX_MOVES];
  int k;
  int color = board[target];
  int result = 0;
  struct local_owl_data *owl;
  int reading_nodes_when_called = get_reading_node_counter();
  char saved_goal[BOARDMAX];
  double start = 0;
  int tactical_nodes;
  int move = 0;
  int move2 = 0;
#if PATTERN_CHECK_ON_DEMAND
  struct matched_patterns_list_data shape_patterns;

  shape_patterns.initialized = 0;
#endif

  result_certain = 1;
  if (worm[target].unconditional_status == DEAD)
    return 0;

  if (search_persistent_owl_cache(OWL_THREATEN_DEFENSE, target, 0, 0,
				  &result, defend1, defend2, NULL))
    return result;

  if (debug & DEBUG_OWL_PERFORMANCE)
    start = gg_cputime();

  TRACE("owl_threaten_defense %1m\n", target);
  init_owl(&owl, target, NO_MOVE, NO_MOVE, 1);
  memcpy(saved_goal, owl->goal, sizeof(saved_goal));
  owl_make_domains(owl, NULL);
#if PATTERN_CHECK_ON_DEMAND
  owl_shapes(&shape_patterns, moves, color, owl, &owl_defendpat_db);
  for (k = 0; k < MAX_MOVES; k++) {
    current_owl_data = owl;
    if (!get_next_move_from_list(&shape_patterns, color, moves, 1))
      break;
    else {
#else
  if (owl_shapes(moves, color, owl, &owl_defendpat_db)) {
    for (k = 0; k < MAX_MOVES; k++) {
#endif
      if (moves[k].pos != NO_MOVE && moves[k].value > 0)
	if (trymove(moves[k].pos, color, moves[k].name, target, EMPTY, 0)) {
	  owl->lunches_are_current = 0;
	  owl_update_goal(moves[k].pos, moves[k].same_dragon, owl);
	  if (do_owl_defend(target, &move2, owl, EMPTY, 0) == WIN) {
	    move = moves[k].pos;
	    popgo();
	    /* Don't return the second move if occupied before trymove */
	    if (move2 != NO_MOVE && IS_STONE(board[move2]))
	      move2 = NO_MOVE;
	    result = WIN;
	    break;
	  }
	  else
	    popgo();
	  memcpy(owl->goal, saved_goal, sizeof(saved_goal));
	}
    }
  }
  tactical_nodes = get_reading_node_counter() - reading_nodes_when_called;
  gg_assert(stackp == 0);

  DEBUG(DEBUG_OWL_PERFORMANCE, 
    "owl_threaten_defense %1m %1m %1m, result %d (%d, %d nodes, %f seconds)\n",
	    target, move, move2, result, owl->local_owl_node_counter,
	    tactical_nodes, gg_cputime() - start);

  store_persistent_owl_cache(OWL_THREATEN_DEFENSE, target, 0, 0,
			     result, move, move2, 0,
			     tactical_nodes, owl->goal, board[target]);

  if (defend1)
    *defend1 = move;
  if (defend2)
    *defend2 = move2;

#if PATTERN_CHECK_ON_DEMAND
  close_pattern_list(&shape_patterns);
#endif
  return result;
}


/* 
 * This function is invoked from do_owl_attack() and do_owl_defend()
 * for each node to determine whether the the dragon has sufficient
 * eye potential to live. It also generates vital moves to attack or
 * defend the eyes. There are two distinct sources for eyes. The first
 * is the eyespaces found by make_domains() and evaluated by
 * compute_eyes_pessimistic(). The second is the lunches found by
 * owl_find_lunches() and evaluated by sniff_lunch().
 *
 * The return value is a pessimistic estimate of the min number of
 * eyes. If this is 2 or more we should be certain of life.
 * (Unfortunately this is not 100% reliable. The patterns in
 * owl_vital_apats.db are used to compensate for this. See
 * do_owl_attack() and do_owl_defend() for how these are used.)
 *
 * More optimistic estimates of the number of eyes are returned in
 * *probable_min and *probable_max.
 *
 * Vital moves to attack or defend eyes are returned in the moves[]
 * array. Also moves to reduce the uncertainty of the eye estimates
 * are added to this array, but with smaller move values. The
 * parameter does_attack determines whether to generate vital attack
 * moves or vital defense moves.
 *
 * The dragon is specified by the information in the owl struct. The
 * color of the dragon is passed in the color parameter. If color is
 * BLACK, eye should be owl->black_eye and if color is WHITE, eye
 * should be owl->white_eye.
 *
 * For use in the semeai code, a second dragon 
 *
 * FIXME: Both the color and the eye parameters are redundant since
 * this information is already provided through the owl struct.
 *
 * The parameter komaster is currently unused. It is included to
 * prepare better handling of ko once the optics code becomes more ko
 * aware.
 */

static int
owl_determine_life(struct local_owl_data *owl,
		   struct local_owl_data *second_owl,
		   struct eye_data eye[BOARDMAX],
		   int color, int komaster, int does_attack,
		   struct owl_move_data *moves, int *probable_min,
		   int *probable_max)
{
  char mw[BOARDMAX];  /* mark relevant eye origins */
  signed char mx[BOARDMAX]; /* mark potential half or false eyes */
  int vital_values[BOARDMAX];
  int true_genus = 0;
  int max, min, pessimistic_min;
  int attack_point;
  int defense_point;
  int m, n;
  int k;
  int lunch;
  int eye_color;
  int topological_intersections;
  memset(mw, 0, sizeof(mw));
  memset(mx, 0, sizeof(mx));
  memset(vital_values, 0, sizeof(vital_values));
  UNUSED(komaster);

  for (k = 0; k < MAX_MOVES; k++) {
    moves[k].pos = 0;
    moves[k].value = -1;
    moves[k].name = NULL;
    moves[k].same_dragon = 2;
  }
  
  if (!owl->lunches_are_current)
    owl_find_lunches(owl);
  
  if (0) {
    int k;
    for (k = 0; k < MAX_LUNCHES; k++)
      if (owl->lunch[k] != NO_MOVE)
	gprintf("owl lunch %1m, attack %1m, defend %1m\n",
		owl->lunch[k],
		owl->lunch_attack_point[k],
		owl->lunch_defense_point[k]);
  }

  owl_make_domains(owl, second_owl);

  /* The eyespaces we want to evaluate are the ones which
   * are adjacent to the dragon (whose stones comprise the
   * support of goal) which are not GRAY_BORDERED. These
   * are the eyespaces of the dragon. Now we find their
   * origins.
   *
   * It is required that there are at least two distinct connections,
   * adjacent or diagonal, between non-marginal eyespace vertices and
   * stones of the goal dragon. Otherwise there is a risk that we
   * include irrelevant eye spaces.
   */

  if (color == WHITE)
    eye_color = WHITE_BORDER;
  else
    eye_color = BLACK_BORDER;

  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      int pos = POS(m, n);
      if (board[pos] && owl->goal[pos]) {
	for (k = 0; k < 8; k++) {
	  int pos2 = pos + delta[k];
	  if (ON_BOARD(pos2)
	      && eye[pos2].color == eye_color
	      && eye[pos2].origin != NO_MOVE
	      && !eye[pos2].marginal)
	    mw[eye[pos2].origin]++;
	}
      }
    }

  /* Reset halfeye data. Set topological eye value to something big. */
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      owl->half_eye[POS(m, n)].type = 0;
      owl->half_eye[POS(m, n)].value = 10.0;
    }
  
  /* Find topological half eyes and false eyes by analyzing the
   * diagonal intersections, as described in the Texinfo
   * documentation (Eyes/Eye Topology).
   */

  /* First mark the potential halfeyes or false eyes. */
  topological_intersections = 0;
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      int pos = POS(m, n);
      if (eye[pos].color == eye_color
	  && eye[pos].origin != NO_MOVE
	  && mw[eye[pos].origin] > 1
	  && (!eye[pos].marginal || life)
	  && eye[pos].neighbors <= 1) {
	mx[pos] = 1;
	topological_intersections++;
      }
    }

  /* Then examine them. */
  while (topological_intersections > 0) {
    for (m = 0; m < board_size; m++)
      for (n = 0; n < board_size; n++) {
	int pos = POS(m, n);
	float sum;

	if (mx[pos] <= 0)
	  continue;

	mx[pos] = -1;
	topological_intersections--;
	
	sum = topological_eye(pos, color, owl->black_eye, owl->white_eye,
			      owl->half_eye);
	
	if (sum >= 4.0) {
	  /* False eye. */
	  int previously_marginal = eye[pos].marginal;
	  owl->half_eye[pos].type = FALSE_EYE;
	  if (eye[pos].esize == 1
	      || is_legal(pos, OTHER_COLOR(color))
	      || board[pos] == OTHER_COLOR(color)) {
	    add_false_eye(pos, eye, owl->half_eye);
	    
	    /* Marginal status may have changed. This can change the
             * topological eye evaluation for diagonal neighbors, so
             * we mark these for another pass if they have already
             * been examined.
	     */
	    if (!previously_marginal) {
	      int k;
	      for (k = 4; k < 8; k++) {
		int i = m + deltai[k];
		int j = n + deltaj[k];
		if (ON_BOARD(POS(i, j)) && mx[POS(i, j)] == -1) {
		  mx[POS(i, j)] = 1;
		  topological_intersections++;
		}
	      }
	    }
	  }
	}
	else if (sum > 2.0) {
	  owl->half_eye[pos].type = HALF_EYE;
	  ASSERT1(owl->half_eye[pos].num_attacks > 0, pos);
	  ASSERT_ON_BOARD1(owl->half_eye[pos].attack_point[0]);
	  ASSERT1(owl->half_eye[pos].num_defends > 0, pos);
	  ASSERT_ON_BOARD1(owl->half_eye[pos].defense_point[0]);
	}
      }
  }

  *probable_min = 0;
  *probable_max = 0;
  /* This test must be conditioned on (m, n) being its own origin,
   * because some origins get moved during the topological eye
   * code.
   *
   * FIXME: I don't think eye origins are moved around any more. 
   */

  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      int pos = POS(m, n);
      if (mw[pos] > 1 && eye[pos].origin == pos) {
	int value = 0;
	const char *reason = "";
	int i, j;
	compute_eyes_pessimistic(pos, &max, &min, &pessimistic_min,
				 &attack_point, &defense_point,
				 eye, owl->half_eye);
	/* If this eyespace includes an owl inessential string, we
         * must assume that the pessimistic min is 0.
	 */
	for (i = 0; i < board_size; i++)
	  for (j = 0; j < board_size; j++)
	    if (mw[POS(i, j)] > 1
		&& eye[POS(i, j)].origin == pos
		&& owl->inessential[POS(i, j)])
	      pessimistic_min = 0;
	
	true_genus += pessimistic_min;
	*probable_min += min;
	*probable_max += max;

	/* Fill in the maxeye field for use by the owl_eyespace() function. */
	eye[pos].maxeye = max;
	
	/* This shortcut has been disabled for two reasons:
	 * 1. Due to the vital attack moves being able to later reduce
	 * the true genus, we can't say that a certain true_genus is
	 * sufficient.
	 * 2. This part of the code is in now way time critical. If
	 * the life code is enabled, this may change.
	 */
#if 0
	/* Found two certain eyes---look no further. */
	if (true_genus >= 2)
	  return 2;
#endif
	
	if (max != min) {
	  value = 50;
	  if (max - min == 2)
	    value = 70;
	  else if (max - pessimistic_min == 2)
	    value = 60;
	  reason = "vital move";
	}
	else if (max != pessimistic_min) {
	  if (max - pessimistic_min == 2)
	    value = 40;
	  else
	    value = 30;
	  reason = "marginal eye space";
	}

	if (value > 0) {
	  if (does_attack && attack_point != NO_MOVE) {
	    if (vital_values[attack_point] > 0) {
	      value += vital_values[attack_point];
	      if (value > 98)
		value = 98; /* Higher values may get special interpretation. */
	    }
	    
	    TRACE("%s at %1m, score %d (eye at %1m, max %d, min %d, pessimistic_min %d)\n",
		  reason, attack_point, value, pos, max, min,
		  pessimistic_min);
	    
	    if (eye[attack_point].marginal
		&& modify_stupid_eye_vital_point(&attack_point))
	      TRACE("vital point looked stupid, moved it to %1m\n",
		    attack_point);
	    
	    owl_add_move(moves, attack_point, value, reason, 1);
	    vital_values[attack_point] = value;
	  }
	  /* The reason for the last set of tests is that we don't
	   * want to play a self atari in e.g. this position
	   *
	   * |XXX.
	   * |OOX.
	   * |.OX.
	   * |XOXX
	   * |XOOX
	   * |O*OX
	   * +----
	   *
	   * but it's okay in this position
	   * 
	   * |XXXXX
	   * |....X
	   * |OOOOX
	   * |.XXOX
	   * |.*XOX
	   * +-----
	   *
	   * In both cases * is the vital point according to the graph
	   * matching. The significant difference is that in the first
	   * case the vital point is adjacent to stones in the goal.
	   */
	  else if (!does_attack
		   && defense_point != NO_MOVE
		   && board[defense_point] == EMPTY
		   && (!liberty_of_goal(defense_point, owl)
		       || !is_self_atari(defense_point, color)
		       || is_ko(defense_point, color, NULL)
		       || safe_move(defense_point, color) != 0)) {
	    if (vital_values[defense_point] > 0) {
	      value += vital_values[defense_point];
	      if (value > 98)
		value = 98; /* Higher values may get special interpretation. */
	    }
	    
	    TRACE("%s at %1m, score %d (eye at %1m, max %d, min %d, pessimistic_min %d)\n",
		  reason, defense_point, value, pos, max, min,
		  pessimistic_min);

	    if (eye[defense_point].marginal
		&& modify_stupid_eye_vital_point(&defense_point))
	      TRACE("vital point looked stupid, moved it to %1m\n",
		    defense_point);
	    
	    owl_add_move(moves, defense_point, value, reason, 1);
	    vital_values[defense_point] = value;
	  }
	}
      }
    }
  /* Sniff each lunch for nutritional value. The assumption is that
   * capturing the lunch is gote, therefore the number of half eyes
   * equals the MINIMUM number of eyes yielded by the resulting eye
   * space.
   */
  {
    for (lunch = 0; (lunch < MAX_LUNCHES); lunch++)
      if (owl->lunch[lunch] != NO_MOVE
	  && owl->lunch_defense_point[lunch] != NO_MOVE) {
	int value = 0;
	int lunch_min;
	int lunch_probable;
	int lunch_max;
	sniff_lunch(owl->lunch[lunch], 
		    &lunch_min, &lunch_probable, &lunch_max, owl);

	*probable_max += lunch_max;
	
	if (lunch_probable == 0)
	  value = 20;
	else if (lunch_probable == 1 && lunch_max == 1) {
	  value = 60 + countstones(owl->lunch[lunch]);
	}
	else if (lunch_probable == 1 && lunch_max == 2)
	  value = 70 + countstones(owl->lunch[lunch]);
	else
	  value = 75 + countstones(owl->lunch[lunch]);
	
	if (owl->lunch_attack_code[lunch] != WIN)
	  value -= 10;

	if (value < 21  && countstones(owl->lunch[lunch]) == 1)
	  continue;

	if (does_attack) {
	  TRACE("save lunch at %1m with %1m, score %d\n",
		owl->lunch[lunch], owl->lunch_defense_point[lunch], value);
	  owl_add_move(moves, owl->lunch_defense_point[lunch], value,
		       "save lunch", 1);
	}
	else {
	  TRACE("eat lunch at %1m with %1m, score %d\n",
		owl->lunch[lunch], owl->lunch_attack_point[lunch], value);
	  owl_add_move(moves, owl->lunch_attack_point[lunch], value,
		       "eat lunch", 1);
	}
      }
  }
  return true_genus;
}


/* The optics code occasionally comes up with stupid vital moves, like
 * a in this position:
 *
 * ----+
 * O...|
 * OX..|
 * OX..|
 * O.X.|
 * .O.a|
 * ....|
 *
 * This function moves such moves to the second line.
 *
 */
static int
modify_stupid_eye_vital_point(int *vital_point)
{
  int up;
  int right;
  int k;
  
  for (k = 0; k < 4; k++) {
    up = delta[k];
    if (ON_BOARD(*vital_point - up))
      continue;

    if (board[*vital_point + up] != EMPTY)
      continue;

    right = delta[(k+1) % 4];

    if (board[*vital_point + right] != EMPTY
	|| board[*vital_point - right] != EMPTY)
      continue;

    if (board[*vital_point + 2 * up] != EMPTY
	|| board[*vital_point + up + right] != EMPTY
	|| board[*vital_point + up - right] != EMPTY) {
      *vital_point += up;
      return 1;
    }
  }
  
  return 0;
}

	
/* 
 * Generates up to max_moves moves, attempting to attack or defend the goal
 * dragon. The found moves are put in moves, an array of owl_move_data
 * structs, starting in the position 'initial'.  The entries in the array are
 * sorted by value with moves[initial] having highest priority. When no more
 * moves are available this is indicated by value and coordinates in the array
 * being -1.
 *
 * This function automatically initializes the owl_safe_move cache and,
 * if PATTERN_CHECK_ON_DEMAND is set, the pattern list. WATCH OUT: This has
 * to be matched with a call to close_pattern_list(pattern_list)!!!
 *
 * Returns 1 if at least one move is found, or 0 if no move is found.  */

static int 
owl_shapes(
#if PATTERN_CHECK_ON_DEMAND
	   struct matched_patterns_list_data *pattern_list,
#endif
           struct owl_move_data moves[MAX_MOVES],
	   int color, struct local_owl_data *owl, struct pattern_db *type)
{
  int k;
  SGFTree *save_sgf_dumptree = sgf_dumptree;
  int save_count_variations = count_variations;
  sgf_dumptree = NULL;
  count_variations = 0;

  current_owl_data = owl;
  
  for (k = 0; k < MAX_MOVES; k++) {
    moves[k].pos = NO_MOVE;
    moves[k].value = -1;
    moves[k].name = NULL;
    moves[k].same_dragon = 2;
  }

  /* We must reset the owl safe_move_cache before starting the
   * pattern matching. The cache is used by owl_shapes_callback().
   */
  memset(owl->safe_move_cache, 0, sizeof(owl->safe_move_cache));
#if PATTERN_CHECK_ON_DEMAND
  init_pattern_list(pattern_list);
  matchpat(collect_owl_shapes_callbacks, color, type, pattern_list, owl->goal);
#else
  matchpat(owl_shapes_callback, color, type, moves, owl->goal);
#endif

  sgf_dumptree = save_sgf_dumptree;
  count_variations = save_count_variations;

#if PATTERN_CHECK_ON_DEMAND
  return 0;
#else
  if (moves[0].value > 0)
    return 1;
  else
    return 0;
#endif
}  


/* This function contains all the expensive checks for a matched pattern. */
static int
check_pattern_hard(int move, int color, struct pattern *pattern, int ll)
{
  int constraint_checked = 0;
  int safe_move_checked = 0;

  /* The very first check is whether we can disregard the pattern due
   * due to an owl safe_move_cache lookup.
   */
  if (! (pattern->class & CLASS_s))
    if (current_owl_data->safe_move_cache[move]) {
      if (current_owl_data->safe_move_cache[move] == 1)
        return 0;
      else
        safe_move_checked = 1;
    }

  /* If the constraint is cheap to check, we do this first. */
  if ((pattern->autohelper_flag & HAVE_CONSTRAINT)
      && (pattern->constraint_cost < 0.45)) {
    if (!pattern->autohelper(pattern, ll, move, color, 0))
      return 0;
    constraint_checked = 1;
  }

  /* For sacrifice patterns, the survival of the stone to be played is
   * not checked. Otherwise we discard moves which can be captured. 
   * Illegal ko captures are accepted for ko analysis.
   */
  if ((!(pattern->class & CLASS_s)) && (!safe_move_checked)) {
    if (!owl_safe_move(move, color)) {
      if (0)
	TRACE("  move at %1m wasn't safe, discarded\n", move);
      return 0;
    }
    if (!is_legal(move, color)) {
      if (0)
	TRACE("  move at %1m wasn't legal, discarded\n", move);
      return 0;
    }
  }
  
  /* For class n patterns, the pattern is contingent on an opponent
   * move at * not being captured.
   *
   * We can't use owl_safe_move() here because we would try the wrong color.
   */
  if (pattern->class & CLASS_n) {
    if (safe_move(move, OTHER_COLOR(color)) == 0) {
      if (0)
	TRACE("  opponent can't play safely at %1m, move discarded\n", move);
      return 0;
    }
  }

  /* If the pattern has a constraint, call the autohelper to see
   * if the pattern must be rejected.
   */
  if (pattern->autohelper_flag & HAVE_CONSTRAINT && (!constraint_checked))
    if (!pattern->autohelper(pattern, ll, move, color, 0))
      return 0;
  return 1;
}

#if PATTERN_CHECK_ON_DEMAND

/* This initializes a pattern list, allocating memory for 200 patterns.
 * If more patterns need to be stored, collect_owl_shapes_callbacks will
 * dynamically reallocate additional memory.
 * Only the space for list->pattern_list is allocated here, *list needs to
 * have been allocated by the calling function.
 *
 * This function is automatically called from owl_shapes. Every call here
 * has to be matched by a call to close_pattern_list below.
 */
static void
init_pattern_list(struct matched_patterns_list_data *list)
{
  list->counter = 0;
  list->used = 0;
  list->ordered_up_to = 0;
  gg_assert(!list->initialized);
  list->pattern_list = malloc(200*sizeof(list->pattern_list[0]));
  if (0)
    gprintf("List at %x has new array at %x\n", list, list->pattern_list);
  gg_assert(list->pattern_list != NULL);
  list->list_size = 200;
  list->initialized = 1;
}

/* This function has to get called before the memory of *list is freed
 * in the calling function.
 */
static void
close_pattern_list(struct matched_patterns_list_data *list)
{
  /* FIXME: The allpats option should be taken into account here. */
  if (list->initialized) {
    if (0)
      gprintf("%d patterns matched, %d patterns checked\n", list->counter,
	      list->used);
    if (0)
      gprintf("Pattern list at %x freed for list at %x\n",
	      list->pattern_list, list);
    free(list->pattern_list);
  }
  list->counter = -1;
}

/* Can be called from gdb for debugging:
 * (gdb) set dump_pattern_list(&shape_patterns)
 */
void
dump_pattern_list(struct matched_patterns_list_data *list)
{
  int i;
  struct matched_pattern_data *matched_pattern;
  if (!list->initialized)
    return;
  gprintf("%oList size %d. %d Patterns in list, "
          "%d have been used, ordered up to %d.\n",
          list->list_size, list->counter, list->used, list->ordered_up_to);
  for (i = 0; i < list->counter; i++) {
    matched_pattern = &list->pattern_list[i];
    gprintf("%o  Pattern %s (orient. %d) at %1m, value %f.\n",
	    matched_pattern->pattern->name, matched_pattern->ll,
	    matched_pattern->move, matched_pattern->pattern->value);
  }
}


/* This function stores a found pattern in the list for later evaluation.
 * The only processing done is computing the position of the move, and
 * forgetting the color.
 */
static void
collect_owl_shapes_callbacks(int m, int n, int color, struct pattern *pattern,
                             int ll, void *data)
{
  struct matched_patterns_list_data *matched_patterns = data;
  struct matched_pattern_data *next_pattern;

  UNUSED(color); /* The calling function has to remember that. */

  if (matched_patterns->counter >= matched_patterns->list_size) {
    matched_patterns->list_size += 100;
    matched_patterns->pattern_list
        = realloc(matched_patterns->pattern_list,
	          matched_patterns->list_size
	          * sizeof(matched_patterns->pattern_list[0]));
  }
  next_pattern = &matched_patterns->pattern_list[matched_patterns->counter];
  next_pattern->move = AFFINE_TRANSFORM(pattern->movei, pattern->movej,
			                ll, m, n);
  next_pattern->pattern = pattern;
  next_pattern->ll = ll;
  matched_patterns->counter++;
}

/* This function searches in the previously stored list of matched patterns
 * for the highest valued unused patterns that have a valid constraint.
 * It returns the moves at the next empty positions in the array (moves[]).
 * (Empty positions in the moves array are marked by having value <=0. There
 * must be enough empty positions in the list.)
 * If the highest valued pattern found has a value less than cutoff,
 * no move is returned.
 * Returns 1 if a move is found, 0 otherwise.
 *
 * One bubble sort-like iteration is used to find the next highest valued
 * pattern; then it is checked whether this move has not been tried before,
 * and if the pattern constraint is valid. This is repeated until enough
 * moves are found or the end of the list is reached.
 */

static int
get_next_move_from_list(struct matched_patterns_list_data *list, int color,
                        struct owl_move_data *moves, int cutoff)
{
  int top, bottom;
  float top_val;
  int k;
  int i;
  int move;
  struct matched_pattern_data matched_pattern;
  int move_found = 0;
  SGFTree *save_sgf_dumptree = sgf_dumptree;
  int save_count_variations = count_variations;
    
  sgf_dumptree = NULL;
  count_variations = 0;

  /* The patterns above list->used have already been either discarded or
   * used by the calling function.
   */
  for (top = list->used; top < list->counter; top++) {
    /* Maybe we already know the top entry (if previous call was ended
     * by a value cutoff.
     */
    top_val = list->pattern_list[top].pattern->value;
    if (top >= list->ordered_up_to) {
      /* One bubble sort iteration. */
      for (bottom = list->counter-1; bottom > top; bottom--)
	if (list->pattern_list[bottom].pattern->value > top_val) {
	  matched_pattern = list->pattern_list[bottom];
	  list->pattern_list[bottom] = list->pattern_list[top];
	  list->pattern_list[top] = matched_pattern;
	  top_val = list->pattern_list[top].pattern->value;
	}
      list->ordered_up_to++;
    }
    matched_pattern = list->pattern_list[top];
    if (top_val < (float) cutoff) {
      list->ordered_up_to = top + 1;
      list->used = top;
      sgf_dumptree = save_sgf_dumptree;
      count_variations = save_count_variations;
      return 0;
    }
    move = matched_pattern.move;
    ASSERT_ON_BOARD1(move);
    for (k = 0; k < MAX_MOVES; k++) {
      if (moves[k].pos == move || moves[k].value <= 0)
	break;
    }
    if (moves[k].pos == move)
      continue;
    gg_assert(k < MAX_MOVES); /* There has to be an empty space. */
    if (check_pattern_hard(move, color, matched_pattern.pattern,
			   matched_pattern.ll)) {
      moves[k].pos = move;
      moves[k].value = (int) top_val;
      moves[k].name = matched_pattern.pattern->name;
      move_found = 1;
      TRACE("Pattern %s found at %1m with value %d\n",
	    matched_pattern.pattern->name, move, moves[k].value);

      if (matched_pattern.pattern->class & CLASS_B)
        moves[k].same_dragon = 0;
      else if (matched_pattern.pattern->class & CLASS_b) {
	int same_dragon = 1;
	/* If we do not yet know whether the move belongs to the same dragon,
	 * we see whether another pattern can clarify.
	 */
	for (i = top + 1; i < list->counter; i++)
	  if ((list->pattern_list[i].move == move) 
	      && ((list->pattern_list[i].pattern->class & CLASS_B)
		  || !(list->pattern_list[i].pattern->class & CLASS_b))
	      && check_pattern_hard(move, color, list->pattern_list[i].pattern,
				    list->pattern_list[i].ll)) {
	    TRACE("Additionally pattern %s found at %1m\n",
		  list->pattern_list[i].pattern->name, move);
	    if (list->pattern_list[i].pattern->class & CLASS_B)
	      same_dragon = 0;
	    else
	      same_dragon = 2;
	    break;
	  }
	moves[k].same_dragon = same_dragon;
      }
      else
	moves[k].same_dragon = 2;

      break;
    } /* if check_pattern_hard */
  }

  sgf_dumptree = save_sgf_dumptree;
  count_variations = save_count_variations;
  list->ordered_up_to = top+1;
  list->used = top+1;
  return (move_found);
}

#endif  /* PATTERN_CHECK_ON_DEMAND */

/* This function takes an array of already found moves (passed as
 * 'data') and looks for moves to replace these. Only moves near
 * the goal dragon are considered.
 */
static void
owl_shapes_callback(int m, int n, int color, struct pattern *pattern,
		    int ll, void *data)
{
  int tval;  /* trial move and its value */
  int move;
  struct owl_move_data *moves = data; /* considered moves passed as data */
  int same_dragon;

  /* Pick up the location of the move */
  move = AFFINE_TRANSFORM(pattern->movei, pattern->movej, ll, m, n);

  /* Before we do any expensive reading, check whether this move
   * already is known with a higher value or if there are too many
   * other moves with higher value.
   */
  if (!allpats) {
    int k;
    for (k = 0; k < MAX_MOVES; k++) {
      if (moves[k].value == -1)
	break;
      if (moves[k].pos == move) {
	if (moves[k].value >= pattern->value)
	  return;
	else
	  break;
      }
    }
    if (k == MAX_MOVES && moves[MAX_MOVES - 1].value >= pattern->value)
      return;
  }
  
  if (!check_pattern_hard(move, color, pattern, ll))
    return;

  /* and work out the value of this move */
  if (pattern->helper) {
    /* ask helper function to consider the move */
    gg_assert(0);
    DEBUG(DEBUG_HELPER, "  asking helper to consider '%s'+%d at %1m\n",
	  pattern->name, ll, move);
    tval = pattern->helper(pattern, ll, move, color);
    
    if (tval > 0) {
      DEBUG(DEBUG_HELPER, "helper likes pattern '%s' value %d at %1m\n",
	    pattern->name, tval, move);
    }
    else {
      DEBUG(DEBUG_HELPER, "  helper does not like pattern '%s' at %1m\n",
	    pattern->name, move);
      return;  /* pattern matcher does not like it */
    }
  }
  else { /* no helper */
    tval = (int) pattern->value;
  }

  /* having made it here, we have made it through all the extra checks */

  TRACE("Pattern %s found at %1m with value %d\n", pattern->name, move, tval);

  if (pattern->class & CLASS_B)
    same_dragon = 0;
  else if (pattern->class & CLASS_b)
    same_dragon = 1;
  else
    same_dragon = 2;
  
  owl_add_move(moves, move, tval, pattern->name, same_dragon);
}


/* Add a move to the list of candidate moves */

static void
owl_add_move(struct owl_move_data *moves, int move, int value,
	     const char *reason, int same_dragon)
{
  int k;

  if (!found_matches[move]) {
    found_matches[move] = 1;
    matches_found++;
  }
  
  /* Add the new move to the list of already found moves, if the value
   * is sufficently large. We keep the list sorted.
   *
   * First we must see if this move already is in the list.
   */
  for (k = 0; k < MAX_MOVES; k++) {
    if (moves[k].value == -1)
      break;
    if (moves[k].pos == move) {
      if (same_dragon > moves[k].same_dragon)
	moves[k].same_dragon = same_dragon;
      break;
    }
  }

  /* Did we already have this move in the list with a higher value? */
  if (k < MAX_MOVES && moves[k].value >= value)
    return;

  /* Insert the move at the right place in the list and adjust other
   * entries as needed.
   */
  for (; k >= 0; k--) {
    if (k == 0 || value <= moves[k-1].value) {
      /* Can't get higher. Insert the move below this point and quit
       * looping.
       */
      if (k < MAX_MOVES) {
	moves[k].pos = move;
	moves[k].value = value;
	moves[k].name = reason;
	/* If B or b class pattern, this move shouldn't be added to the
         * dragon under consideration.
	 */
	moves[k].same_dragon = same_dragon;
      }
      break;
    }
    /* Shuffle the passed move one step downwards. */
    if (k < MAX_MOVES)
      moves[k] = moves[k-1]; /* struct copy */
  }

  /* Assert that the list contains unique moves. */
  if (0) {
    int l;
    for (k = 0; k < MAX_MOVES; k++)
      for (l = k+1; l < MAX_MOVES; l++)
	gg_assert(moves[k].pos == 0
		  || moves[k].pos != moves[l].pos);
  }
}  


/* Marks the dragons at (apos) and (bpos). If only one dragon
 * needs marking, (bpos) should be passed as (0). 
 */

static void
owl_mark_dragon(int apos, int bpos, struct local_owl_data *owl)
{
  int pos;
  int color = board[apos];
  
  ASSERT1(bpos == NO_MOVE || board[bpos] == color, bpos);

  for (pos = BOARDMIN; pos < BOARDMAX; pos++)
    if (ON_BOARD(pos)) {
      if (is_same_dragon(pos, apos) || is_same_dragon(pos, bpos))
	owl->goal[pos] = 1;
      else
	owl->goal[pos] = 0;
    }

  owl->color = color;
  owl_mark_boundary(owl);
}


/* Marks the worms at (apos) and (bpos). If only one worm
 * needs marking, (bpos) should be passed as (0). 
 */

static void
owl_mark_worm(int apos, int bpos, struct local_owl_data *owl)
{
  int pos;
  int color = board[apos];
  
  ASSERT1(bpos == NO_MOVE || board[bpos] == color, bpos);

  for (pos = BOARDMIN; pos < BOARDMAX; pos++)
    if (ON_BOARD(pos)) {
      if (is_same_worm(pos, apos) || is_same_worm(pos, bpos))
	owl->goal[pos] = 1;
      else
	owl->goal[pos] = 0;
    }

  owl->color = color;
}


/* Mark the boundary strings of the dragon. A boundary string is marked 2
 * if it adjoins a friendly live dragon, 1 otherwise.
 */

static void
owl_mark_boundary(struct local_owl_data *owl)
{
  int pos;
  int other = OTHER_COLOR(owl->color);
  int k;
  
  memset(owl->boundary, 0, sizeof(owl->boundary));
  /* first find all boundary strings. */
  for (pos = BOARDMIN; pos < BOARDMAX; pos++)
    if (board[pos] == other && !owl->boundary[pos]) {
      for (k = 0; k < 8; k++)
	if (ON_BOARD(pos + delta[k]) && owl->goal[pos + delta[k]]) {
	  mark_string(pos, owl->boundary, 1);
	  break;
	}
    }
  
  /* Upgrade the mark of a boundary string if it adjoins a safe
   * friendly dragon.
   */
  for (pos = BOARDMIN; pos < BOARDMAX; pos++)
    if (board[pos] == other && owl->boundary[pos] == 1) {
      for (k = 0; k < 4; k++) {
	int pos2 = pos + delta[k];
	if (board[pos2] == owl->color
	    && !owl->goal[pos2]
	    && ((dragon[pos2].status != DEAD && countstones(pos2) > 2)
		|| dragon[pos2].status == ALIVE)) {
	  mark_string(pos, owl->boundary, 2);
	  break;
	}
      }
    }
  
  /* During the owl reading, stones farther away may become parts of
   * the boundary. We mark those strings neighboring some other
   * friendly dragon with boundary value 2 right away, since we have
   * no mechanism for detecting this later.
   */
  for (pos = BOARDMIN; pos < BOARDMAX; pos++)
    if (board[pos] == other && owl->boundary[pos] == 0) {
      int k;
      /* If a lunch has been amalgamated into a larger dragon, we
       * have to back out now.
       *
       * Notice that we assume that no stone of the attacking color
       * has been placed on the board with trymove() when this
       * function is called. Thus we can (mostly) trust the worm data for
       * stones of this color.
       */
      if (worm[pos].attack_codes[0] != 0
	  && worm[pos].size != dragon[pos].size)
	continue;
      
      /* This can happen if called when stackp > 0 */
      if (dragon[pos].id == -1)
	continue;
      
      for (k = 0; k < DRAGON2(pos).neighbors; k++) {
	int d = DRAGON2(pos).adjacent[k];
	int apos = dragon2[d].origin;
	
	if (board[apos] == owl->color && !owl->goal[apos]) {
	  owl->boundary[pos] = 2;
	  break;
	}
      }
    }
}

/* Add the stone just played to the goal dragon if same_dragon is
 * 2. We also add all stones belonging to the same generalized string
 * to the goal. If same_dragon is 1, we only add the stones if at
 * least one stone of the generalized string already was part of the
 * goal. If same_dragon is 0, we don't add any stones at all.
 */
static void
owl_update_goal(int pos, int same_dragon, struct local_owl_data *owl)
{
  int stones[MAX_BOARD * MAX_BOARD];
  int num_stones;
  int k;
  int do_add = 1;
  SGFTree *save_sgf_dumptree = sgf_dumptree;
  int save_count_variations = count_variations;
  
  if (same_dragon == 0)
    return;

  /* Turn off sgf output during find_superstring(). */
  sgf_dumptree = NULL;
  count_variations = 0;
  
  find_superstring(pos, &num_stones, stones);

  /* Turn sgf output back on. */
  sgf_dumptree = save_sgf_dumptree;
  count_variations = save_count_variations;
  
  /* If same_dragon field is 1, only add if the played stone
   * clearly is in contact with the goal dragon.
   */
  if (same_dragon == 1) {
    do_add = 0;
    for (k = 0; k < num_stones; k++)
      if (owl->goal[stones[k]] != 0) {
	do_add = 1;
	break;
      }
  }
  
  if (do_add)
    for (k = 0; k < num_stones; k++) {
      if (owl->goal[stones[k]] == 0) {
	if (0)
	  TRACE("Added %1m to goal.\n", stones[k]);
	owl->goal[stones[k]] = 2;
      }
    }

  if (0)
    goaldump(owl->goal);
}


/* We update the boundary marks. The boundary mark must be
 * constant on each string. It is nonzero if the string
 * adjoins the goal dragon, or if the string includes a
 * stone played in the course of analysis. If the string
 * adjoins a live friendly dragon, the boundary mark is 2.
 */
static void
owl_update_boundary_marks(int pos, struct local_owl_data *owl)
{
  char boundary_mark = 0;
  int k;

  for (k = 0; k < 4; k++) {
    int pos2 = pos + delta[k];
    if (ON_BOARD(pos2) && owl->boundary[pos2] > boundary_mark)
      boundary_mark = owl->boundary[pos2];
  }
  owl->boundary[pos] = boundary_mark;

  for (k = 0; k < 4; k++) {
    int pos2 = pos + delta[k];
    if (board[pos2] == board[pos]
	&& owl->boundary[pos2] < boundary_mark)
      mark_string(pos2, owl->boundary, boundary_mark);
  }
}

/* Lists the goal array. For use in GDB:
 * (gdb) set goaldump(goal).
 */

void
goaldump(char goal[BOARDMAX])
{
  int pos;
  for (pos = BOARDMIN; pos < BOARDMAX; pos++)
    if (goal[pos])
      gprintf("%o%1m (%d)  ", pos, (int) goal[pos]);
  gprintf("\n");
}


/* Add owl reasons. This function should be called once during
 * genmove.
 */

void
owl_reasons(int color)
{
  int pos;

  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (!ON_BOARD(pos) || board[pos] == EMPTY)
      continue;
    if (dragon[pos].origin == pos
	&& dragon[pos].matcher_status == CRITICAL
	&& dragon[pos].owl_attack_point != NO_MOVE) {
      if (board[pos] == color) {
	if (dragon[pos].owl_defense_point != NO_MOVE) {
	  add_owl_defense_move(dragon[pos].owl_defense_point, pos,
			       dragon[pos].owl_defense_code);
	  DEBUG(DEBUG_OWL, "owl: %1m defends %1m at move %d\n",
		dragon[pos].owl_defense_point, pos, movenum+1);
	}
      }
      else { /* opponent's dragon */
	/* We don't want to add this move reason if the attacker
	 * dies because the victim only formed a nakade shape.
	 *
	 * FIXME: This code overlaps heavily with some code in
	   * examine_move_safety() in move_reasons.c. The caching
	   * scheme should minimize the performance hit, but of course
	   * it's unfortunate to have the code duplication.
	   */
	int move = dragon[pos].owl_attack_point;
	
	/* No worries if we catch something big. */
	if (dragon[pos].effective_size < 8) {
	  /* Look through the neighbors of the victim for dragons of
	   * our color. If we find at least one being thought alive
	   * everything is ok. Otherwise we keep track of the
             * largest one for further examination.
	     */
	  int largest = 0;
	  int k;
	  int bpos = NO_MOVE;
	  int safe = 0;
	  for (k = 0; k < DRAGON2(pos).neighbors; k++) {
	    int d = DRAGON2(pos).adjacent[k];
	    if (DRAGON(d).color == color) {
	      if (DRAGON(d).matcher_status == ALIVE) {
		safe = 1;
		break;
	      }
	      if (DRAGON(d).size > largest) {
		bpos = dragon2[d].origin;
		largest = DRAGON(d).size;
	      }
	    }
	  }
	  
	  /* It may occasionally happen that no neighbor of our
	   * color was found. Assume safe in that case.
	   */
	  if (bpos == NO_MOVE)
	    safe = 1;
	  
	    /* If not yet thought safe, ask the owl code whether the
	     * owl attack defends the (largest) attacker.
	     */
	  if (!safe && owl_does_defend(move, bpos) != WIN) {
	    DEBUG(DEBUG_OWL,
		  "owl: %1m attacks %1m at move %d, but the attacker dies.\n",
		  move, pos, movenum+1);
	    DRAGON2(pos).safety = INESSENTIAL;
	    continue;
	  }
	}
	
	/* If we've reached this far, the attack is okay. */
	add_owl_attack_move(move, pos, dragon[pos].owl_attack_code);
	DEBUG(DEBUG_OWL, "owl: %1m attacks %1m at move %d\n", move, pos,
	      movenum+1);
      }
    }
    else if (dragon[pos].origin == pos
	     && dragon[pos].owl_status == DEAD
	     && dragon[pos].owl_threat_status == CAN_THREATEN_DEFENSE) {
      if (board[pos] == color 
	  && dragon[pos].owl_defense_point != NO_MOVE)
	add_owl_defense_threat_move(dragon[pos].owl_defense_point, pos, WIN);
      if (board[pos] == color
	    && dragon[pos].owl_second_defense_point != NO_MOVE
	  && is_legal(dragon[pos].owl_second_defense_point, color))
	add_owl_defense_threat_move(dragon[pos].owl_second_defense_point,
				    pos, WIN);
      /* If the opponent can threaten to live, an attacking
       * move gets a small value to make sure it's really dead.
       */
      if (board[pos] == OTHER_COLOR(color)
	  && dragon[pos].owl_threat_status == CAN_THREATEN_DEFENSE
	  && dragon[pos].owl_attack_point != NO_MOVE)
	add_owl_prevent_threat_move(dragon[pos].owl_attack_point, pos);
    }
    else if (dragon[pos].origin == pos
	     && dragon[pos].owl_status == ALIVE
	     && board[pos] == OTHER_COLOR(color)
	     && dragon[pos].owl_threat_status == CAN_THREATEN_ATTACK) {
      if (dragon[pos].owl_attack_point != NO_MOVE)
	add_owl_attack_threat_move(dragon[pos].owl_attack_point, pos, WIN);
      if (dragon[pos].owl_second_attack_point != NO_MOVE
	  && is_legal(dragon[pos].owl_second_attack_point, color))
	add_owl_attack_threat_move(dragon[pos].owl_second_attack_point, pos,
				   WIN);
    }
    /* The owl code found the friendly dragon alive, but was uncertain,
     * and an extra point of defense was found, so this might
     * be a good place to play.
     */
    else if (dragon[pos].origin == pos
	     && dragon[pos].owl_status == ALIVE
	     && board[pos] == color
	     && !dragon[pos].owl_attack_certain
	     && dragon[pos].owl_defense_certain
	     && ON_BOARD(dragon[pos].owl_defense_point))
      add_owl_uncertain_defense_move(dragon[pos].owl_defense_point, pos);
    /* The owl code found the dragon dead, but was uncertain,
     * and an extra point of attack was found, so this might
     * be a good place to play.
     */
    else if (dragon[pos].origin == pos
	     && dragon[pos].owl_status == DEAD
	     && board[pos] == OTHER_COLOR(color)
	     && !dragon[pos].owl_attack_certain
	     && ON_BOARD(dragon[pos].owl_attack_point))
      add_owl_uncertain_defense_move(dragon[pos].owl_attack_point, pos);
  }
}

/* Use the owl code to determine whether the move at (move) makes
 * the dragon at (target) owl safe. This is used to test whether
 * tactical defenses are strategically viable and whether a vital eye
 * point does kill an owl critical dragon. 
 *
 * Should be called only when stackp==0.
 */

int
owl_does_defend(int move, int target)
{
  int color = board[target];
  int result = 0;
  struct local_owl_data *owl;
  int reading_nodes_when_called = get_reading_node_counter();
  int tactical_nodes;
  int origin;
  int acode;
  double start = 0;

  if (debug & DEBUG_OWL_PERFORMANCE)
    start = gg_cputime();

  if (worm[target].unconditional_status == DEAD)
    return 0;

  origin = dragon[target].origin;
  TRACE("owl_does_defend %1m %1m(%1m)\n", move, target, origin);

  if (search_persistent_owl_cache(OWL_DOES_DEFEND, move, target, 0,
				  &result, NULL, NULL, NULL))
    return result;

  if (trymove(move, color, "owl_does_defend", target, EMPTY, 0)) {
    /* Check if a compatible owl_attack() is cached. */
    if (search_persistent_owl_cache(OWL_ATTACK, origin, 0, 0,
				    &result, NULL, NULL, NULL)) {
      popgo();
      return 3 - result;
    }
    
    init_owl(&owl, target, NO_MOVE, move, 1);
    acode = do_owl_attack(target, NULL, owl, EMPTY, 0);
    result = 3 - acode;
    popgo();
  }
  else
    return 0;  /* Don't cache anything in this case. */

  tactical_nodes = get_reading_node_counter() - reading_nodes_when_called;

  DEBUG(DEBUG_OWL_PERFORMANCE,
	"owl_does_defend %1m %1m(%1m), result %d (%d, %d nodes, %f seconds)\n",
	move, target, origin, result, owl->local_owl_node_counter, 
	tactical_nodes, gg_cputime() - start);

  store_persistent_owl_cache(OWL_DOES_DEFEND, move, target, 0,
			     result, 0, 0, 0,
			     tactical_nodes, owl->goal, board[target]);

  return result;
}


/* Use the owl code to determine whether the dragon at (target) is owl
 * safe after an own move at (move). This is used to detect
 * blunders. In case the dragon is not safe, it also tries to find a
 * defense point making (target) safe in a later move.
 *
 * Should be called only when stackp==0.
 */

int
owl_confirm_safety(int move, int target, int *defense_point)
{
  int color = board[target];
  int result = 0;
  struct local_owl_data *owl;
  int reading_nodes_when_called = get_reading_node_counter();
  int tactical_nodes;
  int origin;
  int defense = 0;
  double start = 0.0;

  if (debug & DEBUG_OWL_PERFORMANCE)
    start = gg_cputime();

  if (worm[target].unconditional_status == DEAD)
    return 0;

  origin = dragon[target].origin;
  TRACE("owl_confirm_safety %1m %1m(%1m)\n", move, target, origin);

  if (search_persistent_owl_cache(OWL_CONFIRM_SAFETY, move, target, 0,
				  &result, defense_point, NULL, NULL))
    return result;

  if (trymove(move, color, "owl_confirm_safety", target, EMPTY, NO_MOVE)) {
    /* Check if a compatible owl_attack() is cached. */
    if (search_persistent_owl_cache(OWL_ATTACK, origin, 0, 0,
				    &result, defense_point, NULL, NULL)) {
      popgo();
      if (!result)
	return WIN;
      else
	return 0;
    }
    
    init_owl(&owl, target, NO_MOVE, move, 1);
    if (!do_owl_attack(target, &defense, owl, EMPTY, NO_MOVE))
      result = WIN;
    popgo();
  }
  else
    return 0;  /* Don't cache anything in this case. */

  tactical_nodes = get_reading_node_counter() - reading_nodes_when_called;

  DEBUG(DEBUG_OWL_PERFORMANCE,
	"owl_confirm_safety %1m %1m(%1m), result %d %1m (%d, %d nodes, %f seconds)\n",
	move, target, origin, result, defense,
	owl->local_owl_node_counter, tactical_nodes,
	gg_cputime() - start);

  store_persistent_owl_cache(OWL_CONFIRM_SAFETY, move, target, 0,
			     result, defense, 0, 0,
			     tactical_nodes, owl->goal, board[target]);

  if (defense_point)
    *defense_point = defense;

  return result;
}


/* Use the owl code to determine whether the attack move at (move) of
 * the dragon (target) is effective, i.e. whether it kills the stones.
 *
 * Should be called only when stackp==0.
 */

int
owl_does_attack(int move, int target)
{
  int color = board[target];
  int other = OTHER_COLOR(color);
  int result = 0;
  struct local_owl_data *owl;
  int reading_nodes_when_called = get_reading_node_counter();
  int tactical_nodes;
  int origin;
  int dcode;
  double start = 0.0;

  if (debug & DEBUG_OWL_PERFORMANCE)
    start = gg_cputime();

  if (worm[target].unconditional_status == ALIVE)
    return 0;

  origin = dragon[target].origin;
  TRACE("owl_does_attack %1m %1m(%1m)\n", move, target, origin);

  if (search_persistent_owl_cache(OWL_DOES_ATTACK, move, target, 0,
				  &result, NULL, NULL, NULL))
    return result;

  /* FIXME: We want to do this after the trymove(), but currently
   * owl_mark_dragon() may crash if the trymove() happens to remove
   * some stones of the goal dragon from the board.
   */
#if 1
    init_owl(&owl, target, NO_MOVE, NO_MOVE, 1);
#endif

    if (trymove(move, other, "owl_does_attack", target, EMPTY, 0)) {
    /* Check if a compatible owl_defend() is cached. */
    if (search_persistent_owl_cache(OWL_DEFEND, origin, 0, 0,
				    &result, NULL, NULL, NULL)) {
      popgo();
      return 3 - result;
    }

#if 0
    owl->local_owl_node_counter = 0;
    owl->lunches_are_current = 0;
    owl_mark_dragon(target, NO_MOVE, owl);
#endif
    owl_update_boundary_marks(move, owl);
#if 0
    compute_owl_escape_values(owl);
#endif
    /* FIXME: Should also check if part of the dragon was captured,
     *        like do_owl_attack() does.
     */
    if (board[target] == EMPTY)
      dcode = 0;
    else
      dcode = do_owl_defend(target, NULL, owl, EMPTY, 0);
    result = 3 - dcode;
    owl->lunches_are_current = 0;
    popgo();
  }
  else
    return 0;  /* Don't cache anything in this case. */

  tactical_nodes = get_reading_node_counter() - reading_nodes_when_called;

  DEBUG(DEBUG_OWL_PERFORMANCE,
	"owl_does_attack %1m %1m(%1m), result %d (%d, %d nodes, %f seconds)\n",
	move, target, origin, result, owl->local_owl_node_counter, 
	tactical_nodes, gg_cputime() - start);

  store_persistent_owl_cache(OWL_DOES_ATTACK, move, target, 0,
			     result, 0, 0, 0,
			     tactical_nodes, owl->goal, board[target]);

  return result;
}


/* Use the owl code to determine whether connecting the two dragons
 * (target1) and (target2) by playing at (move) results in a living
 * dragon. Should be called only when stackp==0.
 */

int
owl_connection_defends(int move, int target1, int target2)
{
  int color = board[target1];
  int result = 0;
  int reading_nodes_when_called = get_reading_node_counter();
  int tactical_nodes;
  double start = 0.0;
  struct local_owl_data *owl;

  if (debug & DEBUG_OWL_PERFORMANCE)
    start = gg_cputime();

  gg_assert(board[target2] == color);
  TRACE("owl_connection_defends %1m %1m %1m\n", move, target1, target2);

  if (worm[target1].unconditional_status == DEAD)
    return 0;
  if (worm[target2].unconditional_status == DEAD)
    return 0;

  if (search_persistent_owl_cache(OWL_CONNECTION_DEFENDS, move, target1,
				  target2, &result, NULL, NULL, NULL))
    return result;

  init_owl(&owl, target1, target2, NO_MOVE, 1);

  if (trymove(move, color, "owl_connection_defends", target1, EMPTY, 0)) {
    owl_update_goal(move, 1, owl);
    if (!do_owl_attack(move, NULL, owl, EMPTY, 0))
      result = WIN;
    owl->lunches_are_current = 0;
    popgo();
  }
  tactical_nodes = get_reading_node_counter() - reading_nodes_when_called;
  
  DEBUG(DEBUG_OWL_PERFORMANCE,
	"owl_conn_defends %1m %1m %1m, result %d (%d, %d nodes, %f seconds)\n",
	move, target1, target2, result, owl->local_owl_node_counter,
	tactical_nodes, gg_cputime() - start);

  store_persistent_owl_cache(OWL_CONNECTION_DEFENDS, move, target1, target2,
			     result, 0, 0, 0, tactical_nodes,
			     owl->goal, color);

  return result;
}


/* This function attempts to make a list of dead strings
 * which may be relevant to the life of the goal dragon.
 * Such strings are called owl lunches. They are ignored
 * (treated as invisible) during the running of make_domains.
 *
 * In certain cases we also need to identify tactically safe strings
 * which should be included in the eyespace, e.g. in this position:
 *
 * -------
 * OXXOOXO
 * OX.O.XO
 * OXX.XXO
 * OOXXXOO
 * .OOOOO.
 *
 * The three O stones cannot be captured, but they can't live
 * independently without capturing the surrounding stones. We call
 * such stones INESSENTIAL and identify them by the condition that for
 * each liberty of the corresponding superstring, the following must
 * hold:
 *
 * 1. At least one neighbor of the liberty is the goal dragon.
 * 2. No neighbor of the liberty is the same color as the tested string.
 * 3. No neighbor of the liberty of the same color as the goal dragon
 *    does not belong to the goal dragon.
 * 4. No neighbor of the liberty belonging to the goal dragon can be
 *     tactically captured.
 *
 * There is a weakness with this characterization though, which can be
 * seen in this position:
 *
 * --------
 * OX..OOX.
 * OX.X.XOO
 * OX.XX.O.
 * O.XXOOO.
 * .OOOO...
 *
 * The two O stones intruding in X's eyespace cannot be tactically
 * captured and their liberties satisfy the requirements above. Still
 * it doesn't make any sense to count those stones as
 * inessential. Therefore we add another requirement on the stones
 * themself:
 *
 * 5. No neighbor of the stones does not belong to the goal or can be
 * tactically captured.
 */

static void
owl_find_lunches(struct local_owl_data *owl)
{
  int m, n;
  int k;
  int lunches = 0;
  int prevlunch;
  int lunch;
  int acode;
  int apos;
  int dcode;
  int dpos;
  int color = owl->color;
  int other = OTHER_COLOR(color);
  char already_checked[BOARDMAX];

  SGFTree *save_sgf_dumptree = sgf_dumptree;
  int save_count_variations = count_variations;
    
  sgf_dumptree = NULL;
  count_variations = 0;
  for (prevlunch = 0; prevlunch < MAX_LUNCHES; prevlunch++)
    owl->lunch[prevlunch] = NO_MOVE;
  memset(owl->inessential, 0, sizeof(owl->inessential));
  
  memset(already_checked, 0, sizeof(already_checked));
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      int pos = POS(m, n);
      if (board[pos] == color && owl->goal[pos]) {
	/* Loop over the eight neighbors. */
	for (k = 0; k < 8; k++) {
	  int d = delta[k];
	  
	  /* If the immediate neighbor is empty, we look two steps away. */
	  if (k < 4 && board[pos + d] == EMPTY)
	    d *= 2;
	  
	  if (board[pos + d] != other)
	    continue;
	    
	  lunch = find_origin(pos + d);
	  if (already_checked[lunch])
	    continue;
	  already_checked[lunch] = 1;
	  
	  attack_and_defend(lunch, &acode, &apos, &dcode, &dpos);
	  if (acode != 0) {
	    owl->lunch[lunches] = lunch;
	    owl->lunch_attack_code[lunches]  = acode;
	    owl->lunch_attack_point[lunches] = apos;
	    owl->lunch_defend_code[lunches]  = dcode;
	    if (dcode != 0)
	      owl->lunch_defense_point[lunches] = dpos;
	    else
	      owl->lunch_defense_point[lunches] = NO_MOVE;
	    lunches++;
	    if (lunches == MAX_LUNCHES) {
	      sgf_dumptree = save_sgf_dumptree;
	      count_variations = save_count_variations;
	      owl->lunches_are_current = 1;
	      return;
	    }
	  }
	  else if (!owl->inessential[lunch]) {
	    /* Test for inessentiality. */
	    int adj;
	    int adjs[MAXCHAIN];
	    int num_stones;
	    int stones[MAX_BOARD * MAX_BOARD];
	    int liberties;
	    int libs[MAXLIBS];
	    int r;
	    int essential = 0;
	    int superstring[BOARDMAX];

	    /* First check the neighbors of the string. */
	    adj = chainlinks(lunch, adjs);
	    for (r = 0; r < adj; r++) {
	      if (!owl->goal[adjs[r]] || attack(adjs[r], NULL) != 0) {
		essential = 1;
		break;
	      }
	    }
	    
	    if (essential)
	      continue;

	    find_superstring_stones_and_liberties(lunch, &num_stones, stones,
						  &liberties, libs, 0);

	    memset(superstring, 0, sizeof(superstring));
	    for (r = 0; r < num_stones; r++)
	      superstring[stones[r]] = 1;
	    
	    for (r = 0; r < liberties; r++) {
	      int bpos = libs[r];
	      int goal_found = 0;
	      int s;

	      for (s = 0; s < 4; s++) {
		int cpos = bpos + delta[s];

		if (!ON_BOARD(cpos))
		  continue;
		if (board[cpos] == color) {
		  if (attack(cpos, NULL) != 0) {
		    essential = 1;
		    break;
		  }
		  else if (owl->goal[cpos])
		    goal_found = 1;
		  else {
		    essential = 1;
		    break;
		  }
		}
		else if (board[cpos] == other
			 && !superstring[cpos]) {
		  essential = 1;
		  break;
		}
	      }
	      if (!goal_found)
		essential = 1;
	      
	      if (essential)
		break;
	    }
	    
	    if (!essential) {
	      TRACE("Inessential string found at %1m.\n", lunch);
	      for (r = 0; r < num_stones; r++)
		owl->inessential[stones[r]] = 1;
	    }
	  }
	}
      }
    }
  
  owl->lunches_are_current = 1;
  sgf_dumptree = save_sgf_dumptree;
  count_variations = save_count_variations;
}


/* Wrapper for make domains. The second set of owl data is optional.
 * Use a null pointer if it is not needed. Otherwise, make_domains
 * is run separately for the two owl data, but information about
 * tactically dead lunches is used from *both* sources through
 * the owl_lively() calls.
 */

static void
owl_make_domains(struct local_owl_data *owla, struct local_owl_data *owlb)
{
  /* We need to set this so that owl_lively() can be used. */
  current_owl_data = owla;
  other_owl_data = owlb;
  
  if (!owla->lunches_are_current)
    owl_find_lunches(owla);
  make_domains(owla->black_eye, owla->white_eye, 1);
  
  if (owlb) {
    if (!owlb->lunches_are_current)
      owl_find_lunches(owlb);
    make_domains(owlb->black_eye, owlb->white_eye, 1);
  }
}

/* True unless (pos) is EMPTY or occupied by a lunch for the goal dragon.  
 * Used during make_domains (see optics.c: lively macro). A ``lively''
 * worm is one that might be alive, hence cannot be ignored in 
 * determining eye spaces.
 */

int 
owl_lively(int pos)
{
  int origin;
  int lunch;
  ASSERT_ON_BOARD1(pos);

  if (board[pos] == EMPTY)
    return 0;
  origin = find_origin(pos);

  /* When reading a semeai there is a second set of owl data to consider.
   * Strings of the second owl are considered lively no matter what,
   * since declaring such a string dead prematurely can prevent the
   * semeai code from finishing its job.
   *
   * On the other hand a friendly string which is a lunch of the
   * other dragon and can't be saved is not lively.
   */
  if (other_owl_data) {
    if (other_owl_data->goal[pos])
      return 1;
    for (lunch = 0; lunch < MAX_LUNCHES; lunch++)
      if (other_owl_data->lunch[lunch] == origin
	  && other_owl_data->lunch_defense_point[lunch] == NO_MOVE)
	return 0;
  }
  /* Lunches that can't be saved are dead, so don't report them as lively. */

  for (lunch = 0; lunch < MAX_LUNCHES; lunch++)
    if (current_owl_data->lunch[lunch] == origin
	&& current_owl_data->lunch_defense_point[lunch] == NO_MOVE)
      return 0;
  
  /* Inessential stones are not lively. */
  if (current_owl_data->inessential[origin])
    return 0;
  
  return 1;
}


/* Caching version of safe_move for the callback. This function has
 * its own cache, separate from the global safe move cache. Note that
 * since the cache is reset by owl_shapes before starting pattern
 * matching, and since (unlike safe_move) this function is always
 * called from the same place in owl_shapes_callback, the color will
 * be the same each time it is called. So there is no need to have
 * separate caches for B and W.
 */

static int
owl_safe_move(int move, int color)
{
  int acode, safe = 0;

  if (trymove(move, color, "owl_safe_move", 0, EMPTY, 0)) {
    acode = attack(move, NULL);
    if (acode != WIN)
      safe = 1;
    else
      safe = 0;
    current_owl_data->lunches_are_current = 0;
    popgo();
  }
  current_owl_data->safe_move_cache[move] = safe+1;
  return safe;
}
  

/* This function, called when stackp==0, returns true if capturing
 * the string at (str) results in a live group.
 */

#define MAX_SUBSTANTIAL_LIBS 10

int
owl_substantial(int str)
{
  int k;
  int m, n;
  int libs[MAX_SUBSTANTIAL_LIBS + 1];
  int liberties = findlib(str, MAX_SUBSTANTIAL_LIBS+1, libs);
  int reading_nodes_when_called = get_reading_node_counter();
  int tactical_nodes;
  int result;
  double start = 0.0;
  struct local_owl_data *owl;

  if (debug & DEBUG_OWL_PERFORMANCE)
    start = gg_cputime();

  /* FIXME: We want to use the full init_owl here too (cf. similar
   * remark below).
   */
  reduced_init_owl(&owl);

  owl->color = OTHER_COLOR(board[str]);
  owl->local_owl_node_counter = 0;
  gg_assert(stackp == 0);

  /* Big strings are always substantial since the biggest nakade is
   * six stones. (There are probably rare exceptions to this
   * rule, but they are unlikely to come up in a game.)
   */
  if (countstones(str) > 6)
    return 1;
  
  if (liberties > MAX_SUBSTANTIAL_LIBS)
    return 0;
  
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++)
      owl->goal[POS(m, n)] = 0;
  /* Mark the neighbors of the string. If one is found which is alive, return
   * true. */
  {
    int adjs[MAXCHAIN];
    int adj;

    adj = chainlinks(str, adjs);
    for (k = 0; k < adj; k++) {
      if (dragon[adjs[k]].matcher_status == ALIVE)
	return 1;
      for (m = 0; m < board_size; m++)
	for (n = 0; n < board_size; n++)
	  if (is_same_dragon(POS(m, n), adjs[k]))
	    owl->goal[POS(m, n)] = 1;
    }
  }

  /* We must check the cache while stackp == 0, but we wait until the
   * trivial tests have been done.
   */
  if (search_persistent_owl_cache(OWL_SUBSTANTIAL, str, 0, 0,
				  &result, NULL, NULL, NULL))
    return result;

  /* fill all the liberties */
  for (k = 0; k < liberties; k++) {
    if (trymove(libs[k], owl->color, NULL, 0, EMPTY, 0)) {
      if (level >= 10)
	increase_depth_values();
      owl->goal[libs[k]] = 1;
    }
    else {
      /* if we can't fill, try swapping with the next liberty */
      if (k < liberties-1
	  && trymove(libs[k+1], owl->color, NULL, 0, EMPTY, 0)) {
	owl->goal[libs[k]] = 1;
	libs[k+1] = libs[k];
      }
      else {
	/* Can't fill the liberties. Give up! */
	while (stackp > 0) {
	  if (level >= 10)
	    decrease_depth_values();
	  popgo();
	}
	return 0;
      }
    }
  }
  /* FIXME: We would want to use init_owl() here too, but it doesn't
   * fit very well with the construction of the goal array above.
   */
  compute_owl_escape_values(owl);
  owl_mark_boundary(owl);
  owl->lunches_are_current = 0;

  if (do_owl_attack(libs[0], NULL, owl, EMPTY, 0))
    result = 0;
  else
    result = 1;
  while (stackp > 0) {
    if (level >= 10)
      decrease_depth_values();
    popgo();
  }

  tactical_nodes = get_reading_node_counter() - reading_nodes_when_called;
  DEBUG(DEBUG_OWL_PERFORMANCE,
	"owl_substantial %1m, result %d (%d, %d nodes, %f seconds)\n",
	str, result, owl->local_owl_node_counter,
	tactical_nodes, gg_cputime() - start);

  store_persistent_owl_cache(OWL_SUBSTANTIAL, str, 0, 0, result, 0, 0, 0,
			     tactical_nodes, owl->goal, owl->color);

  return result;
}



/* Returns true if and only if (i, j) is a 1-2 vertex, i.e. next to a
 * corner.
 */
static int
one_two_point(int pos)
{
  int i = I(pos);
  int j = J(pos);
  
  if ((i == 0 || i == board_size-1 || j == 0 || j == board_size-1)
      && (i == 1 || i == board_size-2 || j == 1 || j == board_size-2))
    return 1;

  return 0;
}



/* Reports the number of eyes gotten by capturing a boundary string.
 * This implementation tends to give an optimistic view of the
 * chances, so if it tells that the lunch is worthless, it truly
 * should be. The converse is not true.
 */

static void
sniff_lunch(int pos, int *min, int *probable, int *max,
	    struct local_owl_data *owl)
{
  int other = OTHER_COLOR(board[pos]);
  int size;

  ASSERT1(IS_STONE(board[pos]), pos);

  if (owl->boundary[pos] == 2) {
    *min = 2;
    *probable = 2;
    *max = 2;
    return;
  }

  size = countstones(pos);
  if (size > 6) {
    *min = 2;
    *probable = 2;
    *max = 2;
  }
  else if (size > 4) {
    *min = 1;
    *probable = 2;
    *max = 2;
  }
  else if (size > 2) {
    *min = 0;
    *probable = 1;
    *max = 2;
  }
  else if (size == 2) {
    int stones[2];
    findstones(pos, 2, stones);
    /* A lunch on a 1-2 point tends always to be worth contesting. */
    if ((obvious_false_eye(stones[0], other)
	|| obvious_false_eye(stones[1], other))
	&& !(one_two_point(stones[0]) || one_two_point(stones[1]))) {
      *min = 0;
      *probable = 0;
      *max = 0;
    }
    else {
      *min = 0;
      *probable = 1;
      *max = 1;
    }
  }
  else if (size == 1) {
    if (!obvious_false_eye(pos, other)) {
      *min = 0;
      *probable = 1;
      *max = 1;
    }
    else {
      *min = 0;
      *probable = 0;
      *max = 0;
    }
  }
}


/* Conservative relative of topological_eye. Essentially the same
 * algorithm is used, but only tactically safe opponent strings on
 * diagonals are considered. This may underestimate the false/half eye
 * status, but it should never be overestimated.
 */
int
obvious_false_eye(int pos, int color)
{
  int i = I(pos);
  int j = J(pos);
  int k;
  int diagonal_sum = 0;
  for (k = 4; k < 8; k++) {
    int di = deltai[k];
    int dj = deltaj[k];
    
    if (!ON_BOARD2(i+di, j) && !ON_BOARD2(i, j+dj))
      diagonal_sum--;
    
    if (!ON_BOARD2(i+di, j+dj))
      diagonal_sum++;
    else if (BOARD(i+di, j+dj) == OTHER_COLOR(color)
	     && !attack(POS(i+di, j+dj), NULL))
      diagonal_sum += 2;
  }
  
  return diagonal_sum >= 4;
}


/* Retrieve topological eye values stored in the half_eye[] array of
 * the current owl data.
 *
 * FIXME: Sooner or later we'll want this to return a non-rounded
 * value. When we change this, we have to review all patterns using
 * the autohelper owl_topological_eye().
 */
int
owl_topological_eye(int pos, int color)
{
  float value;
  UNUSED(color);
  value = current_owl_data->half_eye[pos].value;
  if (value > 2.0 && value < 4.0)
    return 3;
  else if (value <= 2.0)
    return (int) (value + 0.99); /* Round up. */
  else
    return (int) value;          /* Round down. */
}

/* This function returns true if it is judged that the capture of the
 * string at (pos) is sufficient to create one eye.
 */

int
vital_chain(int pos)
{
  int min;
  int probable;
  int max;
  sniff_lunch(pos, &min, &probable, &max, current_owl_data);

  if (max > 0)
    return 1;
  
  return 0;
}


static void
compute_owl_escape_values(struct local_owl_data *owl)
{
  int pos;
  int m, n;
  
  compute_escape_influence(owl->goal, owl->color, owl->escape_values, 0);
  DEBUG(DEBUG_ESCAPE, "Owl escape values:\n");

  for (m = 0; m < board_size; m++) {
    for (n = 0; n < board_size; n++) {
      pos = POS(m, n);
      if (dragon[pos].color == owl->color) {
	if (dragon[pos].status == ALIVE)
	  owl->escape_values[pos] = 6;
	else if (dragon[pos].status == UNKNOWN
		 && (DRAGON2(pos).escape_route > 5 || DRAGON2(pos).moyo > 5))
	  owl->escape_values[pos] = 4;
      }
      DEBUG(DEBUG_ESCAPE, "%o%d", owl->escape_values[pos]);
    }
    DEBUG(DEBUG_ESCAPE, "%o\n");
  }
}


/* Used by autohelpers. */
int
owl_escape_value(int pos)
{
  /* FIXME: Should have a more robust mechanism to avoid 
   * escaping inwards. Returning a negative value is just a kludge.
   */
  int k;
  ASSERT_ON_BOARD1(pos);
  if (current_owl_data->goal[pos])
    return -10;

  if (board[pos] == EMPTY)
    for (k = 0; k < 8; k++)
      if (ON_BOARD(pos + delta[k]) && current_owl_data->goal[pos + delta[k]])
	return -10;
  
  return current_owl_data->escape_values[pos];
}


/* Used by autohelpers. */
int
owl_goal_dragon(int pos)
{
  return current_owl_data->goal[pos] != 0;
}

/* Used by autohelpers.
 * Returns 1 if (apos) is an eyespace for the color having a stone
 * at (bpos), but only if it's worth at least a half eye.
 */
int
owl_eyespace(int apos, int bpos)
{
  int origin;
  ASSERT1(IS_STONE(board[bpos]), bpos);
  ASSERT_ON_BOARD1(apos);
  
  if (board[bpos] == WHITE) {
    origin = current_owl_data->white_eye[apos].origin;
    return (ON_BOARD(origin)
	    && current_owl_data->white_eye[origin].color == WHITE_BORDER
	    && current_owl_data->white_eye[origin].maxeye > 0);
  }
  else {
    origin = current_owl_data->black_eye[apos].origin;
    return (ON_BOARD(origin)
	    && current_owl_data->black_eye[origin].color == BLACK_BORDER
	    && current_owl_data->black_eye[origin].maxeye > 0);
  }
}
  

/* Used by autohelpers.
 * Returns 1 if (apos) is an eyespace for the color having a stone
 * at (bpos), which is possibly worth 2 eyes.
 */
int
owl_big_eyespace(int apos, int bpos)
{
  int origin;
  ASSERT1(IS_STONE(board[bpos]), bpos);
  ASSERT_ON_BOARD1(apos);

  if (board[bpos] == WHITE) {
    origin = current_owl_data->white_eye[apos].origin;
    return (ON_BOARD(origin) 
	    && current_owl_data->white_eye[origin].color == WHITE_BORDER
	    && current_owl_data->white_eye[origin].maxeye == 2);
  }
  else {
    origin = current_owl_data->black_eye[apos].origin;
    return (ON_BOARD(origin)
	    && current_owl_data->black_eye[origin].color == BLACK_BORDER
	    && current_owl_data->black_eye[origin].maxeye == 2);
  }
}
  

/* Used by autohelpers.
 * Returns 1 if (apos) is a non-marginal eyespace for the color having
 * a stone at (bpos).
 */
int
owl_proper_eye(int apos, int bpos)
{
  ASSERT1(IS_STONE(board[bpos]), bpos);
  ASSERT_ON_BOARD1(apos);

  if (board[bpos] == WHITE)
    return (current_owl_data->white_eye[apos].color == WHITE_BORDER
	    && !current_owl_data->white_eye[apos].marginal);
  else
    return (current_owl_data->black_eye[apos].color == BLACK_BORDER
	    && !current_owl_data->black_eye[apos].marginal);
}
  

static int
owl_escape_route(struct local_owl_data *owl)
{
  return dragon_escape(owl->goal, owl->color, owl->escape_values);
}


/****************************
 * Initialization of owl data
 ****************************/

/* This is a temporary solution. We want to be able to use the full
 * init_owl() also in owl_substantial.
 */
static void
reduced_init_owl(struct local_owl_data **owl)
{
  if (owl_stack_size == 0) {
    owl_stack_size = owl_reading_depth + 2;
    owl_stack = malloc(owl_stack_size * sizeof(*owl_stack));
    gg_assert(owl_stack != NULL);
  }
  *owl = &owl_stack[0];
}


/*
 * If use_stack is set, the stack is initialized, and the return value
 * of *owl is a pointer to the bottom of the stack.
 */
static void
init_owl(struct local_owl_data **owl, int target1, int target2, int move,
         int use_stack)
{
  if (use_stack)
    reduced_init_owl(owl);

  (*owl)->local_owl_node_counter = 0;
  (*owl)->lunches_are_current = 0;
  owl_mark_dragon(target1, target2, *owl);
  if (move != NO_MOVE)
    owl_update_goal(move, 1, *owl);
  compute_owl_escape_values(*owl);
}


/***********************
 * Storage of owl data
 ***********************/

/* Push owl data one step upwards in the stack. The stack is dynamically
 * reallocated if it is too small.
 */
static void
push_owl(struct local_owl_data **owl)
{
  gg_assert(*owl == &owl_stack[owl_stack_pointer]);
  /* Do we need to enlarge the stack? */
  if (owl_stack_pointer == owl_stack_size - 1) {
    if (0)
      gprintf("Have to enlarge owl stack!");
    owl_stack_size++;
    owl_stack = realloc(owl_stack, owl_stack_size * sizeof(*owl_stack));
    gg_assert(owl_stack != NULL);
    *owl = &owl_stack[owl_stack_pointer];
  }

  /* Copy the owl data. */
  owl_stack_pointer++;
  owl_stack[owl_stack_pointer] = **owl;
  *owl = &owl_stack[owl_stack_pointer];
}

/* Retrieve owl data from the stack. The local_owl_node_counter field
 * is not reset.
 */
static void
pop_owl(struct local_owl_data **owl)
{
  int nodes = (*owl)->local_owl_node_counter;
  gg_assert(*owl == &owl_stack[owl_stack_pointer]);
  owl_stack_pointer--;
  *owl = &owl_stack[owl_stack_pointer];
  (*owl)->local_owl_node_counter = nodes;
}

/***********************
 * Persistent owl cache
 ***********************/

#define HIGH_LIBERTY_BIT 4

/* FIXME: Unify with the same function in reading.c. */
static void
draw_active_area(char board[BOARDMAX], int apos)
{
  int i, j, ii;
  int c = ' ';

  start_draw_board();
  
  for (i = 0; i < board_size; i++) {
    ii = board_size - i;
    fprintf(stderr, "\n%2d", ii);
    
    for (j = 0; j < board_size; j++) {
      if (board[POS(i, j)] == EMPTY)
	c = '.';
      else if (board[POS(i, j)] == WHITE)
	c = 'o';
      else if (board[POS(i, j)] == (WHITE | HIGH_LIBERTY_BIT))
	c = 'O';
      else if (board[POS(i, j)] == BLACK)
	c = 'x';
      else if (board[POS(i, j)] == (BLACK | HIGH_LIBERTY_BIT))
	c = 'X';
      if (board[POS(i, j)] == GRAY)
	c = '?';
      
      if (POS(i, j) == apos)
	fprintf(stderr, "[%c", c);
      else if (j > 0 && POS(i, j-1) == apos)
	fprintf(stderr, "]%c", c);
      else
	fprintf(stderr, " %c", c);
    }
    
    fprintf(stderr, " %d", ii);
  }

  end_draw_board();
}

/* Returns 1 if the stored board is compatible with the current board,
 * 0 otherwise.
 */
static int
verify_stored_board(char p[BOARDMAX])
{
  int pos;
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (!ON_BOARD(pos))
      continue;
    else if (p[pos] == GRAY)
      continue;
    else if ((p[pos] & 3) != board[pos])
      return 0;
    else if (!(p[pos] & HIGH_LIBERTY_BIT))
      continue;
    else if (countlib(pos) <= 4)
      return 0;
  }
  
  return 1;
}

/* Remove persistent cache entries which are no longer compatible with
 * the board. For efficient use of the cache, it's recommended to call
 * this function once per move, before starting the owl reading. It's
 * not required for correct operation though. 
 */
void
purge_persistent_owl_cache()
{
  int k;
  static int last_purge_position_number = -1;
  gg_assert(stackp == 0);

  /* Never do this more than once per move. */
  if (last_purge_position_number == position_number)
    return;
  else
    last_purge_position_number = position_number;

  for (k = 0; k < persistent_owl_cache_size; k++) {
    if (persistent_owl_cache[k].boardsize != board_size
	|| !verify_stored_board(persistent_owl_cache[k].board)) {
      /* Move the last entry in the cache here and back up the loop
       * counter to redo the test at this position in the cache.
       */
      if (k < persistent_owl_cache_size - 1)
	persistent_owl_cache[k] 
	  = persistent_owl_cache[persistent_owl_cache_size - 1];
      k--;
      persistent_owl_cache_size--;
    }
  }
}

static int
search_persistent_owl_cache(int routine, int apos, int bpos, int cpos,
			    int *result, int *move, int *move2, int *certain)
{
  int k;
  gg_assert(stackp == 0 || stackp == 1);

  for (k = 0; k < persistent_owl_cache_size; k++) {
    if (persistent_owl_cache[k].routine == routine
	&& persistent_owl_cache[k].apos == apos
	&& persistent_owl_cache[k].bpos == bpos
	&& persistent_owl_cache[k].cpos == cpos
	&& verify_stored_board(persistent_owl_cache[k].board)) {
      *result = persistent_owl_cache[k].result;
      if (move) *move = persistent_owl_cache[k].move;
      if (move2) *move2 = persistent_owl_cache[k].move2;
      if (certain) *certain = persistent_owl_cache[k].result_certain;
      DEBUG(DEBUG_OWL_PERSISTENT_CACHE,
	    "persistent owl cache hit: routine %s at %1m result %d\n",
	    routine_to_string(routine), apos, bpos, cpos, 
	    result_to_string(persistent_owl_cache[k].result));
      return 1;
    }
  }
  return 0;
}

static void
store_persistent_owl_cache(int routine, int apos, int bpos, int cpos,
			   int result, int move, int move2, int certain,
			   int tactical_nodes,
			   char goal[BOARDMAX], int goal_color)
{
  char active[BOARDMAX];
  int pos;
  int k;
  int r;
  int other = OTHER_COLOR(goal_color);
  gg_assert(stackp == 0);

  /* If cache is full, first try to purge it. */
  if (persistent_owl_cache_size == MAX_OWL_CACHE_SIZE)
    purge_persistent_owl_cache();

  /* FIXME: Kick out oldest or least expensive entry instead of giving up. */
  if (persistent_owl_cache_size == MAX_OWL_CACHE_SIZE) {
    DEBUG(DEBUG_OWL_PERFORMANCE, "Persistent owl cache full.\n");
    return;
  }

  persistent_owl_cache[persistent_owl_cache_size].boardsize  	 = board_size;
  persistent_owl_cache[persistent_owl_cache_size].routine    	 = routine;
  persistent_owl_cache[persistent_owl_cache_size].apos	     	 = apos;
  persistent_owl_cache[persistent_owl_cache_size].bpos	     	 = bpos;
  persistent_owl_cache[persistent_owl_cache_size].cpos	     	 = cpos;
  persistent_owl_cache[persistent_owl_cache_size].result     	 = result;
  persistent_owl_cache[persistent_owl_cache_size].result_certain = certain;
  persistent_owl_cache[persistent_owl_cache_size].move	         = move;
  persistent_owl_cache[persistent_owl_cache_size].move2	         = move2;
  persistent_owl_cache[persistent_owl_cache_size].tactical_nodes =
    tactical_nodes;
  persistent_owl_cache[persistent_owl_cache_size].movenum = movenum;
  
  /* Remains to set the board. We let the active area be
   * the goal +
   * distance four expansion through empty intersections and own stones +
   * adjacent opponent strings +
   * liberties of adjacent opponent strings with less than five liberties +
   * liberties of low liberty neighbors of adjacent opponent strings
   * with less than five liberties.
   */
  for (pos = BOARDMIN; pos < BOARDMAX; pos++)
    if (ON_BOARD(pos))
      active[pos] = (goal[pos] != 0);

  /* Also add critical moves to the active area. */
  if (ON_BOARD1(move))
    active[move] = 1;

  if (ON_BOARD1(move2))
    active[move2] = 1;

  for (k = 1; k < 5; k++) {
    for (pos = BOARDMIN; pos < BOARDMAX; pos++){
      if (!ON_BOARD(pos) || board[pos] == other || active[pos] != 0) 
	continue;
      if ((ON_BOARD(SOUTH(pos)) && active[SOUTH(pos)] == k)
	  || (ON_BOARD(WEST(pos)) && active[WEST(pos)] == k)
	  || (ON_BOARD(NORTH(pos)) && active[NORTH(pos)] == k)
	  || (ON_BOARD(EAST(pos)) && active[EAST(pos)] == k)) {
	if (board[pos] == EMPTY)
	  active[pos] = k + 1;
	else
	  mark_string(pos, active, (char) (k + 1));
      }
    }
  }
  
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (board[pos] != other || active[pos] != 0) 
      continue;
    for (r = 0; r < 4; r++) {
      int pos2 = pos + delta[r];
      if (ON_BOARD(pos2) && board[pos2] != other && active[pos2] != 0) {
	active[pos] = 1;
	break;
      }
    }
  }
  
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (board[pos] == other && active[pos] != 0 && countlib(pos) < 5) {
      int libs[4];
      int liberties = findlib(pos, 4, libs);
      int adjs[MAXCHAIN];
      int adj;
      for (r = 0; r < liberties; r++)
	active[libs[r]] = 1;
      
      /* Also add liberties of neighbor strings if these are three
       * or less.
       */
      adj = chainlinks(pos, adjs);
      for (r = 0; r < adj; r++) {
	if (countlib(adjs[r]) <= 3) {
	  int s;
	  liberties = findlib(adjs[r], 3, libs);
	  for (s = 0; s < liberties; s++)
	    active[libs[s]] = 1;
	}
      }
    }
  }
  
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    int value = board[pos];
    if (!ON_BOARD(pos))
      continue;
    if (!active[pos])
      value = GRAY;
    else if (IS_STONE(board[pos]) && countlib(pos) > 4)
      value |= HIGH_LIBERTY_BIT;
    
    persistent_owl_cache[persistent_owl_cache_size].board[pos] = value;
  }

  if (debug & DEBUG_OWL_PERSISTENT_CACHE) {
    gprintf("%o Stored result in cache (entry %d):\n",
	    persistent_owl_cache_size);
    print_persistent_owl_cache_entry(persistent_owl_cache_size);
  }
  
  persistent_owl_cache_size++;
}


/* For debugging purposes. */
static void
print_persistent_owl_cache_entry(int k)
{
  struct owl_cache *entry = &(persistent_owl_cache[k]);
  gprintf("%omovenum         = %d\n",  entry->movenum);
  gprintf("%otactical_nodes  = %d\n",  entry->tactical_nodes);
  gprintf("%oroutine         = %s\n",  routine_to_string(entry->routine));
  gprintf("%o(apos)          = %1m\n", entry->apos);
  gprintf("%o(bpos)          = %1m\n", entry->bpos);
  gprintf("%o(cpos)          = %1m\n", entry->cpos);
  gprintf("%oresult          = %d\n",  entry->result);
  gprintf("%o(move)          = %1m\n", entry->move);
  gprintf("%o(move2)         = %1m\n", entry->move2);
  
  draw_active_area(entry->board, entry->apos);
}


/* Helper for the owl_hotspots() function below. */
static void
mark_dragon_hotspot_values(float values[BOARDMAX], int dr,
			   float contribution, char active_board[BOARDMAX])
{
  int pos;
  int k;
  ASSERT1(IS_STONE(board[dr]), dr);
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (board[pos] != EMPTY)
      continue;
    for (k = 0; k < 8; k++) {
      int pos2 = pos + delta[k];
      if (IS_STONE(board[pos2])
	  && (is_same_dragon(pos2, dr)
	      || (are_neighbor_dragons(pos2, dr)
		  && board[pos2] == board[dr]))
	  && (countlib(pos2) <= 4
	      || is_edge_vertex(pos))) {
	if (k < 4) {
	  if (is_same_dragon(pos2, dr))
	    values[pos] += contribution;
	  else
	    values[pos] += 0.5 * contribution;
	  break;
	}
	else {
	  /* If pos2 = SOUTHWEST(pos), this construction makes
	   *    pos3 = SOUTH(pos) and
	   *    pos4 = WEST(pos)
	   * and corresponding for all other diagonal movements.
	   */
	  int pos3 = pos + delta[k % 4];
	  int pos4 = pos + delta[(k+1) % 4];
	  if (board[pos3] == EMPTY || countlib(pos3) <= 2
	      || board[pos4] == EMPTY || countlib(pos4) <= 2)
	    values[pos] += 0.5 * contribution;
	  break;
	}
      }
    }
    /* If not close to the dragon, but within the active area, give
     * negative hotspot contribution.
     */
    if (k == 8 && active_board[pos] == EMPTY) {
      values[pos] -= 0.5 * contribution;
    }
  }
}
  

/* Based on the entries in the owl cache and their tactical_nodes
 * field, compute where the relatively most expensive owl reading is
 * going on.
 */
void
owl_hotspots(float values[BOARDMAX])
{
  int pos;
  int k, r;
  int libs[MAXLIBS];
  int liberties;
  int sum_tactical_nodes = 0;

  /* Don't bother checking out of board. Set values[] to zero there too. */
  for (pos = BOARDMIN; pos < BOARDMAX; pos++)
    values[pos] = 0.0;
  
  /* Compute the total number of tactical nodes for the cached entries. */
  for (k = 0; k < persistent_owl_cache_size; k++)
    sum_tactical_nodes += persistent_owl_cache[k].tactical_nodes;

  if (sum_tactical_nodes <= 100)
    return;

  /* Loop over all entries and increase the value of vertices adjacent
   * to dragons involving expensive owl reading.
   */
  for (k = 0; k < persistent_owl_cache_size; k++) {
    struct owl_cache *entry = &(persistent_owl_cache[k]);
    float contribution = entry->tactical_nodes / (float) sum_tactical_nodes;
    if (debug & DEBUG_OWL_PERSISTENT_CACHE) {
      gprintf("Owl hotspots: %d %1m %f\n", entry->routine, entry->apos,
	      contribution);
    }
    switch (entry->routine) {
    case OWL_ATTACK:
    case OWL_THREATEN_ATTACK:
    case OWL_DEFEND:
    case OWL_THREATEN_DEFENSE:
      mark_dragon_hotspot_values(values, entry->apos,
				 contribution, entry->board);
      break;
    case OWL_DOES_DEFEND:
    case OWL_DOES_ATTACK:
    case OWL_CONFIRM_SAFETY:
      mark_dragon_hotspot_values(values, entry->bpos,
				 contribution, entry->board);
      break;
    case OWL_CONNECTION_DEFENDS:
      mark_dragon_hotspot_values(values, entry->bpos,
				 contribution, entry->board);
      mark_dragon_hotspot_values(values, entry->cpos,
				 contribution, entry->board);
      break;
    case OWL_SUBSTANTIAL:
      /* Only consider the liberties of (apos). */
      liberties = findlib(entry->apos, MAXLIBS, libs);
      for (r = 0; r < liberties; r++)
	values[libs[r]] += contribution;
      break;
    default:
      gg_assert(0); /* Shouldn't happen. */
      break;
    }
  }
}


/* Returns the number of worms in the goal dragon, and a pointer to each */

static int
catalog_goal(struct local_owl_data *owl, int goal_worm[MAX_WORMS])
{
  int pos;
  int worms = 0;
  int k;

  for (k = 0; k < MAX_WORMS; k++)
    goal_worm[k] = NO_MOVE;

  for (pos = BOARDMIN; pos < BOARDMAX && worms < MAX_WORMS; pos++)
    if (ON_BOARD(pos)
	&& board[pos]
	&& (owl->goal)[pos]) {
      int origin = find_origin(pos);
      if (pos == origin) {
	if (0) {
	  DEBUG(DEBUG_SEMEAI, "goal worm: %1m\n", pos);
	}
	goal_worm[worms++] = pos;
      }
    }
  return worms;
}



/***********************/

/* Clear statistics. */
void
reset_owl_node_counter()
{
  global_owl_node_counter = 0;
}


/* Retrieve statistics. */
int
get_owl_node_counter()
{
  return global_owl_node_counter;
}


/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */


/* readconnect.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* #include <stdio.h> */
/* #include <stdlib.h> */
/* #include <stdarg.h> */
/* #include <string.h> */

/* #include "gnugo.h" */
/* #include "liberty.h" */
/* #include "gg_utils.h" */

/* #include "cache.h" */


/* Size of array where candidate moves are stored. */
/* emgena */
#undef MAX_MOVES
#define MAX_MOVES 362

/* trace of a search */

typedef struct _zone {
  int array[BOARDMAX];
  unsigned int bits[1+BOARDMAX/32];
  int i;
} zone;

static int recursive_connect2(int str1, int str2, int *move,
			      int komaster, int kom_pos, int has_passed);
static int recursive_disconnect2(int str1, int str2, int *move,
				 int komaster, int kom_pos, int has_passed);

static int add_array(int *array, int elt);
static int element_array(int *array,int elt);
static void intersection_array(int *array1, int *array2);
static int snapback(int str);
static int connection_one_move(int str1, int str2);
static int prevent_connection_one_move(int *moves, int str1, int str2);
static int connected_one_move(int str1, int str2);
static int moves_to_connect_in_two_moves(int *moves, int str1, int str2);
static int connection_two_moves(int str1, int str2);
static int prevent_connection_two_moves(int *moves, int str1, int str2);
#if 0
static int connected_two_moves(int str1, int str2);
#endif
static int moves_to_connect_in_three_moves(int *moves, int str1, int str2,
					   int does_connect);
#if 0
static int simple_connection_three_moves(int str1, int str2);
static int prevent_simple_connection_three_moves(int *moves,
						 int str1, int str2);
#endif

static int recursive_connect(int str1, int str2, int *move);
static int recursive_disconnect(int str1, int str2, int *move);

static int quiescence_connect(int str1, int str2, int *move);
static int quiescence_capture(int str, int *move);
/* static int capture_one_move(int str); */
static int prevent_capture_one_move(int *moves, int str1);
static int recursive_transitivity(int str1, int str2, int str3, int *move);
static int recursive_non_transitivity(int str1, int str2, int str3, int *move);
static void order_connection_moves(int *moves, int str1, int str2,
				   int color_to_move, const char *funcname);

int nodes_connect = 0;
int max_nodes_connect = 2000;
int max_connect_depth = 64;
int max_connect_depth2 = 20; /* Used by the alternate algorithm. */

/* Statistics. */
static int global_connection_node_counter = 0;

static void
init_zone(zone *zn)
{
  zn->array[0] = 0;
  memset(zn->bits, 0, 1 + BOARDMAX / 8);
}

/* send back 1 if the intersection is in the zone
 */

#if 0
static int
elt_zone(zone *zn, int elt)
{
  if ((zn->bits[elt >> 5] >> (elt & 31)) & 1)
    return 1;
  return 0;
}
#endif

/* Adds an intersection to a zone
 */

static void
add_zone(zone *zn, int elt)
{
  if (((zn->bits[elt >> 5] >> (elt & 31)) & 1) == 0) {
    zn->bits[elt >> 5] |= (1 << (elt & 31));
    zn->array[0]++;
    zn->array[zn->array[0]] = elt;
  }
}

/* start to loop over a zone
 */

#if 0
static int
start_zone(zone *zn)
{
  if (zn->array[0] < 1)
    return -1;
  zn->i = 1;
  return zn->array[1];
}
#endif

/* continue to loop over a zone
 */

#if 0
static int
next_zone(zone *zn)
{
  zn->i++;
  if (zn->i > zn->array[0])
    return -1;
  return zn->array[zn->i];
}
#endif

/* only keep the elements of zn1 which are also in zn2 */

#if 0
static void
intersection_zone(zone *zn1, zone *zn2)
{
  int r, s;
  
  for (r = start_zone(zn1); r > -1; r = next_zone(zn1))
    if (!elt_zone(zn2, r)) {
      for (s = r; s < zn1->array[0]; s++)
	zn1->array[s] = zn1->array[s+1];
      zn1->bits[r >> 5] &= ~ (1 << (r & 31));
      zn1->array[0]--;
      zn1->i--;
    }
}
#endif

/* Adds an integer to an array of integers if it is not already there.
 * The number of elements of the array is in array[0].
 */

static int
add_array(int *array, int elt)
{
  int r;
  
  for (r = 1; r < array[0] + 1; r++)
    if (array[r] == elt)
      return 0;

  array[0]++;
  array[array[0]] = elt;
  return 1;
}

/* test if an element is part of an array */

static int
element_array(int *array,int elt)
{
  int r;
  for (r = 1; r < array[0] + 1; r++)
    if (array[r] == elt)
      return 1;
  return 0;
}

/* only keep the elements of array1 which are also in array2 */

static void
intersection_array(int *array1, int *array2)
{
  int r, s;
  
  for (r = 1; r < array1[0] + 1; r++)
    if (!element_array(array2, array1[r])) {
      for (s = r; s< array1[0]; s++)
	array1[s]=array1[s+1];
      array1[0]--;
      r--;
    }
}

/* verifies that capturing the stone at str is not a snapback */

static int
snapback(int str)
{
  int stones, liberties, lib;
  SGFTree *save_sgf_dumptree = sgf_dumptree;

  /* if more than one stone captured, not a snapback */
  stones = countstones(str);
  if (stones > 1)
    return 0;

  /* if more than one liberty, not a snapback */
  liberties = findlib(str, 1, &lib);
  if (liberties > 1)
    return 0;

  /* turn off the sgf traces
   */
  sgf_dumptree = NULL;
  
  /* if only one liberty after capture */
  if (trymove(lib, OTHER_COLOR(board[str]), "snapback", str, EMPTY, 0)) {
    liberties = 0;
    if (IS_STONE(board[lib]))
      liberties = countlib(lib);
    popgo();
    sgf_dumptree = save_sgf_dumptree;
    if (liberties > 1)
      return 0;
    return WIN;
  }
  
  /* Turn the sgf traces back on. */
  sgf_dumptree = save_sgf_dumptree;
  
  return 0;
}

/* connection by playing and finding a ponnuki after play */

static int
ponnuki_connect(int *moves, int str1, int str2, zone *zn)
{
  int r, s, k, res = 0;
  int liberties, libs[MAXLIBS];
  int adj, adjs[MAXCHAIN];
  int neighb, neighbs[MAXCHAIN];

  /* finds connection through two forbidden liberties for
   * the opponent
   * + + + + + + +
   * + + @ O O @ +
   * + @ + @ @ x +
   * + + @ + + + +
   * - - - - - - -
   *
   * + + + + + + +
   * + + @ O O @ +
   * + @ + @ @ O @
   * + + @ + + x +
   * - - - - - - -
   */
  liberties = findlib(str1, MAXLIBS, libs);
  for (r = 0; r < liberties; r++)
    if (is_self_atari(libs[r], OTHER_COLOR(board[str1]))) 
      for (k = 0; k < 4; k++) {
	int pos = libs[r] + delta[k];
	if (board[pos] == board[str1]
	    && !same_string(pos, str1)
	    && !same_string(pos, str2) ) {
	  /* try to connect pos to str2 in one move */
	  /* play a common liberty */
	  neighb = findlib(pos, MAXLIBS, neighbs);
	  for (s = 0; s < neighb; s++)
	    if (liberty_of_string(neighbs[s], str2)) {
	      res = 1;
	      add_zone(zn, libs[r]);
	      add_zone(zn, neighbs[s]);
	      add_array(moves, neighbs[s]);
	    }
	  /* or capture a common adjacent string */
	  adj = chainlinks2(pos, adjs, 1);
	  for (s = 0; s < adj; s++)
	    if (adjacent_strings(adjs[s], str2)
		&& !snapback(adjs[s])) {
	      res = 1;
	      neighb = findlib(adjs[s], 1, neighbs);
	      add_zone(zn, libs[r]);
	      add_zone(zn, neighbs[0]);
	      add_array(moves, neighbs[0]);
	    }
	}
      }
  
  return res;
}

/* connection in one move, finds all moves and memorizes intersections
 * involved in the connection.
 */

static int
moves_connection_one_move(int *moves, int str1, int str2, zone *zn)
{
  int r;
  int adj, adjs[MAXCHAIN];

  /* If one string is missing we have already failed. */
  if (board[str1] == EMPTY || board[str2] == EMPTY)
    return 0;

  /* Common liberties. */
  if (have_common_lib(str1, str2, NULL))
    return WIN;

  /* Common adjacent string in atari, more than one stone, no snapback. */
  adj = chainlinks2(str1, adjs, 1);
  for (r = 0; r < adj; r++)
    if (adjacent_strings(adjs[r], str2)
        && !snapback(adjs[r]))
      return WIN;
  
  /* Connections through a ponnuki */
  if (ponnuki_connect(moves, str1, str2, zn))
    return WIN;
  if (ponnuki_connect(moves, str2, str1, zn))
    return WIN;

  return 0;
}

/* Verifies that the strings str1 and str2 can be connected
 * directly by playing one move, either by playing a common liberty
 * of the two strings, or by capturing a common adjacent string.
 *
 * This is the gi1 game function.
 */

static int
connection_one_move(int str1, int str2)
{
  int moves[BOARDMAX];
  zone zn;
  init_zone(&zn);
  moves[0] = 0;
  return moves_connection_one_move(moves, str1, str2, &zn);
}

/* If the two strings str1 and str2 can be connected sends back WIN fill the
 * array moves with the only move that can prevent a connection in one move
 * (common liberties, liberties of common adjacent strings in atari).
 *
 * This is the ip1 game function. */

static int
prevent_connection_one_move(int *moves, int str1, int str2)
{
  int r, s;
  int liberties, libs[MAXLIBS];
  int adj, adjs[MAXCHAIN];
  int adjadj, adjadjs[MAXCHAIN];
  
  /* Common liberties. */
  if (have_common_lib(str1, str2, libs)) {
    add_array(moves, libs[0]);
    return WIN;
  }
  
  /* Save a common adjacent string in atari, more than one stone, no snapback.
   */
  adj = chainlinks2(str1, adjs, 1);
  for (r = 0; r < adj; r++)
    if (adjacent_strings(adjs[r], str2)
        && !snapback(adjs[r])) {
      liberties = findlib(adjs[r], MAXLIBS, libs);
      add_array(moves, libs[0]);
      adjadj = chainlinks2(adjs[r], adjadjs, 1);
      for (s = 0; s < adjadj; s++) {
	findlib(adjadjs[s], MAXLIBS, libs);
	add_array(moves, libs[0]);
      }
      return WIN;
    }
  
  return 0;
}

/* Returns WIN if str1 and str2 are connected in at most
 * one move even if the opponent plays first.
 * Verify that the strings are connectable in one move
 * and find the only possible moves that can prevent
 * using prevent_connection_one_move. If none of these
 * moves works, the two strings are connected.
 *
 * This is the g1 game function.
 */

static int
connected_one_move(int str1, int str2)
{
  int r, res = 0;
  int moves[MAX_MOVES];
  SGFTree *save_sgf_dumptree = sgf_dumptree;

  /* turn off the sgf traces
   */
  sgf_dumptree = NULL;
  
  moves[0] = 0;
  if (prevent_connection_one_move(moves, str1, str2)) {
    order_connection_moves(moves, str1, str2, OTHER_COLOR(board[str1]),
			   "connected_one_move");
    res = WIN;
    for (r = 1; ((r < moves[0] + 1) && res); r++) {
      if (trymove(moves[r], OTHER_COLOR(board[str1]),
		  "connected_one_move", str1, EMPTY, 0)) {
	if (!connection_one_move(str1, str2))
	  res = 0;
	popgo();
      }
    }
  }

  /* Turn the sgf traces back on. */
  sgf_dumptree = save_sgf_dumptree;
  
  return res;
}

/* Find the moves that might be able to connect in less than three plies.
 * That is moves that can connect the strings if another move of the same
 * color is played just after:
 * - common liberties of the two strings;
 * - moves on the liberties of an opponent string with less than two
 *   liberties adjacent to both strings, or adjacent to one string and
 *   that has a common liberty with the second string;
 * - liberties of one string that are second order liberties of the
 *   other string.
 *
 * Returns WIN if a direct connection has been found. Returns 0
 * otherwise.
 */

static int
moves_to_connect_in_two_moves(int *moves, int str1, int str2)
{
  int r, s, common_adj_liberty;
  int liberties, libs[MAXLIBS];
  int adj, adjs[MAXCHAIN];
  int adjadj, adjadjs[MAXCHAIN];
  int k;
  int color = board[str1];
  int move;
  
  /* Common liberties. */
  if (have_common_lib(str1, str2, libs)) {
    add_array(moves, libs[0]);
    return 1;
  }
  
  /* Capture a common adjacent string or an adjacent liberty of str1
   * that has a common liberty with str2...
   */
  adj = chainlinks3(str1, adjs, 2);
  for (r = 0; r < adj; r++) {
    liberties = findlib(adjs[r], MAXLIBS, libs);
    common_adj_liberty = 0;
    for (s = 0; s < liberties; s++)
      if (liberty_of_string(libs[s], str2))
	common_adj_liberty = 1;
    if (common_adj_liberty || adjacent_strings(adjs[r], str2)) {
      for (s = 0; s < liberties; s++)
	add_array(moves, libs[s]);
      adjadj = chainlinks2(adjs[r], adjadjs, 1);
      for (s = 0; s < adjadj; s++) {
	findlib(adjadjs[s], MAXLIBS, libs);
	add_array(moves, libs[0]);
      }
    }
  }

  /* ...and vice versa. */
  adj = chainlinks3(str2, adjs, 2);
  for (r = 0; r < adj; r++) {
    liberties = findlib(adjs[r], MAXLIBS, libs);
    common_adj_liberty = 0;
    for (s = 0; s < liberties; s++)
      if (liberty_of_string(libs[s], str1))
	common_adj_liberty = 1;
    if (common_adj_liberty || adjacent_strings(adjs[r], str1)) {
      for (s = 0; s < liberties; s++)
	add_array(moves, libs[s]);
      adjadj = chainlinks2(adjs[r], adjadjs, 1);
      for (s = 0; s < adjadj; s++) {
	findlib(adjadjs[s], MAXLIBS, libs);
	add_array(moves, libs[0]);
      }
    }
  }
  
  /* Liberties of str1 that are second order liberties of str2 and
   * vice versa.
   */
  liberties = findlib(str1, MAXLIBS, libs);
  for (r = 0; r < liberties; r++) {
    if (board[SOUTH(libs[r])] == EMPTY) {
      if (liberty_of_string(SOUTH(libs[r]), str2)) {
	add_array(moves, libs[r]);
	add_array(moves, SOUTH(libs[r]));
      }
    }
    
    if (board[WEST(libs[r])] == EMPTY) {
      if (liberty_of_string(WEST(libs[r]), str2)) {
	add_array(moves, libs[r]);
	add_array(moves, WEST(libs[r]));
      }
    }

    if (board[NORTH(libs[r])] == EMPTY) {
      if (liberty_of_string(NORTH(libs[r]), str2)) {
	add_array(moves, libs[r]);
	add_array(moves, NORTH(libs[r]));
      }
    }

    if (board[EAST(libs[r])] == EMPTY) {
      if (liberty_of_string(EAST(libs[r]), str2)) {
	add_array(moves, libs[r]);
	add_array(moves, EAST(libs[r]));
      }
    }    
  }

  /* Liberties of str1 which are adjacent to a friendly string with
   * common liberty with str2.
   */
  liberties = findlib(str1, MAXLIBS, libs);
  for (r = 0; r < liberties; r++) {
    for (k = 0; k < 4; k++) {
      int pos = libs[r] + delta[k];
      if (board[pos] == color
	  && !same_string(pos, str1)
	  && quiescence_connect(pos, str2, &move)) {
	add_array(moves, libs[r]);
	add_array(moves, move);
      }
    }
  }

  /* And vice versa. */
  liberties = findlib(str2, MAXLIBS, libs);
  for (r = 0; r < liberties; r++) {
    for (k = 0; k < 4; k++) {
      int pos = libs[r] + delta[k];
      if (board[pos] == color
	  && !same_string(pos, str2)
	  && quiescence_connect(pos, str1, &move)) {
	add_array(moves, libs[r]);
	add_array(moves, move);
      }
    }
  }

  return 0;
}
  
/* Tests if the strings can be connected in three plies starts
 * with finding the possible moves that can connect.  If two
 * moves in a row are played, then try them and stops at the
 * first working move.  The strings are connected in two moves
 * if the function connected_one_move is verified after a move.
 *
 * This is the gi2 game function.
 */

static int
connection_two_moves(int str1, int str2)
{
  int r, res = 0, moves[MAX_MOVES];
  SGFTree *save_sgf_dumptree = sgf_dumptree;
 
  /* If one string is missing we have already failed. */
  if (board[str1] == EMPTY || board[str2] == EMPTY)
    return 0;
  
  moves[0] = 0;
  if (moves_to_connect_in_two_moves(moves, str1, str2))
    return WIN;
  order_connection_moves(moves, str1, str2, board[str1],
			 "connection_two_moves");
  
  /* turn off the sgf traces
   */
  sgf_dumptree = NULL;
  
  for (r = 1; ((r < moves[0] + 1) && !res); r++) {
    if (trymove(moves[r], board[str1],
		"connection_two_moves", str1, EMPTY, 0)) {
      if (connected_one_move(str1, str2))
	res = WIN;
      popgo();
    }
  }
  
  sgf_dumptree = save_sgf_dumptree;
  
  return res;
}

/* Find the complete set of possible moves that can prevent
 * a connection in three plies.
 *
 * The function is not yet written, but moves_to_connect_in_two_moves does
 * a similar job, so it is called temporarly.
 */

static int
moves_to_prevent_connection_in_two_moves(int *moves, int str1, int str2)
{
  if (moves_to_connect_in_two_moves(moves, str1, str2))
    return 1;
  return 0;
}

/* Find all the moves that prevent to connect in a three plies
 * deep search and put them in the moves array.  Returns 0 if
 * there is no three plies connection, or else it tries all the
 * possible preventing moves.  If after a possible preventing
 * moves, there no connection in one move and no connection in
 * two moves, then the moves prevents a three plies deep
 * connection, and it is added to the moves array.
 *
 * this is the ip2 game function */

static int
prevent_connection_two_moves(int *moves, int str1, int str2)
{
  int r, res = 0;
  int possible_moves[MAX_MOVES];
  SGFTree *save_sgf_dumptree = sgf_dumptree;

  /* turn off the sgf traces
   */
  sgf_dumptree = NULL;
    
  if (connection_two_moves(str1, str2)) {
    res = WIN;
    possible_moves[0] = 0;
    moves_to_prevent_connection_in_two_moves(possible_moves, str1, str2);
    order_connection_moves(possible_moves, str1, str2,
			   OTHER_COLOR(board[str1]),
			   "prevent_connection_two_moves");
    for (r = 1; r < possible_moves[0] + 1; r++) {
      if (trymove(possible_moves[r], OTHER_COLOR(board[str1]), 
		  "prevent_connection_two_moves", str1, EMPTY, 0)) {
	if (!connection_one_move(str1, str2))
	  if (!connection_two_moves(str1, str2))
	    add_array(moves, possible_moves[r]);
	popgo();
      }
    }
  }

  sgf_dumptree = save_sgf_dumptree;  

  return res;
}

/* Only partially written.
 *
 * Find all the moves than can connect if two subsequent
 * moves of the same color are played after
 * - common liberties;
 * - liberties of common adjacent strings with 3 liberties or less;
 * - liberties of adjacent strings with 2 liberties or less that have
 *   liberties that are second order liberties of the other string;
 * - liberties of one string that are second order liberties of the
 *   other string;
 * - second order liberties of the first string that are second order 
 *   liberties of the other string;
 *
 * A function that computes the second order liberties of a string is
 * needed as well as a function that checks efficiently if an
 * intersection is a second order liberty of a given string.
 *
 * If does_connect is 1, generate moves to connect, otherwise generate
 * moves to disconnect.
 */

static int
moves_to_connect_in_three_moves(int *moves, int str1, int str2,
				int does_connect)
{
  int r, s;
  int liberties, libs[MAXLIBS];
  int liberties2, libs2[MAXLIBS];
  int adj, adjs[MAXCHAIN];
  int adjadj, adjadjs[MAXCHAIN];
  int move;
  int k;
  int secondlib1[BOARDMAX];
  int secondlib2[BOARDMAX];
  int pos;
  
  if (moves_to_connect_in_two_moves(moves, str1, str2))
    return 1;

  /* Find second order liberties of str1. */
  memset(secondlib1, 0, sizeof(secondlib1));
  liberties = findlib(str1, MAXLIBS, libs);
  for (r = 0; r < liberties; r++)
    for (k = 0; k < 4; k++) {
      int pos = libs[r] + delta[k];
      if (board[pos] == EMPTY)
	secondlib1[pos] = 1;
      else if (board[pos] == board[str1]) {
	liberties2 = findlib(pos, MAXLIBS, libs2);
	for (s = 0; s < liberties2; s++)
	  secondlib1[libs2[s]] = 1;
      }
    }
  
  /* Find second order liberties of str2.
   */
  memset(secondlib2, 0, sizeof(secondlib2));
  liberties = findlib(str2, MAXLIBS, libs);
  for (r = 0; r < liberties; r++)
    for (k = 0; k < 4; k++) {
      int pos = libs[r] + delta[k];
      if (board[pos] == EMPTY)
	secondlib2[pos] = 1;
      else if (board[pos] == board[str2]) {
	liberties2 = findlib(pos, MAXLIBS, libs2);
	for (s = 0; s < liberties2; s++)
	  secondlib2[libs2[s]] = 1;
      }
    }
  
  /* Second order liberties of str1 that are second order liberties
   * of str2 and vice versa.
   */
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (secondlib1[pos] && secondlib2[pos])
      add_array(moves, pos);
  }

  /* Capture a neighbor of str1 which is in atari. The captured string
   * must in turn have a neighbor which can connect to str2 easily.
   */
  adj = chainlinks2(str1, adjs, 1);
  for (r = 0; r < adj; r++) {
    adjadj = chainlinks(adjs[r], adjadjs);
    for (s = 0; s < adjadj; s++) {
      if (!same_string(adjadjs[s], str1)
	  && quiescence_connect(adjadjs[s], str2, &move)) {
	findlib(adjs[r], 1, libs);
	add_array(moves, libs[0]);
	add_array(moves, move);
      }
    }
  }

  /* And vice versa. */
  adj = chainlinks2(str2, adjs, 1);
  for (r = 0; r < adj; r++) {
    adjadj = chainlinks(adjs[r], adjadjs);
    for (s = 0; s < adjadj; s++) {
      if (!same_string(adjadjs[s], str2)
	  && quiescence_connect(adjadjs[s], str1, &move)) {
	findlib(adjs[r], 1, libs);
	add_array(moves, libs[0]);
	add_array(moves, move);
      }
    }
  }

  /* Liberties of neighbor of str1 with at most two liberties, which
   * are second order liberties of str2.
   */
  adj = chainlinks3(str1, adjs, 2);
  for (r = 0; r < adj; r++) {
    liberties = findlib(adjs[r], 2, libs);
    for (s = 0; s < liberties; s++)
      if (second_order_liberty_of_string(libs[s], str2))
	add_array(moves, libs[s]);
  }

  /* And vice versa. */
  adj = chainlinks3(str2, adjs, 2);
  for (r = 0; r < adj; r++) {
    liberties = findlib(adjs[r], 2, libs);
    for (s = 0; s < liberties; s++)
      if (second_order_liberty_of_string(libs[s], str1))
	add_array(moves, libs[s]);
  }
  
  /* Move in on a three liberty opponent string which is adjacent to
   * str1 and has a liberty in common with str2.
   */
  adj = chainlinks2(str1, adjs, 3);
  for (r = 0; r < adj; r++) {
    if (have_common_lib(adjs[r], str2, NULL)) {
      liberties = findlib(adjs[r], 3, libs);
      for (s = 0; s < liberties; s++) {
	/* If generating a connecting move, require the liberty to be
         * no further than diagonal to a second order liberty of one
         * of the strings.
	 */
	for (k = 0; k < 8; k++) {
	  if (!does_connect
	      || (ON_BOARD(libs[s] + delta[k])
		  && (secondlib1[libs[s] + delta[k]]
		      || secondlib2[libs[s] + delta[k]]))) {
	    add_array(moves, libs[s]);
	    break;
	  }
	}
      }
    }
  }

  /* And vice versa. */
  adj = chainlinks2(str2, adjs, 3);
  for (r = 0; r < adj; r++) {
    if (have_common_lib(adjs[r], str1, NULL)) {
      liberties = findlib(adjs[r], 3, libs);
      for (s = 0; s < liberties; s++) {
	/* If generating a connecting move, require the liberty to be
         * no further than diagonal to a second order liberty of one
         * of the strings.
	 */
	for (k = 0; k < 8; k++) {
	  if (!does_connect
             || (ON_BOARD(libs[s] + delta[k])
                 && (secondlib1[libs[s] + delta[k]]
                     || secondlib2[libs[s] + delta[k]]))) {
	    add_array(moves, libs[s]);
	    break;
	  }
	}
      }
    }
  }
  
  return 0;
}


/* Not yet written.
 *
 * Find the complete set of possible moves that can prevent
 * a connection in 5 plies.
 */

static int
moves_to_prevent_connection_in_three_moves(int *moves, int str1, int str2)
{
  if (moves_to_connect_in_three_moves(moves, str1, str2, 0))
    return 1;
  return 0;
}

/* 
 * The simplest depth 4 connection:
 *
 * If there are forced moves to prevent connection in one move,
 * try them, and verify that they all lead to a depth 1 or
 * depth 3 connection.
 * 
 * This is the g211 game function.
 */

static int
simply_connected_two_moves(int str1, int str2)
{
  int r, res = 0;
  int moves[MAX_MOVES];
  SGFTree *save_sgf_dumptree = sgf_dumptree;

  /* turn off the sgf traces
   */
  sgf_dumptree = NULL;
  
  
  /* If one string is missing we have already failed. */
  if (board[str1] == EMPTY || board[str2] == EMPTY)
    return 0;
  
  moves[0] = 0;
  if (prevent_connection_one_move(moves, str1, str2)) {
    res = WIN;
    order_connection_moves(moves, str1, str2, OTHER_COLOR(board[str1]),
			   "simply_connected_two_moves");
    for (r = 1; ((r < moves[0] + 1) && res); r++) {
      if (trymove(moves[r], OTHER_COLOR(board[str1]),
		  "simply_connected_two_moves", str1, EMPTY, 0)) {
	if (!connection_one_move(str1, str2))
	  if (!connection_two_moves(str1, str2))
	    res = 0;
	popgo();
      }
    }
  }
  
  sgf_dumptree = save_sgf_dumptree;
  
  return res;
}

/* Test if a move is a simple depth 5 connection.
 *
 * This is the gi311 game function.
 */

static int
simple_connection_three_moves(int str1, int str2)
{
  int r, res = 0, moves[MAX_MOVES];
  SGFTree *save_sgf_dumptree = sgf_dumptree;

  /* turn off the sgf traces
   */
  sgf_dumptree = NULL;
    
  
  moves[0] = 0;
  if (moves_to_connect_in_two_moves(moves, str1, str2))
    return WIN;
  order_connection_moves(moves, str1, str2, board[str1],
			 "simple_connection_three_moves");
  for (r = 1; ((r < moves[0] + 1) && !res); r++) {
    if (trymove(moves[r], board[str1],
		"simple_connection_three_moves", str1, EMPTY, 0)) {
      if (simply_connected_two_moves(str1, str2))
	res = WIN;
      popgo();
    }
  }
  
  sgf_dumptree = save_sgf_dumptree;
  
  return res;
}

/* Find the forced moves that prevent a simple depth 5 connection.
 * Fills the array moves with the forced moves.
 *
 * This is the ip311 game function.
 *
 * It finds moves in very important situations such as:
 *
 * + + + O + +
 * + @ @ O + +
 * + @ O @ @ +
 * + @ O + + +
 * + + + + + +
 * - - - - - -
 *
 * and enables recursive_disconnect to prove the two black
 * strings are connected in these situations.
 */

static int
prevent_simple_connection_three_moves(int *moves, int str1, int str2)
{
  int r, res = 0;
  int possible_moves[MAX_MOVES];
  SGFTree *save_sgf_dumptree = sgf_dumptree;

  /* turn off the sgf traces
   */
  sgf_dumptree = NULL;
    
  
  if (simple_connection_three_moves(str1, str2)) {
    res = WIN;
    possible_moves[0] = 0;
    moves_to_prevent_connection_in_three_moves(possible_moves, str1, str2);
    order_connection_moves(moves, str1, str2, OTHER_COLOR(board[str1]),
			   "prevent_simple_connection_three_moves");
    for (r = 1; r < possible_moves[0] + 1; r++) {
      if (trymove(possible_moves[r], OTHER_COLOR(board[str1]), 
		  "prevent_simple_connection_three_moves", str1, EMPTY, 0)) {
	if (!connection_one_move(str1, str2))
	  if (!connection_two_moves(str1, str2))
	    if (!simple_connection_three_moves(str1, str2))
	      add_array(moves, possible_moves[r]);
	popgo();
      }
    }
  }
  
  sgf_dumptree = save_sgf_dumptree;
  
  return res;
}

/* Find simple connections by looking at common liberties
 * or directly capturing a common adjacent string without a snapback
 * or looking at a ladder for a common adjacent string.
 */

static int
quiescence_connect(int str1, int str2, int *move)
{
  int r;
  int lib;
  int adj, adjs[MAXCHAIN];

  /* Common liberties. */
  if (have_common_lib(str1, str2, &lib)) {
    *move = lib;
    return WIN;
  }

  /* Common adjacent string in atari, more than one stone, no snapback. */
  adj = chainlinks2(str1, adjs, 1);
  for (r = 0; r < adj; r++)
    if (adjacent_strings(adjs[r], str2)
        && !snapback(adjs[r])) {
      findlib(adjs[r], 1, move);
      return WIN;
    }
  
  /* Common adjacent string two liberties, read ladder. */
  adj = chainlinks2(str1, adjs, 2);
  for (r = 0; r < adj; r++)
    if (adjacent_strings(adjs[r], str2))
      if (quiescence_capture(adjs[r], move))
	return WIN;
  
  return 0;
}


/* Externally callable frontend to recursive_connect(). */

int
string_connect(int str1, int str2, int *move)
{
  int dummy_move;
  int save_verbose;
  int result;

  if (move == NULL)
    move = &dummy_move;
  
  nodes_connect = 0;
  *move = PASS_MOVE;
  
  if (alternate_connections) {
    save_verbose = verbose;
    if (verbose > 0)
      verbose--;
    result = recursive_connect2(str1, str2, move, EMPTY, NO_MOVE, 0);
    verbose = save_verbose;
    return result;
  }

  return recursive_connect(str1, str2, move);
}


/* returns WIN if str1 and str2 can be connected. */

static int
recursive_connect(int str1, int str2, int *move)
{
  int i, res = 0, Moves[MAX_MOVES], ForcedMoves[MAX_MOVES];
  SETUP_TRACE_INFO2("recursive_connect", str1, str2);
  
  if (board[str1] == EMPTY || board[str2] == EMPTY) {
    SGFTRACE2(PASS_MOVE, 0, "one string already captured");
    return 0;
  }
  
  if (same_string(str1, str2)) {
    SGFTRACE2(PASS_MOVE, WIN, "already connected");
    return WIN;
  }

  if (nodes_connect > max_nodes_connect) {
    SGFTRACE2(PASS_MOVE, 0, "connection node limit reached");
    return 0;
  }
  
  if (stackp == max_connect_depth) {
    SGFTRACE2(PASS_MOVE, 0, "connection depth limit reached");
    return 0;
  }

  nodes_connect++;
  global_connection_node_counter++;
  
  if (quiescence_connect (str1, str2, move)) {
    SGFTRACE2(*move, WIN, "quiescence_connect");
    return WIN;
  }

  ForcedMoves[0] = 0;
  Moves[0] = 0;
  /* if one of the strings to connect can be captured
   * and there are forced moves to prevent the capture
   * then the only moves to try are the moves that
   * defend the string: all the other moves will
   * lead to the capture of the string
   */
  if (!prevent_capture_one_move(ForcedMoves, str1))
    prevent_capture_one_move(ForcedMoves, str2);
#if 0
  else if (prevent_capture_two_moves(ForcedMoves, str1))
     ; 
  else if (prevent_capture_two_moves(ForcedMoves, str2))
     ; 
#endif
  
  /* We are at a max node, so any move we can find
   * is ok. Try moves that can connect in three moves
   * because the function that prevent connection in one
   * and two moves are called at AND nodes.
   */
  moves_to_connect_in_three_moves(Moves, str1, str2, 1);

  /* if there are some forced moves to prevent the capture
   * of one of the two strings, then we only look at
   * the moves that prevent capture and that might also
   * connect
   */
  if (ForcedMoves[0] != 0 && Moves[0] != 0)
    intersection_array(Moves, ForcedMoves);

  order_connection_moves(Moves, str1, str2, board[str1],
			 "recursive_connect");
  for (i = 1; ((i < Moves[0] + 1) && (res == 0)); i++) {
    if (trymove(Moves[i], board[str1], "recursive_connect", str1, EMPTY, 0)) {
      if (!recursive_disconnect(str1, str2, move)) {
	*move = Moves[i];
	res = WIN;
      }
      popgo();
    }
  }

  if (res == WIN) {
    SGFTRACE2(*move, WIN, "success");
  }
  else {
    SGFTRACE2(PASS_MOVE, 0, "failure");
  }
  
  return res;
}
  

/* Externally callable frontend to recursive_disconnect(). */

int
disconnect(int str1, int str2, int *move)
{
  int i;
  int res = WIN;
  int Moves[MAX_MOVES];
  int dummy_move;
  int result;
  int save_verbose;
  
  if (move == NULL)
    move = &dummy_move;
  
  nodes_connect = 0;
  *move = PASS_MOVE;
  
  if (alternate_connections) {
    save_verbose = verbose;
    if (verbose > 0)
      verbose --;
    result = recursive_disconnect2(str1, str2, move, EMPTY, NO_MOVE, 0);
    verbose = save_verbose;
    return result;
  }

  Moves[0] = 0;
  moves_to_prevent_connection_in_three_moves (Moves, str1, str2);
  if (Moves[0] > 0)
    res = 0;
  order_connection_moves(Moves, str1, str2, OTHER_COLOR(board[str1]),
			 "disconnect");
  for (i = 1; ((i < Moves[0] + 1) && (res == 0)); i++)
    if (trymove(Moves[i], OTHER_COLOR(board[str1]),
		"disconnect", str1, EMPTY, 0)) {
      if (!recursive_connect(str1, str2, move)) {
	*move = Moves[i];
	res = WIN;
      }
      popgo();
    }
  return res;
}


/* Returns WIN if str1 and str2 can be disconnected. */

static int
recursive_disconnect(int str1, int str2, int *move)
{
  int i, res = WIN, Moves[MAX_MOVES];
  
  SETUP_TRACE_INFO2("recursive_disconnect", str1, str2);
  
  if (board[str1] == EMPTY || board[str2] == EMPTY) {
    SGFTRACE2(PASS_MOVE, WIN, "one string already captured");
    return WIN;
  }

  if (quiescence_capture(str1, move)) {
    SGFTRACE2(*move, WIN, "first string capturable");
    return WIN;
  }
  if (quiescence_capture(str2, move)) {
    SGFTRACE2(*move, WIN, "second string capturable");
    return WIN;
  }

  if (same_string(str1, str2)) {
    SGFTRACE2(PASS_MOVE, 0, "already connected");
    return 0;
  }
  
  if (nodes_connect > max_nodes_connect) {
    SGFTRACE2(PASS_MOVE, WIN, "connection node limit reached");
    return WIN;
  }
  
  if (stackp == max_connect_depth) {
    SGFTRACE2(PASS_MOVE, WIN, "connection depth limit reached");
    return WIN;
  }
  
  nodes_connect++;
  global_connection_node_counter++;
  
  /* we are at an and node
   * only look at forced moves here,
   * it ensures that the result of recursive_disconnect
   * is proved if it returns 0 (that is connections are proved)
   */
  Moves[0] = 0;

  if (prevent_connection_one_move(Moves, str1, str2))
    res = 0;
  else if (prevent_connection_two_moves(Moves, str1, str2))
    res = 0;
  else if (prevent_simple_connection_three_moves(Moves, str1, str2))
    res = 0;
  
  if (res == 0)
    order_connection_moves(Moves, str1, str2, OTHER_COLOR(board[str1]),
			   "recursive_disconnect");
    for (i = 1; ((i < Moves[0] + 1) && (res == 0)); i++)
      if (trymove(Moves[i], OTHER_COLOR(board[str1]),
		  "recursive_disconnect", str1, EMPTY, 0)) {
	if (!recursive_connect(str1, str2, move)) {
	  *move = Moves[i];
	  res = WIN;
	}
	popgo();
      }

  if (res == WIN) {
    SGFTRACE2(*move, WIN, "success");
  }
  else {
    SGFTRACE2(PASS_MOVE, 0, "failure");
  }
  
  return res;
}
 
/* Reads simple ladders.
 */

static int
quiescence_capture(int str, int *move)
{
  SGFTree *save_sgf_dumptree = sgf_dumptree;
  int save_count_variations = count_variations;
  int result = 0;

  /* We turn off the sgf traces here to avoid cluttering them up with
   * naive_ladder moves.
   */
  sgf_dumptree = NULL;
  count_variations = 0;

  if (countlib(str) == 1) {
    findlib(str, 1, move);
    result = WIN;
  }
  else if (countlib(str) == 2)
    result = simple_ladder(str, move);

  /* Turn the sgf traces back on. */
  sgf_dumptree = save_sgf_dumptree;
  count_variations = save_count_variations;

  return result;
}

#if 0
static int
capture_one_move(int str) 
{
  if (countlib(str) == 1)
    return 1;
  return 0;
}
#endif

/* Find all the possible moves that can prevent the capture
 * of a string in atari.
 *
 * The ip1 game function.
 */

static int
prevent_capture_one_move(int *moves, int str1)
{
  int r, res = 0;
  int liberties, libs[MAXLIBS];
  int adj, adjs[MAXCHAIN];
  
  liberties = findlib(str1, MAXLIBS, libs);
  if (liberties == 1) {
    add_array(moves, libs[0]);
    res = WIN;
    adj = chainlinks2(str1, adjs, 1);
    for (r = 0; r < adj; r++) {
      findlib(adjs[r], 1, libs);
      add_array(moves, libs[0]);
    }
  }
  return res;
}


/* Returns WIN if str1, str2 and str3 can be connected. */

static int
recursive_transitivity(int str1, int str2, int str3, int *move)
{
  int i, res = 0, Moves[MAX_MOVES], ForcedMoves[MAX_MOVES];

  SETUP_TRACE_INFO2("recursive_transitivity", str1, str3);
  
  if (board[str1] == EMPTY || board[str2] == EMPTY || board[str3] == EMPTY) {
    SGFTRACE2(PASS_MOVE, 0, "one string already captured");
    return 0;
  }
  
  if (same_string(str1, str2) && same_string(str1, str3)) {
    SGFTRACE2(PASS_MOVE, WIN, "already connected");
    return WIN;
  }

  if (nodes_connect > max_nodes_connect) {
    SGFTRACE2(PASS_MOVE, 0, "connection node limit reached");
    return 0;
  }
  
  if (stackp == max_connect_depth) {
    SGFTRACE2(PASS_MOVE, 0, "connection depth limit reached");
    return 0;
  }

  nodes_connect++;
  global_connection_node_counter++;
  
  if (same_string(str1, str2))
    if (quiescence_connect (str1, str3, move)) {
      SGFTRACE2(*move, WIN, "quiescence_connect");
      return WIN;
    }

  if (same_string(str2, str3))
    if (quiescence_connect (str1, str2, move)) {
      SGFTRACE2(*move, WIN, "quiescence_connect");
      return WIN;
    }

  ForcedMoves[0] = 0;
  Moves[0] = 0;
  /* If one of the strings to connect can be captured
   * and there are forced moves to prevent the capture
   * then the only moves to try are the moves that
   * defend the string. All the other moves will
   * lead to the capture of the string.
   */
  if (!prevent_capture_one_move(ForcedMoves, str1))
    if (!prevent_capture_one_move(ForcedMoves, str2))
      prevent_capture_one_move(ForcedMoves, str3);
  
  /* We are at a max node, so any move we can find
   * is ok. Try moves that can connect in two moves
   * because the function that prevents connection in one
   * move is called at and nodes.
   */
  moves_to_connect_in_two_moves (Moves, str1, str2);
  moves_to_connect_in_two_moves (Moves, str2, str3);

  /* If there are some forced moves to prevent the capture
   * of one of the two strings, then we only look at
   * the moves that prevent capture and that might also
   * connect.
   */
  if ( (ForcedMoves[0] != 0) && (Moves[0] != 0) )
    intersection_array(Moves, ForcedMoves);

  order_connection_moves(Moves, str1, str2, board[str1],
			 "recursive_transitivity");
  for (i = 1; ((i < Moves[0] + 1) && (res == 0)); i++) {
    if (trymove(Moves[i], board[str1], "recursive_transitivity", 
		str1, EMPTY, 0)) {
      if (!recursive_non_transitivity(str1, str2, str3, move)) {
	*move = Moves[i];
	res = WIN;
      }
      popgo();
    }
  }

  if (res == WIN) {
    SGFTRACE2(*move, WIN, "success");
  }
  else {
    SGFTRACE2(PASS_MOVE, 0, "failure");
  }
  
  return res;
}
  
/* Externally callable frontend to recursive_non_transitivity(). */

int
non_transitivity(int str1, int str2, int str3, int *move)
{
  int i, res = WIN, Moves[MAX_MOVES];
  
  nodes_connect = 0;
  *move = PASS_MOVE;
  moves_to_prevent_connection_in_three_moves (Moves, str1, str3);
  if (Moves[0] > 0)
    res = 0;
  order_connection_moves(Moves, str1, str2, OTHER_COLOR(board[str1]),
			 "non_transitivity");
  for (i = 1; ((i < Moves[0] + 1) && (res == 0)); i++)
    if (trymove(Moves[i], OTHER_COLOR(board[str1]),
		"non_transitivity", str1, EMPTY, 0)) {
      if (!recursive_transitivity(str1, str2, str3, move)) {
	*move = Moves[i];
	res = WIN;
      }
      popgo();
    }
  return res;
}

/* Returns WIN if str1, str2 and str3 can be disconnected. */

static int
recursive_non_transitivity(int str1, int str2, int str3, int *move)
{
  int i, res = WIN, Moves[MAX_MOVES];
  
  SETUP_TRACE_INFO2("recursive_non_transitivity", str1, str3);
  
  if (board[str1] == EMPTY || board[str2] == EMPTY
      || board[str3] == EMPTY) {
    SGFTRACE2(PASS_MOVE, WIN, "one string already captured");
    return WIN;
  }

  if (quiescence_capture(str1, move)) {
    SGFTRACE2(*move, WIN, "first string capturable");
    return WIN;
  }
  if (quiescence_capture(str2, move)) {
    SGFTRACE2(*move, WIN, "second string capturable");
    return WIN;
  }
  if (quiescence_capture(str3, move)) {
    SGFTRACE2(*move, WIN, "third string capturable");
    return WIN;
  }

  if (same_string(str1, str2) && same_string(str1, str3)) {
    SGFTRACE2(PASS_MOVE, 0, "already connected");
    return 0;
  }
  
  if (nodes_connect > max_nodes_connect) {
    SGFTRACE2(PASS_MOVE, WIN, "connection node limit reached");
    return WIN;
  }
  
  if (stackp == max_connect_depth) {
    SGFTRACE2(PASS_MOVE, WIN, "connection depth limit reached");
    return WIN;
  }
  
  nodes_connect++;
  global_connection_node_counter++;
  
  /* We are at an and node. Only look at forced moves. */
  Moves[0] = 0;
  if (prevent_connection_one_move(Moves, str1, str3))
    res = 0;
  else if (prevent_connection_two_moves(Moves, str1, str3))
    res = 0;
  else if (prevent_simple_connection_three_moves(Moves, str1, str3))
    res = 0;
  
  if (res == 0)
    order_connection_moves(Moves, str1, str2, OTHER_COLOR(board[str1]),
			   "recursive_non_transitivity");
    for (i = 1; ((i < Moves[0] + 1) && (res == 0)); i++)
      if (trymove(Moves[i], OTHER_COLOR(board[str1]),
		  "recursive_non_transitivity", str1, EMPTY, 0)) {
	if (!recursive_transitivity(str1, str2, str3, move)) {
	  *move = Moves[i];
	  res = WIN;
	}
	popgo();
      }

  if (res == WIN) {
    SGFTRACE2(*move, WIN, "success");
  }
  else {
    SGFTRACE2(PASS_MOVE, 0, "failure");
  }
  
  return res;
}


/* Order the moves so that we try the ones likely to succeed early. */
static void
order_connection_moves(int *moves, int str1, int str2, int color_to_move,
		       const char *funcname)
{
  int scores[MAX_MOVES];
  int r;
  int i, j;
  UNUSED(str2);
  UNUSED(color_to_move);

  for (r = 1; r <= moves[0]; r++) {
    int move = moves[r];

    /* Look at the neighbors of this move and count the things we
     * find. Friendly and opponent stones are related to color, i.e.
     * the player to move, not to the color of the string.
     *
     * We don't use all these values. They are only here so we can
     * reuse incremental_order_moves() which was developed for the
     * tactical reading.
     */
    int number_edges       = 0; /* outside board */
    int number_same_string = 0; /* the string being attacked */
    int number_own         = 0; /* friendly stone */
    int number_opponent    = 0; /* opponent stone */
    int captured_stones    = 0; /* number of stones captured by this move */
    int threatened_stones  = 0; /* number of stones threatened by this move */
    int saved_stones       = 0; /* number of stones in atari saved */
    int number_open        = 0; /* empty intersection */
    int libs;

    /* We let the incremental board code do the heavy work. */
    incremental_order_moves(move, color_to_move, str1, &number_edges,
			    &number_same_string, &number_own,
			    &number_opponent, &captured_stones,
			    &threatened_stones, &saved_stones, &number_open);

    if (0)
      gprintf("%o %1m values: %d %d %d %d %d %d %d %d\n", move, number_edges,
	      number_same_string, number_own, number_opponent,
	      captured_stones, threatened_stones, saved_stones, number_open);

    scores[r] = 0;
    libs = approxlib(move, color_to_move, 10, NULL);

    /* Avoid self atari. */
    if (libs == 1 && captured_stones == 0)
      scores[r] -= 10;

    /* Good to get many liberties. */
    if (libs < 4)
      scores[r] += libs;
    else
      scores[r] += 4;

    /* Very good to capture opponent stones. */
    if (captured_stones > 0)
      scores[r] += 5 + captured_stones;

    /* Good to threaten opponent stones. */
    if (threatened_stones > 0)
      scores[r] += 3;

    /* Extremely good to save own stones. */
    if (saved_stones > 0)
      scores[r] += 10 + saved_stones;
  }
  
  /* Now sort the moves.  We use selection sort since this array will
   * probably never be more than 10 moves long.  In this case, the
   * overhead imposed by quicksort will probably overshadow the gains
   * given by the O(n*log(n)) behaviour over the O(n^2) behaviour of
   * selection sort.
   */
  for (i = 1; i <= moves[0]; i++) {
    /* Find the move with the biggest score. */
    int maxscore = scores[i];
    int max_at = i;
    for (j = i+1; j <= moves[0]; j++) {
      if (scores[j] > maxscore) {
	maxscore = scores[j];
	max_at = j;
      }
    }

    /* Now exchange the move at i with the move at max_at.
     * Don't forget to exchange the scores as well.
     */
    if (max_at != i) {
      int temp = moves[i];
      int tempmax = scores[i];

      moves[i] = moves[max_at];
      scores[i] = scores[max_at];

      moves[max_at] = temp;
      scores[max_at] = tempmax;
    }
  }

  if (0) {
    gprintf("%oVariation %d:\n", count_variations);
    for (i = 1; i <= moves[0]; i++)
      gprintf("%o  %1M %d\n", moves[i], scores[i]);
  }

  if (sgf_dumptree) {
    char buf[500];
    char *pos;
    int chars;
    sprintf(buf, "Move order for %s: %n", funcname, &chars);
    pos = buf + chars;
    for (i = 1; i <= moves[0]; i++) {
      sprintf(pos, "%c%d (%d) %n", J(moves[i]) + 'A' + (J(moves[i]) >= 8),
	      board_size - I(moves[i]), scores[i], &chars);
      pos += chars;
    }
    sgftreeAddComment(sgf_dumptree, NULL, buf);
  }
}

/* Clear statistics. */
void
reset_connection_node_counter()
{
  global_connection_node_counter = 0;
}


/* Retrieve statistics. */
int
get_connection_node_counter()
{
  return global_connection_node_counter;
}


/*********************************************************
 *
 * Alternate connection reading algorithm.
 *
 * This code is enabled with the --enable-alternate-connections
 * configure flag at build time or toggled with the
 * --alternate-connections option at run time.
 *
 *********************************************************/

/* This has been copied from reading.c and modified.
 */

#define ADD_CANDIDATE_MOVE(move, distance, moves, distances, num_moves)\
  do {\
    int l;\
    for (l = 0; l < num_moves; l++)\
      if (moves[l] == (move)) {\
        if (distances[l] > distance)\
          distances[l] = distance;\
	break;\
      }\
    if ((l == num_moves) && (num_moves < MAX_MOVES)) {\
      moves[num_moves] = move;\
      distances[num_moves] = distance;\
      (num_moves)++;\
    }\
  } while (0)


struct connection_data {
  float distances[BOARDMAX];
  float deltas[BOARDMAX];
  int queue[BOARDMAX];
  int queue_start;
  int queue_end;
};

#define HUGE_CONNECTION_DISTANCE 100.0

static int find_connection_moves(int str1, int str2, int color_to_move,
				 int moves[MAX_MOVES], float *total_distance);
static void compute_connection_distances(int str,
					 struct connection_data *conn);
static void print_connection_distances(struct connection_data *conn);
static int trivial_connection(int str1, int str2, int *move);
static int does_secure(int color, int move, int pos);
static int does_secure_through_ladder(int color, int move, int pos);
static int ladder_capture(int str, int *move);
static int ladder_capturable(int pos, int color);
static int no_escape_from_atari(int str);
static int no_escape_from_ladder(int str);


/* Try to connect two strings. This function is called in a mutual
 * recursion with recursive_disconnect2(). Return codes and the
 * meaning of komaster and kom_pos is identical to the tactical
 * reading functions. For the has_passed parameter, see the
 * documentation of recursive_disconnect2().
 *
 * The algorithm is
 * 1. Check if the strings are trivially connected or disconnected or
 *    the result is already cached.
 * 2. Find connection moves.
 * 3. Try one move at a time and call recursive_disconnect2() to see
 *    whether we were successful.
 * 4. If no move was found we assume success if the connection
 *    distance was small and failure otherwise.
 */
static int
recursive_connect2(int str1, int str2, int *move, int komaster, int kom_pos,
		   int has_passed)
{
  int color = board[str1];
  int moves[MAX_MOVES];
  int num_moves;
  float distance = 0.0;
  int k;
  int xpos;
  int savemove = NO_MOVE;
  int savecode = 0;
  int found_read_result;
  Read_result *read_result = NULL;
  
  SETUP_TRACE_INFO2("recursive_connect2", str1, str2);

  if (move)
    *move = NO_MOVE;

  nodes_connect++;
  global_connection_node_counter++;
  
  if (board[str1] == EMPTY || board[str2] == EMPTY) {
    SGFTRACE2(PASS_MOVE, 0, "one string already captured");
    return 0;
  }
  
  if (same_string(str1, str2)) {
    SGFTRACE2(PASS_MOVE, WIN, "already connected");
    return WIN;
  }

  if (nodes_connect > max_nodes_connect) {
    SGFTRACE2(PASS_MOVE, 0, "connection node limit reached");
    return 0;
  }
  
  if (stackp > max_connect_depth2) {
    SGFTRACE2(PASS_MOVE, 0, "connection depth limit reached");
    return 0;
  }

  if (stackp <= depth
      && (hashflags & HASH_CONNECT)
      && !has_passed) {
    found_read_result = get_read_result2(CONNECT, komaster, kom_pos, 
					 &str1, &str2, &read_result);
    if (found_read_result) {
      TRACE_CACHED_RESULT2(*read_result);
      if (rr_get_result(*read_result) != 0)
	if (move)
	  *move = rr_get_move(*read_result);

      SGFTRACE2(rr_get_move(*read_result),
		rr_get_result(*read_result), "cached");
      return rr_get_result(*read_result);
    }
  }
  
  if (trivial_connection(str1, str2, &xpos) == WIN) {
    SGFTRACE2(xpos, WIN, "trivial connection");
    READ_RETURN_CONN(read_result, move, xpos, WIN);
  }
  
  num_moves = find_connection_moves(str1, str2, color, moves, &distance);
  
  for (k = 0; k < num_moves; k++) {
    int new_komaster;
    int new_kom_pos;
    int ko_move;

    xpos = moves[k];
    
    if (komaster_trymove(xpos, color, "recursive_connect2", str1,
			 komaster, kom_pos, &new_komaster, &new_kom_pos,
			 &ko_move, stackp <= ko_depth && savecode == 0)) {
      if (!ko_move) {
	int acode = recursive_disconnect2(str1, str2, NULL,
					  new_komaster, new_kom_pos,
					  has_passed);
	popgo();
	if (acode == 0) {
	  SGFTRACE2(xpos, WIN, "connection effective");
	  READ_RETURN_CONN(read_result, move, xpos, WIN);
	}
	/* if the move works with ko we save it, then look for something
	 * better.
	 */
	UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, xpos);
      }
      else {
	if (recursive_disconnect2(str1, str2, NULL,
				  new_komaster, new_kom_pos,
				  has_passed) != WIN) {
	  savemove = xpos;
	  savecode = KO_B;
	}
	popgo();
      }
    }
  }

  if (num_moves == 0 && distance < 1.0) {
    SGFTRACE2(NO_MOVE, WIN, "no move, probably connected");
    READ_RETURN_CONN(read_result, move, NO_MOVE, WIN);
  }
  
  if (savecode != 0) {
    SGFTRACE2(savemove, savecode, "saved move");
    READ_RETURN_CONN(read_result, move, savemove, savecode);
  }

  SGFTRACE2(0, 0, NULL);
  READ_RETURN_CONN(read_result, move, NO_MOVE, 0);
}


/* Try to disconnect two strings. This function is called in a mutual
 * recursion with recursive_connect2(). Return codes and the meaning
 * of komaster and kom_pos is identical to the tactical reading
 * functions.
 *
 * The algorithm is
 * 1. Check if the strings are trivially connected or disconnected or
 *    the result is already cached.
 * 2. Find disconnection moves.
 * 3. Try one move at a time and call recursive_connect2() to see
 *    whether we were successful.
 * 4. If no move was found we assume failure if the connection
 *    distance was small. Otherwise we pass and let
 *    recursive_connect2() try to connect. However, if we already have
 *    passed once we just declare success. Whether a pass already has
 *    been made is indicated by the has_passed parameter.
 */
static int
recursive_disconnect2(int str1, int str2, int *move, int komaster, int kom_pos,
		      int has_passed)
{
  int color = board[str1];
  int other = OTHER_COLOR(color);
  int moves[MAX_MOVES];
  int num_moves;
  float distance = 0.0;
  int k;
  int xpos;
  int savemove = NO_MOVE;
  int savecode = 0;
  int found_read_result;
  Read_result *read_result = NULL;

  SETUP_TRACE_INFO2("recursive_disconnect2", str1, str2);
  
  nodes_connect++;
  global_connection_node_counter++;

  if (move)
    *move = NO_MOVE;
  
  if (board[str1] == EMPTY || board[str2] == EMPTY) {
    SGFTRACE2(PASS_MOVE, WIN, "one string already captured");
    return WIN;
  }

  if (same_string(str1, str2)) {
    SGFTRACE2(PASS_MOVE, 0, "already connected");
    return 0;
  }
  
  if (nodes_connect > max_nodes_connect) {
    SGFTRACE2(PASS_MOVE, WIN, "connection node limit reached");
    return WIN;
  }
  
  if (stackp > max_connect_depth2) {
    SGFTRACE2(PASS_MOVE, WIN, "connection depth limit reached");
    return WIN;
  }
  
  if ((stackp <= depth) && (hashflags & HASH_DISCONNECT)) {
    found_read_result = get_read_result2(DISCONNECT, komaster, kom_pos, 
					 &str1, &str2, &read_result);
    if (found_read_result) {
      TRACE_CACHED_RESULT2(*read_result);
      if (rr_get_result(*read_result) != 0)
	if (move)
	  *move = rr_get_move(*read_result);

      SGFTRACE2(rr_get_move(*read_result),
		rr_get_result(*read_result), "cached");
      return rr_get_result(*read_result);
    }
  }
  
  if (ladder_capture(str1, &xpos) == WIN) {
    SGFTRACE2(xpos, WIN, "first string capturable");
    READ_RETURN_CONN(read_result, move, xpos, WIN);
  }
  if (ladder_capture(str2, &xpos) == WIN) {
    SGFTRACE2(xpos, WIN, "second string capturable");
    READ_RETURN_CONN(read_result, move, xpos, WIN);
  }

  num_moves = find_connection_moves(str1, str2, other, moves, &distance);
  
  for (k = 0; k < num_moves; k++) {
    int new_komaster;
    int new_kom_pos;
    int ko_move;

    xpos = moves[k];
    
    if (komaster_trymove(xpos, other, "recursive_disconnect2", str1,
			 komaster, kom_pos, &new_komaster, &new_kom_pos,
			 &ko_move, stackp <= ko_depth && savecode == 0)) {
      if (!ko_move) {
	int dcode = recursive_connect2(str1, str2, NULL,
				       new_komaster, new_kom_pos, has_passed);
	popgo();
	if (dcode == 0) {
	  SGFTRACE2(xpos, WIN, "disconnection effective");
	  READ_RETURN_CONN(read_result, move, xpos, WIN);
	}
	/* if the move works with ko we save it, then look for something
	 * better.
	 */
	UPDATE_SAVED_KO_RESULT(savecode, savemove, dcode, xpos);
      }
      else {
	if (recursive_connect2(str1, str2, NULL,
			       new_komaster, new_kom_pos,
			       has_passed) != WIN) {
	  savemove = xpos;
	  savecode = KO_B;
	}
	popgo();
      }
    }
  }

  if (num_moves == 0
      && distance >= 1.0
      && (has_passed
	  || !recursive_connect2(str1, str2, NULL, komaster, kom_pos, 1))) {
    SGFTRACE2(NO_MOVE, WIN, "no move, probably disconnected");
    READ_RETURN_CONN(read_result, move, NO_MOVE, WIN);
  }
  
  if (savecode != 0) {
    SGFTRACE2(savemove, savecode, "saved move");
    READ_RETURN_CONN(read_result, move, savemove, savecode);
  }

  SGFTRACE2(0, 0, NULL);
  READ_RETURN_CONN(read_result, move, NO_MOVE, 0);
}


/* Find moves to connect or disconnect the two strings str1 and str2.
 * If color_to_move equals the color of the strings we search for
 * connecting moves and otherwise disconnecting moves. The moves are
 * returned in the moves[] array and the number of moves is the return
 * value of the function. The parameter *total_distance is set to the
 * approximated connection distance between the two strings. This is
 * most useful when no moves are found. If *total_distance is small
 * they are probably already effectively connected and if it is huge
 * they are probably disconnected.
 *
 * The algorithm is to compute connection distances around each string
 * and find points where the sum of the distances is small, or more
 * exactly where the sum of the distances after the move would be
 * small. This can be done with help of delta values returned together
 * with distance values from the function
 * compute_connection_distances(). This "distance after move" measure
 * is modified with various bonuses and then used to order the found
 * moves.
 */
static int
find_connection_moves(int str1, int str2, int color_to_move,
		      int moves[MAX_MOVES], float *total_distance)
{
  int color = board[str1];
  int other = OTHER_COLOR(color);
  int connect_move = (color_to_move == color);
  int r;
  struct connection_data conn1;
  struct connection_data conn2;
  float distances[MAX_MOVES];
  int num_moves = 0;
  SGFTree *save_sgf_dumptree = sgf_dumptree;
  int save_count_variations = count_variations;
  int acode = 0;
  int attack_move = NO_MOVE;
  int dcode = 0;
  int defense_move = NO_MOVE;
  float max_dist1;
  float max_dist2;
  int lib;
  int k;
  int i, j;

  /* We turn off the sgf traces here to avoid cluttering them up with
   * tactical reading moves.
   */
  sgf_dumptree = NULL;
  count_variations = 0;

  compute_connection_distances(str1, &conn1);
  compute_connection_distances(str2, &conn2);

  if (findlib(str1, 1, &lib) == 1) {
    conn1.distances[lib] = 0;
    conn2.distances[lib] = conn2.distances[str1];
  }

  if (findlib(str2, 1, &lib) == 1) {
    conn2.distances[lib] = 0;
    conn1.distances[lib] = conn1.distances[str2];
  }


  max_dist1 = conn1.distances[str2];
  max_dist2 = conn2.distances[str1];

  *total_distance = gg_min(max_dist1, max_dist2);

  if (verbose > 0) {
    gprintf("%oVariation %d\n", save_count_variations);
    dump_stack();
    showboard(0);
    print_connection_distances(&conn1);
    print_connection_distances(&conn2);
  }

  /* Loop through the points with smallish distance from str1 an look
   * for ones also having a small distane to str2.
   */
  for (r = 0; r < conn1.queue_end; r++) {
    int pos = conn1.queue[r];
    float dist1 = conn1.distances[pos];
    float deltadist1 = conn1.deltas[pos];
    float dist2 = conn2.distances[pos];
    float deltadist2 = conn2.deltas[pos];
    float d1;
    float d2;
    float distance;
    
    if (dist1 - deltadist1 + dist2 - deltadist2 > 2.5
	|| dist1 > max_dist1
	|| dist2 > max_dist2)
      continue;

    if (board[pos] == other && find_origin(pos) != pos)
      continue;

    if (board[pos] == color)
      continue;
    
    if (verbose > 0)
      gprintf("%oMove %1m, (%f, %f, %f, %f)\n",
	      pos, dist1, deltadist1, dist2, deltadist2);

    /* The basic quality of the move is the sum of the distances to
     * each string minus the two delta values. This distance value
     * will subsequently be modified to take other factors into
     * account.
     */
    d1 = dist1 - deltadist1;
    d2 = dist2 - deltadist2;
    distance = d1 + d2;
    if (verbose > 0)
      gprintf("%o  %f, primary distance\n", distance);
    
    /* Bonus if d1 and d2 are well balanced. */
    if (1.5 * d1 > d2 && 1.5 * d2 > d1) {
      distance -= 0.1;
      if (verbose > 0)
	gprintf("%o  -0.1, well balanced\n");
    }

    /* Check the surrounding eight vertices to see whether this move
     * is "between" the two strings.
     */
    for (k = 0; k < 8; k++) {
      if (ON_BOARD(pos + delta[k]) && board[pos + delta[k]] != other) {
	d1 = dist1 - conn1.distances[pos + delta[k]];
	d2 = dist2 - conn2.distances[pos + delta[k]];
	if (d1 * d2 <= 0.0 && (d1 != 0.0 || d2 != 0.0))
	  break;
      }
    }
    if (k == 8 && board[pos] == EMPTY
	&& (!((liberty_of_string(pos, str1) && countlib(str1) < 3)
	      || (liberty_of_string(pos, str2) && countlib(str2) < 3)))) {
      if (verbose > 0)
	gprintf("%o  discarded, not on the shortest path\n");
      continue;
    }
    
    if (board[pos] == EMPTY) {
      if (!is_self_atari(pos, color_to_move)) {
	ADD_CANDIDATE_MOVE(pos, distance, moves, distances, num_moves);
      }
      else {
	if (verbose > 0)
	  gprintf("%o  discarded, self atari\n");
      }
    }
    else if (board[pos] == other) {
      attack_and_defend(pos, &acode, &attack_move, &dcode, &defense_move);
      if (verbose > 0)
	gprintf("%o  attack with code %d at %1m, defense with code %d at %1m\n",
		acode, attack_move, dcode, defense_move);
      
      if (connect_move && acode != 0) {
	if (dcode == 0) {
	  distance += 0.5;
	  if (verbose > 0)
	    gprintf("%o  +0.5, no defense\n");
	}
	else {
	  if (conn1.distances[attack_move]
	      + conn2.distances[attack_move] > dist1 + dist2) {
	    distance += 0.5;
	    if (verbose > 0)
	      gprintf("%o  +0.5, attack point not on shortest path\n");
	  }
	}
	ADD_CANDIDATE_MOVE(attack_move, distance - 0.15, moves, distances,
			   num_moves);
	if (verbose > 0)
	  gprintf("%o  -0.15, capturing a string\n");
      }
      else if (!connect_move && acode != 0 && dcode != 0) {
	ADD_CANDIDATE_MOVE(defense_move, distance - 0.5, moves, distances,
			   num_moves);
	if (verbose > 0)
	  gprintf("%o  -0.5, defending a string\n");
      }
    }
  }

  /* Turn the sgf traces back on. */
  sgf_dumptree = save_sgf_dumptree;
  count_variations = save_count_variations;

  /* Modify the distance values for the moves with various bonuses. */
  for (r = 0; r < num_moves; r++) {
    int move = moves[r];
    int adjacent_to_attacker = 0;

    for (k = 0; k < 4; k++) {
      int pos = move + delta[k];
      if (board[pos] == other) {
	adjacent_to_attacker = 1;
	distances[r] -= 0.15;
	if (verbose > 0)
	  gprintf("%o%1M -0.15, adjacent to attacker string\n", move);
	if (countlib(pos) <= 2) {
	  distances[r] -= 0.2;
	  if (verbose > 0)
	    gprintf("%o%1M -0.2, adjacent to attacker string with at most two liberties\n", move);
	  if ((conn1.distances[move] - conn1.deltas[move] <= 0.5
	       || conn1.distances[pos] - conn1.deltas[pos] <= 0.5)
	      && (conn2.distances[move] - conn2.deltas[move] <= 0.5
		  || conn2.distances[pos] - conn2.deltas[pos] <= 0.5)
	      && conn1.distances[pos] < *total_distance
	      && conn2.distances[pos] < *total_distance) {
	    distances[r] -= 0.7;
	    if (verbose > 0)
	      gprintf("%o%1M -0.7, capture or atari of immediately connecting string\n", move);
	  }
	}
      }
      else if (board[pos] == color) {
	if (countlib(pos) <= 2) {
	  if (verbose > 0)
	    gprintf("%o%1M -0.2, adjacent to defender string with at most two liberties\n", move);
	}
      }
    }
    if (adjacent_to_attacker
	&& color != color_to_move
	&& is_edge_vertex(move)) {
      distances[r] -= 0.1;
      if (verbose > 0)
	gprintf("%o%1M -0.1, disconnect move on edge\n", move);
    }
    
  }

  /* Normalize distance values. See comment to gg_normalize_float() in
   * utils/gg_utils.c for an explanation of this operation. It is
   * assumed that all distance values are integral multiples of 0.001.
   */
  for (i = 0; i < num_moves; i++)
    distances[i] = gg_normalize_float(distances[i], 0.001);
  
  /* Now sort the moves.  We use selection sort since this array will
   * probably never be more than 10 moves long.  In this case, the
   * overhead imposed by quicksort will probably overshadow the gains
   * given by the O(n*log(n)) behaviour over the O(n^2) behaviour of
   * selection sort.
   */
  for (i = 0; i < num_moves; i++) {
    /* Find the move with the smallest distance. */
    float mindistance = distances[i];
    int min_at = i;
    for (j = i + 1; j < num_moves; j++) {
      if (distances[j] < mindistance) {
	mindistance = distances[j];
	min_at = j;
      }
    }

    /* Now exchange the move at i with the move at min_at.
     * Don't forget to exchange the distances as well.
     */
    if (min_at != i) {
      int temp = moves[i];
      float tempmin = distances[i];

      moves[i] = moves[min_at];
      distances[i] = distances[min_at];

      moves[min_at] = temp;
      distances[min_at] = tempmin;
    }
  }

  if (verbose > 0) {
    gprintf("%oSorted moves:\n");
    for (i = 0; i < num_moves; i++)
      gprintf("%o%1M %f\n", moves[i], distances[i]);
  }

  if (sgf_dumptree) {
    char buf[500];
    char *pos;
    int chars;
    sprintf(buf, "Move order for %sconnect: %n",
	    color_to_move == color ? "" : "dis", &chars);
    pos = buf + chars;
    for (i = 0; i < num_moves; i++) {
      sprintf(pos, "%c%d (%4.2f) %n", J(moves[i]) + 'A' + (J(moves[i]) >= 8),
	      board_size - I(moves[i]), distances[i], &chars);
      pos += chars;
    }
    sgftreeAddComment(sgf_dumptree, NULL, buf);
  }


  /* Filter out moves with distance at least 1.5 more than the best
   * move.
   */
  for (r = 0; r < num_moves; r++)
    if (distances[r] > distances[0] + 1.5)
      break;
  num_moves = r;

  return num_moves;
}


/* Helper macro for the function below. */
/* emgena */
#undef ENQUEUE

#define ENQUEUE(conn, pos, dist, delta) \
  do { \
    if (dist < conn->distances[pos]) { \
      if (board[pos] == EMPTY) { \
        if (conn->distances[pos] == HUGE_CONNECTION_DISTANCE) \
          conn->queue[conn->queue_end++] = pos; \
        conn->distances[pos] = dist; \
        conn->deltas[pos] = delta; \
      } \
      else { \
        int r; \
        num_stones = findstones(pos, MAX_BOARD * MAX_BOARD, stones); \
        for (r = 0; r < num_stones; r++) { \
          if (conn->distances[stones[r]] == HUGE_CONNECTION_DISTANCE) \
            conn->queue[conn->queue_end++] = stones[r]; \
          conn->distances[stones[r]] = dist; \
          conn->deltas[stones[r]] = delta; \
	} \
      } \
    } \
  } while (0);

/* Compute connection distances from the string str to nearby
 * vertices. This is a rough approximation of the number of moves
 * required to secure a connection from str to another vertex of the
 * board. We also compute delta values which are intended to tell how
 * big difference a particular move locally has on the connection
 * distance. However, remember that this is only a heuristic with the
 * sole purpose of helping to find relevant moves for connection
 * problems.
 *
 * The algorithm is to propagate connection values outwards using a
 * breadth-first searching strategy, implemented through an implicitly
 * sorted queue. The propagation to new vertices depends on
 * geometrical features with significance for connections. E.g. a
 * bamboo joint is recognized and the distance added when passing
 * through it is small. New points are added to the queue through the
 * ENQUEUE macro above. This checks whether the point has already been
 * entered on the queue and updates the distance and delta values if
 * the previous ones were worse. When a stone is entered, all stones
 * of the string are added to the queue simultaneously.
 *
 * The propagation is inhibited when the distance becomes too large.
 */
static void
compute_connection_distances(int str, struct connection_data *conn)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int pos;
  int k;
  float distance;
  int stones[MAX_BOARD * MAX_BOARD];
  int num_stones = findstones(str, MAX_BOARD * MAX_BOARD, stones);
  
  conn->queue_start = 0;
  conn->queue_end = 0;

  /* Initialize distance and delta values so that the former are
   * everywhere huge and the latter everywhere zero.
   */
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    conn->distances[pos] = HUGE_CONNECTION_DISTANCE;
    conn->deltas[pos] = 0.0;
  }

  /* Add all stones in the initial string to the queue. */
  for (k = 0; k < num_stones; k++) {
    ENQUEUE(conn, stones[k], 0.0, 0.0);
  }

  /* Loop until we reach the end of the queue. */
  for (; conn->queue_start < conn->queue_end; conn->queue_start++) {
    float smallest_dist = HUGE_CONNECTION_DISTANCE;
    int best_index = -1;

    gg_assert(conn->queue_end <= MAX_BOARD * MAX_BOARD);

    /* Find the smallest distance among the queued points. */
    for (k = conn->queue_start; k < conn->queue_end; k++) {
      if (conn->distances[conn->queue[k]] < smallest_dist) {
	smallest_dist = conn->distances[conn->queue[k]];
	best_index = k;
      }
    }

    /* Exchange the best point with the first element in the queue. */
    if (best_index != conn->queue_start) {
      int tmp = conn->queue[conn->queue_start];
      conn->queue[conn->queue_start] = conn->queue[best_index];
      conn->queue[best_index] = tmp;
    }

    /* Now we are ready to pick the first element in the queue and
     * process it.
     */
    pos = conn->queue[conn->queue_start];
    distance = conn->distances[pos];

    /* No further propagation if the distance is too large. */
    if (distance > 3.0)
      break;

    /* Search for new vertices to propagate to. */
    if (board[pos] == color) {
      for (k = 0; k < 4; k++) {
	/* List of relative coordinates. (pos) is marked by *.
	 *
	 *  jef.
	 *  igb.
	 * kh*ac
	 *   .d.
	 *
	 */
	int right = delta[k];
	int up = delta[(k+1)%4];

	/* FIXME: Compactify this list. */
	int apos = pos + right;
	int bpos = pos + right + up;
	int cpos = pos + 2 * right;
	int epos = pos + 2*up;
	int fpos = pos + right + 2*up;
	int gpos = pos + up;
	int hpos = pos - right;
	int ipos = pos - right + up;
	int jpos = pos - right + 2 * up;
	int kpos = pos - 2 * right;
	
	/* Case 1. "a" is empty and would be suicide for the opponent. */
	if (board[apos] == EMPTY && is_suicide(apos, other)) {
	  ENQUEUE(conn, apos, distance, 0.0);
	}
	
	/* Case 2. "a" is empty and would be self atari for the opponent. */
	if (board[apos] == EMPTY
	    && conn->distances[apos] > distance + 0.1
	    && is_self_atari(apos, other)) {
	  ENQUEUE(conn, apos, distance + 0.1, 0.1);
	}
	
	/* Case 3. Bamboo joint of "*" + "a" to "e" + "f" through "b" and "g".
	 * Notice that the order of these tests is significant. We must
	 * check bpos before fpos and epos to avoid accessing memory
	 * outside the board array. (Notice that fpos is two steps away
	 * from pos, which we know is on the board.)
	 */
	if (board[apos] == color && board[bpos] == EMPTY
	    && board[fpos] == color && board[epos] == color
	    && board[gpos] == EMPTY) {
	  ENQUEUE(conn, bpos, distance + 0.1, 0.1);
	  ENQUEUE(conn, gpos, distance + 0.1, 0.1);
	}
	   
	/* Case 4. Diagonal connection to another stone "b" through
	 * empty vertices "a" and "g".
	 */
	if (board[bpos] == color
	    && board[apos] == EMPTY
	    && board[gpos] == EMPTY
	    && conn->distances[bpos] > distance + 0.2) {
	  ENQUEUE(conn, apos, distance + 0.2, 0.2);
	  ENQUEUE(conn, gpos, distance + 0.2, 0.2);
	}
	   
	/* Case 5. Almost bamboo joint.
	 * 
	 */
	if (board[gpos] == EMPTY
	    && board[epos] == color
            && conn->distances[gpos] > distance + 0.2
	    && approxlib(gpos, other, 3, NULL) <= 2
	    && ((board[bpos] == EMPTY
		 && approxlib(bpos, color, 3, NULL) >= 3
		 && (board[apos] == color
		     || (board[apos] == EMPTY
			 && approxlib(apos, other, 3, NULL) <= 2))
		 && (board[fpos] == color
		     || (board[fpos] == EMPTY
			 && approxlib(fpos, other, 3, NULL) <= 2)))
		|| (board[ipos] == EMPTY
		    && approxlib(ipos, color, 3, NULL) >= 3
		    && (board[hpos] == color
			|| (board[hpos] == EMPTY
			    && approxlib(hpos, other, 3, NULL) <= 2))
		    && (board[jpos] == color
			|| (board[jpos] == EMPTY
			    && approxlib(jpos, other, 3, NULL) <= 2))))) {
	  ENQUEUE(conn, gpos, distance + 0.2, 0.2);
	}
	   	   
	/* Case 6. "a" is empty and an opponent move can be captured in
	 * a ladder.
	 */
	if (board[apos] == EMPTY
	    && conn->distances[apos] > distance + 0.7
	    && ladder_capturable(apos, other)) {
	  ENQUEUE(conn, apos, distance + 0.7, 0.7);
	}

	/* Case 7. "a" is empty or occupied by opponent.
	 */
	if ((board[apos] == EMPTY || board[apos] == other)
	    && conn->distances[apos] > distance + 1.0) {
	  ENQUEUE(conn, apos, distance + 1.0, 1.0);
	}

	/* Case 8. Diagonal connection to empty vertex "b" through
	 * empty vertex "a" or "g", which makes "a" or "g" self_atari
	 * for opponent.
	 */
	if (board[bpos] == EMPTY
	    && board[apos] == EMPTY
	    && conn->distances[bpos] > distance + 1.1
	    && does_secure(color, bpos, apos)) {
	  ENQUEUE(conn, bpos, distance + 1.1, 1.0);
	}

	if (board[bpos] == EMPTY
	    && board[gpos] == EMPTY
	    && conn->distances[bpos] > distance + 1.1
	    && does_secure(color, bpos, gpos)) {
	  ENQUEUE(conn, bpos, distance + 1.1, 1.0);
	}

	/* Case 9. One-space jump to empty vertex "e" through empty
	 * vertex "g", which makes "g" self_atari for opponent.
	 */
	if (board[gpos] == EMPTY
	    && board[epos] == EMPTY
	    && conn->distances[epos] > distance + 1.1
	    && does_secure(color, epos, gpos)) {
	  ENQUEUE(conn, epos, distance + 1.1, 1.0);
	}

	/* Case 10. Diagonal connection to empty vertex "b" through
	 * empty vertices "a" and "g".
	 */
	if (board[bpos] == EMPTY
	    && board[apos] == EMPTY && board[gpos] == EMPTY
            && conn->distances[bpos] > distance + 1.3) {
	  ENQUEUE(conn, bpos, distance + 1.3, 1.0);
	}

	/* Case 11. Keima to f or j on edge and one space jump on
	 * first or second line.
	 */
	if (board[apos] == EMPTY
	    && board[bpos] == EMPTY
	    && board[gpos] == EMPTY
	    && board[epos] == EMPTY
	    && board[fpos] == EMPTY
	    && (conn->distances[fpos] > distance + 1.3
		|| conn->distances[epos] > distance + 1.5)
	    && countlib(pos) >= 3
	    && (!ON_BOARD(cpos) || !ON_BOARD(hpos))) {
	  ENQUEUE(conn, fpos, distance + 1.3, 1.0);
	  ENQUEUE(conn, epos, distance + 1.3, 1.0);
	}

	if (countlib(pos) >= 3
	    && board[hpos] == EMPTY
	    && board[ipos] == EMPTY
	    && board[gpos] == EMPTY
	    && board[epos] == EMPTY
	    && board[jpos] == EMPTY
	    && (conn->distances[jpos] > distance + 1.3
		|| conn->distances[epos] > distance + 1.5)
	    && (!ON_BOARD(apos) || !ON_BOARD(kpos))) {
	  ENQUEUE(conn, jpos, distance + 1.3, 1.0);
	  ENQUEUE(conn, epos, distance + 1.3, 1.0);
	}

	/* Case 12. Diagonal connection to empty vertex "b" through
	 * empty vertex "a" or "g", which allows opponent move at "a"
	 * or "g" to be captured in a ladder.
	 */
	if (board[bpos] == EMPTY
	    && board[apos] == EMPTY
	    && conn->distances[bpos] > distance + 1.2
	    && does_secure_through_ladder(color, bpos, apos)) {
	  ENQUEUE(conn, bpos, distance + 1.2, 1.0);
	}

	if (board[bpos] == EMPTY
	    && board[gpos] == EMPTY
	    && conn->distances[bpos] > distance + 1.2
	    && does_secure_through_ladder(color, bpos, gpos)) {
	  ENQUEUE(conn, bpos, distance + 1.2, 1.0);
	}

	/* Case 13. Diagonal connection to empty vertex "b" through
	 * empty vertex "a" or "g", with no particular properties.
	 */
	if (board[bpos] == EMPTY
	    && board[apos] == EMPTY
	    && conn->distances[bpos] > distance + 1.8) {
	  ENQUEUE(conn, bpos, distance + 1.8, 0.9);
	}

	if (board[bpos] == EMPTY
	    && board[gpos] == EMPTY
	    && conn->distances[bpos] > distance + 1.8
	    && does_secure_through_ladder(color, bpos, gpos)) {
	  ENQUEUE(conn, bpos, distance + 1.8, 0.9);
	}

	/* Case 14. Diagonal connection to empty vertex "b" through
	 * opponent stones "a" or "g" with few liberties.
	 */
	if (board[bpos] == EMPTY
	    && board[apos] == other
	    && board[gpos] == other
	    && conn->distances[bpos] > distance + 2.0
	    && (countlib(apos) + countlib(gpos) <= 6)) {
	  ENQUEUE(conn, bpos, distance + 2.0, 1.0);
	}

	/* Case 15. Diagonal connection to own stone "b" through
	 * opponent stones "a" or "g" with few liberties.
	 */
	if (board[bpos] == color
	    && board[apos] == other
	    && board[gpos] == other
	    && conn->distances[bpos] > distance + 2.0
	    && (countlib(apos) + countlib(gpos) <= 5)) {
	  ENQUEUE(conn, bpos, distance + 2.0, 1.0);
	}

	/* Case 16. Adjacent opponent stone at "a" which can't avoid atari.
	 */
	if (board[apos] == other
	    && conn->distances[apos] > distance + 0.1
	    && no_escape_from_atari(apos)) {
	  ENQUEUE(conn, apos, distance + 0.1, 0.1);
	}

	/* Case 17. Adjacent opponent stone at "a" which can't avoid
	 * ladder capture.
	 */
	if (board[apos] == other
	    && conn->distances[apos] > distance + 0.3
	    && no_escape_from_ladder(apos)) {
	  ENQUEUE(conn, apos, distance + 0.3, 0.3);
	}
      }
    }
    else if (board[pos] == EMPTY
	     || (board[pos] == other
		 && (no_escape_from_ladder(pos))
		 && countlib(pos) <= 2)) {
      for (k = 0; k < 4; k++) {
	/* List of relative coordinates. (pos) is marked by *.
	 *
	 *  jef.
	 *  igb.
	 * kh*ac
	 *   .d.
	 *
	 */
	int right = delta[k];
	int up = delta[(k+1)%4];

	/* FIXME: Compactify this list. */
	int apos = pos + right;
	int bpos = pos + right + up;
#if 0
	int cpos = pos + 2 * right;
	int epos = pos + 2*up;
	int fpos = pos + right + 2*up;
#endif
	int gpos = pos + up;
#if 0
	int hpos = pos - right;
	int ipos = pos - right + up;
	int jpos = pos - right + 2 * up;
	int kpos = pos - 2 * right;
#endif
	
	if (board[apos] == color) {
	  ENQUEUE(conn, apos, distance, 0.0);
	}
	else if (ON_BOARD(apos)) {
	  ENQUEUE(conn, apos, distance + 1.0, 1.0);
	}

	/* Case 1. Diagonal connection to empty vertex "b" through
	 * empty vertices "a" and "g".
	 */
	if (board[bpos] == EMPTY
	    && board[apos] == EMPTY
	    && board[gpos] == EMPTY
            && conn->distances[bpos] > distance + 1.5) {
	  ENQUEUE(conn, bpos, distance + 1.5, 1.0);
	}
	
	/* Case 2. Diagonal connection to friendly stone at "b" through
	 * empty vertices "a" and "g".
	 */
	if (board[bpos] == color
	    && board[apos] == EMPTY
	    && board[gpos] == EMPTY
	    && conn->distances[bpos] > distance + 1.3) {
	  ENQUEUE(conn, bpos, distance + 1.3, 1.0);
	}
      }
    }
  }
}


/* Print the connection distances in a struct connection_data. */
static void
print_connection_distances(struct connection_data *conn)
{
  int i, j;
  int ch;
  
  fprintf(stderr, "  ");
  for (j = 0, ch = 'A'; j < board_size; j++, ch++) {
    if (ch == 'I')
      ch++;
    fprintf(stderr, "  %c ", ch);
  }
  fprintf(stderr, "\n");

  for (i = 0; i < board_size; i++) {
    fprintf(stderr, "%2d ", board_size - i);
    for (j = 0; j < board_size; j++) {
      int pos = POS(i, j);
      if (conn->distances[pos] == HUGE_CONNECTION_DISTANCE) {
	if (board[pos] == WHITE)
	  fprintf(stderr, " O  ");
	if (board[pos] == BLACK)
	  fprintf(stderr, " X  ");
	if (board[pos] == EMPTY)
	  fprintf(stderr, " .  ");
      }
      else {
	fprintf(stderr, "%3.1f ", conn->distances[pos]);
      }
    }
    fprintf(stderr, "\n");
  }
  fprintf(stderr, "\n");
}


/* Test whether there is a trivial connection between str1 and str2
 * and if so return the connecting move in *move. By trivial
 * connection we mean that they either have a common liberty or a
 * common neighbor which can be tactically attacked.
 */
static int
trivial_connection(int str1, int str2, int *move)
{
  SGFTree *save_sgf_dumptree = sgf_dumptree;
  int save_count_variations = count_variations;
  int adj, adjs[MAXCHAIN];
  int r;
  int result = 0;
  
  if (have_common_lib(str1, str2, move))
    return WIN;

  adj = chainlinks(str1, adjs);

  /* We turn off the sgf traces here to avoid cluttering them up with
   * tactical reading moves.
   */
  sgf_dumptree = NULL;
  count_variations = 0;
  
  for (r = 0; r < adj; r++)
    if (adjacent_strings(adjs[r], str2) && attack(adjs[r], move) == WIN) {
      result = WIN;
      break;
    }

  /* Turn the sgf traces back on. */
  sgf_dumptree = save_sgf_dumptree;
  count_variations = save_count_variations;
  
  return result;
}


/* True if a move by color makes an opponent move at pos a self atari.
 */
static int
does_secure(int color, int move, int pos)
{
  int result = 0;
  if (trymove(move, color, NULL, NO_MOVE, EMPTY, NO_MOVE)) {
    if (is_self_atari(pos, OTHER_COLOR(color)))
      result = 1;
    popgo();
  }
  
  return result;
}


/* True if a move by color makes an opponent move at pos a self atari
 * or possible to capture in a ladder.
 */
static int
does_secure_through_ladder(int color, int move, int pos)
{
  int result = 0;
  
  if (trymove(move, color, NULL, NO_MOVE, EMPTY, NO_MOVE)) {
    if (ladder_capturable(pos, OTHER_COLOR(color)))
      result = 1;
    popgo();
  }
  
  return result;
}

/* Test whether the string str can be immediately taken off the board
 * or captured in a ladder. If so the capturing move is returned in
 * *move.
 */
static int
ladder_capture(int str, int *move)
{
  int result;
  SGFTree *save_sgf_dumptree = sgf_dumptree;
  int save_count_variations = count_variations;
  int liberties = countlib(str);
  
  /* We turn off the sgf traces here to avoid cluttering them up with
   * tactical reading moves.
   */
  sgf_dumptree = NULL;
  count_variations = 0;

  if (liberties == 1)
    result = attack(str, move);
  else if (liberties == 2)
    result = simple_ladder(str, move);
  else
    result = 0;
  
  /* Turn the sgf traces back on. */
  sgf_dumptree = save_sgf_dumptree;
  count_variations = save_count_variations;

  return result;
}

/* Test whether a move at pos by color can be captured in a ladder. */
static int
ladder_capturable(int pos, int color)
{
  int result = 0;
  
  if (trymove(pos, color, NULL, NO_MOVE, EMPTY, NO_MOVE)) {
    int liberties = countlib(pos);
    if (liberties == 1 && attack(pos, NULL) == WIN)
      result = 1;
    else if (liberties == 2 && simple_ladder(pos, NULL) == WIN)
      result = 1;
    popgo();
  }
  else
    result = 1;
  
  return result;
}


/* Test whether the string str with one liberty is stuck with at most
 * one liberty. This function trivially returns false if the string
 * has more than one liberty to start with.
 */
static int
no_escape_from_atari(int str)
{
  int lib;
  int adj[MAXCHAIN];

  if (findlib(str, 1, &lib) > 1)
    return 0;

  if (accurate_approxlib(lib, board[str], 2, NULL) > 1)
    return 0;

  /* FIXME: Should exclude snapback. */
  if (chainlinks2(str, adj, 1) > 0)
    return 0;

  return 1;
}


/* Test whether the string str with one liberty is captured in a
 * ladder. This function trivially returns false if the string has
 * more than one liberty to start with.
 * FIXME: Needs a simple_ladder_defense().
 */
static int
no_escape_from_ladder(int str)
{
  int result = 0;
  SGFTree *save_sgf_dumptree = sgf_dumptree;
  int save_count_variations = count_variations;
  
  /* We turn off the sgf traces here to avoid cluttering them up with
   * tactical reading moves.
   */
  sgf_dumptree = NULL;
  count_variations = 0;
  
  if (countlib(str) == 1 && find_defense(str, NULL) == 0)
    result = 1;
  
  /* Turn the sgf traces back on. */
  sgf_dumptree = save_sgf_dumptree;
  count_variations = save_count_variations;

  return result;
}


/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */

/***********************************************************************/


/* reading.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* #include <stdio.h> */
/* #include <stdlib.h> */
/* #include <stdarg.h> */
/* #include <string.h> */

/* #include "gnugo.h" */
/* #include "liberty.h" */
/* #include "gg_utils.h" */

/* #include "cache.h" */
/* #include "patterns.h" */


#if EXPERIMENTAL_READING

/* When to use pattern-base reading */
int defend_by_pattern = 0;
int attack_by_pattern = 1;

static int do_tactical_pat(int is_attack, int str, int *move, 
			   int komaster, int kom_pos);
static int do_defend_pat(int str, int *move, int komaster, int kom_pos);
static int do_attack_pat(int str, int *move, int komaster, int kom_pos);

#endif

/* emgena */
#undef MAX_MOVES

/* Size of array where candidate moves are stored. */
#define MAX_MOVES 50

/* emgena */
#undef ADD_CANDIDATE_MOVE

#define ADD_CANDIDATE_MOVE(move, score, moves, scores, num_moves)\
  do {\
    int la;\
    for (la = 0; la < num_moves; la++)\
      if (moves[la] == (move)) {\
        if (scores[la] < score)\
          scores[la] = score;\
	break;\
      }\
    if ((la == num_moves) && (num_moves < MAX_MOVES)) {\
      moves[num_moves] = move;\
      scores[num_moves] = score;\
      (num_moves)++;\
    }\
  } while (0)

#define REMOVE_CANDIDATE_MOVE(move, moves, scores, num_moves)\
  do {\
    int kr, lr;\
    for (kr = 0; kr < num_moves; kr++) {\
      if (moves[kr] == (move)) {\
        for (lr = kr; lr < num_moves-1; lr++) {\
	  moves[lr] = moves[lr+1];\
	  scores[lr] = scores[lr+1];\
	}\
        (num_moves)--;\
	break;\
      }\
    }\
  } while (0)


/*
 * The functions in reading.c are used to read whether groups 
 * can be captured or not. See the Texinfo documentation 
 * (Reading) for more information.
 *
 * NULL POINTERS: Many functions in this file can use pointers
 * to return the locations of recommended plays. These can be
 * set NULL in which case these values are not returned.
 */

static int do_find_defense(int str, int *move, int komaster, int kom_pos);
static int defend1(int str, int *move, int komaster, int kom_pos);
static int defend2(int str, int *move, int komaster, int kom_pos);
static int defend3(int str, int *move, int komaster, int kom_pos);
static int defend4(int str, int *move, int komaster, int kom_pos);
static int special_rescue(int str, int lib, int *move, 
			  int komaster, int kom_pos,
			  int tried[], int num_tried);
static int special_rescue2(int str, int libs[2], int *move, 
			   int komaster, int kom_pos,
			   int tried[], int num_tried);
static int special_rescue3(int str, int libs[3], int *move, 
			   int komaster, int kom_pos);
static int special_rescue4(int str, int libs[3], int *move, 
			   int komaster, int kom_pos);
static void special_rescue5(int str, int libs[3], int moves[MAX_MOVES],
			    int scores[MAX_MOVES], int *num_moves);
static void special_rescue6(int str, int libs[3], int moves[MAX_MOVES],
			    int scores[MAX_MOVES], int *num_moves);
static void edge_clamp(int str, int moves[MAX_MOVES],
		       int scores[MAX_MOVES], int *num_moves);
static int do_attack(int str, int *move, int komaster, int kom_pos);
static int attack1(int str, int *move, int komaster, int kom_pos);
static int attack2(int str, int *move, int komaster, int kom_pos);
static int attack3(int str, int *move, int komaster, int kom_pos);
static int attack4(int str, int *move, int komaster, int kom_pos);
static int find_cap2(int str, int alib, int blib, int *move,
		     int komaster, int kom_pos);
static int find_cap3(int str, int *move, int komaster, int kom_pos);
static int special_attack2(int str, int libs[2], int *move,
			   int komaster, int kom_pos);
static int special_attack3(int str, int libs[2], int *move,
			   int komaster, int kom_pos);
static int special_attack4(int str, int libs[2], int *move,
			   int komaster, int kom_pos);
static int draw_back(int str, int *move, int komaster, int kom_pos);
static int edge_closing_backfill(int str, int apos, int *move);
static void edge_block(int str, int apos, int moves[MAX_MOVES],
		       int scores[MAX_MOVES], int *num_moves);
static void propose_edge_moves(int str, int *libs, int liberties,
			       int moves[MAX_MOVES], int scores[MAX_MOVES],
			       int *num_moves, int color);
static void break_chain_moves(int str, int moves[MAX_MOVES],
			      int scores[MAX_MOVES], int *num_moves);
static void break_chain2_efficient_moves(int str, int moves[MAX_MOVES],
					 int scores[MAX_MOVES],
					 int *num_moves);
static void break_chain2_moves(int str, int moves[MAX_MOVES],
			       int scores[MAX_MOVES], int *num_moves,
			       int require_safe);
static int break_chain2(int str, int *move, int komaster, int kom_pos);
static int break_chain3(int str, int *move, int komaster, int kom_pos);
static int superstring_breakchain(int str, int *move,
				  int komaster, int kom_pos,
				  int liberty_cap);
static void double_atari_chain2(int str, int moves[MAX_MOVES],
				int scores[MAX_MOVES], int *num_moves);
static void order_moves(int str, int num_moves, int *moves,
			int *scores, int color, const char *funcname);
static int simple_ladder_attack(int str, int *move, int komaster, int kom_pos);
static int simple_ladder_defend(int str, int *move, int komaster, int kom_pos);
static int in_list(int move, int num_moves, int *moves);


/* ================================================================ */
/*                     Persistent reading cache                     */
/* ================================================================ */


/* Persistent reading cache to reuse read results between moves and
 * within the same move when one or more far away moves have been
 * played.
 */

#define MAX_CACHE_DEPTH 5

struct reading_cache {
  int boardsize;
  char board[BOARDMAX];
  int movenum;
  int nodes;
  int score;
  int remaining_depth;
  int routine;			/* ATTACK or FIND_DEFENSE */
  int str;			/* contested string (origin) */
  int result;
  int move;			/* attack/defense point */
  int stack[MAX_CACHE_DEPTH];
  int move_color[MAX_CACHE_DEPTH];
};

#define MAX_READING_CACHE_SIZE 100
static struct reading_cache persistent_reading_cache[MAX_READING_CACHE_SIZE];
static int persistent_reading_cache_size = 0;

static void mgena_draw_active_area(char p[BOARDMAX]);
static int  mgena_verify_stored_board(char p[BOARDMAX]);


static int search_persistent_reading_cache(int routine, int str,
					   int *result, int *move);
static void store_persistent_reading_cache(int routine, int str,
					   int result, int move, int nodes);
static void print_persistent_reading_cache_entry(int k);
static void mark_string_hotspot_values(float values[BOARDMAX],
				       int m, int n, float contribution);

/* Statistics. */
static int reading_node_counter = 0;
static int nodes_when_called = 0;


/* ================================================================ */  
/*                          Goal functions                          */
/* ================================================================ */


/*
 * These functions define goals for the reading process.  They use 
 * the rest of the reading machinery to evaluate whether the goal
 * is fulfillable.
 *
 * The simplest goals are defined by attack() and find_defense(),
 * namely to see if it is possible to capture or defend a single
 * string.  More complex goals are defined by e.g. attack_either()
 * or defend_both().
 *
 * The functions in this section and the next are the only ones which are
 * callable from outside this file.  
 */


/* attack(str, *move) determines if the string at (str) can be 
 * captured, and if so, (*move) returns the attacking move, unless
 * (move) is a null pointer. Use a null pointer if you are interested
 * in the result of the attack but not the attacking move itself.
 *
 * Return WIN if the attack succeeds unconditionally, 0 if it doesn't.
 * Returns KO_A or KO_B if the result depends on ko: 
 *   - Returns KO_A if the attack succeeds provided attacker is willing to
 *     ignore any ko threat (the attacker makes the first ko capture).
 *   - Returns KO_B if attack succeeds provided attacker has a ko threat
 *     which must be answered (the defender makes the first ko capture).
 */

#define MIN_NODES_TO_REPORT 1000

int
attack(int str, int *move)
{
  int result;
  int nodes;
  int origin;
  int the_move = NO_MOVE;

  nodes_when_called = reading_node_counter;
  /* Don't even spend time looking in the cache if there are more than
   * four liberties.
   */
  if (countlib(str) > 4)
    return 0;

  origin = find_origin(str);
  if (search_persistent_reading_cache(ATTACK, origin, &result, &the_move)) {
    if (move) *move = the_move;
    return result;
  }

  memset(shadow, 0, sizeof(shadow));
  result = do_attack(str, &the_move, EMPTY, 0);
  nodes = reading_node_counter - nodes_when_called;

  if (debug & DEBUG_READING_PERFORMANCE) {
    if (reading_node_counter - nodes_when_called >= MIN_NODES_TO_REPORT) {
      if (result != 0)
	gprintf("%oattack %1m(%1m) = %d %1M, %d nodes ", str, origin, result,
		the_move, nodes);
      else
	gprintf("%oattack %1m(%1m) = %d, %d nodes ", str, origin, result,
		nodes);
      dump_stack();
    }
  }

  store_persistent_reading_cache(ATTACK, origin, result, the_move, nodes);
  
  if (move) *move = the_move;
  return result;
}


/* find_defense(str, *move) attempts to find a move that will save
 * the string at (str). It returns WIN if such a move is found, with
 * (*move) the location of the saving move, unless (move) is a
 * null pointer. It is not checked that tenuki defends, so this may 
 * give an erroneous answer if !attack(str).
 * 
 * Returns KO_A or KO_B if the result depends on ko. Returns KO_A if the
 * string can be defended provided the defender is willing to ignore
 * any ko threat. Returns KO_B if the defender wins by having a ko threat
 * which must be answered.
 */

int 
find_defense(int str, int *move)
{
  int result;
  int nodes;
  int origin;
  int the_move = NO_MOVE;

  nodes_when_called = reading_node_counter;
  /* Don't even spend time looking in the cache if there are more than
   * four liberties.
   */
  if (countlib(str) > 4) {
    if (move) *move = NO_MOVE;
    return WIN;
  }

  origin = find_origin(str);
  if (search_persistent_reading_cache(FIND_DEFENSE, origin, 
				      &result, &the_move)) {
    if (move) *move = the_move;
    return result;
  }

  memset(shadow, 0, sizeof(shadow));
  result = do_find_defense(str, &the_move, EMPTY, 0);
  nodes = reading_node_counter - nodes_when_called;

  if (debug & DEBUG_READING_PERFORMANCE) {
    if (reading_node_counter - nodes_when_called >= MIN_NODES_TO_REPORT) {
      if (result != 0)
	gprintf("%odefend %1m(%1m) = %d %1M, %d nodes ", str, origin, result,
		the_move, nodes);
      else
	gprintf("%odefend %1m(%1m) = %d, %d nodes ", str, origin, result,
		nodes);
      dump_stack();
    }
  }

  store_persistent_reading_cache(FIND_DEFENSE, origin, result, 
				 the_move, nodes);
  
  if (move) *move = the_move;
  return result;
}


/* attack_and_defend(str, &acode, &attack_point,
 *                        &dcode, &defense_point)
 * is a frontend to the attack() and find_defense() functions, which
 * guarantees a consistent result. If a string cannot be attacked, 0
 * is returned and acode is 0. If a string can be attacked and
 * defended, WIN is returned, acode and dcode are both non-zero, and
 * (attack_point), (defense_point) both point to vertices on the board. 
 * If a string can be attacked but not defended, 0 is again returned, 
 * acode is non-zero, dcode is 0, and (attack_point) points to a vertex 
 * on the board.
 *
 * This function in particular guarantees that if there is an attack,
 * it will never return (defense_point) = NO_MOVE, which means the string is
 * safe without defense. Separate calls to attack() and find_defense()
 * may occasionally give this result, due to irregularities introduced
 * by the persistent reading cache.
 */
int
attack_and_defend(int str,
		  int *attack_code, int *attack_point,
		  int *defend_code, int *defense_point)
{
  int acode = 0;
  int apos = NO_MOVE;
  int dcode = 0;
  int dpos = NO_MOVE;

  acode = attack(str, &apos);
  if (acode != 0) {
    dcode = find_defense(str, &dpos);
    
    /* If find_defense() says the string is safe as is, we believe
     * this in favor of attack()'s opinion. Actually this is probably
     * incorrect, but we can't easily find a defense point to return.
     */
    if (dcode == WIN && dpos == NO_MOVE) {
      acode = 0;
      apos = NO_MOVE;
    }
  }

  if (attack_code)
    *attack_code = acode;
  if (attack_point)
    *attack_point = apos;
  if (defend_code)
    *defend_code = dcode;
  if (defense_point)
    *defense_point = dpos;

  return acode != 0 && dcode != 0;
}


/*
 * attack_either(astr, bstr) returns true if there is a move which
 * guarantees that at least one of the strings (astr) and (bstr)
 * can be captured. A typical application for this is in connection
 * patterns, where after a cut it suffices to capture one of the cutting
 * stones.
 *
 * FIXME: The current implementation only looks for uncoordinated
 *        attacks. This is insufficient to find double ataris or 
 *        moves such as 'a' in positions like
 *
 *        XOOOOOOOX
 *        XOXXOXXOX
 *        XX..a..XX
 *        ---------
 *
 *        where neither of the threatened X stones can be captured right
 *        out. Still either can be captured by a move down to a.
 */

int
attack_either(int astr, int bstr)
{
  int asuccess = 0;
  int bsuccess = 0;
  int color = board[astr];
  ASSERT1(IS_STONE(color) , astr);
  ASSERT1(color == board[bstr], bstr);

  /* Start by attacking the string with the fewest liberties. On
   * average this seems to be slightly more efficient.
   */
  if (countlib(astr) > countlib(bstr)) {
    int t = astr;
    astr = bstr;
    bstr = t;
  }

  asuccess = attack(astr, NULL);
  if (asuccess == WIN)
    return asuccess;

  bsuccess = attack(bstr, NULL);
  if (asuccess || bsuccess) {
    return (asuccess > bsuccess) ? asuccess : bsuccess;
  }

  /* Try (a little) harder */
  {
    int libs[2];
    int alibs = findlib(astr, 2, libs);
    int defended0 = WIN;
    int defended1 = WIN;
    int other = OTHER_COLOR(color);
    /* Let's just try the case where the group with the fewest liberties
     * has only 2, and try each atari in turn.
     */
    if (alibs == 2) {
      if (trymove(libs[0], other, "attack_either-A", astr, EMPTY, NO_MOVE)) {
	defended0 = defend_both(astr, bstr);
	popgo();
      }
      if (defended0 
	  && trymove(libs[1], other, "attack_either-B", astr,
		     EMPTY, NO_MOVE)) {
	defended1 = defend_both(astr, bstr);
	popgo();
      }
    }
    return 3 - ((defended0 > defended1) ? defended1 : defended0);
  }

}


/*
 * defend_both(astr, bstr) returns true if both the strings (astr)
 * and (bstr) can be defended simultaneously or if there is no attack.
 * A typical application for this is in connection patterns, where
 * after a cut it's necessary to defend both cutting stones.
 *
 * FIXME: The current implementation only makes halfhearted
 * attempts to find coordinated defense moves. A proper implementation
 * would require some serious reading.
 */

int
defend_both(int astr, int bstr)
{
  int a_threatened = 0;
  int b_threatened = 0;
  int a_savepos;
  int b_savepos;
  int acode = 0;
  int dcode = 0;
  
  int color = board[astr];
  ASSERT1(IS_STONE(color) , astr);
  ASSERT1(color == board[bstr], bstr);

  attack_and_defend(astr, &acode, NULL, &dcode, &a_savepos);
  if (acode != 0) {
    a_threatened = 1;
    if (dcode == 0)
      return 0; /* (astr) already lost */
  }
  
  attack_and_defend(bstr, &acode, NULL, &dcode, &b_savepos);
  if (acode != 0) {
    b_threatened = 1;
    if (dcode == 0)
      return 0; /* (bstr) already lost */
  }

  /* Neither string can be attacked or only one of them, in which case
   * we have time to save it.
   */
  if (!a_threatened || !b_threatened)
    return WIN;
  
  /* If both strings are threatened we assume that one will become lost,
   * unless find_defense() happened to return the same defense point for
   * both (which e.g. may happen if they are in fact the same string).
   * This is still a bit too pessimistic, as there may be one move which
   * saves both strings. To do this right we should try each move which
   * defends either string and see if it also defends the other string.
   */

  if (a_savepos == b_savepos)
    return WIN; /* Both strings can be attacked but also defended 
                 * by one move. */

  /* We also try each of the returned defense points and see whether
   * the other string can still be attacked. This still gives a
   * somewhat pessimistic estimation.
   */

  if (trymove(a_savepos, color, "defend_both-A", astr, EMPTY, NO_MOVE)) {
    if (board[bstr] && !attack(bstr, NULL)) {
      popgo();
      return WIN;
    }
    popgo();
  }
  
  if (trymove(b_savepos, color, "defend_both-B", bstr, EMPTY, NO_MOVE)) {
    if (board[astr] && !attack(astr, NULL)) {
      popgo();
      return WIN;
    }
    popgo();
  }

  /* The next improvement is to try to attack a common adjacent string. */
  {
    int adjs1[MAXCHAIN];
    int neighbors1;
    int adjs2[MAXCHAIN];
    int neighbors2;
    int r;
    int s;
    int epos;
    int fpos;
    
    neighbors1 = chainlinks(astr, adjs1);
    neighbors2 = chainlinks(bstr, adjs2);
    
    for (r = 0; r < neighbors1; r++) {
      epos = adjs1[r];
      if (countlib(epos) <= 4
	  && (epos != a_savepos)
	  && (epos != b_savepos)) {
	/* Is (epos) also adjacent to (bstr)? */
	for (s = 0; s < neighbors2; s++) {
	  if (adjs2[s] == adjs1[r])
	    break;
	}
	if (s == neighbors2)
	  continue;   /* No, it wasn't. */

	if (attack(epos, &fpos)) {
	  if (trymove(fpos, color, "defend_both-C", astr, EMPTY, NO_MOVE)) {
	    if (board[astr] && board[bstr]
		&& !attack(astr, NULL) 
		&& !attack(bstr, NULL)) {
	      popgo();
	      return WIN;
	    }
	    popgo();
	  }
	}
      }
    }  
  }
  
  /* Both strings can be attacked but we have only time to defend one. */
  return 0;
}


/*
 * break_through(apos, bpos, cpos) returns WIN if a position can
 * succesfully be broken through and CUT if it can be cut. The position
 * is assumed to have the shape (the colors may be reversed)
 *
 * .O.       dbe
 * OXO       aFc
 *
 * It is X to move and try to capture at least one of a, b, and c. If
 * this succeeds, X is said to have broken through the position.
 * Otherwise X may try to cut through the position, which means
 * keeping F safe and getting a tactically safe string at either d or
 * e.
 *
 * Important notice: a, b, and c must be given in the correct order.
 *
 * FIXME: The reading involved here can most likely be improved.
 *
 * FIXME: We need to take ko results properly into account.
 */

static int
break_through_helper(int apos, int bpos, int cpos,
		     int dpos, int epos, int Fpos,
		     int color, int other);

int
break_through(int apos, int bpos, int cpos)
{
  int color = board[apos];
  int other = OTHER_COLOR(color);

  int dpos;
  int epos;
  int Fpos;
  int gpos;
  
  int success = 0;
  int success2 = 0;
  
  /* Basic sanity checking. */
  ASSERT1(IS_STONE(color) , apos);
  ASSERT1(color == board[bpos], bpos);
  ASSERT1(color == board[cpos], cpos);

  /* Construct the rest of the points in the pattern. */
  Fpos = (apos + cpos) / 2;      /* F midpoint between a and c. */
  dpos = apos + bpos - Fpos;     /* Use diagonal relation a+b = d+F. */
  epos = bpos + cpos - Fpos;     /* Use diagonal relation b+c = e+F. */

  /* More sanity checking. */
  ASSERT1(board[dpos] == EMPTY , dpos);
  ASSERT1(board[epos] == EMPTY , epos);

  /* F might already have been captured. (play_break_through_n() can't
   * detect this.
   */
  if (board[Fpos] == EMPTY)
    return 0;
  
  ASSERT1(board[Fpos] == other, Fpos);

  /* First X tries to play at d. */
  success = break_through_helper(apos, bpos, cpos, dpos, epos, Fpos,
				 color, other);
  if (success == WIN)
    return WIN;
  
  success2 = break_through_helper(cpos, bpos, apos, epos, dpos, Fpos,
				  color, other);

  if (success2 == WIN)
    return WIN;

  if (success2 == CUT)
    success = CUT;

  /* If we haven't been lucky yet, we might need to start by
   * defending F.
   *
   * FIXME: The function would probably be considerably faster if we
   * start by checking whether F needs defense. Beware of ko potential
   * though.
   */
  success2 = 0;
  if (attack_and_defend(Fpos, NULL, NULL, NULL, &gpos)) {
    if (trymove(gpos, other, "break_through-A", Fpos, EMPTY, NO_MOVE)) {
      /* Now we let O defend his position by playing either d or e.
       * FIXME: There may be other plausible moves too.
       */
      if (trymove(dpos, color, "break_through-B", Fpos, EMPTY, NO_MOVE)) {
	/* O connects at d, so X cuts at e. */
	if (safe_move(epos, other)) {
	  success2 = CUT;
	  if (!board[cpos] || attack(cpos, NULL))
	    success2 = WIN;
	}
	popgo();
      }

      if (success2 > 0 && trymove(epos, color, "break_through-C", Fpos,
				  EMPTY, NO_MOVE)) {
	/* O connects at e, so X cuts at d. */
	if (safe_move(dpos, other)) {
	  /* success2 is already WIN or CUT. */
	  if (board[apos] && !attack(apos, NULL))
	    success2 = CUT;
	}
	else
	  success2 = 0;
	popgo();
      }
      popgo();
    }
  }
    
  if (success2 > 0)
    return success2;

  return success;
}

/* Helper function for break_through(). Since we can symmetrically
 * start by cutting at d or e, we use the same code for both attacks,
 * simply switching positions between the two calls.
 */
static int
break_through_helper(int apos, int bpos, int cpos,
		     int dpos, int epos, int Fpos,
		     int color, int other)
{
  int success = 0;
  int gpos;

  if (trymove(dpos, other, "break_through_helper-A", Fpos, EMPTY, NO_MOVE)) {
    /* If F can be attacked we can't start in this way. */
    if (!attack(Fpos, NULL)) {
      /* If d is safe too, we have at least managed to break through. */
      if (!attack(dpos, &gpos))
	success = CUT;

      /* Too bad, d could be attacked. We let O play the attack and
       * then try to make a second cut at e. But first we must test if
       * O at e is sufficient to capture d.
       */
      else {
	if (trymove(epos, color, "break_through_helper-E", Fpos,
		    EMPTY, NO_MOVE)) {
	  if (!board[dpos] || !find_defense(dpos, NULL)) {
	    popgo();
	    popgo();
	    return 0;
	  }
	  popgo();
	}
	
	if (gpos == epos) {
	  popgo();
	  return 0;
	}

	if (trymove(gpos, color, "break_through_helper-F", Fpos,
		    EMPTY, NO_MOVE)) {
	  if (trymove(epos, other, "break_through_helper-G", Fpos,
		      EMPTY, NO_MOVE)) {
	    if (!attack(epos, NULL)) {
	      success = CUT;
     	      /* Make sure b and c are safe.  If not, back up & let O try 
	       * to defend in a different way. */
	      if (board[bpos] 
		  && board[cpos] 
		  && defend_both(bpos, cpos)) {
		/* Can't do better than CUT. */
		popgo();  
		popgo();
		popgo();
		return CUT;
	      }
	    }
	    popgo();
	  }
	  popgo();
	}
      }
      
      /* By now, we're sure a cut works, so now we can try 
       * to capture something. */
	if (!board[apos] || !board[bpos] || !defend_both(apos, bpos))
	  success = WIN;
	else {
	  /* Both a and b could be defended, or didn't need to be.
	   * Let's see if a move at e is sufficient for O.
	   */
	  int attack_on_b = 0;
	  int attack_on_a = 0;

	  if (trymove(epos, color, "break_through_helper-B", Fpos, 
		      EMPTY, NO_MOVE)) {
	    if (attack(bpos, NULL))
	      attack_on_b = 1;
	    else if (attack(apos, NULL))
	      attack_on_a = 1;
	    popgo();
	  }

	  /* Let O find a defense and play it. */
	  if (attack_on_a || attack_on_b) {
	    int hpos = NO_MOVE;

	    if (((attack_on_a && find_defense(apos, &hpos))
		|| (attack_on_b && find_defense(bpos, &hpos)))
		&& hpos != NO_MOVE
		&& trymove(hpos, color, "break_through_helper-C", Fpos,
			   EMPTY, NO_MOVE)) {
	      /* Now we make a second cut at e, trying to capture
	       * either b or c.
	       */
	      if (trymove(epos, other, "break_through_helper-D", Fpos,
			  EMPTY, NO_MOVE)) {
		if (!board[bpos]
		    || !board[cpos] 
		    || !defend_both(bpos, cpos))
		  success = WIN;
		popgo();
	      }
	      popgo();
	    }
	    else
	      success = WIN; /* This should have been covered by
			      * defend_both(), so probably unnecessary. */
	}
      }
    }
    popgo();
  }

  return success;
}


/* ---------------------------------------------------------------- */
/*                              Threats                             */
/* ---------------------------------------------------------------- */


/* Return up to max_threats threats to capture the string at str.
 * If the string is directly attackable the number of threats
 * is reported to be 0.
 *
 * NOTE:  You can call attack_threats with moves[] and codes[] 
 *        already partly filled in. So if you want to get the
 *        threats from scratch, you have to set them to 0
 *        yourself.
 *
 * FIXME: Shall we report upgrades, like we can capture in ko but
 *        have a threat to capture unconditionally?
 */

int
attack_threats(int str, int max_points, int moves[], int codes[])
{
  int other;
  int num_threats;
  int liberties;
  int libs[MAXLIBS];
  int num_adj;
  int adjs[MAXCHAIN];
  int k;
  int l;
  int r;

  ASSERT1(IS_STONE(board[str]), str);
  other = OTHER_COLOR(board[str]);

  /* Only handle strings with no way to capture immediately.
   * For now, we treat ko the same as unconditionally. */
  if (attack(str, NULL) != 0)
    return 0;

  /* This test would seem to be unnecessary since we only threaten
   * strings with attack_code == 0, but it turns out that single
   * stones with one liberty that can be captured, but come to
   * live again in a snap-back get attack_code == 0.
   *
   * The test against 6 liberties is just an optimization.
   */
  liberties = findlib(str, MAXLIBS, libs);
  if (liberties > 1 && liberties < 6) {
    for (k = 0; k < liberties; k++) {
      int aa = libs[k];

      /* Try to threaten on the liberty. */
      if (trymove(aa, other, "attack_threats-A", str, EMPTY, NO_MOVE)) {
       int acode = attack(str, NULL);
       if (acode != 0)
	 movelist_change_point(aa, acode, max_points, moves, codes);
       popgo();
      }

      /* Try to threaten on second order liberties. */
      for (l = 0; l < 4; l++) {
       int bb = libs[k] + delta[l];

       if (!ON_BOARD(bb)
           || IS_STONE(board[bb])
           || liberty_of_string(bb, str))
         continue;

       if (trymove(bb, other, "attack_threats-B", str, EMPTY, NO_MOVE)) {
         int acode = attack(str, NULL);
         if (acode != 0)
	   movelist_change_point(bb, acode, max_points, moves, codes);
         popgo();
       }
      }
    }
  }

  /* Threaten to attack by saving weak neighbors. */
  num_adj = chainlinks(str, adjs);
  for (k = 0; k < num_adj; k++) {
    int bb;
    int dd;  /* Defense point of weak neighbor. */
    int acode;
    int dcode;

    attack_and_defend(adjs[k], &acode, NULL, &dcode, &dd);
    if (acode == 0 || dcode == 0)
      continue;

    /* The strange code using r == -1 below is only avoid duplication
     * of the code starting with "if (trymove..)" below.
     * If r == -1 and stackp == 0 then use the defense point what we got from
     * attack_and_defend above. Otherwise step through all defense points.
     */
    for (r = -1; r < max_points; r++) {
      if (stackp == 0) {
	if (r == -1)
	  continue;
	if (worm[adjs[k]].defend_codes[r] == 0)
	  break;
	bb = worm[adjs[k]].defense_points[r];
      }
      else {
	if (r == -1)
	  bb = dd;
	else
	  break;
      }

      /* Test the move and see if it is a threat. */
      if (trymove(bb, other, "attack_threats-C", str, EMPTY, NO_MOVE)) {
	if (board[str] == EMPTY)
	  acode = WIN;
	else
	  acode = attack(str, NULL);
	if (acode != 0)
	  movelist_change_point(bb, acode, max_points, moves, codes);
	popgo();
      }
    }
  }

  /* Return actual number of threats found regardless of attack code. */
  if (codes[max_points - 1] > 0)
    return max_points;
  for (num_threats = 0; num_threats < max_points; num_threats++)
    if (codes[num_threats] == 0)
      break;
  return num_threats;
}


/* ================================================================ */  
/*                       Defensive functions                        */
/* ================================================================ */


/* Like find_defense, but takes the komaster argument. If the
 * opponent is komaster, reading functions will not try
 * to take ko.
 */

static int
do_find_defense(int str, int *move, int komaster, int kom_pos)
{
  int xpos;
  int dcode = 0;
  int liberties;
  int found_read_result;
  Read_result *read_result = NULL;
  
  SETUP_TRACE_INFO("find_defense", str);
  
  RTRACE("Can we rescue %1m?\n", str);

  /* We first check if the number of liberties is larger than four. In
   * that case we don't cache the result and to avoid needlessly
   * storing the position in the hash table, we must do this test
   * before we look for cached results.
   */
  liberties = countlib(str);
  
  if (liberties > 4
      || (liberties == 4 && stackp > depth)
      || (liberties == 3 && stackp > depth)) {
    /* No need to cache the result in these cases. */
    SGFTRACE(0, WIN, "too many liberties or stackp > depth");
    if (move)
      *move = 0;
    return WIN;
  }

  if ((stackp <= depth) && (hashflags & HASH_FIND_DEFENSE)) {
    found_read_result = get_read_result(FIND_DEFENSE, komaster, kom_pos, 
					&str, &read_result);
    if (found_read_result) {
      TRACE_CACHED_RESULT(*read_result);
      if (rr_get_result(*read_result) != 0)
	if (move)
	  *move = rr_get_move(*read_result);

      SGFTRACE(rr_get_move(*read_result),
	       rr_get_result(*read_result), "cached");
      return rr_get_result(*read_result);
    }
  }

#if EXPERIMENTAL_READING
  if (defend_by_pattern) {
    dcode = do_defend_pat(str, &xpos, komaster, kom_pos);
    /* We set liberties to 0 to pass over the non-pattern code below. */
    liberties = 0;
  }
#endif

  if (liberties == 1)
    dcode = defend1(str, &xpos, komaster, kom_pos);
  else if (liberties == 2)
    dcode = defend2(str, &xpos, komaster, kom_pos);
  else if (liberties == 3)
    dcode = defend3(str, &xpos, komaster, kom_pos);
  else if (liberties == 4)
    dcode = defend4(str, &xpos, komaster, kom_pos);

  if (dcode) {
    RTRACE("saving move for %1m found at %1m!\n", str, xpos);
    READ_RETURN(read_result, move, xpos, dcode);
  }
    
  READ_RETURN0(read_result);
}


/* If str points to a string with exactly one liberty, defend1 
 * determines whether it can be saved by extending or capturing
 * a boundary chain having one liberty. The function returns WIN if the string
 * can be saved, otherwise 0. It returns KO_A or KO_B if it can be saved,
 * conditioned on ko. Returns KO_A if it can be saved provided (color) is
 * willing to ignore any ko threat. Returns KO_B if it can be saved if (color)
 * has a ko threat which must be answered.
 *
 * The pair defend1-attack2 call each other recursively to
 * read situations such as ladders. They read all ladders to the end.
 * If the reading ply (stackp) is deeper than the deep-reading cutoff
 * parameter depth, whose default value DEPTH is defined in gnugo.h, then a
 * string is assumed alive if it can get 3 liberties. When
 * fourlib_depth < stackp < depth, a string is considered alive if it can get
 * four liberties. When stackp < fourlib_depth, it is considered alive
 * if it can get 5 liberties.
 * */

static int
defend1(int str, int *move, int komaster, int kom_pos)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int xpos;
  int lib;
  int moves[MAX_MOVES];
  int scores[MAX_MOVES];
  int num_moves = 0;
  int savemove = 0;
  int savecode = 0;
  int liberties;
  int k;
  int found_read_result;
  Read_result *read_result = NULL;

  SETUP_TRACE_INFO("defend1", str);
  reading_node_counter++;
  
  gg_assert(IS_STONE(board[str]));
  ASSERT1(countlib(str) == 1, str);
  RTRACE("try to escape atari on %1m.\n", str);

  if ((stackp <= depth) && (hashflags & HASH_DEFEND1)) {
  
    found_read_result = get_read_result(DEFEND1, komaster, kom_pos,
					&str, &read_result);
    if (found_read_result) {
      TRACE_CACHED_RESULT(*read_result);
      if (rr_get_result(*read_result) != 0)
	*move = rr_get_move(*read_result);

      SGFTRACE(rr_get_move(*read_result),
	       rr_get_result(*read_result), "cached");
      return rr_get_result(*read_result);
    }
  }

  /* lib will be the liberty of the string. */
  liberties = findlib(str, 1, &lib);
  ASSERT1(liberties == 1, str);

  /* Collect moves to try in the first batch.
   * 1. First order liberty.
   * 2. Chain breaking moves.
   */
  moves[0] = lib;
  scores[0] = 0;
  num_moves = 1;
  
  break_chain_moves(str, moves, scores, &num_moves);
  order_moves(str, num_moves, moves, scores, color, read_function_name);

  for (k = 0; k < num_moves; k++) {
    int new_komaster;
    int new_kom_pos;
    int ko_move;

    xpos = moves[k];
    if (komaster_trymove(xpos, color, "defend1-A", str, komaster, kom_pos,
			 &new_komaster, &new_kom_pos,
			 &ko_move, stackp <= ko_depth && savecode == 0)) {
      if (!ko_move) {
	int acode = do_attack(str, NULL, new_komaster, new_kom_pos);
	popgo();
	if (acode == 0) {
	  SGFTRACE(xpos, WIN, "defense effective - A");
	  READ_RETURN(read_result, move, xpos, WIN);
	}
	/* if the move works with ko we save it, then look for something
	 * better.
	 */
	UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, xpos);
      }
      else {
	if (do_attack(str, NULL, new_komaster, new_kom_pos) != WIN) {
	  savemove = xpos;
	  savecode = KO_B;
	}
	popgo();
      }
    }
  }

  /* If the string is a single stone and a capture would give a ko,
   * try to defend it with ko by backfilling.
   *
   * FIXME: What is an example of this? Is it correct that the
   *           return value is WIN and not KO_A or KO_B?
   */
  if (stackp <= backfill_depth
      && countstones(str) == 1
      && is_ko(lib, other, NULL)) {
    int libs2[6];
    liberties = approxlib(lib, color, 6, libs2);
    if (liberties <= 5) {
      for (k = 0; k < liberties; k++) {
	int apos = libs2[k];
	if ((liberties == 1 || !is_self_atari(apos, other))
	    && trymove(apos, color, "attack1-C", str, komaster, kom_pos)) {
	  int acode = do_attack(str, NULL, komaster, kom_pos);
	  if (acode == 0) {
	    popgo();
	    SGFTRACE(apos, WIN, "backfilling");
	    READ_RETURN(read_result, move, apos, WIN);
	  }
	  UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, apos);
	  popgo();
	}
      }
    }
  }
  
  if (savecode != 0) {
    SGFTRACE(savemove, savecode, "saved move");
    READ_RETURN(read_result, move, savemove, savecode);
  }
  
  SGFTRACE(0, 0, NULL);
  READ_RETURN0(read_result);
}



/* If str points to a group with two liberties, defend2 determines
 * whether the group can be saved by extending, or by capturing part of
 * its surrounding chain. A group is considered safe if either part of
 * the surrounding chain may be captured, or if it can get 3
 * liberties. It is presumed that the opponent could kill if tenuki.
 * If both extensions work, it prefers the one which maximizes 
 * liberties.
 *
 * *move returns the move to save the stones.
 */

static int 
defend2(int str, int *move, int komaster, int kom_pos)
{
  int color, other;
  int xpos;
  int liberties;
  int libs[2];
  int liberties2;
  int libs2[6];
  int moves[MAX_MOVES];
  int scores[MAX_MOVES];
  int num_moves = 0;
  int savemove = 0;
  int savecode = 0;
  int bc;
  int k;
  int r;
  int s;
  int found_read_result;
  Read_result *read_result = NULL;

  SETUP_TRACE_INFO("defend2", str);
  reading_node_counter++;

  memset(moves, 0, sizeof(moves));

  RTRACE("trying to rescue %1m\n", str);
  color = board[str];
  other = OTHER_COLOR(color);

  gg_assert(IS_STONE(board[str]));
  gg_assert(countlib(str) == 2);

  if ((stackp <= depth) && (hashflags & HASH_DEFEND2)) {
  
    found_read_result = get_read_result(DEFEND2, komaster, kom_pos,
					&str, &read_result);
    if (found_read_result) {
      TRACE_CACHED_RESULT(*read_result);
      if (rr_get_result(*read_result) != 0)
	*move = rr_get_move(*read_result);

      SGFTRACE(rr_get_move(*read_result),
	       rr_get_result(*read_result), "cached");
      return rr_get_result(*read_result);
    }
  }

  liberties = findlib(str, 2, libs);
  ASSERT1(liberties == 2, str);

  /* Collect moves to try in the first batch.
   * 1. First order liberties.
   * 2. Chain breaking moves.
   * 3. Second order liberties moving up from first line to second.
   * 4. Edge clamps.
   */
  for (k = 0; k < liberties; k++) {
    moves[k] = libs[k];
    scores[k] = 0;
  }
  num_moves = liberties;
  
  break_chain_moves(str, moves, scores, &num_moves);
  break_chain2_efficient_moves(str, moves, scores, &num_moves);
  propose_edge_moves(str, libs, liberties, moves, scores, &num_moves, color);
  edge_clamp(str, moves, scores, &num_moves);

  order_moves(str, num_moves, moves, scores, color, read_function_name);

  for (k = 0; k < num_moves; k++) {
    int new_komaster;
    int new_kom_pos;
    int ko_move;

    xpos = moves[k];
    
    if (komaster_trymove(xpos, color, "defend2-A", str,
			 komaster, kom_pos, &new_komaster, &new_kom_pos,
			 &ko_move, stackp <= ko_depth && savecode == 0)) {
      if (!ko_move) {
	int acode = do_attack(str, NULL, new_komaster, new_kom_pos);
	popgo();
	if (acode == 0) {
	  SGFTRACE(xpos, WIN, "defense effective - A");
	  READ_RETURN(read_result, move, xpos, WIN);
	}
	/* if the move works with ko we save it, then look for something
	 * better.
	 */
	UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, xpos);
      }
      else {
	if (do_attack(str, NULL, new_komaster, new_kom_pos) != WIN) {
	  savemove = xpos;
	  savecode = KO_B;
	}
	popgo();
      }
    }
  }

  /* Look for backfilling moves. */
  for (k = 0; k < liberties; k++) {
    if (is_self_atari(libs[k], other)) {
      liberties2 = approxlib(libs[k], color, 6, libs2);
      for (r = 0; r < liberties2; r++) {
	xpos = libs2[r];
	/* Don't reconsider previously tested moves. */
	for (s = 0; s < num_moves; s++)
	  if (xpos == moves[s])
	    break;
	if (s < num_moves)
	  continue;

	if (trymove(xpos, color, "defend2-C", str, komaster, kom_pos)) {
	  int acode;
	  /* If the newly placed stone is in atari, we give up without
           * fight.
	   */
	  if (countlib(xpos) == 1 && countstones(xpos) > 1)
	    acode = WIN;
	  else {
	    acode = do_attack(str, NULL, komaster, kom_pos);
    	    moves[s] = xpos;
	  }

	  popgo();
	  if (acode == 0) {
	    SGFTRACE(xpos, WIN, "backfill effective");
	    READ_RETURN(read_result, move, xpos, WIN);
	  }
	  UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, xpos);
	}
      }
    }
    liberties2 = approxlib(libs[k], other, 3, libs2);
    if (liberties2 <= 2) {
      for (r = 0; r < liberties2; r++) {
	xpos = libs2[r];
	/* Don't reconsider previously tested moves. */
	for (s = 0; s < num_moves; s++)
	  if (xpos == moves[s])
	    break;
	if (s < num_moves)
	  continue;

	if (!is_self_atari(xpos, color)
	    && trymove(xpos, color, "defend2-D", str, komaster, kom_pos)) {
	  int acode = do_attack(str, NULL, komaster, kom_pos);
	  moves[s] = xpos;
	  popgo();
	  if (acode == 0) {
	    SGFTRACE(xpos, WIN, "backfill effective");
	    READ_RETURN(read_result, move, xpos, WIN);
	  }
	  UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, xpos);
	}
      }
    }
  }

  if (stackp <= depth) {
    for (k = 0; k < liberties; k++) {
      int dcode = special_rescue(str, libs[k], &xpos, komaster, kom_pos,
				 moves, num_moves);
      if (dcode == WIN) {
	SGFTRACE(xpos, WIN, "special rescue");
	READ_RETURN(read_result, move, xpos, WIN);
      }
      UPDATE_SAVED_KO_RESULT_UNREVERSED(savecode, savemove, dcode, xpos);
    }
  }
  
  if (stackp <= backfill_depth) {
    int dcode = special_rescue2(str, libs, &xpos, komaster, kom_pos,
				moves, num_moves);
    if (dcode == WIN) {
      SGFTRACE(xpos, WIN, "special rescue2");
      READ_RETURN(read_result, move, xpos, WIN);
    }
    UPDATE_SAVED_KO_RESULT_UNREVERSED(savecode, savemove, dcode, xpos);
  }
  
  if (level >= 10 && stackp <= superstring_depth) {
    int dcode = superstring_breakchain(str, &xpos, komaster, kom_pos, 4);
    if (dcode == WIN) {
      SGFTRACE(xpos, WIN, "superstring_breakchain");
      READ_RETURN(read_result, move, xpos, WIN);
    }
    UPDATE_SAVED_KO_RESULT_UNREVERSED(savecode, savemove, dcode, xpos);
  }

  /* If nothing else works, we try playing a liberty of the
   * super_string.
   */
  if (level >= 10 && stackp <= superstring_depth) {
    int ss_liberties;
    int ss_libs[MAX_LIBERTIES + 4];

    find_superstring_liberties(str, &ss_liberties, ss_libs, 3);
    for (k = 0; k < ss_liberties; k++) {
      int apos = ss_libs[k];
      
      /* Skip if already tried */
      for (s = 0; s < num_moves; s++)
	if (apos == moves[s])
	  break;
      if (s < num_moves)
	continue;
      
      if (liberty_of_string(apos, str))
	continue;
      if (trymove(apos, color, "defend2-E", str, komaster, kom_pos)) {
	int acode;
	/* If the newly placed stone is in atari, we give up without fight. */
	if (countlib(apos) == 1)
	  acode = WIN;
	else {
	  acode = do_attack(str, NULL, komaster, kom_pos);
	  moves[s] = apos;
	}
	popgo();
	if (acode == 0) {
	  SGFTRACE(apos, WIN, "superstring liberty");
	  READ_RETURN(read_result, move, apos, WIN);
	}
	UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, apos);
      }
    }
    
    /* Now we are truly desperate. Try playing second order liberties of
     * the superstring.
     */
    for (k = 0; k < ss_liberties; k++) {
      int apos = ss_libs[k];
      int dcode;
	
      if (liberty_of_string(apos, str))
	continue;
      
      dcode = special_rescue(str, apos, &xpos, komaster, kom_pos,
			     moves, num_moves);
      if (dcode == WIN) {
	SGFTRACE(xpos, WIN, "special rescue");
	READ_RETURN(read_result, move, xpos, WIN);
      }
      UPDATE_SAVED_KO_RESULT_UNREVERSED(savecode, savemove, dcode, xpos);
    }
  }

  /* We place the more speculative moves trying to break chain links
   * with 2 or 3 liberties last, because these moves often are not
   * really relevant.
   */
  
  bc = break_chain2(str, &xpos, komaster, kom_pos);
  if (bc == WIN) {
    SGFTRACE(xpos, bc, "break chain2");
    READ_RETURN(read_result, move, xpos, bc);
  }
  UPDATE_SAVED_KO_RESULT_UNREVERSED(savecode, savemove, bc, xpos);

  if (stackp <= backfill_depth) {
    int saved_num_moves = num_moves;
    special_rescue5(str, libs, moves, scores, &num_moves);
    
    /* Only order and test the new set of moves. */
    order_moves(str, num_moves-saved_num_moves,
		&(moves[saved_num_moves]),
		&(scores[saved_num_moves]), other, read_function_name);
    
    for (k = saved_num_moves; k < num_moves; k++) {
      int new_komaster;
      int new_kom_pos;
      int ko_move;
      xpos = moves[k];
      if (is_self_atari(xpos, color))
	continue;
      
      if (komaster_trymove(xpos, color, "defend2-F", str,
			   komaster, kom_pos, &new_komaster, &new_kom_pos,
			   &ko_move, stackp <= ko_depth && savecode == 0)) {
	if (!ko_move) {
	  int acode = do_attack(str, NULL, new_komaster, new_kom_pos);
	  popgo();
	  if (acode == 0) {
	    SGFTRACE(xpos, WIN, "defense effective - A");
	    READ_RETURN(read_result, move, xpos, WIN);
	  }
	  /* if the move works with ko we save it, then look for something
	   * better.
	   */
	  UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, xpos);
	}
	else {
	  if (do_attack(str, NULL, new_komaster, new_kom_pos) != WIN) {
	    savemove = xpos;
	    savecode = KO_B;
	  }
	  popgo();
	}
      }
    }
  }

  if (stackp <= backfill2_depth) {
    bc = break_chain3(str, &xpos, komaster, kom_pos);
    if (bc == WIN) {
      SGFTRACE(xpos, bc, "break chain3");
      READ_RETURN(read_result, move, xpos, bc);
    }
    UPDATE_SAVED_KO_RESULT_UNREVERSED(savecode, savemove, bc, xpos);
  }

  if (savecode != 0) {
    SGFTRACE(savemove, savecode, "saved move");
    READ_RETURN(read_result, move, savemove, savecode);
  }

  RTRACE("failed to find rescuing move.\n");
  SGFTRACE(0, 0, NULL);
  READ_RETURN0(read_result);
}


/* defend3(str, *move) attempts to find a move rescuing the 
 * string at (str) with 3 liberties.  If such a move can be found,
 * it returns true and the saving move in *move.
 */

static int 
defend3(int str, int *move, int komaster, int kom_pos)
{
  int color, other;
  int xpos;
  int liberties;
  int libs[3];
  int moves[MAX_MOVES];
  int scores[MAX_MOVES];
  int num_moves = 0;
  int savemove = 0;
  int savecode = 0;
  int bc;
  int k;
  int found_read_result;
  Read_result *read_result = NULL;

  SETUP_TRACE_INFO("defend3", str);
  reading_node_counter++;

  RTRACE("trying to rescue %1m\n", str);
  color = board[str];
  other = OTHER_COLOR(color);

  gg_assert(IS_STONE(board[str]));
  gg_assert(countlib(str) == 3);

  if ((stackp <= depth) && (hashflags & HASH_DEFEND3)) {
    found_read_result = get_read_result(DEFEND3, komaster, kom_pos,
					&str, &read_result);
    if (found_read_result) {
      TRACE_CACHED_RESULT(*read_result);
      if (rr_get_result(*read_result) != 0)
	*move = rr_get_move(*read_result);

      SGFTRACE(rr_get_move(*read_result),
	       rr_get_result(*read_result), "cached");
      return rr_get_result(*read_result);
    }
  }

  liberties = findlib(str, 3, libs);
  ASSERT1(liberties == 3, str);

  /* Collect moves to try in the first batch.
   * 1. First order liberties.
   * 2. Chain breaking moves.
   * 3. Second order liberties moving up from first line to second.
   * 4. Edge clamps.
   */
  for (k = 0; k < liberties; k++) {
    moves[k] = libs[k];
    scores[k] = 0;
  }
  num_moves = liberties;
  
  break_chain_moves(str, moves, scores, &num_moves);
  break_chain2_efficient_moves(str, moves, scores, &num_moves);
  propose_edge_moves(str, libs, liberties, moves, scores, &num_moves, color);
  edge_clamp(str, moves, scores, &num_moves);

  order_moves(str, num_moves, moves, scores, color, read_function_name);

  for (k = 0; k < num_moves; k++) {
    int new_komaster;
    int new_kom_pos;
    int ko_move;

    if (stackp >= branch_depth && k > 0)
      break;
    
    xpos = moves[k];
    
    if (komaster_trymove(xpos, color, "defend3-A", str, komaster, kom_pos,
			 &new_komaster, &new_kom_pos,
			 &ko_move, stackp <= ko_depth && savecode == 0)) {
      if (!ko_move) {
	int acode = do_attack(str, NULL, new_komaster, new_kom_pos);
	popgo();
	if (acode == 0) {
	  SGFTRACE(xpos, WIN, "defense effective - A");
	  READ_RETURN(read_result, move, xpos, WIN);
	}
	/* if the move works with ko we save it, then look for something
	 * better.
	 */
	UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, xpos);
      }
      else {
	if (do_attack(str, NULL, new_komaster, new_kom_pos) != WIN) {
	  savemove = xpos;
	  savecode = KO_B;
	}
	popgo();
      }
    }
  }

  /* This looks a little too expensive. */
#if 0
  /* Look for backfilling moves. */
  if (stackp <= backfill_depth) {
    int liberties2;
    int libs2[6];
    int r;
    int s;
    for (k = 0; k < liberties; k++) {
      if (is_self_atari(libs[k], other)) {
	liberties2 = approxlib(libs[k], color, 6, libs2);
	for (r = 0; r < liberties2; r++) {
	  xpos = libs2[r];
	  /* Don't reconsider previously tested moves. */
	  for (s = 0; s < num_moves; s++)
	    if (xpos == moves[s])
	      break;
	  if (s < num_moves)
	    continue;
	  
	  if (trymove(xpos, color, "defend3-D", str, komaster, kom_pos)) {
	    int acode;
	    /* If the newly placed stone is in atari, we give up
             * without fight.
	     */
	    if (countlib(xpos) == 1)
	      acode = WIN;
	    else
	      acode = do_attack(str, NULL, komaster, kom_pos);

	    popgo();
	    if (acode == 0) {
	      SGFTRACE(xpos, WIN, "backfill effective");
	      READ_RETURN(read_result, move, xpos, WIN);
	    }
	    UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, xpos);
	  }
	}
      }
      else {
	liberties2 = approxlib(libs[k], other, 3, libs2);
	if (liberties2 <= 3) {
	  for (r = 0; r < liberties2; r++) {
	    xpos = libs2[r];
	    /* Don't reconsider previously tested moves. */
	    for (s = 0; s < num_moves; s++)
	      if (xpos == moves[s])
		break;
	    if (s < num_moves)
	      continue;
	    
	    if (!is_self_atari(xpos, color)
		&& trymove(xpos, color, "defend2-G", str, komaster, kom_pos)) {
	      int acode = do_attack(str, NULL, komaster, kom_pos);
	      popgo();
	      if (acode == 0) {
		SGFTRACE(xpos, WIN, "backfill effective");
		READ_RETURN(read_result, move, xpos, WIN);
	      }
	      UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, xpos);
	    }
	  }
	}
      }
    }
  }
#endif
  
  /* If nothing else works, try to defend with second order liberties. */
  if (stackp <= depth) {
    for (k = 0; k < liberties; k++) {
      int dcode = special_rescue(str, libs[k], &xpos, komaster, kom_pos,
				 moves, num_moves);
      if (dcode == WIN) {
	SGFTRACE(xpos, WIN, "special rescue");
	READ_RETURN(read_result, move, xpos, WIN);
      }
      UPDATE_SAVED_KO_RESULT_UNREVERSED(savecode, savemove, dcode, xpos);
    }
  }

  if (stackp <= backfill_depth) {
    int dcode = special_rescue3(str, libs, &xpos, komaster, kom_pos);
    if (dcode == WIN) {
      SGFTRACE(xpos, WIN, "special rescue3");
      READ_RETURN(read_result, move, xpos, WIN);
    }
    UPDATE_SAVED_KO_RESULT_UNREVERSED(savecode, savemove, dcode, xpos);
  }
    
  if (stackp <= backfill_depth) {
    int dcode = special_rescue4(str, libs, &xpos, komaster, kom_pos);
    if (dcode == WIN) {
      SGFTRACE(xpos, WIN, "special rescue4");
      READ_RETURN(read_result, move, xpos, WIN);
    }
    UPDATE_SAVED_KO_RESULT_UNREVERSED(savecode, savemove, dcode, xpos);
  }
    
  if (level >= 10 && stackp <= backfill2_depth) {
    int dcode = superstring_breakchain(str, &xpos, komaster, kom_pos, 4);
    if (dcode == WIN) {
      SGFTRACE(xpos, WIN, "superstring_breakchain");
      READ_RETURN(read_result, move, xpos, WIN);
    }
    UPDATE_SAVED_KO_RESULT_UNREVERSED(savecode, savemove, dcode, xpos);
  }

  /* If nothing else works, we try playing a liberty of the
   * super_string.
   */
  if (level >= 10 && stackp <= backfill2_depth) {
    int ss_liberties;
    int ss_libs[MAX_LIBERTIES + 4];

    find_superstring_liberties(str, &ss_liberties, ss_libs, 3);
    for (k = 0; k < ss_liberties; k++) {
      int apos = ss_libs[k];
	
      if (liberty_of_string(apos, str))
	continue;
      if (trymove(apos, color, "defend3-C", str, komaster, kom_pos)) {
	int acode;
	/* If the newly placed stone is in atari, we give up without fight. */
	if (countlib(apos) == 1)
	  acode = WIN;
	else
	  acode = do_attack(str, NULL, komaster, kom_pos);

	popgo();
	if (acode == 0) {
	  SGFTRACE(apos, WIN, "superstring liberty");
	  READ_RETURN(read_result, move, apos, WIN);
	}
	UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, apos);
      }
    }

    /* Now we are truly desperate. Try playing second order liberties of
     * the superstring.
     */
    for (k = 0; k < ss_liberties; k++) {
      int apos = ss_libs[k];
      int dcode;
	
      if (liberty_of_string(apos, str))
	continue;
      
      dcode = special_rescue(str, apos, &xpos, komaster, kom_pos,
			     moves, num_moves);
      if (dcode == WIN) {
	SGFTRACE(xpos, WIN, "special rescue");
	READ_RETURN(read_result, move, xpos, WIN);
      }
      UPDATE_SAVED_KO_RESULT_UNREVERSED(savecode, savemove, dcode, xpos);
    }
  }

  /* We place the more speculative moves trying to break chain links
   * with 2 or 3 liberties last, because these moves often are not
   * really relevant.
   */
  if (stackp <= backfill2_depth) {
    bc = break_chain2(str, &xpos, komaster, kom_pos);
    if (bc == WIN) {
      SGFTRACE(xpos, bc, "break chain2");
      READ_RETURN(read_result, move, xpos, bc);
    }
    UPDATE_SAVED_KO_RESULT_UNREVERSED(savecode, savemove, bc, xpos);
  }

  if (stackp <= backfill_depth) {
    int saved_num_moves = num_moves;
    special_rescue5(str, libs, moves, scores, &num_moves);
    special_rescue6(str, libs, moves, scores, &num_moves);
    
    /* Only order and test the new set of moves. */
    order_moves(str, num_moves-saved_num_moves,
		&(moves[saved_num_moves]),
		&(scores[saved_num_moves]), other, read_function_name);
    
    for (k = saved_num_moves; k < num_moves; k++) {
      int new_komaster;
      int new_kom_pos;
      int ko_move;
      xpos = moves[k];
      if (is_self_atari(xpos, color))
	continue;
      
      if (komaster_trymove(xpos, color, "defend3-E", str,
			   komaster, kom_pos, &new_komaster, &new_kom_pos,
			   &ko_move, stackp <= ko_depth && savecode == 0)) {
	if (!ko_move) {
	  int acode = do_attack(str, NULL, new_komaster, new_kom_pos);
	  popgo();
	  if (acode == 0) {
	    SGFTRACE(xpos, WIN, "defense effective - A");
	    READ_RETURN(read_result, move, xpos, WIN);
	  }
	  /* if the move works with ko we save it, then look for something
	   * better.
	   */
	  UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, xpos);
	}
	else {
	  if (do_attack(str, NULL, new_komaster, new_kom_pos) != WIN) {
	    savemove = xpos;
	    savecode = KO_B;
	  }
	  popgo();
	}
      }
    }
  }
    
  if (stackp <= backfill2_depth) {
    bc = break_chain3(str, &xpos, komaster, kom_pos);
    if (bc == WIN) {
      SGFTRACE(xpos, bc, "break chain3");
      READ_RETURN(read_result, move, xpos, bc);
    }
    UPDATE_SAVED_KO_RESULT_UNREVERSED(savecode, savemove, bc, xpos);
  }
  
  if (savecode != 0) {
    SGFTRACE(savemove, savecode, "saved move");
    READ_RETURN(read_result, move, savemove, savecode);
  }

  RTRACE("failed to find rescuing move.\n");
  SGFTRACE(0, 0, NULL);
  READ_RETURN0(read_result);
}


/* defend4(str, *move) attempts to find a move rescuing the 
 * string at (str) with 4 liberties.  If such a move can be found,
 * it returns true, and if the pointer move is not NULL, 
 * then it returns the saving move in *move.
 */

static int 
defend4(int str, int *move, int komaster, int kom_pos)
{
  int color, other;
  int xpos;
  int liberties;
  int libs[4];
  int moves[MAX_MOVES];
  int scores[MAX_MOVES];
  int num_moves = 0;
  int savemove = 0;
  int savecode = 0;
  int k;
  int found_read_result;
  Read_result *read_result = NULL;
  
  SETUP_TRACE_INFO("defend4", str);
  reading_node_counter++;

  RTRACE("trying to rescue %1m\n", str);
  color = board[str];
  other = OTHER_COLOR(color);

  gg_assert(IS_STONE(board[str]));
  gg_assert(countlib(str) == 4);

  if ((stackp <= depth) && (hashflags & HASH_DEFEND4)) {
    found_read_result = get_read_result(DEFEND4, komaster, kom_pos,
					&str, &read_result);
    if (found_read_result) {
      TRACE_CACHED_RESULT(*read_result);
      if (rr_get_result(*read_result) != 0)
	*move = rr_get_move(*read_result);

      SGFTRACE(rr_get_move(*read_result),
	       rr_get_result(*read_result), "cached");
      return rr_get_result(*read_result);
    }
  }

  liberties = findlib(str, 4, libs);
  ASSERT1(liberties == 4, str);

  /* Collect moves to try in the first batch.
   * 1. First order liberties.
   * 2. Chain breaking moves.
   */
  for (k = 0; k < liberties; k++) {
    moves[k] = libs[k];
    scores[k] = 0;
  }
  num_moves = liberties;
  
  break_chain_moves(str, moves, scores, &num_moves);
  break_chain2_efficient_moves(str, moves, scores, &num_moves);

  order_moves(str, num_moves, moves, scores, color, read_function_name);

  for (k = 0; k < num_moves; k++) {
    int new_komaster;
    int new_kom_pos;
    int ko_move;

    if (stackp >= branch_depth && k > 0)
      break;
    
    xpos = moves[k];
    
    if (komaster_trymove(xpos, color, "defend4-A", str, komaster, kom_pos,
			 &new_komaster, &new_kom_pos,
			 &ko_move, stackp <= ko_depth && savecode == 0)) {
      if (!ko_move) {
	int acode = do_attack(str, NULL, new_komaster, new_kom_pos);
	popgo();
	if (acode == 0) {
	  SGFTRACE(xpos, WIN, "defense effective - A");
	  READ_RETURN(read_result, move, xpos, WIN);
	}
	/* if the move works with ko we save it, then look for something
	 * better.
	 */
	UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, xpos);
      }
      else {
	if (do_attack(str, NULL, new_komaster, new_kom_pos) != WIN) {
	  savemove = xpos;
	  savecode = KO_B;
	}
	popgo();
      }
    }
  }

  if (stackp <= backfill_depth) {
    int bc = break_chain2(str, &xpos, komaster, kom_pos);
    if (bc == WIN) {
      SGFTRACE(xpos, WIN, "break chain2");
      READ_RETURN(read_result, move, xpos, WIN);
    }
    UPDATE_SAVED_KO_RESULT_UNREVERSED(savecode, savemove, bc, xpos);
  }

  if (savecode != 0) {
    SGFTRACE(savemove, savecode, "saved move");
    READ_RETURN(read_result, move, savemove, savecode);
  }

  RTRACE("failed to find rescuing move.\n");
  SGFTRACE(0, 0, NULL);
  READ_RETURN0(read_result);
}


/*
 * special_rescue(str, lib, *move) is called with (str) a
 * string having a liberty at (lib). The saving move is returned
 * in (*move).
 *
 * This checks whether a move on a second order liberty is a rescuing
 * move, e.g. in shapes like:
 *
 *   .        O        O       X.XXO
 *  O.*  or  ..*  or  O.*  or  XOOXO
 *   O        O        O       ...*.
 *                             -----
 *
 * This will occasionally save a string where no other move will. To
 * reduce the branching caused by these moves, we require that the
 * opponent can be trivially captured when trying to intercept on the
 * corresponding first order liberty.
 */

static int
special_rescue(int str, int lib, int *move, int komaster, int kom_pos,
	       int tried[], int num_tried)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int k, r;
  int savemove = 0;
  int savecode = 0;

  /* Loop over the four neighbours of the liberty, (lib + d). */
  for (k = 0; k < 4; k++) {
    int d = delta[k];
    if (board[lib + d] == EMPTY) {
      for (r = 0; r < num_tried; r++)
	if (lib + d == tried[r]) 
	  break;
      if (r < num_tried)
	continue;

      /* Use approxlib() to test for trivial capture. */
      if (approxlib(lib, other, 3, NULL) > 2)
	continue;

      /* Don't play into a self atari. */
      if (is_self_atari(lib + d, color))
	continue;
      
      if (trymove(lib + d, color, "special_rescue", str, komaster, kom_pos)) {
	int acode = do_attack(str, NULL, komaster, kom_pos);
	if (acode == 0) {
	  popgo();
	  *move = lib + d;
	  return WIN;
	}
	UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, lib + d);
	popgo();
      }
    }
  }

  if (savecode != 0)
    *move = savemove;

  return savecode;
}


/* In a situation like this:
 *       
 *   OOXXXX     the following code can find the
 *   .OXOOX     defensive move at 'c'.
 *   .cO.OX
 *   .X.OOX
 *   ------
 *
 *   OOXXXX     It also can find more general moves like 'c' here.
 *   .OXOOX     
 *   cXO.OX
 *   ...OOX
 *   ------
 */
static int
special_rescue2(int str, int libs[2], int *move, int komaster, int kom_pos,
		int tried[], int num_tried)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int newlibs[4];
  int liberties;
  int newstr;
  int xpos;
  int moves[MAX_MOVES];
  int scores[MAX_MOVES];
  int num_moves = 0;
  int savemove = 0;
  int savecode = 0;
  int k, r, s;

  for (r = 0; r < 2; r++) {
    /* Let alib be one of the liberties and require it to be suicide
     * for the opponent.
     */
    int alib = libs[r];
    if (!is_suicide(alib, other))
      continue;

    for (k = 0; k < 4; k++) {
      if (board[alib + delta[k]] == color
	  && !same_string(alib + delta[k], str)) {
	newstr = alib + delta[k];
	liberties = findlib(newstr, 4, newlibs);
	
	for (s = 0; s < liberties && s < 4; s++) {
	  ADD_CANDIDATE_MOVE(newlibs[s], 0, moves, scores, num_moves);
	}
	break_chain_moves(newstr, moves, scores, &num_moves);
	break_chain2_efficient_moves(newstr, moves, scores, &num_moves);
	edge_clamp(newstr, moves, scores, &num_moves);
      }
    }
  }

  for (k = 0; k < num_moves; k++) {
    xpos = moves[k];
    for (r = 0; r < num_tried; r++)
      if (xpos == tried[r]) 
	break;
    if (r < num_tried) 
      continue;
    
    if (!is_self_atari(xpos, color)
	&& trymove(xpos, color, "special_rescue2", str, komaster, kom_pos)) {
      int acode = do_attack(str, NULL, komaster, kom_pos);
      if (acode != WIN) {
	if (acode == 0) {
	  popgo();
	  *move = xpos;
	  return WIN;
	}
	UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, xpos);
      }
      popgo();
    }
  }

  if (savecode != 0)
    *move = savemove;

  return savecode;
}


/* In a situation like this:
 *
 *   ...X.XXO
 *   .XXXOOXO
 *   XXOO.OXO     the following code can find the
 *   .O..X.*.     defensive move at '*'.
 *   --------
 *
 *   OXO   cde
 *   .*.   afg
 *   ---   b--
 */
static int
special_rescue3(int str, int libs[3], int *move, int komaster, int kom_pos)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int apos, bpos, cpos, dpos, epos, fpos, gpos;
  int savemove = 0;
  int savecode = 0;
  int k, l, r;

  ASSERT1(countlib(str) == 3, str);
  
  for (r = 0; r < 3; r++) {
    /* Let (apos) be one of the three liberties. */
    apos = libs[r];
    /* Try to find the configuration above. */
    for (k = 0; k < 4; k++) {
      bpos = apos + delta[k];
      if (ON_BOARD(bpos))
	continue;

      cpos = apos - delta[k];
      if (board[cpos] != color)
	continue;
      
      if (!same_string(cpos, str))
	continue;

      for (l = 0; l < 2; l++) {
	int normal = delta[(k+1)%4];
	if (l == 1)
	  normal = -normal;
	
	dpos = cpos + normal;
	if (board[dpos] != other)
	  continue;

	epos = dpos + normal;
	if (board[epos] != color)
	  continue;

	fpos = apos + normal;
	if (board[fpos] != EMPTY)
	  continue;

	gpos = fpos + normal;
	if (board[gpos] != EMPTY)	
	  continue;

	/* Configuration found. Now require an X move at 'a' not
	 * getting too many liberties.
	 */

	if (approxlib(apos, other, 4, NULL) > 3)
	  continue;
	
	/* Try to play at (fpos). */
	if (trymove(fpos, color, "special_rescue3", str, komaster, kom_pos)) {
	  int acode = do_attack(str, NULL, komaster, kom_pos);
	  if (acode != WIN) {
	    if (acode == 0) {
	      popgo();
	      *move = fpos;
	      return WIN;
	    }
	    UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, fpos);
	  }
	  popgo();
	}
      }
    }
  }

  if (savecode != 0)
    *move = savemove;

  return savecode;
}


/* In a situation like this:
 *
 *   .XXXXX
 *   XX.*OO
 *   X.OX..     the following code can find the
 *   ......     defensive move at '*'.
 *   ------
 *
 *   .*O   acd
 *   OX.   be.
 */
static int
special_rescue4(int str, int libs[3], int *move, int komaster, int kom_pos)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int apos, bpos, cpos, dpos, epos;
  int savemove = 0;
  int savecode = 0;
  int k, l, r;

  ASSERT1(countlib(str) == 3, str);
  
  for (r = 0; r < 3; r++) {
    /* Let (apos) be one of the three liberties. */
    apos = libs[r];
    /* Try to find the configuration above. */
    for (k = 0; k < 4; k++) {
      bpos = apos + delta[k];
      if (board[bpos] != color)
	continue;

      if (!same_string(bpos, str))
	continue;

      for (l = 0; l < 2; l++) {
	int normal = delta[(k+1)%4];
	if (l == 1)
	  normal = -normal;

	cpos = apos + normal;
	if (board[cpos] != EMPTY)
	  continue;

	dpos = cpos + normal;
	if (board[dpos] != color)
	  continue;

	epos = bpos + normal;
	if (board[epos] != other)
	  continue;

	/* Configuration found. Now require that (dpos) has at least 3
         * liberties and (epos) at most 3 liberties.
	 */

	if (countlib(dpos) < 3)
	  continue;
	
	if (countlib(epos) > 3)
	  continue;
	
	/* Try to play at (cpos). */
	if (trymove(cpos, color, "special_rescue4", str, komaster, kom_pos)) {
	  int acode = do_attack(str, NULL, komaster, kom_pos);
	  if (acode != WIN) {
	    if (acode == 0) {
	      popgo();
	      *move = cpos;
	      return WIN;
	    }
	    UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, cpos);
	  }
	  popgo();
	}
      }
    }
  }

  if (savecode != 0)
    *move = savemove;

  return savecode;
}


/* In situations like these
 *
 *   |XXXX    |.X...    |.X...
 *   |OOOX    |.XOO.    |XXOO.
 *   |..OX    |OOXO.    |OOXO.
 *   |O.OX    |O.X*O    |O.XOO
 *   |.X*.    |O.X.O    |O.X*O
 *   +----    +-----    +-----
 *
 * the smaller of the O strings can be defended by *. The property
 * they have in common is that the defended string has (at least) two
 * liberties in common with an X string and it's effective to play on
 * an exterior liberty of this string. Similarly it may be worth
 * defending a weak neighbor of the X string.
 *
 * This function may be called for strings with 2 or 3 liberties and
 * returns moves which are potentially useful in these positions.
 */
static void
special_rescue5(int str, int libs[3], int moves[MAX_MOVES],
		int scores[MAX_MOVES], int *num_moves)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int apos, bpos;
  int k, r, s;
  int liberties = countlib(str);
  int libs2[4];
  int liberties2;

  ASSERT1(liberties == 2 || liberties == 3, str);
  
  for (r = 0; r < liberties; r++) {
    apos = libs[r];
    
    for (k = 0; k < 4; k++) {
      bpos = apos + delta[k];
      if (board[bpos] != other)
	continue;

      /* Don't bother if it has too many liberties. */
      if (countlib(bpos) > liberties + 1)
	continue;

      if (count_common_libs(str, bpos) < 2)
	continue;

      liberties2 = findlib(bpos, 4, libs2);
      for (s = 0; s < liberties2; s++)
	if (!liberty_of_string(libs2[s], str))
	  ADD_CANDIDATE_MOVE(libs2[s], 0, moves, scores, *num_moves);

      /* Reinforce the second order chain. */
      if (liberties2 <= liberties) {
	int adj;
	int adjs[MAXCHAIN];
	int t;
	adj = chainlinks2(bpos, adjs, 1);
	for (t = 0; t < adj; t++) {
	  int cpos;
	  break_chain_moves(adjs[t], moves, scores, num_moves);
	  
	  findlib(adjs[t], 1, &cpos);
	  ADD_CANDIDATE_MOVE(cpos, 0, moves, scores, *num_moves);
	}
  
	/* Defend against double atari in the surrounding chain early. */
	double_atari_chain2(bpos, moves, scores, num_moves);
      }
    }
  }
}


/* In situations like this
 *
 *   |.bOX
 *   |.Xa.
 *   |.OXX
 *   |.O..
 *   |.XX.
 *
 * the lower O string can often be defended at a or b.
 *
 * This function may be called for strings with 3 or 4 liberties and
 * returns the * moves in the configuration below:
 *
 * |..O   |.*O
 * |.X.   |.c*
 * |.O?   |ab?
 *
 */
static void
special_rescue6(int str, int libs[3], int moves[MAX_MOVES],
		int scores[MAX_MOVES], int *num_moves)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int apos, bpos, cpos;
  int right, up;
  int k, l, r;
  int liberties = countlib(str);

  ASSERT1(liberties == 3 || liberties == 4, str);
  
  for (r = 0; r < liberties; r++) {
    apos = libs[r];
    
    for (k = 0; k < 4; k++) {
      right = delta[k];
      
      if (ON_BOARD(apos - right))
	continue;
      
      bpos = apos + right;
      if (board[bpos] != color || !same_string(str, bpos))
	continue;

      for (l = 0; l < 2; l++) {
	up = delta[(k+1) % 4];
	if (l == 1)
	  up = -up;

	cpos = bpos + up;
	if (board[cpos] != other)
	  continue;

	if (board[apos + up] != EMPTY)
	  continue;

	if (board[cpos + right] != EMPTY)
	  continue;

	if (board[apos + up + up] != EMPTY)
	  continue;
	
	if (board[cpos + up] != EMPTY)
	  continue;
	
	if (board[cpos + up + right] != color)
	  continue;
	
	
	ADD_CANDIDATE_MOVE(cpos + right, 0, moves, scores, *num_moves);
	ADD_CANDIDATE_MOVE(cpos + up, 0, moves, scores, *num_moves);
      }
    }
  }
}


/* In positions like
 *
 * |.XXOO.
 * |XXOX..
 * |OOOX*.
 * |......
 * +------
 *
 * the O stones to the left are best defended by the move at *.
 *
 * This function tries to find an adjacent string (apos) with exactly
 * three liberties. One of the liberties (bpos) must be on the edge
 * (but not in the corner). Diagonal to this liberty must be one stone
 * of the attacked string (cpos) and another liberty (dpos) of the
 * adjacent string. The third liberty (epos) must be adjacent to
 * (dpos). Furthermore must an O stone at (dpos) get at least three
 * liberties and and X stone at (epos) must get at most three
 * liberties.
 *
 * |.XXOO.
 * |XXOXe.
 * |OOcad.
 * |...b..
 * +------
 *
 * The defense move at (dpos) is proposed if the above conditions
 * are satisfied.
 */

static void
edge_clamp(int str, int moves[MAX_MOVES], int scores[MAX_MOVES],
	   int *num_moves)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int apos;
  int bpos;
  int cpos;
  int dpos;
  int epos;
  int adj, adjs[MAXCHAIN];
  int libs[3];
  int k, l, r;
  
  /* Pick up neighbors with three liberties. */
  adj = chainlinks2(str, adjs, 3);

  for (r = 0; r < adj; r++) {
    apos = adjs[r];
    /* Find a liberty at the edge. */
    bpos = NO_MOVE;
    findlib(apos, 3, libs);
    for (k = 0; k < 3; k++) {
      if (is_edge_vertex(libs[k])) {
	bpos = libs[k];
	break;
      }
    }
    if (bpos == NO_MOVE)
      continue;

    /* Edge liberty found. Establish up and right directions. */
    for (k = 0; k < 4; k++) {
      int up = delta[k];
      if (ON_BOARD(bpos - up))
	continue;
      if (board[bpos + up] != other)
	continue;
       
      for (l = 0; l < 2; l++) {
	int right = delta[(k+1)%4];
	if (l == 1)
	  right = -right;

	cpos = bpos + up - right;
	dpos = bpos + up + right;

	if (board[cpos] != color || !same_string(cpos, str))
	  continue;

	if (board[dpos] != EMPTY || !liberty_of_string(dpos, apos))
	  continue;

	epos = dpos + up;

	if (board[epos] != EMPTY || !liberty_of_string(epos, apos))
	  continue;

	if (approxlib(dpos, color, 3, NULL) < 3)
	  continue;
	
	if (approxlib(epos, other, 4, NULL) > 3)
	  continue;

	/* (dpos) looks like a good move. Add it to the list with a
         * substantial initial score.
	 */
	ADD_CANDIDATE_MOVE(dpos, 10, moves, scores, *num_moves);
      }
    }
  }
}


/* 
 * This function handles some special cases on the edge.
 *
 * 1. If (str) points to a string and 'a' an edge liberty of it,
 *    there is no point of trying to defend the string by crawling 
 *    along the edge if there is no hope of ever getting more liberties.
 *    This is of course if the blocking enemy group has enough liberties
 *    of its own.
 *
 *      XX       XX
 *      O.       Oa
 *      --       --
 *
 *    This function searches the edge towards the corner and sees if there
 *    is a friendly stone on one of the two first lines. If not, the move
 *    is removed from the  list of moves.
 *
 * 2. If (str) points to a string and 'a' an edge liberty of it,
 *    the drawing back/climbing up move 'b' is often correct attack or
 *    defense. Another good move to try is 'c' (but usually not for
 *    defense of a 2 liberty string).
 * 
 *      X.?        Xbc
 *      O..        Oa.
 *      ---        ---
 *
 *    This function adds the points configured like 'b' and 'c' relative to
 *    (str) to the list of moves.
 *
 * color is the color to move.
 */

static void
propose_edge_moves(int str, int *libs, int liberties, int moves[MAX_MOVES], 
		   int scores[MAX_MOVES], int *num_moves, int to_move)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int right;
  int up;
  int apos;
  int k, l;
  int r;

  for (r = 0; r < liberties; r++) {
    apos = libs[r];
    for (k = 0; k < 4; k++) {
      up = delta[k];
      if (ON_BOARD(apos - up))
	continue;
      
      for (l = 0; l < 2; l++) {
	right = delta[(k+1)%4];
	if (l == 1)
	  right = -right;
       
	if (board[apos + up] == other	   /* other on top of liberty */
	    && countlib(apos + up) > 4     /* blocking group must be secure */
	    && color == to_move) {         /* only applicable as defense */

	  /* Case 1: other above the liberty (crawl along the edge). */
	  int xpos = apos;
	
	  while (ON_BOARD(xpos)) {
	    if (board[xpos] == color
		|| board[xpos + up] == color)
	      break;

	    xpos += right;
	  }

	  /* If no friendly stone found, then it is pointless and we
	   * can just as well remove the move.
	   */
	  if (!ON_BOARD(xpos)) {
	    REMOVE_CANDIDATE_MOVE(apos, moves, scores, *num_moves);
	  }
	}
	else if (board[apos + up] == EMPTY  /* empty above the liberty */
		 && board[apos - right + up] == other
		 && board[apos + right] == EMPTY) { /* empty to the right */

	  /* Case 2: Try to escape or contain. */
	  
	  /* Add b 
	   * If adjacent X stone in atari, boost the initial score of this
	   * move.
	   */
	  if (countlib(apos + up - right) == 1)
	    ADD_CANDIDATE_MOVE(apos + up, 10, moves, scores, *num_moves);
	  else {
	    ADD_CANDIDATE_MOVE(apos + up, 0, moves, scores, *num_moves);
	    
	    /* Add c if empty */
	    if (board[apos + right + up] == EMPTY
		&& (liberties != 2 || color != to_move))
	      ADD_CANDIDATE_MOVE(apos + right + up, 0,
				 moves, scores, *num_moves);
	  }
	}
      }
    }
  }
}


/* ================================================================ */  
/*                       Attacking functions                        */
/* ================================================================ */

/* FIXME: These two globals should be wrapped up in accessors, at least. */
char *rgoal;
int goallib;

#if EXPERIMENTAL_READING
#define MAX_READING_MOVES 99
struct reading_move_data {
  int pos;          /* move coordinate */
  int value;        /* value */
  const char *name; /* name of the pattern suggesting the move */
};


/* reading_callback helper
 * returns 1 if the move need not be tried, because there's
 * already a move in the collected list with a higher value.
 */
static int
r_scan_moves(int move, int value, struct reading_move_data *moves) 
{
  int k;
  for (k = 0; k < MAX_READING_MOVES; k++) {
    if (moves[k].pos == NO_MOVE)
      break;
    
    if (moves[k].pos == move) {
      if (value <= moves[k].value)
	return 1;
      else
	break;
    }
  }
  
  return 0;
}

/* reading_callback helper.
 * pushes moves onto the move list. */
static void
r_push_move(int move, int value, const char * name, 
            struct reading_move_data *moves)
{
  int k;
  for (k = 0; k < MAX_READING_MOVES; k++) {
    if (!moves[k].pos) {
      moves[k].pos = move;
      moves[k].value = value;
      moves[k].name = name;
      moves[++k].pos = 0;
      break;
    }
    
    if (moves[k].value < value) {
      int j = k;
      while (moves[j].pos != NO_MOVE && moves[j].pos != move) 
	j++;
      
      if (moves[j].pos != NO_MOVE)
	j--;
      
      for (; j >= k; j--) {
	moves[j+1].pos = moves[j].pos;
	moves[j+1].value = moves[j].value;
	moves[j+1].name = moves[j].name;
      }
      
      moves[k].pos = move;
      moves[k].value = value;
      moves[k].name = name;
      break;
    }
  }
}

/* Callback function for pattern-based tactical reading */
static void
reading_callback(int m, int n, int color,
                 struct pattern *pattern, int ll, void *data)
{
  int k;
  int move;
  int value = gg_max(pattern->maxvalue, pattern->value);
  struct reading_move_data *moves = data;
  UNUSED(data);
  UNUSED(k);

  move = AFFINE_TRANSFORM(pattern->movei, pattern->movej, ll, m, n);

  if (0)
    gprintf("  Pattern %s called back at %1m (variation %d) orientation %d.\n", 
            pattern->name, move, count_variations, ll);

  if (r_scan_moves(move, value, moves))
    return;

  if (0 && !strcmp("none3", pattern->name))
    gprintf("Pattern %s contraint to be checked at %1m (variation %d) orientation %d.\n", 
            pattern->name, move, count_variations, ll);

  /* If the pattern has a constraint, call the autohelper to see
   * if the pattern must be rejected.
   */
  if (pattern->autohelper_flag & HAVE_CONSTRAINT)
    if (!pattern->autohelper(pattern, ll, move, color, 0))
      return;

  /* If the pattern has a helper, call it.  The helper change the
   * pattern-> value.
   */
  if (pattern->autohelper_flag & HAVE_ACTION)
    pattern->autohelper(pattern, ll, move, color, 1);

  /* Note: The reading code allows helper to change pattern->value */
  value = pattern->value;
  if (value <= 0)
    return;

  if (0)
    gprintf("  Pattern %s MATCHED  at %1m (variation %d) orientation %d.\n", 
            pattern->name, move, count_variations, ll);

  if (r_scan_moves(move, value, moves))
    return;

  r_push_move(move, value, pattern->name, moves);

}


static void
set_goal_worm(int str, int value, char goal[BOARDMAX])
{
  int k;
  int color = board[str];
  if (goal[str])
    return;
  
  goal[str] = value;
  for (k = 0; k < 4; k++) {
    int pos = str + delta[k];
    if (board[pos] == color)
      set_goal_worm(pos, value, goal);
  }
}

static void
set_larger_goal_worm(int str, char goal[BOARDMAX])
{
  int k;
  int color = board[str];
  /*Note: over-ride possible 3 values here.*/
  if (goal[str] == 1)
    return;
  
  goal[str] = 1;
  for (k = 0; k < 4; k++) {
    int pos = str + delta[k];
    if (board[pos] == color) {
      set_larger_goal_worm(pos, goal);
    }
    else if (board[pos] == OTHER_COLOR(color) 
	     && (stackp < (depth+4) || countlib(pos) <= 2)) {
      set_goal_worm(pos, 2, goal);
    }
    else if (stackp < (12+2) && board[pos] == EMPTY) {
      int j;
      for (j = 0; j < 4; j++) {
	int jpos = pos + delta[j];
	if (board[jpos] == color) {
	  set_goal_worm(jpos, 3, goal);
        }
	else if (board[jpos] == OTHER_COLOR(color)) {
          /* Added for defense - not needed for attack (?) */
	  set_goal_worm(jpos, 2, goal);
        }
      }
    }
  }
}

static int
do_attack_pat(int str, int *move, int komaster, int kom_pos)
{
  return do_tactical_pat(1, str, move, komaster, kom_pos);
}

static int
do_defend_pat(int str, int *move, int komaster, int kom_pos)
{
  return do_tactical_pat(0, str, move, komaster, kom_pos);
}


static int
do_tactical_pat(int is_attack, int str, int *move, int komaster, int kom_pos)
{
  char goal[BOARDMAX];
  struct reading_move_data moves[MAX_READING_MOVES];
  int k;
  int color = board[str];
  int next_color = is_attack ? OTHER_COLOR(color) : color;
  int best_other_tactic = WIN;
  int best_move = 0;
  int new_komaster = 0;
  int new_kom_pos = 0;
  int ko_move = 0;
  int libs;
  int skipped = 0;
  const char * attack_defend_str = is_attack ? "Attack" : "Defend";
  const char * trace_str = is_attack ? "attack_pat" : "defend_pat";


  SETUP_TRACE_INFO(trace_str, str);

  ASSERT1(move != NULL, str);

  if (reading_node_counter - nodes_when_called > 15000) {
    SGFTRACE(0, 0, "Way too many variations");
    return 0;
  }

  libs = countlib(str);

  if (stackp > depth && libs>2) {
    SGFTRACE(0, 0, "Too deep");
    return 0;
  }

  if (libs == 1) {
    if (is_attack)
      return attack1(str, move, komaster, kom_pos);
    else
      return defend1(str, move, komaster, kom_pos);
  }

  if (libs == 4) {
    if (is_attack)
      return attack4(str, move, komaster, kom_pos);
    else
      return defend4(str, move, komaster, kom_pos);
  }

  memset(goal, 0, BOARDMAX);

  reading_node_counter++;
  set_larger_goal_worm(str, goal);
  moves[0].pos = 0;
  if (verbose > 1) {
    TRACE("Stack: "); 
    dump_stack();
  }
  rgoal = goal;
  goallib = libs;
  if (is_attack)
    matchpat_goal_anchor(reading_callback, OTHER_COLOR(color),
			 &read_attack_db, moves, goal, 1);
  else
    matchpat_goal_anchor(reading_callback, OTHER_COLOR(color),
			 &read_defend_db, moves, goal, 1);

  if (verbose > 1) {
    TRACE("Moves (variation %d): ", count_variations);
    for (k = 0; k < MAX_READING_MOVES; k++) {
      if (!moves[k].pos)
	break;
      TRACE("%o%s@%1m ", moves[k].name, moves[k].pos);
    }
    TRACE("\n");
  }

  if (sgf_dumptree) {
    char buf[500];
    char *pos;
    int chars;
    gg_snprintf(buf, 500, "Move order for %s: %n",
		read_function_name, &chars);
    
    pos = buf + chars;
    for (k = 0; k < MAX_READING_MOVES; k++) {
      if (moves[k].pos == NO_MOVE)
	break;
      sprintf(pos, "%s (%s-%d) %n", location_to_string(moves[k].pos),
              moves[k].name, moves[k].value, &chars);
      pos += chars;
    }
    sgftreeAddComment(sgf_dumptree, NULL, buf);
  }

  for (k = 0; MAX_READING_MOVES; k++) {
    char namebuf[128];
    if (moves[k].pos == NO_MOVE)
      break;

    gg_snprintf(namebuf, 128, "%s(%d)", moves[k].name, moves[k].value);
    if (k > 3 + skipped && k > 12 - stackp + skipped) {
      if (sgf_dumptree) {
        if (trymove(moves[k].pos, next_color, namebuf, str, 0, 0)) {
          sgftreeAddComment(sgf_dumptree, NULL, 
			    "move trimmed to reduce variations");
          popgo();
        }
      }
      continue;
    }

    if (komaster_trymove(moves[k].pos, next_color, namebuf, str, 
			 komaster, kom_pos,
			 &new_komaster, &new_kom_pos,
			 &ko_move, 
			 stackp <= ko_depth && best_other_tactic == WIN)) {
      int other_tactic;
      ASSERT1(countlib(str) >= 1, str);
      RTRACE("%sing %1m at %1m (Pattern %s)\n", attack_defend_str, str, 
	     moves[k].pos, moves[k].name);
      if (sgf_dumptree) {
        char buf[500];
        sprintf(buf, "tactical_pat komaster: %d %s  new_komaster: %d %s ko_move: %d", 
		komaster, location_to_string(kom_pos), new_komaster, 
		location_to_string(new_kom_pos), ko_move);
        sgftreeAddComment(sgf_dumptree, NULL, buf);
      }
      
      if (stackp > 100) {
        popgo();
        gprintf("komaster: %d %1m  new_komaster: %d %1m ko_move: %d\n", 
		komaster, kom_pos, new_komaster, new_kom_pos, ko_move);
        continue;  /* Short circuit */
      }
      
      if (is_attack)
        other_tactic = do_find_defense(str, 0, new_komaster, new_kom_pos);
      else
        other_tactic = do_attack(str, 0, new_komaster, new_kom_pos);

      if (is_attack && other_tactic != WIN) {
        int same_tactic;
        /* HINT: add 1 || here to generate stack errors in reading:60 
         *    (not positive of problem number) */
        if (stackp < depth + 6 || countlib(str) <= 2) {
          if (is_attack)
     	    same_tactic = do_attack(str, 0, new_komaster, new_kom_pos);
	  else
     	    same_tactic = do_find_defense(str, 0, new_komaster, new_kom_pos);

	  if (!ko_move && other_tactic == 0 && same_tactic != 0) {
	    *move = moves[k].pos;
	    popgo();
	    SGFTRACE(moves[k].pos, WIN,
		     "tactic successful - no defense, ko sub-attack");
	    return WIN;
	  }
        }
	else {
          same_tactic = 0;
          SGFTRACE(moves[k].pos, 0, "Too deep, aborting attack");
        }
	/* This defense assignment may be incorrect. */
	other_tactic = gg_max(other_tactic, WIN - same_tactic);
      }
      if (!other_tactic) {
	if (ko_move) {
	  TRACE("Ko move good: %1m\n", moves[k].pos);
	  other_tactic = KO_A;
	  if (other_tactic < best_other_tactic) {
	    best_move = moves[k].pos;
	    best_other_tactic = other_tactic ;
	  }
	}
	else {
	  popgo();
          /* FIXME: add explicit attack/defense verbage here */
	  SGFTRACE(moves[k].pos, WIN, "tactic successful - no counter.");
	  *move = moves[k].pos;
	  return WIN;
	}
      }
      else if (other_tactic < best_other_tactic) {
	/* May need to check ko_move in this case, too */
	best_move = moves[k].pos;
	best_other_tactic = other_tactic;
      }
      popgo();
    }
    else {
      /* FIXME: Add this back to allow up to 3 legal moves when deep. */
      /* Current implementation counts illegal moves. */
      if (0)
	skipped++;
    }
  }

  if (!is_attack) {
    /* Force attacker to capture - i.e. might be seki. */
    int attack;
    attack = do_attack(str, 0, new_komaster, new_kom_pos);
    if (attack < best_other_tactic) {
      best_move = PASS_MOVE;
      best_other_tactic = attack;
    }
  }


  /* FIXME: Add explicit attack/defense verbage here. */
  SGFTRACE(best_move, WIN - best_other_tactic, "No good tactic.");
  *move = best_move;
  return WIN - best_other_tactic;
}

#endif /*EXPERIMENTAL_READING*/


/* Like attack, but takes the komaster argument. If the
 * opponent is komaster, reading functions will not try
 * to take ko.
 */
static int 
do_attack(int str, int *move, int komaster, int kom_pos)
{
  int color = board[str];
  int xpos;
  int libs;
  int result = 0;
  int found_read_result;
  Read_result *read_result = NULL;

  SETUP_TRACE_INFO("attack", str);

  ASSERT1(color != 0, str);

  if (color == 0)      /* if assertions are turned off, silently fails */
    return 0;

  libs = countlib(str);

  if (libs > 4
      || (libs == 4 && stackp > fourlib_depth)) {
    /* No need to cache the result in these cases. */
    if (sgf_dumptree) {
      char buf[100];
      sprintf(buf, "got 4 liberties (stackp:%d>%d)", 
              stackp, fourlib_depth);
      SGFTRACE(0, 0, buf);
    }
    return 0;
  }

  if ((stackp <= depth) && (hashflags & HASH_ATTACK)) {
    found_read_result = get_read_result(ATTACK, komaster, kom_pos, 
					&str, &read_result);
    if (found_read_result) {
      TRACE_CACHED_RESULT(*read_result);
      if (rr_get_result(*read_result) != 0)
	if (move)
	  *move = rr_get_move(*read_result);

      SGFTRACE(rr_get_move(*read_result),
	       rr_get_result(*read_result), "cached");
      return rr_get_result(*read_result);
    }
  }

#if EXPERIMENTAL_READING
  if (attack_by_pattern) {
    result = do_attack_pat(str, &xpos, komaster, kom_pos);
    /* Set libs to 0 to pass over the non-pattern code below. */
    libs = 0;
  }
#endif

  /* Treat the attack differently depending on how many liberties the 
     string at (str) has. */
  if (libs == 1)
    result = attack1(str, &xpos, komaster, kom_pos);
  else if (libs == 2)
    result = attack2(str, &xpos, komaster, kom_pos);
  else if (libs == 3)
    result = attack3(str, &xpos, komaster, kom_pos);
  else if (libs == 4)
    result = attack4(str, &xpos, komaster, kom_pos);


  ASSERT1(result >= 0 && result <= WIN, str);
  
  if (result)
    READ_RETURN(read_result, move, xpos, result);

  READ_RETURN0(read_result);
}


/* If (str) points to a group with exactly one liberty, attack1
 * determines whether it can be captured by playing at this liberty.
 * If successful, (*move) is the killing move. move may be NULL if
 * caller is only interested in whether it can be captured.
 *
 * The attack may fail for two different reasons. The first one is
 * that the attack may be an illegal ko capture, in this case KO_B is
 * returned (need to play a ko threat before the attack can be
 * fulfilled).
 *
 * The second cause for failure is that the attack is caught in a
 * snapback. We must require that it is a proper snapback, though. By
 * proper snapback we mean a position like
 *
 *  XXXXO
 *  XO.XO
 *  XOXOO
 *  -----
 *
 * where capture by O and recapture by X leaves the X stone intact
 * with at least two liberties:
 *
 *  XXXXO
 *  X..XO
 *  X.XOO
 *  -----
 *
 * There are a number of different kinds of improper snapbacks, which
 * have in common that the attacked string ends up captured. We don't
 * consider these as failures to attack. Three examples are given below.
 *
 *   XXOOOOO     (X can recapture but loses most of the string.)
 *   X.XXXXO
 *   -------
 *
 *   XXXOOOOOOOO (Like the previous example, except O loses one more stone)
 *   XO*XXXXXXXO
 *   -----------
 *
 *   XXXOO       (After three captures, the lone X stone is gone.)
 *   XO.XO
 *   -----
 *
 * This function is fast and never branches. There's little point in
 * caching the result.
 */

static int
attack1(int str, int *move, int komaster, int kom_pos)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int xpos;
  int result = -1;
  
  SETUP_TRACE_INFO("attack1", str);
  reading_node_counter++;
  
  /* Pick up the position of the liberty. */
  findlib(str, 1, &xpos);

  /* If the attacked string consists of more than one stone, the
   * attack never fails. (This assumes simple ko rule. With superko
   * rule it could still be a ko violation.)
   */
  if (countstones(str) > 1)
    result = WIN;
  
  /* Try to play on the liberty. This fails if and only if it is an
   * illegal ko capture.
   */
  else if (trymove(xpos, other, "attack1-A", str, komaster, kom_pos)) {
    /* Is the attacker in atari? If not the attack was successful. */
    if (countlib(xpos) > 1)
      result = WIN;

    /* If the attacking string is also a single stone, a possible
     * recapture would be a ko violation, so the defender has to make
     * a ko threat first.
     */
    else if (countstones(xpos) == 1) {
      /* If the defender is allowed to take the ko the result is KO_A. */
      if (komaster != other)
	result = KO_A;
      else 
	/* But if the attacker is komaster, the attack was successful. */
	result = WIN;
    }
      
    /* Otherwise, do recapture. Notice that the liberty must be
     * at (str) since we have already established that this string
     * was a single stone.
     */
    else if (trymove(str, color, "attack1-B", str, komaster, kom_pos)) {
      /* If this was a proper snapback, (str) will now have more
       * than one liberty.
       */
      if (countlib(str) > 1) {
	/* Proper snapback, attack fails. */
	result = 0;
      }
      else
	result = WIN;
      popgo();
    }
    popgo();
  }
  else {/* Illegal ko capture. */
    if (komaster != color) 
      result = KO_B;
    else
      result = 0;
  }

  /* If not yet successful, try backfilling.
   * FIXME: Maybe only meaningful to do this in positions involving ko.
   */
  if (result != WIN) {
    int liberties;
    int libs[6];
    int k;
    liberties = approxlib(xpos, color, 6, libs);
    if (liberties <= 5)
      for (k = 0; k < liberties; k++) {
	int apos = libs[k];
	if (!is_self_atari(apos, other)
	    && trymove(apos, other, "attack1-C", str, komaster, kom_pos)) {
	  int dcode = do_find_defense(str, NULL, komaster, kom_pos);
	  if (dcode != WIN && do_attack(str, NULL, komaster, kom_pos)) {
	    if (dcode == 0) {
	      popgo();
	      SGFTRACE(apos, WIN, "backfilling");
	      *move = apos;
	      return WIN;
	    }
	    UPDATE_SAVED_KO_RESULT(result, xpos, dcode, apos);
	  }
	  popgo();
	}
      }
  }
  
  if (result > 0) {
    *move = xpos;
    SGFTRACE(xpos, result, NULL);
  }
  else {
    SGFTRACE(0, 0, NULL);
  }
  
  return result;
}


/* If str points to a group with exactly two liberties
 * attack2 determines whether it can be captured in ladder or net.
 * If yes, *move is the killing move. move may be null if caller 
 * is only interested in whether it can be captured.
 *  
 * Returns KO_A or KO_B if it can be killed conditioned on ko. Returns
 * KO_A if it can be killed provided (other) is willing to ignore any
 * ko threat. Returns KO_B if (other) wins provided he has a ko threat
 * which must be answered. Can give a return code KO_B yet *move=0 if
 * the winning move is an illegal ko capture. In this case, making a
 * ko threat and having it answered should transform the position to
 * one where the return code is KO_A.
 *
 * See the comment before defend1 about ladders and reading depth.
 */

static int 
attack2(int str, int *move, int komaster, int kom_pos)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int hpos;
  int xpos;
  int liberties, r;
  int libs[2];
  int libs2[2];
  int adj, adjs[MAXCHAIN];
  int savemove = 0;
  int savecode = 0;
  int acode;
  int dcode;
  int k;
  int atari_possible = 0;
  int moves[MAX_MOVES];
  int scores[MAX_MOVES];
  int num_moves = 0;
  int adjacent_liberties = 0;
  int found_read_result;
  Read_result *read_result = NULL;

  SETUP_TRACE_INFO("attack2", str);
  reading_node_counter++;

  str = find_origin(str);
  ASSERT1(IS_STONE(board[str]), str);
  ASSERT1(countlib(str) == 2, str);

  RTRACE("checking attack on %1m with 2 liberties\n", str);

  if ((stackp <= depth) && (hashflags & HASH_ATTACK2)) {
  
    found_read_result = get_read_result(ATTACK2, komaster, kom_pos,
					&str, &read_result);
    if (found_read_result) {
      TRACE_CACHED_RESULT(*read_result);
      if (rr_get_result(*read_result) != 0)
	*move = rr_get_move(*read_result);

      SGFTRACE(rr_get_move(*read_result),
	       rr_get_result(*read_result), "cached");
      return rr_get_result(*read_result);
    }
  }

  /* The attack may fail if a boundary string is in atari and cannot 
   * be defended.  First we must try defending such a string. 
   *
   * We start by trying to defend the boundary string by looking for an
   * adjacent string which is in atari. 
   */
  adj = chainlinks2(str, adjs, 1);
  for (r = 0; r < adj; r++) {
    /* if stackp > depth and any boundary chain is in atari, assume safe.
     * However, if the captured chain is only of size 1, there can still
     * be a working ladder, so continue if that is the case.
     */
    if (stackp > depth && countstones(adjs[r]) > 1) {
      SGFTRACE(0, 0, "boundary in atari");
      READ_RETURN0(read_result);
    }

    /* Pick up moves breaking the second order chain. */
    if (stackp <= depth)
      break_chain_moves(adjs[r], moves, scores, &num_moves);
    
    findlib(adjs[r], 1, &hpos);
    ADD_CANDIDATE_MOVE(hpos, 0, moves, scores, num_moves);
  }

  /* Get the two liberties of (str). */
  liberties = findlib(str, 2, libs);
  ASSERT1(liberties == 2, str);

  if (libs[0] == SOUTH(libs[1])
      || libs[0] == WEST(libs[1])
      || libs[0] == NORTH(libs[1])
      || libs[0] == EAST(libs[1]))
    adjacent_liberties = 1;
  
  for (k = 0; k < 2; k++) {
    int apos = libs[k];
    if (!is_self_atari(apos, other))
      atari_possible = 1;
    /* we only want to consider the move at (apos) if:
     * stackp <= backfill_depth
     * -or-  stackp <= depth and it is an isolated stone
     * -or-  it is not in immediate atari
     */
    if (stackp <= backfill_depth
	|| ((stackp <= depth || adjacent_liberties) 
	    && board[SOUTH(apos)] != other
	    && board[WEST(apos)] != other
	    && board[NORTH(apos)] != other
	    && board[EAST(apos)] != other)
	|| !is_self_atari(apos, other))
      ADD_CANDIDATE_MOVE(apos, 0, moves, scores, num_moves);

    /* Try backfilling if atari is impossible. */
    if (stackp <= backfill_depth && approxlib(apos, other, 2, libs2) == 1) {
      ADD_CANDIDATE_MOVE(libs2[0], 0, moves, scores, num_moves);
      /* If there is a neighbor in atari, we also try back-capturing. */
      for (r = 0; r < 4; r++) {
	int bpos = libs2[0] + delta[r];
	if (board[bpos] == other && chainlinks2(bpos, adjs, 1) > 0) {
	  /* FIXME: If there is more than one neighbor in atari, we
           * currently just take one randomly. This is maybe not good
           * enough. We might also want to check against snapback.
	   */
	  findlib(adjs[0], 1, &xpos);
	  ADD_CANDIDATE_MOVE(xpos, 0, moves, scores, num_moves);
	}
      }
    }
  }

  /* If we can't make a direct atari, look for edge blocking moves. */
  if (!atari_possible)
    for (k = 0; k < 2; k++) 
      edge_block(str, libs[k], moves, scores, &num_moves);
    

  /* If one of the surrounding chains have only two liberties, which
   * coincide with the liberties of the attacked string, we try to
   * backcapture.
   */
  
  adj = chainlinks2(str, adjs, 2);
  for (r = 0; r < adj; r++) {
    int apos = adjs[r];
    if (liberty_of_string(libs[0], apos)
	&& liberty_of_string(libs[1], apos))
      break_chain_moves(apos, moves, scores, &num_moves);
  }
  
  propose_edge_moves(str, libs, liberties, moves, scores, &num_moves, other);
  order_moves(str, num_moves, moves, scores, other, read_function_name);

  for (k = 0; k < num_moves; k++) {
    int new_komaster;
    int new_kom_pos;
    int ko_move;

    int apos = moves[k];
    if (komaster_trymove(apos, other, "attack2-A", str,
			 komaster, kom_pos, &new_komaster, &new_kom_pos,
			 &ko_move, stackp <= ko_depth && savecode == 0)) {
      if (!ko_move) {
	dcode = do_find_defense(str, NULL, new_komaster, new_kom_pos);
	if (dcode != WIN
	    && do_attack(str, NULL, new_komaster, new_kom_pos)) {
	  if (dcode == 0) {
	    popgo();
	    SGFTRACE(apos, WIN, "attack effective");
	    READ_RETURN(read_result, move, apos, WIN);
	  }
	  UPDATE_SAVED_KO_RESULT(savecode, savemove, dcode, apos);
	}
      }
      else {
	if (do_find_defense(str, NULL, new_komaster, new_kom_pos) != WIN
	    && do_attack(str, NULL, new_komaster, new_kom_pos) != 0) {
	  savemove = apos;
	  savecode = KO_B;
	}
      }
      popgo();
    }
  }
  
  /* The simple ataris didn't work. Try something more fancy. */
  acode = find_cap2(str, libs[0], libs[1], &xpos, komaster, kom_pos);
  if (acode == WIN) {
    SGFTRACE(xpos, WIN, "find cap2");
    READ_RETURN(read_result, move, xpos, WIN);
  }
  UPDATE_SAVED_KO_RESULT_UNREVERSED(savecode, savemove, acode, xpos);

  if (stackp <= backfill_depth) {
    acode = special_attack2(str, libs, &xpos, komaster, kom_pos);
    if (acode == WIN) {
      SGFTRACE(xpos, WIN, "special attack2");
      READ_RETURN(read_result, move, xpos, WIN);
    }
    UPDATE_SAVED_KO_RESULT_UNREVERSED(savecode, savemove, acode, xpos);
  }

  if (stackp <= backfill_depth) {
    acode = special_attack3(str, libs, &xpos, komaster, kom_pos);
    if (acode == WIN) {
      SGFTRACE(xpos, WIN, "special attack3");
      READ_RETURN(read_result, move, xpos, WIN);
    }
    UPDATE_SAVED_KO_RESULT_UNREVERSED(savecode, savemove, acode, xpos);
  }

  if (stackp <= backfill_depth) {
    acode = special_attack4(str, libs, &xpos, komaster, kom_pos);
    if (acode == WIN) {
      SGFTRACE(xpos, WIN, "special attack4");
      READ_RETURN(read_result, move, xpos, WIN);
    }
    UPDATE_SAVED_KO_RESULT_UNREVERSED(savecode, savemove, acode, xpos);
  }

  /* If it is not possible to make a direct atari, we try filling
   * a liberty of the superstring.
   */
  if (level >= 10
      && stackp <= backfill_depth
      && (stackp <= superstring_depth || !atari_possible)) {
    int ss_liberties;
    int ss_libs[MAX_LIBERTIES + 4];
    int liberty_cap = 2;

    if (stackp <= backfill2_depth)
      liberty_cap = 3;
    
    find_superstring_liberties(str, &ss_liberties, ss_libs, liberty_cap);
    if (ss_liberties <= 5) {
      for (k = 0; k < ss_liberties; k++) {
	int apos = ss_libs[k];
	
	if (liberty_of_string(apos, str))
	  continue;
	if (trymove(apos, other, "attack2-C", str, komaster, kom_pos)) {
	  if (countlib(apos) == 1) {
	    /* can't atari, try backfilling. */
	    findlib(apos, 1, &xpos);
	    if (approxlib(xpos, other, 2, NULL) > 1) {
	      popgo();
	      if (trymove(xpos, other, "attack2-D", str, komaster, kom_pos)) {
		dcode = do_find_defense(str, NULL, komaster, kom_pos);
		if (dcode != WIN && do_attack(str, NULL, komaster, kom_pos)) {
		  if (dcode == 0) {
		    popgo();
		    SGFTRACE(xpos, WIN, "attack effective");
		    READ_RETURN(read_result, move, xpos, WIN);
		  }
		  UPDATE_SAVED_KO_RESULT(savecode, savemove, dcode, xpos);
		}
		popgo();
	      }
	    }
	    else
	      popgo();
	  }
	  else {
	    dcode = do_find_defense(str, NULL, komaster, kom_pos);
	    if (dcode != WIN 
		&& do_attack(str, NULL, komaster, kom_pos)) {
	      if (dcode == 0) {
		popgo();
		SGFTRACE(apos, WIN, "attack effective");
		READ_RETURN(read_result, move, apos, WIN);
	      }
	      UPDATE_SAVED_KO_RESULT(savecode, savemove, dcode, apos);
	    }
	    popgo();
	  }
	}
      }
    }
  }

  if (savecode == 0) {
    RTRACE("ALIVE!!\n");
    SGFTRACE(0, 0, NULL);
    READ_RETURN0(read_result);
  }

  SGFTRACE(savemove, savecode, "saved move");
  READ_RETURN(read_result, move, savemove, savecode);
}



/* attack3(str, *move) is used when (str) points to a group with
 * three liberties. It returns true if it finds a way to kill the group.
 *
 * Return code is KO_A if the group can be killed if the attacker is 
 * willing to ignore any ko threat.
 *
 * Return code is KO_B if the group can be killed if the attacker is 
 * able to find a ko threat which must be answered.
 *
 * If non-NULL (*move) will be set to the move which makes the
 * attack succeed.
 */

static int 
attack3(int str, int *move, int komaster, int kom_pos)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int adj, adjs[MAXCHAIN];
  int xpos;
  int liberties;
  int libs[3];
  int r;
  int dcode = 0;
  int k;
  int moves[MAX_MOVES];
  int scores[MAX_MOVES];
  int num_moves = 0;
  int savemove = 0;
  int savecode = 0;
  int found_read_result;
  Read_result *read_result = NULL;
  
  SETUP_TRACE_INFO("attack3", str);
  reading_node_counter++;
  
  gg_assert(IS_STONE(board[str]));
  
  if ((stackp <= depth) && (hashflags & HASH_ATTACK3)) {
    found_read_result = get_read_result(ATTACK3, komaster, kom_pos,
					&str, &read_result);
    if (found_read_result) {
      TRACE_CACHED_RESULT(*read_result);
      if (rr_get_result(*read_result) != 0)
	*move = rr_get_move(*read_result);
      
      SGFTRACE(rr_get_move(*read_result),
	       rr_get_result(*read_result), "cached");
      return rr_get_result(*read_result);
    }
  }
  
  if (stackp > depth) {
    SGFTRACE(0, 0, "stackp > depth");
    READ_RETURN0(read_result);
  }
  
  adj = chainlinks2(str, adjs, 1);
  for (r = 0; r < adj; r++) {
    int hpos;
    break_chain_moves(adjs[r], moves, scores, &num_moves);
    
    findlib(adjs[r], 1, &hpos);
    ADD_CANDIDATE_MOVE(hpos, 0, moves, scores, num_moves);
  }
  
  /* Defend against double atari in the surrounding chain early. */
  double_atari_chain2(str, moves, scores, &num_moves);
  
  /* Get the three liberties of (str). */
  liberties = findlib(str, 3, libs);
  ASSERT1(liberties == 3, str);
  
  for (k = 0; k < 3; k++) {
#if 0
    int libs2[2];
#endif
    int apos = libs[k];
    /* we only want to consider the move at (apos) if:
     * stackp <= backfill_depth
     * -or-  stackp <= depth and it is an isolated stone
     * -or-  it is not in immediate atari
     */
    if (stackp <= backfill_depth
	|| (stackp <= depth
	    && board[SOUTH(apos)] != other
	    && board[WEST(apos)] != other
	    && board[NORTH(apos)] != other
	    && board[EAST(apos)] != other)
	|| !is_self_atari(apos, other))
      ADD_CANDIDATE_MOVE(apos, 0, moves, scores, num_moves);

    if (edge_closing_backfill(str, apos, &xpos))
      ADD_CANDIDATE_MOVE(xpos, 0, moves, scores, num_moves);

#if 0
    /* Try backfilling if atari is impossible. */
    if (stackp <= backfill_depth
	&& approxlib(apos, other, 2, libs2) == 1) {
      ADD_CANDIDATE_MOVE(libs2[0], 0, moves, scores, num_moves);
    }
#endif
    
    /* Look for edge blocking moves. */
    edge_block(str, apos, moves, scores, &num_moves);
  }
  
  /* Pick up some edge moves. */
  propose_edge_moves(str, libs, liberties, moves, scores, &num_moves, other);
  order_moves(str, num_moves, moves, scores, other, read_function_name);

  /* Try the moves collected so far. */
  for (k = 0; k < num_moves; k++) {
    int new_komaster;
    int new_kom_pos;
    int ko_move;
    
    if (stackp >= branch_depth && k > 0)
      break;
    xpos = moves[k];
    if (komaster_trymove(xpos, other, "attack3-A", str,
			 komaster, kom_pos, &new_komaster, &new_kom_pos,
			 &ko_move, stackp <= ko_depth && savecode == 0)) {
      if (!ko_move) {
	dcode = do_find_defense(str, NULL, new_komaster, new_kom_pos);
	if (dcode != WIN && do_attack(str, NULL, new_komaster, new_kom_pos)) {
	  if (dcode == 0) {
	    popgo();
	    SGFTRACE(xpos, WIN, "attack effective");
	    READ_RETURN(read_result, move, xpos, WIN);
	  }
	  UPDATE_SAVED_KO_RESULT(savecode, savemove, dcode, xpos);
	}
      }
      else {
	if (do_find_defense(str, NULL, new_komaster, new_kom_pos) != WIN
	    && do_attack(str, NULL, new_komaster, new_kom_pos) != 0) {
	  savemove = xpos;
	  savecode = KO_B;
	}
      }
      popgo();
    }
  }
    
  /* The simple ataris didn't work. Try something more fancy. */
  if (stackp <= backfill_depth) {
    int acode = find_cap3(str, &xpos, komaster, kom_pos);
    if (acode == WIN) {
      SGFTRACE(xpos, WIN, "find cap3");
      READ_RETURN(read_result, move, xpos, WIN);
    }
    UPDATE_SAVED_KO_RESULT_UNREVERSED(savecode, savemove, acode, xpos);
  }

  if (stackp <= fourlib_depth) {
    int acode = draw_back(str, &xpos, komaster, kom_pos);
    if (acode == WIN) {
      SGFTRACE(xpos, WIN, "draw back");
      READ_RETURN(read_result, move, xpos, WIN);
    }
    UPDATE_SAVED_KO_RESULT_UNREVERSED(savecode, savemove, acode, xpos);
  }

  /* Try to defend chain links with two liberties. */
  if (stackp <= backfill2_depth) {
    int saved_num_moves = num_moves;
    adj = chainlinks2(str, adjs, 2);
    for (r = 0; r < adj; r++) {
      int libs2[2];
      findlib(adjs[r], 2, libs2);
      if (approxlib(libs2[0], other, 4, NULL) > 3
	  && approxlib(libs2[1], other, 4, NULL) > 3)
	continue;
      break_chain_moves(adjs[r], moves, scores, &num_moves);
      break_chain2_moves(adjs[r], moves, scores, &num_moves, 1);
      for (k = 0; k < 2; k++)
	ADD_CANDIDATE_MOVE(libs2[k], 0, moves, scores, num_moves);
    }
    /* Only order and test the new set of moves. */
    order_moves(str, num_moves-saved_num_moves,
		&(moves[saved_num_moves]),
		&(scores[saved_num_moves]), other, read_function_name);
    for (k = saved_num_moves; k < num_moves; k++) {
      int new_komaster;
      int new_kom_pos;
      int ko_move;

      if (stackp >= branch_depth && k > 0)
	break;
      xpos = moves[k];
      
      if (komaster_trymove(xpos, other, "attack3-C", str,
			   komaster, kom_pos, &new_komaster, &new_kom_pos,
			   &ko_move, stackp <= ko_depth && savecode == 0)) {
	if (!ko_move) {
	  dcode = do_find_defense(str, NULL, new_komaster, new_kom_pos);
	  if (dcode != WIN
	      && do_attack(str, NULL, new_komaster, new_kom_pos)) {
	    if (dcode == 0) {
	      popgo();
	      SGFTRACE(xpos, WIN, "attack effective");
	      READ_RETURN(read_result, move, xpos, WIN);
	    }
	    UPDATE_SAVED_KO_RESULT(savecode, savemove, dcode, xpos);
	  }
	}
	else {
	  if (do_find_defense(str, NULL, new_komaster, new_kom_pos) != WIN
	      && do_attack(str, NULL, new_komaster, new_kom_pos) != 0) {
	    savemove = xpos;
	    savecode = KO_B;
	  }
	}
	popgo();
      }
    }
  }
    
  /* If nothing else works, we try filling a liberty of the
   * super_string.
   */
  if (level >= 10 && stackp <= backfill2_depth) {
    int liberties;
    int libs[MAX_LIBERTIES + 4];

    find_superstring_liberties(str, &liberties, libs, 3);
    if (liberties <= 5) {
      for (k = 0; k < liberties; k++) {
	int apos = libs[k];
	
	if (liberty_of_string(apos, str))
	  continue;
	if (trymove(apos, other, "attack3-E", str, komaster, kom_pos)) {
	  if (countlib(apos) == 1) {
	    /* can't atari, try backfilling */
	    findlib(apos, 1, &xpos);
	    if (approxlib(xpos, other, 2, NULL) > 1) {
	      popgo();
	      if (trymove(xpos, other, "attack3-F", str, komaster, kom_pos)) {
		dcode = do_find_defense(str, NULL, komaster, kom_pos);
		if (dcode != WIN && do_attack(str, NULL, komaster, kom_pos)) {
		  if (dcode == 0) {
		    popgo();
		    SGFTRACE(xpos, WIN, "attack effective");
		    READ_RETURN(read_result, move, xpos, WIN);
		  }
		  UPDATE_SAVED_KO_RESULT(savecode, savemove, dcode, xpos);
		}
		popgo();
	      }
	    }
	    else
	      popgo();
	  }
	  else {
	    dcode = do_find_defense(str, NULL, komaster, kom_pos);
	    if (dcode != WIN && do_attack(str, NULL, komaster, kom_pos)) {
	      if (dcode == 0) {
		popgo();
		SGFTRACE(apos, WIN, "attack effective");
		READ_RETURN(read_result, move, apos, WIN);
	      }
	      UPDATE_SAVED_KO_RESULT(savecode, savemove, dcode, apos);
	    }
	    popgo();
	  }
	}
      }
    }
  }

  if (savecode != 0) {
    SGFTRACE(savemove, savecode, "saved move");
    READ_RETURN(read_result, move, savemove, savecode);
  }
  
  SGFTRACE(0, 0, NULL);
  READ_RETURN0(read_result);
}


/* attack4 tries to capture a string with 4 liberties. This function
 * is not cached.
 */

static int 
attack4(int str, int *move, int komaster, int kom_pos)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int xpos;
  int r;
  int k;
  int liberties;
  int libs[4];
  int adj, adjs[MAXCHAIN];
  int dcode = 0;
  int moves[MAX_MOVES];
  int scores[MAX_MOVES];
  int num_moves = 0;
  Read_result *read_result = NULL;
  int savemove = 0;
  int savecode = 0;

  SETUP_TRACE_INFO("attack4", str);
  
  gg_assert(IS_STONE(board[str]));
  reading_node_counter++;
  
  if (stackp > depth) {
    SGFTRACE(0, 0, "stackp > depth");
    return 0;
  }

  adj = chainlinks2(str, adjs, 1);
  for (r = 0; r < adj; r++) {
    int hpos;
    break_chain_moves(adjs[r], moves, scores, &num_moves);
    
    findlib(adjs[r], 1, &hpos);
    ADD_CANDIDATE_MOVE(hpos, 0, moves, scores, num_moves);
  }


  /* Defend against double atari in the surrounding chain early. */
  double_atari_chain2(str, moves, scores, &num_moves);

  /* Give a score bonus to the chain preserving moves. */
  for (k = 0; k < num_moves; k++)
    scores[k] += 5;
  
  /* Get the four liberties of (str). */
  liberties = findlib(str, 4, libs);
  ASSERT1(liberties == 4, str);

  for (k = 0; k < 4; k++) {
    int apos = libs[k];
    /* we only want to consider the move at (apos) if:
     * stackp <= backfill_depth
     * -or-  stackp <= depth and it is an isolated stone
     * -or-  it is not in immediate atari
     */
    if (stackp <= backfill_depth
	|| (stackp <= depth
	    && board[SOUTH(apos)] != other
	    && board[WEST(apos)] != other
	    && board[NORTH(apos)] != other
	    && board[EAST(apos)] != other)
	|| !is_self_atari(apos, other))
      ADD_CANDIDATE_MOVE(apos, 0, moves, scores, num_moves);

    if (edge_closing_backfill(str, apos, &xpos))
      ADD_CANDIDATE_MOVE(xpos, 10, moves, scores, num_moves);

    /* Look for edge blocking moves. */
    edge_block(str, apos, moves, scores, &num_moves);
  }

  /* Pick up some edge moves. */
  propose_edge_moves(str, libs, liberties, moves, scores, &num_moves, other);
  order_moves(str, num_moves, moves, scores, other, read_function_name);

  /* Try the moves collected so far. */
  for (k = 0; k < num_moves; k++) {
    int new_komaster;
    int new_kom_pos;
    int ko_move;

    if (stackp >= branch_depth && k > 0)
      break;
    xpos = moves[k];
    /* Conditional ko capture is disabled because it seems to expensive. */
    if (komaster_trymove(xpos, other, "attack4-A", str,
			 komaster, kom_pos, &new_komaster, &new_kom_pos,
			 &ko_move, 0 && stackp <= ko_depth && savecode == 0)) {
      if (!ko_move) {
	dcode = do_find_defense(str, NULL, new_komaster, new_kom_pos);
	if (dcode != WIN && do_attack(str, NULL, new_komaster, new_kom_pos)) {
	  if (dcode == 0) {
	    popgo();
	    SGFTRACE(xpos, WIN, "attack effective");
	    READ_RETURN(read_result, move, xpos, WIN);
	  }
	  UPDATE_SAVED_KO_RESULT(savecode, savemove, dcode, xpos);
	}
      }
      else {
	if (do_find_defense(str, NULL, new_komaster, new_kom_pos) != WIN
	    && do_attack(str, NULL, new_komaster, new_kom_pos) != 0) {
	  savemove = xpos;
	  savecode = KO_B;
	}
      }
      popgo();
    }
  }

  if (savecode != 0) {
    SGFTRACE(savemove, savecode, "saved move");
    *move = savemove;
    return savecode;
  }

  SGFTRACE(0, 0, NULL);
  return 0;
}


/* If (str) points to a string with 2 or 3 liberties,
 * find_cap2(str, alib, blib, &i, &j, komaster)
 * looks for a configuration of the following type:
 *
 *  X.
 *  .*
 *
 * where X is an element of the string in question. It tries the
 * move at * and returns true this move captures the string, leaving
 * (i, j) pointing to *. 
 */

static int
find_cap2(int str, int alib, int blib, int *move, int komaster, int kom_pos)
{
  int ai, aj;
  int bi, bj;

  /* Check if the two liberties are located like the figure above. */
  if (alib != SW(blib)
      && alib != NW(blib)
      && alib != NE(blib)
      && alib != SE(blib))
    return 0;

  ai = I(alib);
  aj = J(alib);
  bi = I(blib);
  bj = J(blib);
  /* Which of the two corner points should we use? One of them is 
   * always occupied by the string at (str), the other one is either
   * free or occupied by something else.
   */
  if (BOARD(bi, aj) == EMPTY)
    *move = POS(bi, aj);
  else if (BOARD(ai, bj) == EMPTY)
    *move = POS(ai, bj);
  else
    return 0;
  
  /* Ok, we found the spot. Now see if the move works. */
  RTRACE("trying to capture %1m with capping move at %1m\n", str, *move);
  if (trymove(*move, OTHER_COLOR(board[str]), "find_cap2", str,
	      komaster, kom_pos)) {
    int dcode = do_find_defense(str, NULL, komaster, kom_pos);
    popgo();
    switch (dcode) {
    case 0:
      RTRACE("cap2 succeeded!\n");
      return WIN;
      break;
    case WIN:
      RTRACE("cap2 failed!\n");
      return 0;
      break;
    case KO_B:
      RTRACE("cap2 succeeded with ko return code KO_B\n");
      return KO_B;
      break;
    case KO_A:
      RTRACE("cap2 succeeded with ko return code KO_A\n");
      return KO_A;
      break;
    }
  }

  return 0;
}    


/* If (str) points to a string with 3 liberties, find_cap3(str, &move)
 * looks for a configuration of the following type:
 *
 *  XXa
 *  cb*
 *
 * where X are elements of the string in question and a, b and c are
 * its liberties. It tries the move at * and returns true this move
 * captures the string, leaving (*move) pointing to *.
 */

static int
find_cap3(int str, int *move, int komaster, int kom_pos)
{
  int alib, blib;
  int libs[3];
  int xpos = 0;
  int k;
  int savemove = 0;
  int savecode = 0;
  int acode;

  if (findlib(str, 3, libs) != 3)
    return 0;

  for (k = 0; k < 3; k++) {
    /* k and k+1 mod 3 will be (0,1), (1,2) and (2,0); These are the 
     * three combinations of indices that we have to send to find_cap2.
     */
    alib = libs[k];
    blib = libs[(k+1)%3];

    acode = find_cap2(str, alib, blib, &xpos, komaster, kom_pos);
    if (acode == WIN) {
      *move = xpos;
      return WIN;
    }
    UPDATE_SAVED_KO_RESULT_UNREVERSED(savecode, savemove, acode, xpos);
  }

  if (savecode != 0)
    *move = savemove;

  return savecode;
}


/* In a situation like this:
 *       
 * -----        the code that
 * cO.OX        follows can find
 * XXOOX        the attacking move
 * XO.OX        at c.
 * XOOOX
 * XXXXX
 *
 * The name of the function corresponds to special_rescue2, which is
 * fairly similar to this situation.
 */

static int
special_attack2(int str, int libs[2], int *move, int komaster, int kom_pos)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int newlibs[3];
  int xpos;
  int savemove = 0;
  int savecode = 0;
  int k;

  for (k = 0; k < 2; k++) {
    if (is_suicide(libs[k], other) 
	&& (approxlib(libs[k], color, 3, newlibs) == 2)) {
      if (newlibs[0] != libs[1-k])
	xpos = newlibs[0];
      else
	xpos = newlibs[1];

      if (!is_self_atari(xpos, other)
	  && trymove(xpos, other, "special_attack2", str, komaster, kom_pos)) {
	int dcode = do_find_defense(str, NULL, komaster, kom_pos);
	if (dcode != WIN && do_attack(str, NULL, komaster, kom_pos)) {
	  if (dcode == 0) {
	    popgo();
	    *move = xpos;
	    return WIN;
	  }
	  UPDATE_SAVED_KO_RESULT(savecode, savemove, dcode, xpos);
	}
	popgo();
      }
    }
  }

  if (savecode != 0)
    *move = savemove;

  return savecode;
}


/* In situations like these:
 *
 * ..XXX..   ...XX
 * .XX.XX.   .cO.X
 * XXOOOXX   ....X
 * XO.O.OX   XOOXX
 * XO.c.OX   XXXX.
 * -------
 *
 * the code that follows can find the attacking move at c.
 */

static int
special_attack3(int str, int libs[2], int *move, int komaster, int kom_pos)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int acode;
  int dcode;
  int savemove = 0;
  int savecode = 0;
  int newlibs[2];
  int xpos;
  int ypos;
  int apos;
  int bpos;
  int k;

  gg_assert(countlib(str) == 2);

  for (k = 0; k < 2; k++) {
    apos = libs[k];
    bpos = libs[1-k];
    
    if (apos == SOUTH(bpos) || apos == NORTH(bpos)) {
      if (board[WEST(apos)] == EMPTY)
	xpos = WEST(apos);
      else if (board[EAST(apos)] == EMPTY)
	xpos = EAST(apos);
      else
	continue;
    }
    else if (apos == WEST(bpos) || apos == EAST(bpos)) {
      if (board[SOUTH(apos)] == EMPTY)
	xpos = SOUTH(apos);
      else if (board[NORTH(apos)] == EMPTY)
	xpos = NORTH(apos);
      else
	continue;
    }
    else
      return 0; /* Incorrect configuration, give up. */

    if (is_self_atari(xpos, other)
	|| !trymove(xpos, other, "special_attack3-A", str, komaster, kom_pos))
      continue;
    
    if (countlib(xpos) == 2) {
      findlib(xpos, 2, newlibs);
      if (newlibs[0] == apos)
	ypos = newlibs[1];
      else
	ypos = newlibs[0];

      if (!is_self_atari(ypos, color)
	  && trymove(ypos, color, "special_attack3-B", str,
		     komaster, kom_pos)) {
	acode = do_attack(str, NULL, komaster, kom_pos);
	if (acode == 0) {
	  popgo();
	  popgo();
	  continue;
	}
	UPDATE_SAVED_KO_RESULT_UNREVERSED(savecode, savemove, acode, xpos);
	popgo();
      }
    }
    
    dcode = do_find_defense(str, NULL, komaster, kom_pos);
    if (dcode != WIN && do_attack(str, NULL, komaster, kom_pos)) {
      if (dcode == 0) {
	popgo();
	*move = xpos;
	return WIN;
      }
      UPDATE_SAVED_KO_RESULT(savecode, savemove, dcode, xpos);
    }
    popgo();
  }

  if (savecode != 0)
    *move = savemove;
  
  return savecode;
}


/* In situations like these:
 *
 * ...O.O...   ...O.O...
 * XXXXOOXXX   XXXXOOXXX
 * XOOOXXO*.   Xsssbbcd.
 * .X.O.....   .X.sa.e..
 * ---------   ---------
 *
 * the code that follows can find the attacking move at *.
 */

static int
special_attack4(int str, int libs[2], int *move, int komaster, int kom_pos)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int dcode;
  int savemove = 0;
  int savecode = 0;
  int adj, adjs[MAXCHAIN];
  int adj2, adjs2[MAXCHAIN];
  int libs2[2];
  int apos;
  int bpos = 0;
  int cpos;
  int dpos;
  int epos;
  int dlibs;
  int elibs;
  int k, s, t;

  gg_assert(countlib(str) == 2);

  /* To avoid making this too general, we require that both
   * liberties are self ataris for X.
   */
  if (!is_self_atari(libs[0], other) 
      || !is_self_atari(libs[1], other))
    return 0;

  /* Pick up chain links with 2 liberties. */
  adj = chainlinks2(str, adjs, 2);
  
  for (k = 0; k < 2; k++) {
    apos = libs[k];

    /* Check that (apos) also is a liberty of one of the two liberty
     * chain links.
     */
    for (s = 0; s < adj; s++)
      if (liberty_of_string(apos, adjs[s])) {
	bpos = adjs[s];
	break;
      }

    /* Nothing found. */
    if (s == adj)
      continue;

    /* Now require that (bpos) has a chain link, different from (str),
     * also with two liberties.
     */
    adj2 = chainlinks2(bpos, adjs2, 2);

    for (s = 0; s < adj2; s++) {
      cpos = adjs2[s];
      if (same_string(cpos, str))
	continue;
      
      /* Pick up the liberties of (cpos). */
      findlib(cpos, 2, libs2);

      /* Try playing at a liberty. Before doing this, verify that
       * (cpos) cannot get more than two liberties by answering on the
       * other liberty and that we are not putting ourselves in atari.
       * We also shouldn't allow ourselves to get fewer liberties than
       * the defender.
       */
      for (t = 0; t < 2; t++) {
	dpos = libs2[t];
	epos = libs2[1-t];

	if (is_self_atari(dpos, other))
	  continue;

	elibs = approxlib(epos, color, 4, NULL);
	if (elibs > 3)
	  continue;

	dlibs = approxlib(dpos, other, 3, NULL);
	if (elibs > dlibs)
	  continue;

	if (trymove(dpos, other, "special_attack4", str, komaster, kom_pos)) {
	  dcode = do_find_defense(str, NULL, komaster, kom_pos);

	  if (dcode != WIN && do_attack(str, NULL, komaster, kom_pos)) {
	    if (dcode == 0) {
	      popgo();
	      *move = dpos;
	      return WIN;
	    }
	    UPDATE_SAVED_KO_RESULT(savecode, savemove, dcode, dpos);
	  }
	  popgo();
	}
      }
    }
  }

  if (savecode != 0)
    *move = savemove;

  return savecode;
}


/* 
 * If (str) points to a string, draw_back(str, &move, komaster)
 * looks for a move in the following configuration which attacks
 * the string:
 *
 *      X*            X=attacker, O=defender
 *      O.
 *
 * In the initial implementation we consider cases 
 * where X has exactly 2 liberties. 
 *
 */

static int
draw_back(int str, int *move, int komaster, int kom_pos)
{
  int r, k;
  int adj, adjs[MAXCHAIN];
  int libs[2];
  int savemove = 0;
  int savecode = 0;

  adj = chainlinks2(str, adjs, 2);
  for (r = 0; r < adj; r++) {
    findlib(adjs[r], 2, libs);
    for (k = 0; k < 2; k++) {
      if (!liberty_of_string(libs[k], str)
	     && ((ON_BOARD1(SOUTH(libs[k]))
		     && liberty_of_string(SOUTH(libs[k]), str))
	      || (ON_BOARD1(WEST(libs[k]))
	      	     && liberty_of_string(WEST(libs[k]), str))
	      || (ON_BOARD1(NORTH(libs[k]))
	             && liberty_of_string(NORTH(libs[k]), str))
	      || (ON_BOARD1(EAST(libs[k]))
	             && liberty_of_string(EAST(libs[k]), str)))) {
	if (trymove(libs[k], OTHER_COLOR(board[str]), "draw_back", str,
		    komaster, kom_pos)) {
	  int dcode = do_find_defense(str, NULL, komaster, kom_pos);
	  if (dcode != WIN && do_attack(str, NULL, komaster, kom_pos)) {
	    if (dcode == 0) {
	      popgo();
	      *move = libs[k];
	      return WIN;
	    }
	    UPDATE_SAVED_KO_RESULT(savecode, savemove, dcode, libs[k]);
	  }
	  popgo();
	}
      }
    }
  }

  if (savecode != 0)
    *move = savemove;

  return savecode;
}

/* In the following position the reading is much simplifed if we start
 * with the edge closing backfilling move at *.
 *
 * |OO...
 * |.OOO.
 * |.X.O.
 * |XXXO.
 * |.X.*.
 * +-----
 *
 * This function identifies the situation
 *
 * ?XOb
 * Xatc
 * ----
 *
 * where a is a liberty of the attacked string, t is the proposed move,
 * and b and c do not contain more O stones than X stones.
 */

static int
edge_closing_backfill(int str, int apos, int *move)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int k;
  int bpos;
  int cpos;
  int number_x, number_o;

  for (k = 0; k < 4; k++) {
    int up = delta[k];
    int right = delta[(k+1)%4];
    if (ON_BOARD(apos - up))
      continue;
    if (board[apos + up] != color)
      return 0;
    if (board[apos + right] == EMPTY
	&& (!ON_BOARD(apos - right) 
	    || board[apos - right] == color))
      ; /* Everything ok so far. */
    else if (board[apos - right] == EMPTY
	     && (!ON_BOARD(apos + right) 
		 || board[apos + right] == color)) {
      /* Negate right direction. */
      right = -right;
    }
    else
      return 0;
    
    if (board[apos + up + right] != other)
      return 0;

    bpos = apos + up + 2 * right;
    if (!ON_BOARD(bpos))
      return 0;

    cpos = apos + 2 * right;

    number_x = 0;
    number_o = 0;
    if (board[bpos] == color)
      number_x++;
    else if (board[bpos] == other)
      number_o++;

    if (board[cpos] == color)
      number_x++;
    else if (board[cpos] == other)
      number_o++;

    if (number_o > number_x)
      return 0;

    *move = apos + right;
    return WIN;
  }

  return 0;
}


/* The first version of this function seemed to induce too many
 * variations and has therefore been replaced by a much more limited
 * version.
 */
#if 0

/* In positions like
 *
 * OO...
 * XXO*.
 * x.X*.
 * -----
 *
 * where the X stones to the left are being attacked, it is often a
 * good idea to first consider either or both of the moves marked by *
 * in the diagram. Notice that propose_edge_moves() doesn't help with
 * this, since the rightmost X stone is not part of the attacked
 * string, only the corresponding superstring.
 *
 * This function identifies the situation
 *
 * ?XO.?   ?bdf?
 * ?.X.o   haceg
 * -----   -----
 *
 * where a is a liberty of the attacked string, b is a stone of the
 * attacked string, and e and f are the considered moves. Also
 * considered is the situation where the conditions to the right are
 * not correct but c has only two liberties anyway. If safe, the move
 * to make atari on c is proposed.
 *
 * Notice, this code is disabled, as commented above.
 */

static void
edge_block(int str, int apos, int moves[MAX_MOVES], int scores[MAX_MOVES],
	   int *num_moves)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int cpos;
  int dpos;
  int epos;
  int fpos;
  int gpos;
  int hpos;
  int score;
  int k, l;

  /* Search for the right orientation. */
  for (k = 0; k < 4; k++) {
    int up = delta[k];
    if (ON_BOARD(apos - up))
      continue;
    if (board[apos + up] != color || !same_string(apos + up, str))
      return;
    
    for (l = 0; l < 2; l++) {
      int right = delta[(k+1)%4];
      if (l == 1)
	right = -right;

      cpos = apos + right;
      dpos = apos + right + up;

      if (board[cpos] != color || board[dpos] != other)
	continue;

      epos = cpos + right;
      fpos = dpos + right;
      gpos = epos + right;
      hpos = apos - right;
      
      if (!ON_BOARD(epos))
	continue;
      
      if (board[epos] == EMPTY && board[fpos] == EMPTY 
	  && (board[gpos] != color)) {
	/* Everything is set up, suggest moves at e and f. */
	if (!ON_BOARD(hpos) || board[hpos] == color)
	  score = 0;
	else
	  score = -5;
	if (countlib(str) == 2)
	  score -= 10;
	ADD_CANDIDATE_MOVE(epos, score, moves, scores, *num_moves);

	if (countlib(dpos) == 1)
	  score = 25;
	else
	  score = 0;
	if (countlib(str) == 2)
	  score -= 10;
	ADD_CANDIDATE_MOVE(fpos, score, moves, scores, *num_moves);
      }
      else if (countlib(cpos) == 2 && countlib(dpos) > 1) {
	int libs[2];
	int move;
	findlib(cpos, 2, libs);
	if (libs[0] == apos)
	  move = libs[1];
	else
	  move = libs[0];
	if (!is_self_atari(move, other))
	  ADD_CANDIDATE_MOVE(move, 0, moves, scores, *num_moves);
      }
    }
  }
}

#else

/* In positions like
 *
 * OOX..
 * XXO*.
 * x.X..
 * -----
 *
 * where the X stones to the left are being attacked, it is usually
 * important to start by considering the move at *. Thus we propose
 * the move at * with a high initial score.
 *
 * This function identifies the situation
 *
 * XO.?   bdf?
 * .X.o   aceg
 * ----   ----
 *
 * where a is a liberty of the attacked string, b is a stone of the
 * attacked string, and f is the considered moves.
 */

static void
edge_block(int str, int apos, int moves[MAX_MOVES], int scores[MAX_MOVES],
	   int *num_moves)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int k, l;
  int cpos;
  int dpos;
  int epos;
  int fpos;
  int gpos;
  int hpos;

  /* Search for the right orientation. */
  for (k = 0; k < 4; k++) {
    int up = delta[k];
    if (ON_BOARD(apos - up))
      continue;
    if (board[apos + up] != color || !same_string(apos + up, str))
      return;
    
    for (l = 0; l < 2; l++) {
      int right = delta[(k+1)%4];
      if (l == 1)
	right = -right;

      cpos = apos + right;
      dpos = apos + right + up;

      if (board[cpos] != color || board[dpos] != other || countlib(dpos) > 1)
	continue;

      epos = cpos + right;
      fpos = dpos + right;
      gpos = epos + right;
      hpos = apos - right;
      
      if (!ON_BOARD(epos))
	continue;
      
      if (board[epos] == EMPTY && board[fpos] == EMPTY 
	  && (board[gpos] != color))
	ADD_CANDIDATE_MOVE(fpos, 30, moves, scores, *num_moves);
    }
  }
}

#endif

/* ================================================================ */
/*            Defending by attacking surrounding strings            */
/* ================================================================ */

/* Add the chainbreaking moves relative to the string (str) to the
 * (moves[]) array.
 */
static void
break_chain_moves(int str, int moves[MAX_MOVES], int scores[MAX_MOVES],
		  int *num_moves)
{
  int r;
  int xpos;
  int adj, adjs[MAXCHAIN];
  
  /* Find links in atari. */
  adj = chainlinks2(str, adjs, 1);
  
  for (r = 0; r < adj; r++) {
    findlib(adjs[r], 1, &xpos);
    ADD_CANDIDATE_MOVE(xpos, 0, moves, scores, *num_moves);
  }
}


/*
 * Find moves which immediately capture chain links with 2
 * liberties, in the sense that the links cannot escape atari.
 *
 * The used heuristics are slightly sloppy, so useless moves may
 * appear occasionally. This should, however, only lead to slightly
 * worse performance but not to incorrect results.
 */
static void
break_chain2_efficient_moves(int str, int moves[MAX_MOVES],
			     int scores[MAX_MOVES], int *num_moves)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int r;
  int k;
  int adj, adjs[MAXCHAIN];
  int adj2, adjs2[MAXCHAIN];
  int libs[2];
  int ai, aj;
  int bi, bj;
  int ci, cj;
  
  /* Find links with 2 liberties. */
  adj = chainlinks2(str, adjs, 2);
  
  for (r = 0; r < adj; r++) {
    adj2 = chainlinks2(adjs[r], adjs2, 1);
    if (adj2 == 1 && countlib(str) > 2) {
      int apos;
      findlib(adjs2[0], 1, &apos);
      if (!is_self_atari(apos, color))
	ADD_CANDIDATE_MOVE(apos, 0, moves, scores, *num_moves);
      continue;
    }
    
    if (adj2 > 1)
      continue;
    
    findlib(adjs[r], 2, libs);
    for (k = 0; k < 2; k++)
      if (approxlib(libs[k], other, 3, NULL) <= 2
	  && !is_self_atari(libs[1 - k], color))
	ADD_CANDIDATE_MOVE(libs[1 - k], 0, moves, scores, *num_moves);
    
    /* A common special case is this kind of edge position
     * 
     * ..XXX.
     * X.XOO.
     * XOOX*.
     * ......
     * ------
     *
     * where a move at * is most effective for saving the two stones
     * to the left.
     *
     * The code below tries to identify this case. We use the crude
     * heuristic that the two liberties of the X stone we want to
     * capture should be placed diagonally and that one liberty should
     * be on the edge. Then we propose to play the other liberty.
     * Notice that both moves may be proposed when attacking a stone
     * on 2-2.
     *
     * Update: This was too crude. Also require that the X stone is on
     * the second line and that the proposed move is not a self-atari.
     */
    ai = I(libs[0]);
    aj = J(libs[0]);
    bi = I(libs[1]);
    bj = J(libs[1]);
    ci = I(adjs[r]);
    cj = J(adjs[r]);
    if (gg_abs(ai - bi) == 1
	&& gg_abs(aj - bj) == 1
	&& (ci == 1 || ci == board_size - 2
	    || cj == 1 || cj == board_size - 2)) {

      if ((ai == 0 || ai == board_size - 1
	   || aj == 0 || aj == board_size - 1)
	  && !is_self_atari(libs[1], board[str]))
	ADD_CANDIDATE_MOVE(libs[1], 0, moves, scores, *num_moves);

      if ((bi == 0 || bi == board_size - 1
	   || bj == 0 || bj == board_size - 1)
	  && !is_self_atari(libs[0], board[str]))
	ADD_CANDIDATE_MOVE(libs[0], 0, moves, scores, *num_moves);
    }
  }
}

static void
break_chain2_moves(int str, int moves[MAX_MOVES],
		   int scores[MAX_MOVES], int *num_moves, int require_safe)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int r;
  int k;
  int apos;
  int adj;
  int adjs[MAXCHAIN];
  int libs[2];
  int unsafe[2];

  adj = chainlinks2(str, adjs, 2);
  
  for (r = 0; r < adj; r++) {
    apos = adjs[r];

    findlib(apos, 2, libs);
    for (k = 0; k < 2; k++) {
      unsafe[k] = is_self_atari(libs[k], color);
      if (!unsafe[k]
	  || is_ko(libs[k], color, NULL)
	  || (!require_safe
	      && approxlib(libs[k], other, 5, NULL) < 5))
	ADD_CANDIDATE_MOVE(libs[k], 0, moves, scores, *num_moves);
    }

    if (stackp <= backfill2_depth) {
      break_chain_moves(apos, moves, scores, num_moves);
      if (unsafe[0] && unsafe[1]) {
	int libs2[3];
	for (k = 0; k < 2; k++) {
	  if (approxlib(libs[k], other, 3, libs2) == 2) {
	    int s;
	    for (s = 0; s < 2; s++)
	      if (!is_self_atari(libs2[s], color))
		ADD_CANDIDATE_MOVE(libs2[s], 0, moves, scores, *num_moves);
	  }
	}
      }
    }
  }
}

/*
 * (str) points to a group. break_chain2(str, &move)
 * returns WIN if there is a string in the surrounding chain having
 * exactly two liberties whose attack leads to the rescue of
 * (str). Then (*move) points to the location of the attacking move.
 * 
 * Returns KO_A if the saving move depends on ignoring a ko threat;
 * 
 * Returns KO_B if the saving move requires making a ko threat and winning
 * the ko.
 */

static int 
break_chain2(int str, int *move, int komaster, int kom_pos)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int v;
  int libs[2];
  int liberties;
  int moves[MAX_MOVES];
  int scores[MAX_MOVES];
  int num_moves = 0;
  int savemove = 0;
  int savecode = 0;

  SETUP_TRACE_INFO("break_chain2", str);
  
  RTRACE("in break_chain2 at %1m\n", str);
  
  break_chain2_moves(str, moves, scores, &num_moves, 0);
  order_moves(str, num_moves, moves, scores, color, read_function_name);

  /* We do not wish to consider the move if it can be 
   * immediately recaptured, unless stackp <= backfill_depth.
   *
   * With the incremental board code it's not much point in using
   * approxlib() as heuristic whether we want to play the move. Better
   * and more accurate to really play the move and then use findlib() to
   * see how many liberties we obtained.
   */

  for (v = 0; v < num_moves; v++) {
    int new_komaster;
    int new_kom_pos;
    int ko_move;

    if (komaster_trymove(moves[v], color, "break_chain2-A", str,
			 komaster, kom_pos, &new_komaster, &new_kom_pos,
			 &ko_move, savecode == 0 && stackp <= ko_depth)) {
      if (ko_move) {
	if (do_attack(str, NULL, new_komaster, new_kom_pos) != WIN) {
	  savecode = KO_B;
	  savemove = moves[v];
	}
	popgo();
	continue;
      }
    }
    else
      continue;

    /* If we reach here, we have made a move, which was not a
     * conditional ko capture.
     */
    liberties = findlib(moves[v], 2, libs);
    if (liberties > 1) {
      int acode = do_attack(str, NULL, new_komaster, new_kom_pos);
      if (acode == 0) {
	*move = moves[v];
	popgo();
	SGFTRACE(moves[v], 1, "attack defended-A");
	return WIN;
      }
      UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, moves[v]);
    }
    else if (stackp <= backfill_depth) {
      int newer_komaster;
      int newer_kom_pos;
      int bpos = libs[0];
      int try_harder = 0;

      ASSERT1(liberties == 1, str);

      if (komaster_trymove(bpos, other, "break_chain2-C", str,
			   new_komaster, new_kom_pos,
			   &newer_komaster, &newer_kom_pos,
			   &ko_move, savecode == 0 && stackp <= ko_depth)) {
	if (!ko_move) {
	  if (countlib(bpos) <= 2)
	    try_harder = 1;
	  if (IS_STONE(board[str])) {
	    int dcode = do_find_defense(str, NULL, newer_komaster,
					newer_kom_pos);
	    if (dcode == WIN && !try_harder) {
	      *move = moves[v];
	      popgo();
	      popgo();
	      SGFTRACE(moves[v], WIN, "attack defended-B");
	      return WIN;
	    }
	    /* FIXME: Possibly the ko result codes are not handled
	     * correctly in the presence of two trymove().
	     */
	    UPDATE_SAVED_KO_RESULT_UNREVERSED(savecode, savemove,
					      dcode, moves[v]);
	  }
	  popgo();
	}
	else {
	  try_harder = 1;
	  ASSERT1(IS_STONE(board[str]), str);
	  if (do_find_defense(str, NULL, newer_komaster, newer_kom_pos) != 0) {
	    savecode = KO_A; /* Not KO_B since we are one move deeper 
			      * than usual. */
	    savemove = moves[v];
	  }
	  popgo();
	}
      }

      if (try_harder) {
	int acode = do_attack(str, NULL, new_komaster, new_kom_pos);
	if (acode == 0) {
	  *move = moves[v];
	  popgo();
	  SGFTRACE(moves[v], WIN, "attack defended-C");
	  return WIN;
	}
	UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, moves[v]);
      }
    }
    popgo(); /* (moves[v]) */
  }

  if (savecode != 0) {
    *move = savemove;
    SGFTRACE(savemove, savecode, "saved move");
    return savecode;
  }

  SGFTRACE(0, 0, NULL);
  return 0;
}


/*
 * (str) points to a group. break_chain3(str, *move)
 * returns 1 if there is a string in the surrounding chain having
 * exactly three liberties whose attack leads to the rescue of
 * (str). Then (*move) points to the location of the attacking move.
 * 
 * Returns KO_A if the saving move depends on ignoring a ko threat;
 * 
 * Returns KO_B if the saving move requires making a ko threat and winning
 * the ko.
 */

static int 
break_chain3(int str, int *move, int komaster, int kom_pos)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int r;
  int k;
  int u = 0, v;
  int apos;
  int adj;
  int adjs[MAXCHAIN];
  int libs[3];
  int moves[MAX_MOVES];
  int mw[BOARDMAX];
  int savemove = 0;
  int savecode = 0;
  int liberties = countlib(str);

  SETUP_TRACE_INFO("break_chain3", str);

  memset(mw, 0, sizeof(mw));
  
  RTRACE("in break_chain3 at %1m\n", str);
  adj = chainlinks2(str, adjs, 3);
  for (r = 0; r < adj; r++) {
    int lib1 = 0, lib2 = 0, lib3 = 0;
    apos = adjs[r];

    /* We make a list in the (adjs) array of the liberties
     * of boundary strings having exactly three liberties. We mark
     * each liberty in the mw array so that we do not list any
     * more than once.
     */
    findlib(apos, 3, libs);

    /* If the 3 liberty chain easily can run away through one of the
     * liberties, we don't play on any of the other liberties.
     */
    lib1 = approxlib(libs[0], other, 4, NULL);
    lib2 = approxlib(libs[1], other, 4, NULL);
    if (lib1 >= 4 && lib2 >= 4)
      continue;
    lib3 = approxlib(libs[2], other, 4, NULL);

    if ((lib1 >= 4 || lib2 >= 4) && lib3 >= 4)
      continue;

    if (lib1 >= 4 && !mw[libs[0]]) {
      mw[libs[0]] = 1;
      moves[u++] = libs[0];
      continue;
    }
    
    if (lib2 >= 4 && !mw[libs[1]]) {
      mw[libs[1]] = 1;
      moves[u++] = libs[1];
      continue;
    }
    
    if (lib3 >= 4 && !mw[libs[2]]) {
      mw[libs[2]] = 1;
      moves[u++] = libs[2];
      continue;
    }

    /* No easy escape, try all liberties. */
    for (k = 0; k < 3; k++) {
      if (!mw[libs[k]]) {
	mw[libs[k]] = 1;
	moves[u++] = libs[k];
      }
    }
  }
  
  /* We do not wish to consider the move if it can be 
   * immediately recaptured, unless stackp <= backfill2_depth.
   */

  for (v = 0; v < u; v++) {
    if (!trymove(moves[v], color, "break_chain3-A", str, komaster, kom_pos))
      continue;

    if (countlib(moves[v]) == 1 && stackp > backfill2_depth) {
      popgo();
      continue;
    }
    
    /* If we just filled our own liberty we back out now */
    if (countlib(str) >= liberties) {
      int acode = do_attack(str, NULL, komaster, kom_pos);
      if (acode == 0) {
	*move = moves[v];
	popgo();
	SGFTRACE(moves[v], WIN, "attack defended");
	return WIN;
      }
      UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, moves[v]);
    }
    popgo(); /* (moves[v]) */
  }

  if (savecode != 0) {
    *move = savemove;
    SGFTRACE(savemove, savecode, "saved move");
    return savecode;
  }

  SGFTRACE(0, 0, NULL);
  return 0;
}

/* This function looks for moves attacking those components
 * of the surrounding chain of the superstring (see find_superstring
 * for the definition) which have fewer than liberty_cap liberties,
 * and which are not adjacent to the string itself, since those
 * are tested by break_chain. If such a boundary chain can be
 * attacked, and if attacking the boundary results in saving
 * the (str) string, then success is reported.
 */
/* FIXME: Consider ko captures */
static int
superstring_breakchain(int str, int *move, int komaster, int kom_pos,
		       int liberty_cap)
{
  int color = board[str];
  int adj;
  int adjs[MAXCHAIN];
  int k;
  int apos;
  int savemove = 0;
  int savecode = 0;

  SETUP_TRACE_INFO("superstring_breakchain", str);

  proper_superstring_chainlinks(str, &adj, adjs, liberty_cap);
  for (k = 0; k < adj; k++) {
    int new_komaster, new_kom_pos;
    int ko_move;

    if (countlib(adjs[k]) > 1)
      continue;
    findlib(adjs[k], 1, &apos);

    if (komaster_trymove(apos, color, "superstring_break_chain", str,
			 komaster, kom_pos, &new_komaster, &new_kom_pos,
			 &ko_move, savecode == 0 && stackp <= ko_depth)) {
      if (!ko_move) {
	int acode = do_attack(str, NULL, new_komaster, new_kom_pos);
	if (acode == 0) {
	  popgo();
	  *move = apos;
	  SGFTRACE(apos, WIN, "attack defended");
	  return WIN;
	}
	else if (acode != WIN) {
	  UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, apos);
	}
	popgo();
      }
      else {
	if (do_attack(str, NULL, new_komaster, new_kom_pos) != WIN) {
	  savemove = apos;
	  savecode = KO_B;
	}
	popgo();
      }
    }
  }
  
  if (savecode != 0) {
    *move = savemove;
    SGFTRACE(savemove, savecode, "saved move");
    return savecode;
  }

  SGFTRACE(0, 0, NULL);
  return 0;
}

/*
 * If str points to a group, double_atari_chain2() adds all moves
 * which make a double atari on some strings in the surrounding chain
 * to the (movei[], movej[]) arrays.
 */

static void
double_atari_chain2(int str, int moves[MAX_MOVES], int scores[MAX_MOVES],
		    int *num_moves)
{
  int r, k;
  int apos;
  int adj;
  int adjs[MAXCHAIN];
  int libs[2];
  int mw[BOARDMAX];

  memset(mw, 0, sizeof(mw));

  adj = chainlinks2(str, adjs, 2);
  for (r = 0; r < adj; r++) {
    apos = adjs[r];
    findlib(apos, 2, libs);
    for (k = 0; k < 2; k++) {
      mw[libs[k]]++;
      if (mw[libs[k]] == 2) {
	/* Found a double atari, but don't play there unless the move
         * is safe for the defender.
	 */
	if (!is_self_atari(libs[k], board[str]))
	  ADD_CANDIDATE_MOVE(libs[k], 0, moves, scores, *num_moves);
      }
    }
  }
}


/* ================================================================ */
/*                Restricted Attack and Defense                     */
/* ================================================================ */


/* These functions try to attack and defend a string, avoiding moves
 * from a certain set. It is assumed that as soon as the string gets
 * three liberties, it is alive.
 * 
 * These functions can be used to generate backfilling moves as
 * follows: Suppose that we would like to make atari on a
 * string, but the atari is not safe until we make a backfilling
 * move. To find the backfilling move, we make a list of the
 * liberties of the string under attack, declaring these moves
 * forbidden. Neither player will play them while the restricted
 * functions are in effect. We fill the liberty, creating a
 * string which is under attack, and look for a defensive move
 * which avoids the forbidden moves. This is the backfilling
 * move.
 *
 * These are minimalist functions capable of reading a ladder
 * and not much more.
 */

/* Given a list of moves, restricted_defend1 tries to find a 
 * move that defends the string (str) with one liberty,
 * not considering moves from the list.
 */
int
restricted_defend1(int str, int *move, int komaster, int kom_pos,
		   int num_forbidden_moves, int *forbidden_moves)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int xpos;
  int lib;
  int moves[MAX_MOVES];
  int scores[MAX_MOVES];
  int num_moves = 0;
  int savemove = 0;
  int savecode = 0;
  int liberties;
  int k;

  SETUP_TRACE_INFO("restricted_defend1", str);
  reading_node_counter++;
  
  ASSERT1(IS_STONE(board[str]), str);
  ASSERT1(countlib(str) == 1, str);

  RTRACE("try to escape atari on %1m.\n", str);

  /* (lib) will be the liberty of the string. */
  liberties = findlib(str, 1, &lib);
  ASSERT1(liberties == 1, str);

  /* Collect moves to try in the first batch.
   * 1. First order liberty.
   * 2. Chain breaking moves.
   */
  moves[0] = lib;
  scores[0] = 0;
  num_moves = 1;
  
  break_chain_moves(str, moves, scores, &num_moves);
  order_moves(str, num_moves, moves, scores, color, read_function_name);

  for (k = 0; k < num_moves; k++) {
    int ko_capture;

    xpos = moves[k];
    if (in_list(xpos, num_forbidden_moves, forbidden_moves))
      continue;
    /* To avoid loops with double ko, we do not allow any ko captures,
     * even legal ones, if the opponent is komaster.
     */
    if (is_ko(xpos, color, NULL))
      ko_capture = 1;
    else
      ko_capture = 0;

    if ((komaster != other || !ko_capture)
	&& trymove(xpos, color, "restricted_defend1-A", str,
		   komaster, kom_pos)) {
      int libs = countlib(str);
      if (libs > 2) {
	popgo();
	SGFTRACE(xpos, WIN, "defense effective");
	if (move)
	  *move = xpos;
	return WIN;
      }
      if (libs == 2) {
	int acode;

	if (!ko_capture)
	  acode = restricted_attack2(str, NULL, komaster, kom_pos,
				     num_forbidden_moves, forbidden_moves);
	else
	  acode = restricted_attack2(str, NULL, color, xpos,
				     num_forbidden_moves, forbidden_moves);
	popgo();
	if (acode == 0) {
	  SGFTRACE(xpos, WIN, "defense effective");
	  if (move)
	    *move = xpos;
	  return WIN;
	}
	/* if the move works with ko we save it, then look for something
	 * better.
	 */
	UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, xpos);
      }
      else
	popgo();
    }
    else {
      int ko_pos;
      if (stackp <= ko_depth
	  && savecode == 0 
	  && (komaster == EMPTY
	      || (komaster == color
		  && kom_pos == xpos))
	  && is_ko(xpos, color, &ko_pos)
	  && tryko(xpos, color, "restricted_defend1-B", color, ko_pos)) {
	int libs = countlib(str);
	if (libs > 2) {
	  popgo();
	  UPDATE_SAVED_KO_RESULT(savecode, savemove, 2, xpos);
	}
	else if (libs == 2) {
	  int acode;
	  acode = restricted_attack2(str, NULL, color, xpos,
				     num_forbidden_moves, forbidden_moves);
	  popgo();
	  UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, xpos);
	}
	else
	  popgo();
      }
    }
  }

  if (savecode != 0) {
    if (move)
      *move = savemove;
    SGFTRACE(savemove, savecode, "saved move");
    return savecode;
  }

  SGFTRACE(0, 0, NULL);
  return 0;
}


/* Given a list of moves, restricted_attack2 tries to find a 
 * move that attacks the string (str) with two liberties,
 * not considering moves from the list.
 */
int
restricted_attack2(int str, int *move, int komaster, int kom_pos,
		   int num_forbidden_moves, int *forbidden_moves)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int apos;
  int liberties;
  int libs[2];
  int savemove = 0;
  int savecode = 0;
  int k;

  SETUP_TRACE_INFO("restricted_attack2", str);
  reading_node_counter++;

  str = find_origin(str);
  ASSERT1(IS_STONE(board[str]), str);
  ASSERT1(countlib(str) == 2, str);

  RTRACE("restricted attack on %1m with 2 liberties\n", str);

  /* The attack may fail if a boundary string is in atari and cannot 
   * be defended.  First we must try defending such a string. 
   */
  /* Get the two liberties of (str). */
  liberties = findlib(str, 2, libs);
  ASSERT1(liberties == 2, str);

  for (k = 0; k < 2; k++) {
    int ko_pos;
    int ko_capture;

    apos = libs[k];
    if (in_list(apos, num_forbidden_moves, forbidden_moves))
      continue;
    /* To avoid loops with double ko, we do not allow any ko captures,
     * even legal ones, if the opponent is komaster. 
     */
    if (is_ko(apos, other, &ko_pos))
      ko_capture = 1;
    else
      ko_capture = 0;

    if ((komaster != color || !ko_capture)
	&& trymove(apos, other, "restricted_attack2", str,
		   komaster, kom_pos)) {
      if ((!ko_capture 
	   && !restricted_defend1(str, NULL, komaster, kom_pos,
				  num_forbidden_moves, forbidden_moves))
	  || (ko_capture
	      && !restricted_defend1(str, NULL, other, ko_pos,
				     num_forbidden_moves, forbidden_moves))) {
	popgo();
	SGFTRACE(apos, WIN, "attack effective");
	if (move)
	  *move = apos;
	return WIN;
      }
      popgo();
    }
    else if (savecode == 0
	     && (komaster == EMPTY
		 || (komaster == other
		     && kom_pos == apos))
	     && tryko(apos, other, "restricted_attack2", komaster, kom_pos)) {
      if (!restricted_defend1(str, NULL, other, ko_pos,
			      num_forbidden_moves, forbidden_moves)) {
	popgo();
	savecode = KO_B;
	savemove = apos;
      }
      else
	popgo();
    }
  }

  if (savecode != 0) {
    if (move)
      *move = savemove;
    SGFTRACE(savemove, savecode, "saved move");
    return savecode;
  }

  SGFTRACE(0, 0, NULL);
  return 0;
}


/*
 * Returns true if the move is in a given list of moves.
 */

static int
in_list(int move, int num_moves, int *moves)
{
  int k;

  for (k = 0; k < num_moves; k++)
    if (moves[k] == move)
      return 1;
  return 0;
}


/* ================================================================ */
/*                          Move ordering                           */
/* ================================================================ */

/* Parameters used in the ordering of moves to try in the tactical
 * reading.
 */

/*                                              0   1   2   3   4  >4  */
static int defend_lib_score[6]              = {-5, -4,  0,  2,  5, 20};
static int defend_not_adjacent_lib_score[5] = { 0,  0,  2,  4,  6};
static int defend_capture_score[6]          = { 0,  6,  9, 13, 18, 24};
static int defend_atari_score[6]            = { 0,  2,  4,  6,  8, 10};
static int defend_save_score[6]             = { 0,  3,  6,  8, 10, 12};
static int defend_open_score[5]             = { 0,  1,  2,  3,  4};
static int attack_own_lib_score[5]          = {10, -4,  2,  3,  4};
static int attack_string_lib_score[6]       = {-5,  1,  3,  7, 12, 20};
static int attack_capture_score[6]          = {-4,  4, 10, 15, 20, 25};
static int attack_save_score[6]             = { 0, 11, 15, 18, 21, 24};
static int attack_open_score[5]             = { 0,  1,  2,  3,  4};
static int defend_not_edge_score            = 5;
static int attack_not_edge_score            = 1;
static int attack_ko_score                  = -15;
static int cannot_defend_penalty            = -20;
static int safe_atari_score                 = 5;


/* The string at (str) is under attack. The num_moves moves in
 * (moves[]) for color have been deemed interesting in
 * the attack or defense of the group. Most of these moves will be
 * immediate liberties of the group.
 *
 * This function orders the moves in the order where the move most
 * likely to succeed to attack or defend the string will be first and
 * so on.
 *
 * Currently, this is defined as:
 * 1) Moves which let the defending string get more liberties are more
 *    interesting.
 * 2) Moves adjacent to the most open liberties are more 
 *    interesting than those with fewer open liberties.
 * 3) Moves on the edge are less interesting.
 */

static void
order_moves(int str, int num_moves, int *moves, int *scores, int color,
	    const char *funcname)
{
  int string_color = board[str];
  int string_libs = countlib(str);
  int r;
  int i, j;
  int maxscore;
  int max_at;

  /* don't bother sorting if only one move, or none at all */
  if (num_moves < 2)
    return;

  /* Assign a score to each move. */
  for (r = 0; r < num_moves; r++) {
    int move = moves[r];

    /* Look at the neighbors of this move and count the things we
     * find. Friendly and opponent stones are related to color, i.e.
     * the player to move, not to the color of the string.
     */
    int number_edges       = 0; /* outside board */
    int number_same_string = 0; /* the string being attacked */
    int number_own         = 0; /* friendly stone */
    int number_opponent    = 0; /* opponent stone */
    int captured_stones    = 0; /* number of stones captured by this move */
    int threatened_stones  = 0; /* number of stones threatened by this move */
    int saved_stones       = 0; /* number of stones in atari saved */
    int number_open        = 0; /* empty intersection */

    /* We let the incremental_board code do the heavy work. */
    incremental_order_moves(move, color, str, &number_edges,
			    &number_same_string, &number_own,
			    &number_opponent, &captured_stones,
			    &threatened_stones, &saved_stones, &number_open);

    if (0)
      gprintf("%o %1m values: %d %d %d %d %d %d %d %d\n", move, number_edges,
	      number_same_string, number_own, number_opponent, captured_stones,
	      threatened_stones, saved_stones, number_open);
    
    /* Different score strategies depending on whether the move is
     * attacking or defending the string.
     */
    if (color == string_color) {
      /* Defense move.
       *
       * 1) Add twice the number of liberties the group receives by
       *    extending to the intersection of the move, if more than one.
       *    Only applicable if the move is adjacent to the group.
       */
      
      int libs = approxlib(move, color, 10, NULL);
      if (number_same_string > 0) {
	if (libs > 5 || (libs == 4 && stackp > fourlib_depth))
	  scores[r] += defend_lib_score[5] + (libs - 4);
	else
	  scores[r] += defend_lib_score[libs];
      }
      else {
	/* Add points for the number of liberties the played stone
         * obtains when not adjacent to the attacked string.
	 */
	if (libs > 4)
	  scores[r] += defend_not_adjacent_lib_score[4];
	else
	  scores[r] += defend_not_adjacent_lib_score[libs];
      }
      
      /* 2) Add the number of open liberties near the move to its score. */
      gg_assert(number_open <= 4);
      scores[r] += defend_open_score[number_open];
      
      /* 3) Add a bonus if the move is not on the edge. 
       */
      if (number_edges == 0 || captured_stones > 0)
	scores[r] += defend_not_edge_score;
      
      /* 4) Add thrice the number of captured stones. */
      if (captured_stones <= 5)
	scores[r] += defend_capture_score[captured_stones];
      else
	scores[r] += defend_capture_score[5] + captured_stones;

      /* 5) Add points for stones put into atari, unless this is a
       *    self atari.
       */
      if (libs + captured_stones > 1) {
	if (threatened_stones <= 5)
	  scores[r] += defend_atari_score[threatened_stones];
	else
	  scores[r] += defend_atari_score[5] + threatened_stones;
      }

      /* 6) Add a bonus for saved stones. */
      if (saved_stones <= 5)
	scores[r] += defend_save_score[saved_stones];
      else
	scores[r] += defend_save_score[5];
    }
    else {
      /* Attack move.
       *
       * 1) Add the number of liberties the attacker gets when playing
       *    there, but never more than four.
       */
      int libs = approxlib(move, color, 4, NULL);
      if (libs > 4)
	libs = 4;
      scores[r] += attack_own_lib_score[libs];

      if (libs == 0 && captured_stones == 1)
	scores[r] += attack_ko_score;
      
      /* 2) If the move is not a self atari and adjacent to the
       *    string, add the number of liberties the opponent would
       *    gain by playing there. If the string has two liberties,
       *    self-ataris are also ok since they may be snapbacks, but
       *    only if a single stone is sacrificed.
       */
      if ((libs + captured_stones > 1 || (string_libs <= 2 && number_own == 0))
	  && number_same_string > 0) {
	int safe_atari;
	int liberties = approxlib(move, string_color, 5, NULL);
	if (liberties > 5 || (liberties == 4 && stackp > fourlib_depth))
	  liberties = 5;
	scores[r] += attack_string_lib_score[liberties];

	safe_atari = (string_libs <= 2 && libs + captured_stones > 1);
	/* The defender can't play here without getting into atari, so
         * we probably souldn't either.
	 */
	if (liberties == 1 && saved_stones == 0 && !safe_atari)
	  scores[r] += cannot_defend_penalty;

	/* Bonus if we put the attacked string into atari without
         * ourselves getting into atari.
	 */
	if (safe_atari)
	  scores[r] += safe_atari_score;
      }
      
      /* 3) Add the number of open liberties near the move to its score. */
      gg_assert(number_open <= 4);
      scores[r] += attack_open_score[number_open];
      
      /* 4) Add a bonus if the move is not on the edge. */
      if (number_edges == 0)
	scores[r] += attack_not_edge_score;
      
      /* 5) Add twice the number of captured stones. */
      if (captured_stones <= 5)
	scores[r] += attack_capture_score[captured_stones];
      else
	scores[r] += attack_capture_score[5];

      /* 6) Add a bonus for saved stones. */
      if (saved_stones <= 5)
	scores[r] += attack_save_score[saved_stones];
      else
	scores[r] += attack_save_score[5];
    }
  }
  
  /* Now sort the moves.  We use selection sort since this array will
   * probably never be more than 10 moves long.  In this case, the
   * overhead imposed by quicksort will probably overshadow the gains
   * given by the O(n*log(n)) behaviour over the O(n^2) behaviour of
   * selection sort.
   */
  for (i = 0; i < num_moves-1; i++) {

    /* Find the move with the biggest score. */
    maxscore = scores[i];
    max_at = i;
    for (j = i+1; j < num_moves; j++) {
      if (scores[j] > maxscore) {
	maxscore = scores[j];
	max_at = j;
      }
    }

    /* Now exchange the move at i with the move at max_at.
     * Don't forget to exchange the scores as well.
     */
    if (max_at != i) {
      int temp = moves[i];
      int tempmax = scores[i];

      moves[i] = moves[max_at];
      scores[i] = scores[max_at];

      moves[max_at] = temp;
      scores[max_at] = tempmax;
    }
  }

  if (0) {
    gprintf("%oVariation %d:\n", count_variations);
    for (i = 0; i < num_moves; i++)
      gprintf("%o  %1M %d\n", moves[i], scores[i]);
  }

  if (sgf_dumptree) {
    char buf[500];
    char *pos;
    int chars;
    sprintf(buf, "Move order for %s: %n", funcname, &chars);
    pos = buf + chars;
    for (i = 0; i < num_moves; i++) {
      sprintf(pos, "%c%d (%d) %n", J(moves[i]) + 'A' + (J(moves[i]) >= 8),
	      board_size - I(moves[i]), scores[i], &chars);
      pos += chars;
    }
    sgftreeAddComment(sgf_dumptree, NULL, buf);
  }
}


/* Set new values for the move ordering parameters. */
void
tune_move_ordering(int params[MOVE_ORDERING_PARAMETERS])
{
  int k;
  for (k = 0; k < 6; k++) {
    defend_lib_score[k]                = params[k];
    if (k < 5)
      defend_not_adjacent_lib_score[k] = params[k + 6];
    defend_capture_score[k]            = params[k + 11];
    defend_atari_score[k]              = params[k + 17];
    defend_save_score[k]               = params[k + 23];
    if (k < 5) {
      defend_open_score[k]             = params[k + 29];
      attack_own_lib_score[k]          = params[k + 34];
    }
    attack_string_lib_score[k]         = params[k + 39];
    attack_capture_score[k]            = params[k + 45];
    attack_save_score[k]               = params[k + 51];
    if (k < 5)
      attack_open_score[k]             = params[k + 57];
  }
  defend_not_edge_score                = params[62];
  attack_not_edge_score                = params[63];
  attack_ko_score                      = params[64];
  cannot_defend_penalty                = params[65];
  safe_atari_score                     = params[66];

  if (verbose) {
    gprintf("static int defend_lib_score[6]              = {%d, %d, %d, %d, %d, %d};\n",
	    defend_lib_score[0], defend_lib_score[1],
	    defend_lib_score[2], defend_lib_score[3],
	    defend_lib_score[4], defend_lib_score[5]);
    gprintf("static int defend_not_adjacent_lib_score[5] = {%d, %d, %d, %d, %d};\n",
	    defend_not_adjacent_lib_score[0], defend_not_adjacent_lib_score[1],
	    defend_not_adjacent_lib_score[2], defend_not_adjacent_lib_score[3],
	    defend_not_adjacent_lib_score[4]);
    gprintf("static int defend_capture_score[6]          = {%d, %d, %d, %d, %d, %d};\n",
	    defend_capture_score[0], defend_capture_score[1],
	    defend_capture_score[2], defend_capture_score[3],
	    defend_capture_score[4], defend_capture_score[5]);
    gprintf("static int defend_atari_score[6]            = {%d, %d, %d, %d, %d, %d};\n",
	    defend_atari_score[0], defend_atari_score[1],
	    defend_atari_score[2], defend_atari_score[3],
	    defend_atari_score[4], defend_atari_score[5]);
    gprintf("static int defend_save_score[6]             = {%d, %d, %d, %d, %d, %d};\n",
	    defend_save_score[0], defend_save_score[1],
	    defend_save_score[2], defend_save_score[3],
	    defend_save_score[4], defend_save_score[5]);
    gprintf("static int defend_open_score[5]             = {%d, %d, %d, %d, %d};\n",
	    defend_open_score[0], defend_open_score[1],
	    defend_open_score[2], defend_open_score[3],
	    defend_open_score[4]);
    gprintf("static int attack_own_lib_score[5]          = {%d, %d, %d, %d, %d};\n",
	    attack_own_lib_score[0], attack_own_lib_score[1],
	    attack_own_lib_score[2], attack_own_lib_score[3],
	    attack_own_lib_score[4]);
    gprintf("static int attack_string_lib_score[6]       = {%d, %d, %d, %d, %d, %d};\n",
	    attack_string_lib_score[0], attack_string_lib_score[1],
	    attack_string_lib_score[2], attack_string_lib_score[3],
	    attack_string_lib_score[4], attack_string_lib_score[5]);
    gprintf("static int attack_capture_score[6]          = {%d, %d, %d, %d, %d, %d};\n",
	    attack_capture_score[0], attack_capture_score[1],
	    attack_capture_score[2], attack_capture_score[3],
	    attack_capture_score[4], attack_capture_score[5]);
    gprintf("static int attack_save_score[6]             = {%d, %d, %d, %d, %d, %d};\n",
	    attack_save_score[0], attack_save_score[1],
	    attack_save_score[2], attack_save_score[3],
	    attack_save_score[4], attack_save_score[5]);
    gprintf("static int attack_open_score[5]             = {%d, %d, %d, %d, %d};\n",
	    attack_open_score[0], attack_open_score[1],
	    attack_open_score[2], attack_open_score[3],
	    attack_open_score[4]);
    gprintf("static int defend_not_edge_score            = %d;\n", defend_not_edge_score);
    gprintf("static int attack_not_edge_score            = %d;\n", attack_not_edge_score);
    gprintf("static int attack_ko_score                  = %d;\n", attack_ko_score);
    gprintf("static int cannot_defend_penalty            = %d;\n", cannot_defend_penalty);
    gprintf("static int safe_atari_score                 = %d;\n", safe_atari_score);
  }
}



/* ================================================================ */
/*                         Reading utilities                        */
/* ================================================================ */


static int safe_move_cache[BOARDMAX][2];
static int safe_move_cache_when[BOARDMAX][2];
static void clear_safe_move_cache(void);

static void
clear_safe_move_cache(void)
{
  int k;

  for (k = BOARDMIN; k < BOARDMAX; k++) {
    safe_move_cache_when[k][0] = -1;
    safe_move_cache_when[k][1] = -1;
  }
}

/* safe_move(move, color) checks whether a move at (move) is illegal
 * or can immediately be captured. If stackp==0 the result is cached.
 * If the move only can be captured by a ko, it's considered safe.
 * This may or may not be a good convention.
 *
 * For performance reasons, the result of this function is cached.
 */

int
safe_move(int move, int color)
{
  int safe = 0;
  static int initialized = 0;
  
  if (!initialized) {
    clear_safe_move_cache();
    initialized = 1;
  }

  /* If we have this position cached, use the previous value. */
  if (stackp == 0
      && safe_move_cache_when[move][color==BLACK] == position_number)
    return safe_move_cache[move][color==BLACK];

  /* Otherwise calculate the value... */
  if (trymove(move, color, "safe_move-A", 0, EMPTY, 0)) {
    int acode = attack(move, NULL);
    if (acode == 0)
      safe = WIN;
    else if (acode == WIN)
      safe = 0;
    else if (acode == KO_A)
      safe = KO_B;
    else if (acode == KO_B)
      safe = KO_A;
    popgo();
  }
  else if (is_ko(move, color, NULL)
	   && tryko(move, color, "safe_move-B", EMPTY, 0)) {
    if (do_attack(move, NULL, color, move) != WIN)
      safe = KO_B;
    else
      safe = 0;
    popgo();
  }

  /* ...and store it in the cache.
   * FIXME: Only store result in cache when we're working at
   * full depth.
   *
   * Comment: This is currently not a problem since no reduced depth
   * reading is performed.
   */
  if (stackp == 0) {
    if (0)
      gprintf("Safe move at %1m for %s cached when depth=%d, position number=%d\n",
	      move, color_to_string(color), depth, position_number);
    safe_move_cache_when[move][color==BLACK] = position_number;
    safe_move_cache[move][color==BLACK] = safe;
  }

  return safe;
}


/* ===================== Statistics  ============================= */


/* Clear statistics. */
void
reset_reading_node_counter()
{
  reading_node_counter = 0;
}


/* Retrieve statistics. */
int
get_reading_node_counter()
{
  return reading_node_counter;
}

/* ============ Reading shadow and persistent cache =============== */

/* Draw the reading shadow, for debugging purposes */

void
draw_reading_shadow()
{
  int i, j, ii;
  int c = ' ';

  start_draw_board();
  
  for (i = 0; i < board_size; i++) {
    ii = board_size - i;
    fprintf(stderr, "\n%2d", ii);
    
    for (j = 0; j < board_size; j++) {
      if (!shadow[POS(i, j)] && BOARD(i, j) == EMPTY)
	c = '.';
      else if (!shadow[POS(i, j)] && BOARD(i, j) == WHITE)
	c = 'O';
      else if (!shadow[POS(i, j)] && BOARD(i, j) == BLACK)
	c = 'X';
      if (shadow[POS(i, j)] && BOARD(i, j) == EMPTY)
	c = ',';
      else if (shadow[POS(i, j)] && BOARD(i, j) == WHITE)
	c = 'o';
      else if (shadow[POS(i, j)] && BOARD(i, j) == BLACK)
	c = 'x';
      
      fprintf(stderr, " %c", c);
    }
    
    fprintf(stderr, " %d", ii);
  }

  end_draw_board();
}

/* Draw the active area, for debugging purposes */

static void
mgena_draw_active_area(char p[BOARDMAX])
{
  int i, j, ii;
  int c = ' ';

  start_draw_board();
  
  for (i = 0; i < board_size; i++) {
    ii = board_size - i;
    fprintf(stderr, "\n%2d", ii);
    
    for (j = 0; j < board_size; j++) {
      if (p[POS(i, j)] == EMPTY)
	c = '.';
      else if (p[POS(i, j)] == WHITE)
	c = 'O';
      else if (p[POS(i, j)] == BLACK)
	c = 'X';
      if (p[POS(i, j)] == GRAY)
	c = '?';
      
      fprintf(stderr, " %c", c);
    }
    
    fprintf(stderr, " %d", ii);
  }

  end_draw_board();
}


/* Returns 1 if the stored board is compatible with the current board,
 * 0 otherwise.
 */
static int
mgena_verify_stored_board(char p[BOARDMAX])
{
  int k;
  for (k = BOARDMIN; k < BOARDMAX; k++)
    if (ON_BOARD(k) && p[k] != GRAY && p[k] != board[k])
      return 0;
  
  return 1;
}


/* Remove persistent cache entries which are no longer current. */
void
purge_persistent_reading_cache()
{
  int k;
  int r;
  static int last_purge_position_number = -1;
  gg_assert(stackp == 0);

  /* Never do this more than once per move. */
  if (last_purge_position_number == position_number)
    return;
  else
    last_purge_position_number = position_number;

  
  
  for (k = 0; k < persistent_reading_cache_size; k++) {
    int played_moves = 0;
    int entry_ok = 1;

    if (persistent_reading_cache[k].boardsize != board_size)
      entry_ok = 0;
    else {
      for (r = 0; r < MAX_CACHE_DEPTH; r++) {
	int apos = persistent_reading_cache[k].stack[r];
	int color = persistent_reading_cache[k].move_color[r];
	if (apos == 0)
	  break;
	if (board[apos] == EMPTY
	    && trymove(apos, color, "purge_persistent_reading_cache", 0,
		       EMPTY, 0))
	  played_moves++;
	else {
	  entry_ok = 0;
	  break;
	}
      }
    }

    if (!entry_ok 
	|| !mgena_verify_stored_board(persistent_reading_cache[k].board)) {
      /* Move the last entry in the cache here and back up the loop
       * counter to redo the test at this position in the cache.
       */
      if (0)
	gprintf("Purging entry %d from cache.\n", k);
      if (k < persistent_reading_cache_size - 1)
	persistent_reading_cache[k] 
	  = persistent_reading_cache[persistent_reading_cache_size - 1];
      k--;
      persistent_reading_cache_size--;
    }

    while (played_moves > 0) {
      popgo();
      played_moves--;
    }
  }
}


/* Look for a valid read result in the persistent cache. */
static int
search_persistent_reading_cache(int routine, int str, int *result, int *move)
{
  int k;
  int r;

  for (k = 0; k < persistent_reading_cache_size; k++) {
    /* Check that everything matches. */
    struct reading_cache *entry = &(persistent_reading_cache[k]);
    int apos = 0;
    if (entry->routine != routine
	|| entry->str != str
	|| entry->remaining_depth < (depth - stackp)
	|| entry->boardsize != board_size)
      continue;
    
    for (r = 0; r < MAX_CACHE_DEPTH; r++) {
      apos = entry->stack[r];
      if (apos == 0
	  || (entry->board[apos] != GRAY
	      && board[apos] != entry->board[apos]))
	break;
    }

    if (r < MAX_CACHE_DEPTH && apos != 0)
      continue;

    if (!mgena_verify_stored_board(entry->board))
      continue;

    /* Matched alright. Increase score, fill in the answer, and return. */
    entry->score += entry->nodes;
    *result = entry->result;
    if (move)
      *move = entry->move;
    ASSERT1(entry->result == 0 || (entry->move == 0) || ON_BOARD(entry->move),
	    entry->move);

    if ((debug & DEBUG_READING_PERFORMANCE)
	&& entry->nodes >= MIN_NODES_TO_REPORT) {
      if (entry->result != 0)
	gprintf("%o%s %1m = %d %1m, cached (%d nodes) ",
		routine == ATTACK ? "attack" : "defend",
		str, entry->result, entry->move, entry->nodes);
      else 
	gprintf("%o%s %1m = %d, cached (%d nodes) ",
		routine == ATTACK ? "attack" : "defend",
		str, entry->result, entry->nodes);
      dump_stack();
    }

    if (0) {
      /* Check that the cached value is correct. */
      int result2;
      int move2;

      if (routine == ATTACK) 
	result2 = do_attack(str, &move2, EMPTY, 0);
      else
	result2 = do_find_defense(str, &move2, EMPTY, 0);
      
      if (result2 != entry->result
	  || (result2 != 0 && (move2 != entry->move))) {
	gprintf("%oIncorrect cached result %d %1m, should be %d %1m\n",
		entry->result, entry->move, result2, move2);
	print_persistent_reading_cache_entry(k);
	dump_stack();
	showboard(0);
      }
    }

    return 1;
  }

  return 0;
}


/* Store a new read result in the persistent cache. */
static void
store_persistent_reading_cache(int routine, int str, int result, int move,
			       int nodes)
{
  char active[BOARDMAX];
  int k;
  int r;
  int score = nodes;
  struct reading_cache *entry;

  ASSERT1(result == 0 || (move == 0) || ON_BOARD(move), move);

  /* Never cache results at too great depth. */
  if (stackp > MAX_CACHE_DEPTH)
    return;

  /* If cache is still full, consider kicking out an old entry. */
  if (persistent_reading_cache_size == MAX_READING_CACHE_SIZE) {
    int worst_entry = -1;
    int worst_score = score;
    
    for (k = 1; k < persistent_reading_cache_size; k++) {
      if (persistent_reading_cache[k].score < worst_score) {
	worst_score = persistent_reading_cache[k].score;
	worst_entry = k;
      }
    }

    if (worst_entry != -1) {
      /* Move the last entry in the cache here to make space.
       */
      if (worst_entry < persistent_reading_cache_size - 1)
	persistent_reading_cache[worst_entry] 
	  = persistent_reading_cache[persistent_reading_cache_size - 1];
      persistent_reading_cache_size--;
    }
    else
      return;
  }

  entry = &(persistent_reading_cache[persistent_reading_cache_size]);
  entry->boardsize       = board_size;
  entry->movenum         = movenum;
  entry->nodes           = nodes;
  entry->score           = score;
  entry->remaining_depth = depth - stackp;
  entry->routine         = routine;
  entry->str	         = str;
  entry->result          = result;
  entry->move	         = move;

  for (r = 0; r < MAX_CACHE_DEPTH; r++) {
    if (r < stackp)
      get_move_from_stack(r, &(entry->stack[r]), &(entry->move_color[r]));
    else {
      entry->stack[r] = 0;
      entry->move_color[r] = EMPTY;
    }
  }
  
  /* Remains to set the board. We let the active area be the contested
   * string and reading shadow + adjacent empty and strings +
   * neighbors of active area so far + one more expansion from empty
   * to empty.
   */
  for (k = BOARDMIN; k < BOARDMAX; k++)
    active[k] = shadow[k];

  mark_string(str, active, 1);

  /* To be safe, also add the successful move. */
  if (result != 0 && move != 0)
    active[move] = 1;

  /* Add adjacent strings and empty. */
  for (k = BOARDMIN; k < BOARDMAX; k++) {
    if (!ON_BOARD(k))
      continue;
    if (active[k] != 0) 
      continue;
    if ((ON_BOARD(SOUTH(k)) && active[SOUTH(k)] == 1)
	|| (ON_BOARD(WEST(k)) && active[WEST(k)] == 1)
	|| (ON_BOARD(NORTH(k)) && active[NORTH(k)] == 1)
	|| (ON_BOARD(EAST(k)) && active[EAST(k)] == 1)) {
      if (IS_STONE(board[k]))
	mark_string(k, active, 2);
      else
	active[k] = 2;
    }
  }

  /* Remove invincible strings. No point adding their liberties and
   * neighbors.
   */
  for (k = BOARDMIN; k < BOARDMAX; k++) {
    if (!ON_BOARD(k))
      continue;
    if (IS_STONE(board[k]) && worm[k].invincible)
      active[k] = 0;
  }
  
  /* Expand empty to empty. */
  for (k = BOARDMIN; k < BOARDMAX; k++) {
    if (IS_STONE(board[k]) || active[k] != 0) 
      continue;
    if ((board[SOUTH(k)] == EMPTY && active[SOUTH(k)] == 2)
	|| (board[WEST(k)] == EMPTY && active[WEST(k)] == 2)
	|| (board[NORTH(k)] == EMPTY && active[NORTH(k)] == 2)
	|| (board[EAST(k)] == EMPTY && active[EAST(k)] == 2))
      active[k] = 3;
  }
  
  /* Add neighbors of active area so far. */
  for (k = BOARDMIN; k < BOARDMAX; k++) {
    if (!ON_BOARD(k))
      continue;
    if (active[k] != 0) 
      continue;
    if ((ON_BOARD(SOUTH(k)) && active[SOUTH(k)] > 0 && active[SOUTH(k)] < 4)
	|| (ON_BOARD(WEST(k)) && active[WEST(k)] > 0 && active[WEST(k)] < 4)
	|| (ON_BOARD(NORTH(k)) && active[NORTH(k)] > 0 && active[NORTH(k)] < 4)
	|| (ON_BOARD(EAST(k)) && active[EAST(k)] > 1 && active[EAST(k)] < 4))
      active[k] = 4;
  }

  /* Also add the previously played stones to the active area. */
  for (r = 0; r < stackp; r++)
    active[entry->stack[r]] = 5;

  for (k = BOARDMIN; k < BOARDMAX; k++) {
    if (!ON_BOARD(k))
      continue;
    entry->board[k] = 
      active[k] != 0 ? board[k] : GRAY;
  }

  if (0) {
    gprintf("%o Stored result in cache (entry %d):\n",
	    persistent_reading_cache_size);
    print_persistent_reading_cache_entry(persistent_reading_cache_size);
    gprintf("%o Reading shadow was:\n");
    draw_reading_shadow();
  }
  
  persistent_reading_cache_size++;
}


/* For debugging purposes. */
static void
print_persistent_reading_cache_entry(int k)
{
  struct reading_cache *entry = &(persistent_reading_cache[k]);
  int r;
  gprintf("%oboardsize       = %d\n",  entry->boardsize);
  gprintf("%omovenum         = %d\n",  entry->movenum);
  gprintf("%onodes           = %d\n",  entry->nodes);
  gprintf("%oscore           = %d\n",  entry->score);
  gprintf("%oremaining_depth = %d\n",  entry->remaining_depth);
  gprintf("%oroutine         = %d\n",  entry->routine);
  gprintf("%ostr             = %1m\n", entry->str);
  gprintf("%oresult          = %d\n",  entry->result);
  gprintf("%omove            = %1m\n", entry->move);
  
  for (r = 0; r < MAX_CACHE_DEPTH; r++) {
    if (entry->stack[r] == 0)
      break;
    gprintf("%ostack[%d]      = %C %1m\n", r, entry->move_color[r],
	    entry->stack[r]);
  }

  mgena_draw_active_area(entry->board);
}


/* Helper for the reading_hotspots() function below. */
static void
mark_string_hotspot_values(float values[BOARDMAX],
			   int m, int n, float contribution)
{
  int i, j, k;
  
  /* If p[m][n] is EMPTY, we just give the contribution to close empty
   * vertices. This is a rough simplification.
   */
  if (BOARD(m, n) == EMPTY) {
    for (i = -1; i <= 1; i++)
      for (j = -1; j <= 1; j++)
	if (BOARD(m+i, n+j) == EMPTY)
	  values[POS(m+i, n+j)] += contribution;
    return;
  }
  
  /* Otherwise we give contribution to liberties and diagonal
   * neighbors of the string at (m, n).
   */
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      if (BOARD(i, j) != EMPTY)
	continue;
      for (k = 0; k < 8; k++) {
	int di = deltai[k];
	int dj = deltaj[k];
	if (IS_STONE(BOARD(i+di, j+dj))
	    && same_string(POS(i+di, j+dj), POS(m, n))) {
	  if (k < 4) {
	    values[POS(i, j)] += contribution;
	    break;
	  }
	  else {
	    if (BOARD(i+di, j) == EMPTY || countlib(POS(i+di, j)) <= 2
		|| BOARD(i, j+dj) == EMPTY || countlib(POS(i, j+dj)) <= 2)
	      values[POS(i, j)] += contribution;
	    break;
	  }
	}
      }
    }
}
  

/* Based on the entries in the reading cache and their nodes field,
 * compute where the relatively most expensive tactical reading is
 * going on.
 */
void
reading_hotspots(float values[BOARDMAX])
{
  int m, n, k;
  int sum_nodes = 0;

  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++)
      values[POS(m, n)] = 0.0;
  
  /* Compute the total number of nodes for the cached entries. */
  for (k = 0; k < persistent_reading_cache_size; k++)
    sum_nodes += persistent_reading_cache[k].nodes;

  if (sum_nodes <= 100)
    return;

  /* Loop over all entries and increase the value of vertices adjacent
   * to dragons involving expensive tactical reading.
   */
  for (k = 0; k < persistent_reading_cache_size; k++) {
    struct reading_cache *entry = &(persistent_reading_cache[k]);
    float contribution = entry->nodes / (float) sum_nodes;
    if (0) {
      gprintf("Reading hotspots: %d %1m %f\n", entry->routine, entry->str,
	      contribution);
    }
    switch (entry->routine) {
    case ATTACK:
    case FIND_DEFENSE:
      mark_string_hotspot_values(values, I(entry->str), J(entry->str),
				 contribution);
      break;
    default:
      gg_assert(0); /* Shouldn't happen. */
      break;
    }
  }
}


/* ================================================================ */
/*              Code for special purposes.                          */
/* ================================================================ */

/* simple_ladder(str, &move) tries to capture a string (str)
 * with exactly two liberties under simplified assumptions, which are
 * adequate in a ladder. The rules are as follows:
 *
 * 1. The attacker is allowed to play at each of the two liberties,
 *    but no other move. If the move was legal, the string now has
 *    exactly one liberty.
 * 2. The defender must move out of atari. This can only be done by
 *    either extending at the liberty or capturing a neighboring
 *    string which was in atari. All such moves may be tested.
 * 3. Depending on the resulting number of liberties of the string
 *    after the defender's move, we value each node as follows:
 *
 *    3 or more liberties:           the attack has failed
 *    2 liberties:                   recurse
 *    1 liberty:                     the attack has succeeded
 *
 *    illegal move for the defender: successful attack
 *    illegal move for the attacker: failed attack
 *
 * Return codes are as usual 0 for failure, WIN for success, KO_A for
 * a ko where the defender must make the first ko threat and KO_B for
 * a ko where the attacked has to make the first threat. If the attack
 * was successful, (*move) contains the attacking move, unless it is a
 * null pointer.
 *
 * The differences compared to the attack2()/defend1() combination for
 * reading ladders is that this one is a strict ladder reader which
 * never allows the defender to have more than one liberty when it's
 * in turn to move. This has a number of consequences.
 *
 * 1. This function will miss tactical captures involving other
 *    techniques than the ladder.
 *
 * 2. This function is faster because it gives up faster when the
 *    ladder doesn't work. In particular it can't branch out in a huge
 *    tree of exotic variations.
 *
 * 3. This function always reads ladders to the very end. There are no
 *    depth limits or other assumptions to stop reading prematurely.
 *
 * 4. If this function returns WIN, it is guaranteed that the defender
 *    has no way whatsoever to escape, all possibilities are tried.
 *    The converse is definitely not true.
 */

int
simple_ladder(int str, int *move)
{
  return simple_ladder_attack(str, move, EMPTY, NO_MOVE);
}

static int
simple_ladder_attack(int str, int *move, int komaster, int kom_pos)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int apos;
  int libs[2];
  int savemove = 0;
  int savecode = 0;
  int dcode;
  int k;
  int moves[MAX_MOVES];
  int scores[MAX_MOVES];
  int num_moves = 0;

  SETUP_TRACE_INFO("simple_ladder_attack", str);
  reading_node_counter++;

  str = find_origin(str);
  ASSERT1(IS_STONE(board[str]), str);
  ASSERT1(countlib(str) == 2, str);

  /* Get the two liberties of (str). */
  findlib(str, 2, libs);

  for (k = 0; k < 2; k++)
    ADD_CANDIDATE_MOVE(libs[k], 0, moves, scores, num_moves);

  order_moves(str, num_moves, moves, scores, other, read_function_name);

  for (k = 0; k < num_moves; k++) {
    int new_komaster;
    int new_kom_pos;
    int ko_move;

    apos = moves[k];
    if (komaster_trymove(apos, other, "simple_ladder_attack", str,
			 komaster, kom_pos, &new_komaster, &new_kom_pos,
			 &ko_move, savecode == 0)) {
      if (!ko_move) {
	dcode = simple_ladder_defend(str, NULL, new_komaster, new_kom_pos);
	if (dcode != WIN) {
	  if (dcode == 0) {
	    popgo();
	    SGFTRACE(apos, WIN, "attack effective");
	    if (move)
	      *move = apos;
	    return WIN;
	  }
	  UPDATE_SAVED_KO_RESULT(savecode, savemove, dcode, apos);
	}
      }
      else {
	if (do_find_defense(str, NULL, new_komaster, new_kom_pos) != WIN) {
	  savemove = apos;
	  savecode = KO_B;
	}
      }
      popgo();
    }
  }
  
  if (savecode == 0) {
    SGFTRACE(0, 0, NULL);
    return 0;
  }

  SGFTRACE(savemove, savecode, "saved move");
  if (move)
    *move = savemove;
  return savecode;
}


static int
simple_ladder_defend(int str, int *move, int komaster, int kom_pos)
{
  int color = board[str];
  int xpos;
  int lib;
  int moves[MAX_MOVES];
  int scores[MAX_MOVES];
  int num_moves = 0;
  int savemove = 0;
  int savecode = 0;
  int k;

  SETUP_TRACE_INFO("simple_ladder_defend", str);
  reading_node_counter++;
  
  gg_assert(IS_STONE(board[str]));
  ASSERT1(countlib(str) == 1, str);

  /* lib will be the liberty of the string. */
  findlib(str, 1, &lib);

  moves[0] = lib;
  scores[0] = 0;
  num_moves = 1;
  
  break_chain_moves(str, moves, scores, &num_moves);
  order_moves(str, num_moves, moves, scores, color, read_function_name);

  for (k = 0; k < num_moves; k++) {
    int new_komaster;
    int new_kom_pos;
    int ko_move;

    xpos = moves[k];
    if (komaster_trymove(xpos, color, "simple_ladder_defend", str,
			 komaster, kom_pos,
			 &new_komaster, &new_kom_pos,
			 &ko_move, savecode == 0)) {
      int acode;
      int new_libs = countlib(str);
      if (new_libs > 2)
	acode = 0;
      else if (new_libs < 2)
	acode = WIN;
      else
	acode = simple_ladder_attack(str, NULL, new_komaster, new_kom_pos);
      popgo();
      
      if (!ko_move) {
	if (acode == 0) {
	  SGFTRACE(xpos, WIN, "defense effective");
	  if (move)
	    *move = xpos;
	  return WIN;
	}
	/* if the move works with ko we save it, then look for something
	 * better.
	 */
	UPDATE_SAVED_KO_RESULT(savecode, savemove, acode, xpos);
      }
      else {
	if (acode != WIN) {
	  savemove = xpos;
	  savecode = KO_B;
	}
      }
    }
  }

  if (savecode != 0) {
    SGFTRACE(savemove, savecode, "saved move");
    if (move)
      *move = savemove;
    return savecode;
  }  
  
  SGFTRACE(0, 0, NULL);
  return 0;
}


/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */


/* score.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* #include <string.h> */

/* #include "gnugo.h" */
/* #include "liberty.h" */
/* #include "gg_utils.h" */


static int dilate_erode(int dilations, int erosions, 
			int gb[BOARDMAX], int color);
static void print_new_moyo(int dilations, int erosions);
static void close_bubbles(int gb[BOARDMAX]);
static int captured_territory(int pos, int color);


#define ARRAYSIZE MAX_BOARD*MAX_BOARD


/* As explained in the Texinfo documentation, this function
 * takes the characteristic function of the live groups,
 * dilates and erodes the required number of times. If
 * erosions = dilations*(dilations-1)+1, an isolated stone
 * does not get any area, suitable for computing territory.
 *
 * If dragons are CRITICAL, these are awarded to the player
 * 'color' for the purpose of determining an upper and lower
 * bound. The function returns 1 if critical dragons are found,
 * otherwise 0.
 */

static int
dilate_erode(int dilations, int erosions, int gb[BOARDMAX], int color)
{
  int i, j;
  int ii;
  int work[BOARDMAX];
  int n;
  int critical_found = 0;
  
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      ii = POS(i, j);

      if (board[ii] && dragon[ii].matcher_status == CRITICAL)
	critical_found = 1;
      if (board[ii] == WHITE && !captured_territory(ii, color))
	gb[ii] = 128;
      else if (board[ii] == BLACK && !captured_territory(ii, color))      
	gb[ii] = -128;
      else
	gb[ii] = 0;
    }
  
  /* dilate */
  memcpy(work, gb, sizeof(work));
  for (n = 0; n < dilations; n++) {
    for (i = 0; i < board_size; i++)
      for (j = 0; j < board_size; j++) {
	ii = POS(i, j);

	if (gb[ii] >= 0
	    && (!ON_BOARD(SOUTH(ii)) || gb[SOUTH(ii)] >= 0)
	    && (!ON_BOARD(WEST(ii))  || gb[WEST(ii)]  >= 0)
	    && (!ON_BOARD(NORTH(ii)) || gb[NORTH(ii)] >= 0)
	    && (!ON_BOARD(EAST(ii))  || gb[EAST(ii)]  >= 0)) {
	  if (ON_BOARD(SOUTH(ii)) && gb[SOUTH(ii)] > 0)
	    work[ii]++;
	  if (ON_BOARD(WEST(ii))  && gb[WEST(ii)]  > 0)
	    work[ii]++;
	  if (ON_BOARD(NORTH(ii)) && gb[NORTH(ii)] > 0)
	    work[ii]++;
	  if (ON_BOARD(EAST(ii))  && gb[EAST(ii)]  > 0)
	    work[ii]++;
	}
	
	if (gb[ii] <= 0
	    && (!ON_BOARD(SOUTH(ii)) || gb[SOUTH(ii)] <= 0)
	    && (!ON_BOARD(WEST(ii))  || gb[WEST(ii)]  <= 0)
	    && (!ON_BOARD(NORTH(ii)) || gb[NORTH(ii)] <= 0)
	    && (!ON_BOARD(EAST(ii))  || gb[EAST(ii)]  <= 0)) {
	  if (ON_BOARD(SOUTH(ii)) && gb[SOUTH(ii)] < 0)
	    work[ii]--;
	  if (ON_BOARD(WEST(ii))  && gb[WEST(ii)]  < 0)
	    work[ii]--;
	  if (ON_BOARD(NORTH(ii)) && gb[NORTH(ii)] < 0)
	    work[ii]--;
	  if (ON_BOARD(EAST(ii))  && gb[EAST(ii)]  < 0)
	    work[ii]--;
	}
      }
    memcpy(gb, work, sizeof(work));
  }

  /* erode */
  for (n = 0; n < erosions; n++) {
    for (i = 0; i < board_size; i++)
      for (j = 0; j < board_size; j++) {
	ii = POS(i, j);

	if (work[ii] > 0) {
	  if (ON_BOARD(SOUTH(ii)) && gb[SOUTH(ii)] <= 0)
	    work[ii]--;
	  if (ON_BOARD(WEST(ii))  && gb[WEST(ii)]  <= 0 && work[ii] > 0)
	    work[ii]--;
	  if (ON_BOARD(NORTH(ii)) && gb[NORTH(ii)] <= 0 && work[ii] > 0)
	    work[ii]--;
	  if (ON_BOARD(EAST(ii))  && gb[EAST(ii)]  <= 0 && work[ii] > 0)
	    work[ii]--;
	}
	  
	if (work[ii] < 0) {
	  if (ON_BOARD(SOUTH(ii)) && gb[SOUTH(ii)] >= 0)
	    work[ii]++;
	  if (ON_BOARD(WEST(ii))  && gb[WEST(ii)]  >= 0 && work[ii] < 0)
	    work[ii]++;
	  if (ON_BOARD(NORTH(ii)) && gb[NORTH(ii)] >= 0 && work[ii] < 0)
	    work[ii]++;
	  if (ON_BOARD(EAST(ii))  && gb[EAST(ii)]  >= 0 && work[ii] < 0)
	    work[ii]++;
	}
      }
    memcpy(gb, work, sizeof(work));
  }
  
  return critical_found;
}


/* For scoring, it is assumed that any region completely
 * surrounded by territory is territory. This assumption
 * is particularly valid at the end of the game when
 * genmove produces a PASS. This function identifies
 * regions completely surrounded by territory and sets
 * them equal to 1 or -1 for WHITE or BLACK.
 * 
 * We define an *bubble* to be a region of the complement
 * of the region marked in gb. The border color of the
 * bubble may be BLACK, WHITE or GRAY depending on whether
 * it is only adjacent to BLACK or WHITE marked regions,
 * or to both.
 */

static void
close_bubbles(int gb[BOARDMAX])
{
  int bubbles[BOARDMAX];
  int i, j;
  int ii;
  int found_one = 1;

  memset(bubbles, 0, sizeof(bubbles));
  while (found_one) {
    found_one = 0;
    for (i = 0; i < board_size; i++)
      for (j = 0; j < board_size; j++) {
	int white_neighbor = 0;
	int black_neighbor = 0;
	int new_color = 0;

	ii = POS(i, j);

	if (gb[ii] || bubbles[ii] == GRAY)
	  continue;
	
	/* If any neighbor is gray, mark the spot gray */
	if ((ON_BOARD(SOUTH(ii)) && bubbles[SOUTH(ii)] == GRAY)
	    || (ON_BOARD(WEST(ii)) && bubbles[WEST(ii)] == GRAY)
	    || (ON_BOARD(NORTH(ii)) && bubbles[NORTH(ii)] == GRAY)
	    || (ON_BOARD(EAST(ii)) && bubbles[EAST(ii)] == GRAY)) {
	  found_one = 1;
	  bubbles[ii] = GRAY;
	}
	else {
	  /* Look for white neighbors, including the spot itself */
	  if (bubbles[ii] == WHITE
	      || (ON_BOARD(SOUTH(ii))
		  && (gb[SOUTH(ii)] > 0 || bubbles[SOUTH(ii)] == WHITE))
	      || (ON_BOARD(WEST(ii))
		  && (gb[WEST(ii)] > 0 || bubbles[WEST(ii)] == WHITE))
	      || (ON_BOARD(NORTH(ii))
		  && (gb[NORTH(ii)] > 0 || bubbles[NORTH(ii)] == WHITE))
	      || (ON_BOARD(EAST(ii))
		  && (gb[EAST(ii)] > 0 || bubbles[EAST(ii)] == WHITE)))
	    white_neighbor = 1;
	  
	  if (bubbles[ii] == BLACK
	      || (ON_BOARD(SOUTH(ii))
		  && (gb[SOUTH(ii)] < 0 || bubbles[SOUTH(ii)] == BLACK))
	      || (ON_BOARD(WEST(ii))
		  && (gb[WEST(ii)] < 0 || bubbles[WEST(ii)] == BLACK))
	      || (ON_BOARD(NORTH(ii))
		  && (gb[NORTH(ii)] < 0 || bubbles[NORTH(ii)] == BLACK))
	      || (ON_BOARD(EAST(ii))
		  && (gb[EAST(ii)] < 0 || bubbles[EAST(ii)] == BLACK)))
	    black_neighbor = 1;
	  
	  if (white_neighbor) {
	    if (black_neighbor)
	      new_color = GRAY;
	    else
	      new_color = WHITE;
	  }
	  else if (black_neighbor)
	    new_color = BLACK;
	  
	  if (new_color && new_color != bubbles[ii]) {
	    found_one = 1;
	    bubbles[ii] = new_color;
	  }
	}
      }
  }
  /* The bubbles are found and classified. Now adjoin them. */

  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      ii = POS(i, j);

      if (gb[ii])
	continue;
      
      if (bubbles[ii] == WHITE)
	gb[ii] = 1;
      
      if (bubbles[ii] == BLACK)
	gb[ii] = -1;
    }
}


/* Generic function to print the regions in gb, rendering
 * positive as white territory, negative as black. Stones
 * with matcher_status == DEAD are invisible and appear as
 * territory.
 */

static void
print_regions(int gb[BOARDMAX])
{
  int i, j, k;
  int ii;

  start_draw_board();
  for (i = 0; i < board_size; i++) {
    for (j = 0; j < board_size; j++) {
      ii = POS(i, j);

      if (board[ii] && dragon[ii].matcher_status != DEAD)
	k = board[ii];
      else
	k = EMPTY;

      switch (k) {
      case EMPTY:
	if (gb[ii] > 0)
	  draw_color_char(I(ii), J(ii), 'w', GG_COLOR_GREEN);
	else if (gb[ii] < 0)
	  draw_color_char(I(ii), J(ii), 'b', GG_COLOR_MAGENTA);
	else
	  draw_color_char(I(ii), J(ii), '.', GG_COLOR_BLACK);
	break;

      case BLACK:
	if (dragon[ii].matcher_status == CRITICAL)
	  draw_color_char(I(ii), J(ii), 'X', GG_COLOR_RED);
	else
	  draw_color_char(I(ii), J(ii), 'X', GG_COLOR_BLACK);
	break;

      case WHITE:
	if (dragon[ii].matcher_status == CRITICAL)
	  draw_color_char(I(ii), J(ii), 'O', GG_COLOR_RED);
	else
	  draw_color_char(I(ii), J(ii), 'O', GG_COLOR_BLACK);
	break;
      }
    }
  }
  end_draw_board();
}


/* Print the moyo regions after a specified number
 * of dilations and erosions.
 */

void
print_moyo(void)
{
  if (printmoyo & PRINTMOYO_TERRITORY)
    print_new_moyo(5, 21);
  
  if (printmoyo & PRINTMOYO_MOYO)
    print_new_moyo(5, 10);
  
  if (printmoyo & PRINTMOYO_AREA) {
    print_new_moyo(4, 0);
  }
}


static void
print_new_moyo(int dilations, int erosions)
{
  int gb[BOARDMAX];

  dilate_erode(dilations, erosions, gb, WHITE);
  close_bubbles(gb);
  print_regions(gb);
}


/* Put upper and lower score estimates into *upper, *lower and
 * return the average. A positive score favors white. In computing
 * the upper bound, CRITICAL dragons are awarded to white; in
 * computing the lower bound, they are awarded to black.
 */

float
estimate_score(float *upper, float *lower)
{
  int gb[BOARDMAX];

  float white_territory = 0.0;
  float black_territory = 0.0;
  float white_area = 0.0;
  float black_area = 0.0;
  int i, j;
  int ii;
  float u, l;
  int critical;

  critical = dilate_erode(5, 21, gb, WHITE);
  close_bubbles(gb);
  for (i = 0; i < board_size; i++) {
    for (j = 0; j < board_size; j++) {
      ii = POS(i, j);

      if (board[ii] == BLACK) {
	if (captured_territory(ii, WHITE)) {
	  white_territory += 2;
	  white_area++;
	}
	else
	  black_area++;
      }
      else if (board[ii] == WHITE) {
	if (captured_territory(ii, WHITE)) {
	  black_territory += 2;
	  black_area++;
	}
	else
	  white_area++;
      }
      else {
	if (gb[ii] > 0.0) {
	  white_territory++;
	  white_area++;
	}
	else if (gb[ii] < 0.0) {
	  black_territory++;
	  black_area++;
	}
      }
    }
    if (0)
      fprintf(stderr, "in row %d, white territory=%.1f, black=%.1f\n",
	      board_size - i, white_territory, black_territory);
    if (0)
      fprintf(stderr, "in row %d, white area =%.1f, black=%.1f\n",
	      board_size - i, white_area, black_area);
  }

  if (chinese_rules)
    u = white_area - black_area + komi;
  else
    u = white_territory 
      + black_captured - black_territory - white_captured + komi;

  if (critical) {
    white_territory = 0.0;
    black_territory = 0.0;
    white_area = 0.0;
    black_area = 0.0;
    
    dilate_erode(5, 21, gb, BLACK);
    close_bubbles(gb);
    for (i = 0; i < board_size; i++) {
      for (j = 0; j < board_size; j++) {
	ii = POS(i, j);

	if (board[ii] == BLACK) {
	  if (captured_territory(ii, BLACK)) {
	    white_territory += 2;
	    white_area++;
	  }
	  else
	    black_area++;
	}
	else if (board[ii] == WHITE) {
	  if (captured_territory(ii, BLACK)) {
	    black_territory += 2;
	    black_area++;
	  }
	}
	else {
	  if (gb[ii] > 0.0) {
	    white_territory++;
	    white_area++;
	  }
	  else if (gb[ii] < 0.0) {
	    black_territory++;
	    black_area++;
	    
	  }
	}
      }
      
      if (0)
	fprintf(stderr, "in row %d, white territory=%.1f, black=%.1f\n",
		board_size-i, white_territory, black_territory);
      if (0)
	fprintf(stderr, "in row %d, white area =%.1f, black=%.1f\n",
		board_size-i, white_area, black_area);
    }

    if (chinese_rules)
      l = white_area - black_area + komi;
    else
      l = white_territory 
	+ black_captured - black_territory - white_captured + komi;
  }
  else
    l = u;

  if (upper) *upper = u;
  if (lower) *lower = l;

  return (u + l) / 2;
}


/* We do not count dead stones inside the eyespace as territory. Such a
 * stone is characterized as having matcher_status DEAD yet having only
 * DEAD dragons as neighbors.
 *
 * If (pos) is the location of a stone which is DEAD and which is
 * not an exception of this type then it is safe to count it as
 * two points territory for the opponent. This function tests for
 * this condition.
 *
 * CRITICAL dragons are awarded to 'color'.
 */

static int
captured_territory(int pos, int color)
{
  int d;

  if (board[pos] == EMPTY 
      || dragon[pos].matcher_status == ALIVE
      || dragon[pos].matcher_status == UNKNOWN
      || (board[pos] == color && dragon[pos].matcher_status == CRITICAL))
    return 0;

  for (d = 0; d < DRAGON2(pos).neighbors; d++)
    if (DRAGON(DRAGON2(pos).adjacent[d]).color == OTHER_COLOR(board[pos])
	&& (DRAGON(DRAGON2(pos).adjacent[d]).matcher_status == ALIVE
	|| (board[pos] != color
	    && DRAGON(DRAGON2(pos).adjacent[d]).matcher_status == CRITICAL)))
      return 1;

  return 0;
}



/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */


/* semeai.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* #include <stdio.h> */
/* #include <stdlib.h> */

/* #include "gnugo.h" */
/* #include "liberty.h" */



#define INFINITY_ 1000

static void analyze_semeai(int my_dragon, int your_dragon);
static void add_appropriate_semeai_moves(int move, 
					 int my_dragon, int your_dragon, 
					 int my_status, int your_status,
					 int margin_of_safety);
static void small_semeai_analyzer(int str1, int str2, int save_verbose);
static void update_status(int dr, int new_status, int new_safety);


/* semeai() searches for pairs of dragons of opposite color which
 * have safety DEAD. If such a pair is found, analyze_semeai is
 * called to determine which dragon will prevail in a semeai, and
 * whether a move now will make a difference in the outcome. The
 * dragon statuses are revised, and if a move now will make a
 * difference in the outcome, an owl reason is generated.
 */

void
semeai(int color)
{
  int d1, d2;
  int k;
  int apos = NO_MOVE;
  int bpos = NO_MOVE;
  int other = OTHER_COLOR(color);

  TRACE("Semeai Player is THINKING for %s!\n", 
	color_to_string(color));

  for (d1 = 0; d1 < number_of_dragons; d1++) {
    if (DRAGON(d1).color != color
	|| (DRAGON(d1).matcher_status != DEAD
	    && DRAGON(d1).matcher_status != CRITICAL))
      continue;

    for (k = 0; k < dragon2[d1].neighbors; k++) {
      d2 = dragon2[d1].adjacent[k];
      if (DRAGON(d2).color != other
	  || (DRAGON(d2).matcher_status != DEAD
	      && DRAGON(d2).matcher_status != CRITICAL))
	continue;

      /* Dragons d1 (our) and d2 (opponent) are adjacent and both DEAD
       * or CRITICAL.
       */
      apos = DRAGON(d1).origin;
      bpos = DRAGON(d2).origin;

      /* Ignore inessential worms or dragons */
      if (worm[apos].inessential 
	  || DRAGON2(apos).safety == INESSENTIAL
	  || worm[bpos].inessential 
	  || DRAGON2(bpos).safety == INESSENTIAL)
	continue;

      analyze_semeai(apos, bpos);      
    }
  }
}


/* Experimental alternative to semeai() using owl reading */

void
new_semeai(int color)
{
  int d1, d2;
  int k;
  int apos = NO_MOVE;
  int bpos = NO_MOVE;
  int other = OTHER_COLOR(color);
  int best_result_a[MAX_NEIGHBOR_DRAGONS];
  int best_result_b[MAX_NEIGHBOR_DRAGONS];
  int worst_result_a[MAX_NEIGHBOR_DRAGONS];
  int worst_result_b[MAX_NEIGHBOR_DRAGONS];
  int a_best_status = UNKNOWN;  /* status if a plays first */
  int b_worst_status = UNKNOWN; /* status if a plays first */
  int a_worst_status = UNKNOWN; /* status if b plays first */
  int b_best_status = UNKNOWN;  /* status if b plays first */

  int move[MAX_NEIGHBOR_DRAGONS];
  int a_status = UNKNOWN;
  int b_status = UNKNOWN;
  int pass;

  TRACE("Experimental Semeai Module is THINKING for %s!\n", 
	color_to_string(color));
  
  for (d1 = 0; d1 < number_of_dragons; d1++) {
    int semeai_found = 0;
    if (DRAGON(d1).color != color
	|| (DRAGON(d1).matcher_status != DEAD
	    && DRAGON(d1).matcher_status != CRITICAL))
      continue;
    
    /* First pass : collect data
     * Second pass: update statuses
     */
    
    for (k = 0; k < dragon2[d1].neighbors; k++) {
      best_result_a[k] = DEAD;
      worst_result_b[k] = ALIVE;
      move[k] = NO_MOVE;
    }

    for (pass = 0; pass < 2; pass ++) {
      for (k = 0; k < dragon2[d1].neighbors; k++) {
	d2 = dragon2[d1].adjacent[k];
	if (DRAGON(d2).color != other
	    || (DRAGON(d2).matcher_status != DEAD
		&& DRAGON(d2).matcher_status != CRITICAL))
	  continue;
	
	/* Dragons d1 (our) and d2 (opponent) are adjacent and both DEAD
	 * or CRITICAL.
	 */
	apos = DRAGON(d1).origin;
	bpos = DRAGON(d2).origin;
	
	/* The following is something we want to do but
	 * better wait until we have the semeai stuff working
	 * with ko. See nicklas2 test 1401.
	 */
#if 0
	if (DRAGON(d1).matcher_status == CRITICAL
	    && DRAGON(d2).matcher_status == DEAD) {
	  update_status(bpos, CRITICAL, CRITICAL);
	  add_owl_attack_move(dragon[apos].owl_attack_point,
			      bpos, WIN);
	  continue;
	}
#endif

	/* Ignore inessential worms or dragons */
	if (worm[apos].inessential 
	    || DRAGON2(apos).safety == INESSENTIAL
	    || worm[bpos].inessential 
	    || DRAGON2(bpos).safety == INESSENTIAL)
	  continue;
	
	/* A dragon consisting of a single worm which is tactically dead or
	 * critical and having just one neighbor should be ignored.
	 */
	if (dragon[apos].size == worm[apos].size
	    && worm[apos].attack_codes[0] == WIN
	    && DRAGON2(apos).hostile_neighbors == 1)
	  continue;
	if (dragon[bpos].size == worm[bpos].size
	    && worm[bpos].attack_codes[0] == WIN
	    && DRAGON2(bpos).hostile_neighbors == 1)
	  continue;

	/* If one dragon consist of a single stone, don't treat it
	 * as a semeai. (But see nicklas1:1405 for an example where
	 * this rule is bad.
	 */

	if (dragon[apos].size == 1 || dragon[bpos].size == 1)
	  continue;

	semeai_found = 1;
	a_best_status = UNKNOWN;
	b_best_status = UNKNOWN;
	a_worst_status = UNKNOWN;
	b_worst_status = UNKNOWN;

	if (pass == 0) {
	  DEBUG(DEBUG_SEMEAI, "Considering semeai between %1m and %1m\n",
		apos, bpos);
	  owl_analyze_semeai(apos, bpos,
			     best_result_a+k, worst_result_b+k, move+k, 1);
	  if (a_best_status == DEAD
	      || a_best_status == UNKNOWN
	      || (a_best_status == ALIVE_IN_SEKI 
		  && best_result_a[k] == ALIVE)) {
	    a_best_status = best_result_a[k];
	    b_worst_status = worst_result_b[k];
	  }
	  owl_analyze_semeai(bpos, apos, 
			     best_result_b+k, worst_result_a+k, NULL, 1);
	  if (b_best_status == DEAD
	      || b_best_status == UNKNOWN
	      || (b_best_status == ALIVE_IN_SEKI
		  && best_result_b[k] == ALIVE)) {
	    b_best_status = best_result_b[k];
	    a_worst_status = worst_result_a[k];
	  }
	}
	else { /* pass == 1 */
	  if (a_status == CRITICAL
	      && best_result_a[k] != DEAD)
	    add_owl_defense_move(move[k], apos, WIN);
	  if (b_status == CRITICAL
	      && worst_result_b[k] == DEAD)
	    add_owl_attack_move(move[k], bpos, WIN);
	}
      } /* loop over neighbor dragons */
      if (pass == 0 && semeai_found) {
	int a_matcher_status;
	int b_matcher_status;

	if (a_best_status != DEAD && a_worst_status == DEAD)
	  a_status = CRITICAL;
	else
	  a_status = a_worst_status;
	
	if (b_best_status != DEAD && b_worst_status == DEAD)
	  b_status = CRITICAL;
	else
	  b_status = b_worst_status;
	
	a_matcher_status = a_status;
	b_matcher_status = b_status;
	if (a_matcher_status == ALIVE_IN_SEKI)
	  a_matcher_status = ALIVE;
	if (b_matcher_status == ALIVE_IN_SEKI)
	  b_matcher_status = ALIVE;
	
	update_status(apos, a_matcher_status, a_status);
	update_status(bpos, b_matcher_status, b_status);
      }
    }
  }
}

/* liberty_of_dragon(pos, origin) returns true if the vertex at (pos) is a
 * liberty of the dragon with origin at (origin).
 */

static int 
liberty_of_dragon(int pos, int origin)
{
  if (pos == NO_MOVE)
    return 0;

  if (board[pos] != EMPTY)
    return 0;

  if ((ON_BOARD(SOUTH(pos))    && dragon[SOUTH(pos)].origin == origin)
      || (ON_BOARD(WEST(pos))  && dragon[WEST(pos)].origin == origin)
      || (ON_BOARD(NORTH(pos)) && dragon[NORTH(pos)].origin == origin)
      || (ON_BOARD(EAST(pos))  && dragon[EAST(pos)].origin == origin))
    return 1;

  return 0;
}

/* Change the status and safety of a dragon */

static void
update_status(int dr, int new_status, int new_safety)
{
  int pos;
  if (dragon[dr].matcher_status != new_status)
    DEBUG(DEBUG_SEMEAI, "Changing matcher_status of %1m from %s to %s.\n", dr,
	  status_to_string(dragon[dr].matcher_status),
	  status_to_string(new_status));
  if (DRAGON2(dr).safety != new_safety)
    DEBUG(DEBUG_SEMEAI, "Changing safety of %1m from %s to %s.\n", dr,
	  safety_to_string(DRAGON2(dr).safety), safety_to_string(new_safety));
  
  for (pos = BOARDMIN; pos < BOARDMAX; pos++)
    if (IS_STONE(board[pos]) && is_same_dragon(dr, pos))
      dragon[pos].matcher_status = new_status;

  DRAGON2(dr).safety = new_safety;
}



/* analyzes a pair of adjacent dragons which are 
 * DEAD or CRITICAL.
 */
static void
analyze_semeai(int my_dragon, int your_dragon)
{
  /* We start liberty counts at 1 since we will be subtracting
   * the number of worms. */
  int mylibs = 1, yourlibs = 1, commonlibs = 0; 
  int yourlibi = -1, yourlibj = -1;
  int commonlibi = -1, commonlibj = -1;
  int color = board[my_dragon];
  int i, j;
  int m, n;
  int my_status = UNKNOWN;
  int your_status = UNKNOWN;
  int margin_of_safety = 0;
  int owl_code_sufficient = 0;
  
  DEBUG(DEBUG_SEMEAI, "semeai_analyzer: %1m (me) vs %1m (them)\n",
	my_dragon, your_dragon);

  /* If both dragons are owl-critical, and the defense point for my
   * dragon owl_does_attack your dragon, add another owl attack move
   * reason.
   */
  if (dragon[my_dragon].owl_status == CRITICAL
      && dragon[your_dragon].owl_status == CRITICAL) {
    if (dragon[your_dragon].owl_attack_point
	== dragon[my_dragon].owl_defense_point)
      return;
    if (dragon[my_dragon].owl_defense_point != NO_MOVE) {
      int acode = owl_does_attack(dragon[my_dragon].owl_defense_point,
				  your_dragon);
      if (acode != 0) {
	add_owl_attack_move(dragon[my_dragon].owl_defense_point, your_dragon,
			    acode);
	DEBUG(DEBUG_SEMEAI, "added owl attack of %1m at %1m with code %d\n",
	      your_dragon, dragon[my_dragon].owl_defense_point, acode);
	owl_code_sufficient = 1;
      }
    }
  }

  /* If both dragons are owl-critical, or your dragon is owl-critical
   * and my dragon is owl-dead, and the attack point for your dragon
   * owl_does_defend my dragon, add another owl defense move reason
   * and possibly change the owl status of my dragon to critical.
   */
  if ((dragon[my_dragon].owl_status == CRITICAL
       || dragon[my_dragon].owl_status == DEAD)
      && dragon[your_dragon].owl_status == CRITICAL) {
    if (dragon[your_dragon].owl_attack_point
	== dragon[my_dragon].owl_defense_point)
      return;
    if (dragon[your_dragon].owl_attack_point != NO_MOVE) {
      int dcode = owl_does_defend(dragon[your_dragon].owl_attack_point,
				  my_dragon);
      if (dcode != 0) {
	add_owl_defense_move(dragon[your_dragon].owl_attack_point, my_dragon,
			     dcode);
	DEBUG(DEBUG_SEMEAI, "added owl defense of %1m at %1m with code %d\n",
	      my_dragon, dragon[your_dragon].owl_attack_point, dcode);
	if (dragon[my_dragon].owl_status == DEAD) {
	  int pos;

	  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
	    if (!ON_BOARD(pos))
	      continue;
	    if (board[pos] == board[my_dragon]
		&& is_same_dragon(pos, my_dragon)) {
	      dragon[pos].owl_status = CRITICAL;
	      dragon[pos].matcher_status = CRITICAL;
	    }
	  }
	  DEBUG(DEBUG_SEMEAI,
		"changed owl_status and matcher_status of %1m to CRITICAL\n",
		my_dragon);
	}
	owl_code_sufficient = 1;
      }
    }
  }

  /* If the owl code was able to resolve the semeai, exit. */
  if (owl_code_sufficient) {
    DEBUG(DEBUG_SEMEAI, "...owl code sufficient to resolve semeai, exiting\n");
    return;
  }


  /* The semeai module is prone to errors since semeai cannot
   * really be handled by static analysis. It is really only needed
   * when the dragons have many liberties since tight situations
   * can be handled by the tactical reading code. Thus we exclude
   * dragon pairs where either has a tactically DEAD or CRITICAL
   * string which is adjacent to the other dragon which is owl
   * substantial.
   */
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      int pos = POS(m, n);
      if (worm[pos].origin == pos
	  && worm[pos].attack_codes[0] == WIN)
	if (dragon[pos].origin == my_dragon
	    || dragon[pos].origin == your_dragon) {
	  int adj;
	  int adjs[MAXCHAIN];
	  int r;
	  
	  adj = chainlinks(pos, adjs);
	  for (r = 0; r < adj; r++) {
	    int cpos = adjs[r];
	    if (dragon[cpos].origin == my_dragon
		|| dragon[cpos].origin == your_dragon)
	      if (owl_substantial(pos)) {
		DEBUG(DEBUG_SEMEAI, 
		      "...tactical situation detected, exiting\n");
		return;
	      }
	  }
	}
    }
  
  
  /* Mark the dragons as involved in semeai */
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      int pos = POS(i, j);
      if (is_same_dragon(pos, my_dragon)
	  || is_same_dragon(pos, your_dragon))
	DRAGON2(pos).semeai = 1;
    }
  
  /* First we try to determine the number of liberties of each
   * dragon, and the number of common liberties. We subtract
   * 1 minus the number of worms of the dragon from the liberty
   * count, since if a dragon has several worms, a move may
   * have to be invested in connecting them. At the same time
   * we try to find a liberty of the opponent's dragon, and a
   * common liberty, for future reference.
   */
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      int pos = POS(i, j);
      if (board[pos]
	  && worm[pos].origin == pos) {
	if (is_same_dragon(pos, my_dragon))
	  mylibs--;
	if (is_same_dragon(pos, your_dragon))
	  yourlibs--;
      }
      else if (board[pos] == EMPTY) {
	if (liberty_of_dragon(pos, your_dragon)) {
	  yourlibs ++;
	  if (liberty_of_dragon(pos, my_dragon)) {
	    commonlibs++;
	    mylibs++;
	    commonlibi = i;
	    commonlibj = j;
	  }
	  else {
	    yourlibi = i;
	    yourlibj = j;
	  }
	}
	else if (liberty_of_dragon(pos, my_dragon))
	  mylibs++;
      }
    }
  /* We add 1 to the
   * number of liberties of an owl critical dragon if the point
   * of attack is not a liberty of the dragon, since a move
   * may have to be invested in attacking it.
   */

  if (dragon[my_dragon].owl_status == CRITICAL
      && dragon[my_dragon].owl_attack_point != NO_MOVE
      && !liberty_of_string(dragon[my_dragon].owl_attack_point, my_dragon))
    mylibs++;
  
  if (dragon[your_dragon].owl_status == CRITICAL
      && dragon[your_dragon].owl_attack_point != NO_MOVE
      && !liberty_of_string(dragon[your_dragon].owl_attack_point, your_dragon))
    yourlibs++;
  
  /* Now we compute the statuses which result from a
   * naive comparison of the number of liberties. There
   * is some uncertainty in these calculations, so we
   * must exercise caution in applying the results.
   *
   * RULES FOR PLAYING SEMEAI. Let M be the number of liberties
   * of my group, excluding common liberties; let Y be the
   * number of liberties of your group, excluding common
   * liberties; and let C be the number of common liberties.
   * 
   *             If both groups have zero eyes:
   * 
   * (1)  If C=0 and M=Y, whoever moves first wins. CRITICAL.
   * (2)  If C=0 and M>Y, I win.
   * (3)  If C=0 and M<Y, you win.
   * (4)  If C>0 and M >= Y+C then your group is dead and mine is alive.
   * (5)  If C>0 and M = Y+C-1 then the situation is CRITICAL. 
   * (5a) If M=0, then Y=0 and C=1. Whoever moves first kills.
   * (5b) If M>0, then I can kill or you can make seki.
   * (6)  If M < Y+C-1 and Y < M+C-1 then the situation is seki.
   * (7)  If C>0 and Y=M+C-1 the situation is CRITICAL. 
   * (7a) If Y=0, then M=0 and C=1 as in (5). 
   * (7b) If Y>0, you can kill or I can make seki.
   * (8)  If C>0 and Y > M+C then your group is alive and mine is dead.
   *
   *              If both groups have one eye:
   *
   * In this case M > 0 and Y > 0.
   * 
   * (1) If M>C+Y then I win.
   * (2) If Y>C+M then you win.
   * (3) If C=0 and M=Y then whoever moves first kills. CRITICAL.
   * (4) If C>0 and M=C+Y then I can kill, you can make seki. CRITICAL.
   * (5) If C>0 and M<C+Y, Y<C+M, then the situation is seki. 
   * (6) If C>0 and Y=C+M, then you can kill, I can make seki. CRITICAL.
   *
   *            If I have an eye and you dont:
   * 
   * In this case, M > 0. This situation (me ari me nashi) can
   * never be seki. The common liberties must be filled by you,
   * making it difficult to win.
   * 
   * (1) If M+C>Y then I win.
   * (2) If M+C=Y then whoever moves first wins. CRITICAL.
   * (3) If M+C<Y then you win.
   *
   *            If you have an eye and I don't
   * 
   * In this case, Y > 0. 
   * 
   * (1) If Y+C>M you win.
   * (2) If Y+C=M whoever moves first wins. CRITICAL.
   * (3) If Y+C<M I win.  */

  if (DRAGON2(my_dragon).genus == 0
      && DRAGON2(your_dragon).genus == 0) {
    if (commonlibs == 0) {
      if (mylibs > yourlibs) {
	my_status = ALIVE;
	your_status = DEAD;
	margin_of_safety = mylibs - yourlibs;
      }
      else if (mylibs < yourlibs) {
	my_status = DEAD;
	your_status = ALIVE;
	margin_of_safety = yourlibs - mylibs;
      }
      else {
	my_status = CRITICAL;
	your_status = CRITICAL;
	margin_of_safety = 0;
      }
    }
    else if (mylibs == yourlibs + commonlibs - 1) {
      if (mylibs == 0) {
	my_status = CRITICAL;
	your_status = CRITICAL;
	margin_of_safety = 0;
      }
      else {
	/* I can kill, you can make seki */
	my_status = ALIVE;
	your_status = CRITICAL;
	margin_of_safety = 0;
      }
    }
    else if (mylibs < yourlibs + commonlibs - 1
	     && yourlibs < mylibs+commonlibs - 1) {
      /* Seki */
      my_status = ALIVE;
      your_status = ALIVE;
      margin_of_safety = INFINITY_; 
    }
    else if (commonlibs > 0
	     && yourlibs == mylibs + commonlibs - 1) {
      if (yourlibs == 0) {
	my_status = CRITICAL;
	your_status = CRITICAL;
	margin_of_safety = 0;
      }
      else {
	/* you can kill, I can make seki */
	my_status = CRITICAL;
	your_status = ALIVE;
	margin_of_safety = 0;
      }
    }
    else if (commonlibs > 0
	     && yourlibs > mylibs + commonlibs) {
      my_status = DEAD;
      your_status = ALIVE;
      margin_of_safety = yourlibs - mylibs - commonlibs;
    }
  }
  if (DRAGON2(my_dragon).genus > 0
      && DRAGON2(your_dragon).genus > 0) {
    if (mylibs > yourlibs + commonlibs) {
      my_status = ALIVE;
      your_status = DEAD;
      margin_of_safety = mylibs - yourlibs - commonlibs;
    }
    else if (yourlibs > mylibs + commonlibs) {
      my_status = DEAD;
      your_status = ALIVE;
      margin_of_safety = yourlibs - mylibs - commonlibs;
    }
    else if (commonlibs == 0
	     && mylibs == yourlibs) {
      my_status = CRITICAL;
      your_status = CRITICAL;
      margin_of_safety = 0;
    }
    else if (commonlibs > 0
	     && mylibs == commonlibs + yourlibs) {
      my_status = ALIVE;
      your_status = CRITICAL;
      margin_of_safety = 0;
    }
    else if (commonlibs > 0
	     && mylibs < commonlibs + yourlibs
	     && yourlibs < commonlibs + mylibs) {
      /* seki */
      my_status = ALIVE;
      your_status = ALIVE;
      margin_of_safety = INFINITY_;
    }
    else if (commonlibs > 0
	     && yourlibs == commonlibs + mylibs) {
      my_status = CRITICAL;
      your_status = ALIVE;
      margin_of_safety = 0;
    }
  }
  if (DRAGON2(my_dragon).genus > 0
      && DRAGON2(your_dragon).genus == 0) {
    if (mylibs > commonlibs + yourlibs) {
      my_status = ALIVE;
      your_status = DEAD;
      margin_of_safety = mylibs - commonlibs - yourlibs;
    }
    else if (mylibs + commonlibs == yourlibs) {
      my_status = CRITICAL;
      your_status = CRITICAL;
    }
    else if (mylibs + commonlibs < yourlibs) {
      my_status = DEAD;
      your_status = ALIVE;
      margin_of_safety = mylibs + commonlibs - yourlibs;
    }
  }
  if (DRAGON2(my_dragon).genus == 0
      && DRAGON2(your_dragon).genus > 0) {
    if (yourlibs + commonlibs > mylibs) {
      my_status = DEAD;
      your_status = ALIVE;
      margin_of_safety = yourlibs + commonlibs - mylibs;
    }
    else if (yourlibs + commonlibs == mylibs) {
      my_status = CRITICAL;
      your_status = CRITICAL;
      margin_of_safety = 0;
    }
    else if (yourlibs + commonlibs > mylibs) {
      my_status = DEAD;
      your_status = ALIVE;
      margin_of_safety = yourlibs - mylibs - commonlibs;
    }
  }
  
  /* Update matcher statuses */

  /* We do not want to change the matcher status of the friendly
   * dragon if the owl status is critical. If my_status==DEAD by
   * the preceeding heuristics but the owl code finds a way to
   * live, then we should by all means take it. On the other hand
   * if my_status==ALIVE we are alive by semeai, but as a matter
   * of "safety first" if the owl code finds a way to live we may
   * want to take it. So the matcher status is not changed.
   */
  
  if (dragon[my_dragon].owl_status != CRITICAL) {
    if (my_status == ALIVE)
      update_status(my_dragon, ALIVE, ALIVE_IN_SEKI);
    else if (my_status == CRITICAL)
      update_status(my_dragon, CRITICAL, CRITICAL);
    else if (my_status == DEAD)
      update_status(my_dragon, DEAD, DEAD);
  }

  if (your_status == ALIVE)
    update_status(your_dragon, ALIVE, ALIVE_IN_SEKI);
  else if (your_status == CRITICAL)
    update_status(your_dragon, CRITICAL, CRITICAL);
  else if (your_status == DEAD)
    update_status(your_dragon, DEAD, DEAD);
  
  /* Find the recommended semeai moves. In order of priority,
   * (1) We defend our dragon;
   * (2) We attack your dragon;
   * (3) If common liberties > 1, make an eye;
   * (4) If common liberties > 1, kill an eye;
   * (5) Fill a liberty of yours;
   * (6) Fill a common liberty.  */

  if (my_status == CRITICAL || your_status == CRITICAL) {
    int found_one = 0;
    if (dragon[my_dragon].owl_status == CRITICAL
	&& dragon[my_dragon].owl_defense_point != NO_MOVE)
      add_appropriate_semeai_moves(dragon[my_dragon].owl_defense_point,
				   my_dragon, your_dragon,
				   my_status, your_status, margin_of_safety);
    else if (dragon[your_dragon].owl_status == CRITICAL
	     && dragon[your_dragon].owl_attack_point != NO_MOVE)
      add_appropriate_semeai_moves(dragon[your_dragon].owl_attack_point,
				   my_dragon, your_dragon,
				   my_status, your_status, margin_of_safety);
    else if (commonlibs > 1) {
      if (DRAGON2(my_dragon).heyes > 0)
	add_appropriate_semeai_moves(DRAGON2(my_dragon).heye,
				     my_dragon, your_dragon,
				     my_status, your_status, margin_of_safety);
      if (DRAGON2(your_dragon).heyes > 0)
	add_appropriate_semeai_moves(DRAGON2(your_dragon).heye,
				     my_dragon, your_dragon,
				     my_status, your_status, margin_of_safety);
    }
    else {
      for (i = 0; i < board_size-1; i++)
	for (j = 0; j < board_size-1; j++) {
	  int pos = POS(i, j);
	  if (liberty_of_dragon(pos, your_dragon) 
	      && !liberty_of_dragon(pos, my_dragon)
	      && safe_move(pos, color)) {
	    /* add move reasons for EVERY outside liberty where we can
             * play safely. A move to win a semeai might not be a
             * safe move if it is inside the opponent's eyespace. 
             * However we hope that the reading code can analyze the
             * semeai in cases where every safe liberty has been filled.
	     */
	    add_appropriate_semeai_moves(pos, my_dragon, your_dragon,
					 my_status, your_status,
					 margin_of_safety);
	    found_one = 1;
	  }
	}
      if (!found_one) {
	/* No outside liberties --- look for common liberties.
	 * Filling a common liberty is usually bad but if our 
	 * heuristics are accurate, we should only reach this point 
	 * if we definitely have enough liberties to win. As a
	 * sanity check, we require filling a common liberty to
	 * be a safe move.
	 */
	for (i = 0; i < board_size-1; i++)
	  for (j = 0; j < board_size-1; j++) {
	    int pos = POS(i, j);
	    if (liberty_of_dragon(pos, your_dragon)
		&& safe_move(pos, color))
	      add_appropriate_semeai_moves(pos, my_dragon, your_dragon,
					   my_status, your_status,
					   margin_of_safety);
	  }
      }
    }
  }
}

/* Add those move reasons which are appropriate. */

static void
add_appropriate_semeai_moves(int move, int my_dragon, int your_dragon, 
			     int my_status, int your_status, 
			     int margin_of_safety)
{
  if (my_status == CRITICAL)
    add_semeai_move(move, my_dragon);
  else if (margin_of_safety == 1)
    add_semeai_threat(move, my_dragon);
  if (your_status == CRITICAL)
      add_semeai_move(move, your_dragon);
  else if (margin_of_safety == 1)
    add_semeai_threat(move, your_dragon);
}


/* small_semeai() addresses a deficiency in the reading code:
 * for reasons of speed, savestone3 and savestone4 do not
 * sufficiently check whether there may be an adjoining string
 * which can be attacked. So they may overlook a defensive
 * move which consists of attacking an adjoining string.
 *
 * small_semeai() generates all pairs of adjacent attackable
 * worms, then calls owl_analyze_semeai in tactical (non-owl)
 * mode to find out what really happens.
 */

void
small_semeai(int save_verbose)
{
  int apos, bpos;

  /* Generate all adjacent pairs of attackable worms */

  for (apos = BOARDMIN; apos < BOARDMAX; apos++) {

    if (!ON_BOARD(apos) || board[apos] == EMPTY)
      continue;
    if (worm[apos].origin != apos)
      continue;
    if (worm[apos].attack_codes[0] == 0)
      continue;

    for (bpos = BOARDMIN; bpos < BOARDMAX; bpos++) {
      if (!ON_BOARD(bpos) || board[bpos] == EMPTY)
	continue;
      if (worm[bpos].origin != bpos)
	continue;
      if (bpos == apos)
	continue;
      if (worm[bpos].attack_codes[0] == 0)
	continue;
      if (!adjacent_strings(apos, bpos))
	continue;
      if (worm[apos].liberties < 3 && worm[bpos].liberties < 3)
	continue;
      if (save_verbose && apos < bpos)
	gprintf("small semeai found at %1m, %1m\n", apos, bpos);
      small_semeai_analyzer(apos, bpos, save_verbose);
    }
  }
}

/* Helper function for small_semeai. Tries to resolve the
 * semeai between (apos) and (bpos), possibly revising points
 * of attack and defense.
 *
 */

static void
small_semeai_analyzer(int apos, int bpos, int save_verbose)
{
  int move;
  int resulta, resultb;

  /* FIXME: Not ko aware yet (since owl_analyze_semeai isn't).
   * Should be more careful if there is already a defense point.
   */

  owl_analyze_semeai(apos, bpos, &resulta, &resultb, &move, 0);
  if (resulta != DEAD
      && worm[apos].defend_codes[0] == 0 
      && move != NO_MOVE) {
    if (save_verbose)
      gprintf("small semeai: changing defense of %1m to %1m\n",
	      apos, move);
    change_defense(apos, move, WIN);
  }
}



/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */

/* sgfdecide.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* ================================================================ */
/*      Show status for a string, a dragon, etc in an SGF file.     */
/* ================================================================ */

/* #include <stdio.h> */
/* #include <string.h> */

/* #include "sgftree.h" */
/* #include "gnugo.h" */
/* #include "liberty.h" */



/* 
 * decide_string tries to attack and defend the string at (pos),
 * and then writes the number of variations considered in the attack
 * and defence to the sgf file.
 */

void
decide_string(int pos, const char *sgf_output)
{
  int aa, dd;
  int acode, dcode;
  SGFTree  tree;
  
  if (board[pos] == EMPTY) {
    fprintf(stderr, "gnugo: --decide-string called on an empty vertex\n");
    return ;
  }

  if (sgf_output)
    begin_sgftreedump(&tree);

  /* Prepare pattern matcher and reading code. */
  reset_engine();

  count_variations = 1;
  acode = attack(pos, &aa);
  if (acode) {
    if (acode == WIN)
      gprintf("%1m can be attacked at %1m (%d variations)\n", 
	      pos, aa, count_variations);
    else if (acode == KO_A)
	gprintf("%1m can be attacked with ko (good) at %1m (%d variations)\n", 
	      pos, aa, count_variations);
    else if (acode == KO_B)
	gprintf("%1m can be attacked with ko (bad) at %1m (%d variations)\n", 
		pos, aa, count_variations);

    if (debug & DEBUG_READING_PERFORMANCE) {
      gprintf("Reading shadow: \n");
      draw_reading_shadow();
    }

    count_variations = 1;
    dcode = find_defense(pos, &dd);
    if (dcode) {
      if (dcode == WIN)
	gprintf("%1m can be defended at %1m (%d variations)\n", 
		pos, dd, count_variations);
      else if (dcode == KO_A)
	gprintf("%1m can be defended with ko (good) at %1m (%d variations)\n", 
		pos, dd, count_variations);
      else if (dcode == KO_B)
	gprintf("%1m can be defended with ko (bad) at %1m (%d variations)\n", 
		pos, dd, count_variations);
    }
    else
      gprintf("%1m cannot be defended (%d variations)\n", 
	      pos, count_variations);
    if (debug & DEBUG_READING_PERFORMANCE) {
      gprintf("Reading shadow: \n");
      draw_reading_shadow();
    }

  }
  else {
    gprintf("%1m cannot be attacked (%d variations)\n", 
	    pos, count_variations);
    if (debug & DEBUG_READING_PERFORMANCE) {
      gprintf("Reading shadow: \n");
      draw_reading_shadow();
    }
  }

  if (sgf_output) {
    end_sgftreedump(sgf_output);
    count_variations = 0;
  }
}


/* 
 * decide_connection tries to connect and disconnect the strings at
 * (apos) and (bpos), and then writes the number of variations
 * considered in the attack and defence to the sgf file.
 */

void
decide_connection(int apos, int bpos, const char *sgf_output)
{
  int move;
  int result;
  SGFTree tree;

  ASSERT_ON_BOARD1(apos);
  ASSERT_ON_BOARD1(bpos);
  
  if (board[apos] == EMPTY || board[bpos] == EMPTY) {
    fprintf(stderr, "gnugo: --decide-connection called on an empty vertex\n");
    return;
  }

  if (board[apos] != board[bpos]) {
    fprintf(stderr, "gnugo: --decide-connection called for strings of different colors\n");
    return;
  }

  if (sgf_output)
    begin_sgftreedump(&tree);

  /* Prepare pattern matcher and reading code. */
  reset_engine();

  count_variations = 1;
  result = string_connect(apos, bpos, &move);
  if (result == WIN) {
    if (move == NO_MOVE)
      gprintf("%1m and %1m are connected as it stands (%d variations)\n", 
	      apos, bpos, count_variations);
    else
	gprintf("%1m and %1m can be connected at %1m (%d variations)\n", 
		apos, bpos, move, count_variations);
  }
  else
    gprintf("%1m and %1m cannot be connected (%d variations)\n", 
	    apos, bpos, count_variations);
  
  count_variations = 1;
  result = disconnect(apos, bpos, &move);
  if (result == WIN) {
    if (move == NO_MOVE)
      gprintf("%1m and %1m are disconnected as it stands (%d variations)\n", 
	      apos, bpos, count_variations);
    else
	gprintf("%1m and %1m can be disconnected at %1m (%d variations)\n", 
		apos, bpos, move, count_variations);
  }
  else
    gprintf("%1m and %1m cannot be disconnected (%d variations)\n", 
	    apos, bpos, count_variations);
  
  if (sgf_output) {
    end_sgftreedump(sgf_output);
    count_variations = 0;
  }
}


/* 
 * decide_dragon tries to attack and defend the dragon at (pos),
 * and then writes the number of variations considered in the attack
 * and defence to the sgf file.
 */

void
decide_dragon(int pos, const char *sgf_output)
{
  int move = NO_MOVE;
  int acode, dcode;
  SGFTree tree;
  int result_certain;

  if (board[pos] == EMPTY) {
    fprintf(stderr, "gnugo: --decide-dragon called on an empty vertex\n");
    return ;
  }

  /* Prepare pattern matcher and reading code. */
  reset_engine();

  silent_examine_position(board[pos], EXAMINE_DRAGONS_WITHOUT_OWL);
  gprintf("finished examine_position\n");

  /* We want to see the reading performed, not just a result picked
   * from the cache. Thus we clear the cache here.
   */
  reading_cache_clear();
  
  if (sgf_output)
    begin_sgftreedump(&tree);

  count_variations = 1;
  acode = owl_attack(pos, &move, &result_certain);
  if (acode) {
    if (acode == WIN) {
      if (move == NO_MOVE)
	gprintf("%1m is dead as it stands", pos);
      else
	gprintf("%1m can be attacked at %1m (%d variations)", 
		pos, move, count_variations);
    }
    else if (acode == KO_A)
      gprintf("%1m can be attacked with ko (good) at %1m (%d variations)", 
	      pos, move, count_variations);
    else if (acode == KO_B)
      gprintf("%1m can be attacked with ko (bad) at %1m (%d variations)", 
	      pos, move, count_variations);
  }
  else 
    gprintf("%1m cannot be attacked (%d variations)", pos, count_variations);
  
  if (result_certain)
    gprintf("\n");
  else
    gprintf(" result uncertain\n");

  count_variations = 1;
  dcode = owl_defend(pos, &move, &result_certain);

  if (dcode) {
    if (dcode == WIN) {
      if (move == NO_MOVE)
	gprintf("%1m is alive as it stands", pos);
      else 
	gprintf("%1m can be defended at %1m (%d variations)", 
		pos, move, count_variations);
    }
    else if (dcode == KO_A)
      gprintf("%1m can be defended with ko (good) at %1m (%d variations)", 
	      pos, move, count_variations);
    else if (dcode == KO_B)
      gprintf("%1m can be defended with ko (bad) at %1m (%d variations)", 
	      pos, move, count_variations);
  }
  else
    gprintf("%1m cannot be defended (%d variations)",
	    pos, count_variations);

  if (result_certain)
    gprintf("\n");
  else
    gprintf(" result uncertain\n");
  
  if (sgf_output) {
    end_sgftreedump(sgf_output);
    count_variations = 0;
  }
}


void
decide_semeai(int apos, int bpos, const char *sgf_output)
{
  SGFTree tree;
  int resulta, resultb, move;
  int color = board[apos];

  if (color == EMPTY || board[bpos] != OTHER_COLOR(color)) {
    gprintf("gnugo: --decide-semeai called on invalid data\n");
    return;
  }

  /* Prepare pattern matcher and reading code. */
  reset_engine();

  silent_examine_position(board[apos], EXAMINE_DRAGONS_WITHOUT_OWL);
  gprintf("finished examine_position\n");
  count_variations = 1;

  /* We want to see the reading performed, not just a result picked
   * from the cache. Thus we clear the cache here. */
  reading_cache_clear();
  
  if (sgf_output)
    begin_sgftreedump(&tree);
  owl_analyze_semeai(apos, bpos, &resulta, &resultb, &move, 1);
  gprintf("After %s at %1m, %1m is %s, %1m is %s (%d nodes)\n",
	  color == BLACK ? "black" : "white",
	  move,
	  apos, safety_to_string(resulta),
  	  bpos, safety_to_string(resultb),
	  count_variations);
  owl_analyze_semeai(bpos, apos, &resultb, &resulta, &move, 1);
  gprintf("After %s at %1m, %1m is %s, %1m is %s (%d nodes)\n",
	  color == BLACK ? "white" : "black",
	  move,
	  apos, safety_to_string(resulta),
  	  bpos, safety_to_string(resultb),
	  count_variations);

  if (sgf_output) {
    end_sgftreedump(sgf_output);
    count_variations = 0;
  }
}


void
decide_tactical_semeai(int apos, int bpos, const char *sgf_output)
{
  SGFTree tree;
  int resulta, resultb, move;
  int color = board[apos];

  if (color == EMPTY || board[bpos] != OTHER_COLOR(color)) {
    gprintf("gnugo: --decide-semeai called on invalid data\n");
    return;
  }

  /* Prepare pattern matcher and reading code. */
  reset_engine();

  silent_examine_position(board[apos], EXAMINE_DRAGONS_WITHOUT_OWL);
  gprintf("finished examine_position\n");
  count_variations = 1;

  /* We want to see the reading performed, not just a result picked
   * from the cache. Thus we clear the cache here. */
  reading_cache_clear();
  
  if (sgf_output)
    begin_sgftreedump(&tree);
  owl_analyze_semeai(apos, bpos, &resulta, &resultb, &move, 0);
  gprintf("After %s at %1m, %1m is %s, %1m is %s (%d nodes)\n",
	  color == BLACK ? "black" : "white",
	  move,
	  apos, safety_to_string(resulta),
  	  bpos, safety_to_string(resultb),
	  count_variations);
  owl_analyze_semeai(bpos, apos, &resultb, &resulta, &move, 0);
  gprintf("After %s at %1m, %1m is %s, %1m is %s (%d nodes)\n",
	  color == BLACK ? "white" : "black",
	  move,
	  apos, safety_to_string(resulta),
  	  bpos, safety_to_string(resultb),
	  count_variations);

  if (sgf_output) {
    end_sgftreedump(sgf_output);
    count_variations = 0;
  }
}


/* 
 * decide_position tries to attack and defend every dragon with
 * dragon.escape<6 and writes the variations to an sgf file.
 */

void
decide_position(int color, const char *sgf_output)
{
  int pos;
  int move = NO_MOVE;
  int acode = 0, dcode = 0;
  static const char *snames[] = {"dead", "alive", "critical", "unknown"};
  SGFTree tree;

  /* Prepare pattern matcher and reading code. */
  reset_engine();

  silent_examine_position(color, EXAMINE_DRAGONS_WITHOUT_OWL);

  /* We want to see the reading performed, not just a result picked
   * from the cache. Thus we clear the cache here. */
  reading_cache_clear();

  if (sgf_output)
    begin_sgftreedump(&tree);

  count_variations = 1;

  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (!ON_BOARD(pos)
	|| dragon[pos].origin != pos
	|| board[pos] == EMPTY
	|| DRAGON2(pos).escape_route >= 6)
      continue;

    gprintf("\nanalyzing %1m\n", pos);
    gprintf("status=%s, escape=%d\n", 
	    snames[dragon[pos].status], DRAGON2(pos).escape_route);
    acode = owl_attack(pos, &move, NULL);
    if (acode) {
      if (acode == WIN) {
	if (move == NO_MOVE)
	  gprintf("%1m is dead as it stands\n", pos);
	else
	  gprintf("%1m can be attacked at %1m (%d variations)\n", 
		  pos, move, count_variations);
      }
      else if (acode == KO_A)
	gprintf("%1m can be attacked with ko (good) at %1m (%d variations)\n", 
		pos, move, count_variations);
      else if (acode == KO_B)
	gprintf("%1m can be attacked with ko (bad) at %1m (%d variations)\n", 
		pos, move, count_variations);
      
      count_variations = 1;
      dcode = owl_defend(pos, &move, NULL);
      if (dcode) {
	if (dcode == WIN) {
	  if (move == NO_MOVE)
	    gprintf("%1m is alive as it stands\n", pos);
	  else 
	    gprintf("%1m can be defended at %1m (%d variations)\n", 
		    pos, move, count_variations);
	}
	else if (dcode == KO_A)
	  gprintf("%1m can be defended with ko (good) at %1m (%d variations)\n", 
		  pos, move, count_variations);
	else if (dcode == KO_B)
	  gprintf("%1m can be defended with ko (bad) at %1m (%d variations)\n",
		  pos, move, count_variations);
      }
      else
	gprintf("%1m cannot be defended (%d variations)\n", 
		pos, count_variations);
    }
    else 
      gprintf("%1m cannot be attacked (%d variations)\n", 
	      pos, count_variations);
    
    if (acode) {
      if (dcode)
	gprintf("status of %1m revised to CRITICAL\n", pos);
      else
	gprintf("status of %1m revised to DEAD\n", pos);
    }
    else
      gprintf("status of %1m revised to ALIVE\n", pos);
  }
  
  if (sgf_output) {
    end_sgftreedump(sgf_output);
    count_variations = 0;
  }
}


/*
 * Evaluates the eyespace at (pos) and prints a report.
 */

void
decide_eye(int pos, const char *sgf_output)
{
  int color;
  int max, min;
  int attack_point;
  int defense_point;
  int eyepos;
  SGFTree tree;

  reset_engine();
  silent_examine_position(BLACK, EXAMINE_DRAGONS_WITHOUT_OWL);
  
  if (black_eye[pos].color == BLACK_BORDER) 
    color = BLACK;
  else if (white_eye[pos].color == WHITE_BORDER) 
    color = WHITE;
  else {
    gprintf("The eye at %1m is not of a single color.\n", pos);
    return;
  }

  if (printboard)
    showboard(0);

  if (life)
    reset_life_node_counter();

  /* Enable sgf output. */
  if (sgf_output)
    begin_sgftreedump(&tree);
  count_variations = 1;
  
  if (black_eye[pos].color == BLACK_BORDER) {
    eyepos = black_eye[pos].origin;
    compute_eyes(eyepos, &max, &min, &attack_point, &defense_point,
		 black_eye, half_eye, 0, EMPTY);
    gprintf("Black eyespace at %1m: min=%d, max=%d\n", eyepos, min, max);
    if (max != min) {
      gprintf("  vital points: %1m (attack) %1m (defense)\n", attack_point,
	      defense_point);
    }
  }
  if (white_eye[pos].color == WHITE_BORDER) {
    eyepos = white_eye[pos].origin;
    compute_eyes(eyepos, &max, &min, &attack_point, &defense_point,
		 white_eye, half_eye, 0, EMPTY);
    gprintf("White eyespace at %1m: min=%d, max=%d\n", eyepos, min, max);
    if (max != min) {
      gprintf("  vital points: %1m (attack) %1m (defense)\n", attack_point,
	      defense_point);
    }
  }
  
  if (life)
    printf("%d positions examined by the life module.\n",
	   get_life_node_counter());

  /* Finish sgf output. */
  if (sgf_output) {
    end_sgftreedump(sgf_output);
    count_variations = 0;
  }
}


/* 
 * decide_combination tries to find a combination attack for (color) by
 * calling atari_atari().
 */

void
decide_combination(int color, const char *sgf_output)
{
  int attack_move;
  int defense_move;
  SGFTree tree;

  /* Prepare pattern matcher and reading code. */
  reset_engine();

  silent_examine_position(color, EXAMINE_ALL);

  if (sgf_output)
    begin_sgftreedump(&tree);
  count_variations = 1;

  if (atari_atari(color, &attack_move, &defense_move, verbose))
    gprintf("Combination attack for %C at %1m, defense at %1m\n", color,
	    attack_move, defense_move);
  else
    gprintf("No Combination attack for %C\n", color);
  
  if (sgf_output) {
    end_sgftreedump(sgf_output);
    count_variations = 0;
  }
}


/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */


/* shapes.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* #include <stdio.h> */
/* #include <stdlib.h> */

/* #include "gnugo.h" */
/* #include "liberty.h" */

/* #include "patterns.h" */



/* Maximum number of dragons considered by a, B, C, and d class patterns. */
#define MAX_DRAGONS_PER_PATTERN 5

/* Values of joseki patterns. */
#define U_VALUE 40
#define J_VALUE 27
#define j_VALUE 20
#define t_VALUE 15

/* Values of joseki patterns if using experimental influence. */
#define EXP_J_VALUE 35
#define EXP_j_VALUE 22
#define EXP_t_VALUE 17

/* Global variables set to joseki values acc. to experimental_influence. */
float J_value = J_VALUE;
float j_value = j_VALUE;
float t_value = t_VALUE;


/* 
 * This callback is invoked for each matched pattern.
 */

static void
shapes_callback(int m, int n, int color, struct pattern *pattern, int ll,
		void *data)
{
  int k, l;
  int move;
  
  /* Dragons of our color. */
  int my_dragons[MAX_DRAGONS_PER_PATTERN];
  int my_ndragons = 0;

  /* Dragons of other color. */
  int your_dragons[MAX_DRAGONS_PER_PATTERN];
  int your_ndragons = 0;

  /* Make a local copy of the classification that we may modify. */
  unsigned int class = pattern->class;
  
  /* Y patterns get rejected if F flag does not match with
   * experimental_influence mode.
   */
  if (class & CLASS_Y)
    if (!((experimental_influence && !(class & CLASS_F))
	  ||(!experimental_influence && (class & CLASS_F))))
      return;

  /* Don't accept fuseki marked patterns while scoring. */
  if (doing_scoring && (class & CLASS_F))
    return;
  
  /* Don't need auxiliary data in this callback. */
  UNUSED(data);
  
  /* Pick up the location of the move */
  move = AFFINE_TRANSFORM(pattern->movei, pattern->movej, ll, m, n);
  
  /* For some classes of patterns we need to find all dragons present
   * in the pattern.
   */
  if ((class & (CLASS_B | CLASS_C | CLASS_c | CLASS_a | CLASS_d | CLASS_O |
		CLASS_J | CLASS_j | CLASS_U | CLASS_T | CLASS_t)) != 0)
  {
    int other = OTHER_COLOR(color);

    /* Match each point. */
    for (k = 0; k < pattern->patlen; ++k) { 
      int pos; /* absolute (board) co-ord of (transformed) pattern element */
      int origin; /* dragon origin */
      
      /* all the following stuff (currently) applies only at occupied cells */
      if (pattern->patn[k].att == ATT_dot)
	continue;

      /* transform pattern real coordinate */
      pos = AFFINE_TRANSFORM(pattern->patn[k].x, pattern->patn[k].y, ll, m, n);

      /* Already, matchpat rejects O patterns containing a friendly stone with
       * DEAD or CRITICAL matcher_status. If the stone is tactically
       * CRITICAL it still could have matcher_status ALIVE since it might
       * be amalgamated into a live dragon. In this case we want to reject the
       * pattern if (move) does not rescue it. This is most easily tested
       * here within shapes_callback(), since the value of (move) is not
       * known by matchpat().
       */
      if ((class & CLASS_O)
	  && board[pos] == color
	  && worm[pos].attack_points[0] != 0
	  && !does_defend(move, pos))
	return;

      origin = dragon[pos].origin;
      if (board[pos] == color && my_ndragons < MAX_DRAGONS_PER_PATTERN) {
	for (l = 0; l < my_ndragons; l++) {
	  if (my_dragons[l] == origin)
	    break;
	}
	if (l == my_ndragons) {
	  /* We found another dragon of our color. Check that it (or
           * rather the underlying worm) cannot be tactically
           * captured before adding it to the list of my_dragons.  
	   */
	  if (worm[pos].attack_codes[0] == 0
	      || does_defend(move, pos)) {
	    /* Ok, add the dragon to the list. */
	    my_dragons[l] = origin;
	    my_ndragons++;
	  }
	}
      }

      if (board[pos] == other && your_ndragons < MAX_DRAGONS_PER_PATTERN) {
	for (l = 0; l < your_ndragons; l++) {
	  if (your_dragons[l] == origin)
	    break;
	}
	if (l == your_ndragons) {
	  /* We found another opponent dragon, add it to the list. */
	  your_dragons[l] = origin;
	  your_ndragons++;
	}
      }      
    } /* loop over elements */
  } /* if we need to loop over the elements */

  /* Nothing to connect. Remove C class bit. */
  if (my_ndragons < 2)
    class &= ~CLASS_C;

  /* Nothing to cut. Remove B class bit. */
  if (your_ndragons < 2)
    class &= ~CLASS_B;
  
  /*
   * If this pattern can't produce any effect (e.g. if it was a B or C
   * pattern with only one dragon of the appropriate color), don't
   * do any expensive checking but return immediately.
   * If it only has some move_values, these will be ignored.
   */
  if (!pattern->helper
      && !allpats
      && !(pattern->autohelper_flag & HAVE_ACTION)
      && !(class & (CLASS_MOVE_REASONS | CLASS_MOVE_VALUES)))
    return;
  
  /* For sacrifice patterns, the survival of the stone to be played is
   * not checked (but it still needs to be legal). Otherwise we
   * discard moves which can be captured.
   */
  if (!(class & CLASS_s)) {
    /* Don't allow ko unsafety. */
    if (safe_move(move, color) != WIN) {
      if (0)
	TRACE("  move at %1m wasn't safe, discarded\n", move);
      return;
    }
  }
  else {
    /* Allow illegal ko captures at this stage. */
    if (!is_ko(move, color, NULL) && !is_legal(move, color)) {
      if (0)
	TRACE("  move at %1m wasn't legal, discarded\n", move);
      return;
    }
  }
  
  /* For class n patterns, the pattern is contingent on an opponent
   * move at * not being captured.
   */
  if (class & CLASS_n) {
    /* Allow ko unsafety. */
    if (safe_move(move, OTHER_COLOR(color)) == 0) {
      if (0)
	TRACE("  opponent can't play safely at %1m, move discarded\n", move);
      return;
    }
  }
  
  /* If the pattern has a constraint, call the autohelper to see
   * if the pattern must be rejected.
   */
  if (pattern->autohelper_flag & HAVE_CONSTRAINT) {
    if (!pattern->autohelper(pattern, ll, move, color, 0))
      return;
  }

  /* Ask helper for acceptance of pattern. */
  if (pattern->helper) {
    /* ask helper function to consider the move */
    int accepted;
    DEBUG(DEBUG_HELPER, "  asking helper to consider '%s'+%d at %1m\n", 
	  pattern->name, ll, move);
    accepted = pattern->helper(pattern, ll, move, color);
    
    if (accepted) {
      DEBUG(DEBUG_HELPER, "helper likes pattern '%s' at %1m\n",
	    pattern->name, move);
    }
    else {
      DEBUG(DEBUG_HELPER, "  helper does not like pattern '%s' at %1m\n", 
	    pattern->name, move);
      return;  /* pattern matcher does not like it */
    }
  }
      
  /* If using -a, want to see all matches even if not -v */
  if (allpats || verbose) {
    TRACE("pattern '%s'+%d matched at %1m\n", pattern->name, ll, move);
  }
  
  /* does the pattern have an action? */
  if (pattern->autohelper_flag & HAVE_ACTION) {
    pattern->autohelper(pattern, ll, move, color, 1);
  }

  /* Pattern class B, cut all combinations of opponent dragons. */
  if (class & CLASS_B) {
    for (k = 0; k < your_ndragons; k++)
      for (l = k+1; l < your_ndragons; l++) {
	add_cut_move(move, your_dragons[k], your_dragons[l]);
	TRACE("...cuts dragons %1m, %1m\n", your_dragons[k], your_dragons[l]);
      }
  }

  /* Pattern class C, connect all combinations of our dragons. */
  if (class & CLASS_C) {
    for (k = 0; k < my_ndragons; k++)
      for (l = k+1; l < my_ndragons; l++) {
	add_connection_move(move, my_dragons[k], my_dragons[l]);
	TRACE("...connects dragons %1m, %1m\n", my_dragons[k], my_dragons[l]);
      }
  }

  /* Pattern class c, add strategical defense move reason for all our
   * dragons and a small shape bonus.
   *
   * This is a preliminary effect of "weak connection" and may need to
   * be revised.
   */
  if (class & CLASS_c) {
    for (k = 0; k < my_ndragons; k++) {
      add_strategical_defense_move(move, my_dragons[k]);
      TRACE("...strategical defense (weak connection) of %1m\n",
	    my_dragons[k]);
    }
    add_shape_value(move, 1);
    TRACE("...shape value 1\n");
  }

  /* Pattern class b, block to secure territory. */
  if (class & CLASS_b) {
    add_block_territory_move(move);
    TRACE("...blocks territory\n");
  }

  /* Pattern class e, expand to make territory. */
  if (class & CLASS_e) {
    add_expand_territory_move(move);
    TRACE("...expands territory\n");
  }

  /* Pattern class E, expand to make moyo. */
  if (class & CLASS_E) {
    add_expand_moyo_move(move);
    TRACE("...expands moyo\n");
  }

  /* Pattern class a, strategical level attack on all opponent dragons. */
  if (class & CLASS_a) {
    for (k = 0; k < your_ndragons; k++) {
      add_strategical_attack_move(move, your_dragons[k]);
      TRACE("...strategical attack on %1m\n", your_dragons[k]);
    }
  }
  
  /* Pattern class d, strategical level defense of all own dragons. */
  if (class & CLASS_d) {
    for (k = 0; k < my_ndragons; k++) {
      add_strategical_defense_move(move, my_dragons[k]);
      TRACE("...strategical defense of %1m\n", my_dragons[k]);
    }
  }

  /* Pattern class J, joseki standard move. Add expand territory and
   * moyo, and require the value at least J_value.
   */
  if (class & CLASS_J) {
    TRACE("...joseki standard move\n");
    add_expand_territory_move(move);
    TRACE("...expands territory\n");
    add_expand_moyo_move(move);
    TRACE("...expands moyo\n");
    set_minimum_move_value(move, J_value);
    TRACE("... minimum move value %f\n", J_value);
  }

  /* Pattern class j, less urgent joseki move. Add expand territory and
   * moyo, set a minimum value of j_value. If it is a fuseki pattern, set also
   * the maximum value to j_value.
   */
  if (class & CLASS_j) {
    float min_value = j_value;
    TRACE("...less urgent joseki move\n");
    add_expand_territory_move(move);
    TRACE("...expands territory\n");
    add_expand_moyo_move(move);
    TRACE("...expands moyo\n");

    /* Board size modification. */
    min_value *= board_size / 19.0;
    
    if (class & VALUE_SHAPE) {
      min_value *= (1 + 0.01 * pattern->shape);
      class &= ~VALUE_SHAPE;
    };

    if ((board_size >= 17) && (class & CLASS_F)) {
      min_value *= 1.005; /* Otherwise, j patterns not of CLASS_F would */
                          /* get preferred in value_move_reasons */
      set_maximum_move_value(move, min_value);
      TRACE("...move value %f (shape %f)\n", min_value, pattern->shape);
    }
    else 
      TRACE("...minimum move value %f (shape %f)\n",
            min_value, pattern->shape);
    set_minimum_move_value(move, min_value);
  }

  /* Pattern class t, minor joseki move (tenuki OK).
   * Set the (min-)value at t_value
   */
  if (class & CLASS_t) {
    float min_value = t_value;
    TRACE("...minor joseki move\n");
    
    /* Board size modification. */
    min_value *= board_size / 19.0;
    
    if (class & VALUE_SHAPE) {
      min_value *= (1 + 0.01 * pattern->shape);
      class &= ~VALUE_SHAPE;
    };
    
    if ((board_size >= 17) && (class & CLASS_F)) {
      min_value *= 1.005; /* Otherwise, j patterns not of CLASS_F would */
                          /* get preferred in value_move_reasons */
      set_maximum_move_value(move, min_value);
      TRACE("...move value %f (shape %f)\n", min_value, pattern->shape);
    }
    else 
      TRACE("...minimum move value %f (shape %f)\n",
            min_value, pattern->shape);
    set_minimum_move_value(move, min_value);
  }

  /* Pattern class U, very urgent move joseki. Add strategical defense
   * and attack, plus a shape bonus of 15 and a minimum value of 40.
   */
  if (class & CLASS_U) {
    TRACE("...joseki urgent move\n");
    for (k = 0; k < my_ndragons; k++) {
      add_strategical_defense_move(move, my_dragons[k]);
      TRACE("...strategical defense of %1m\n", my_dragons[k]);
    }
    urgent = 1;
    for (k = 0; k < your_ndragons; k++) {
      add_strategical_attack_move(move, your_dragons[k]);
      TRACE("...strategical attack on %1m\n", your_dragons[k]);
    }
    add_shape_value(move, 15);
    TRACE("...shape value 15\n");
    set_minimum_move_value(move, U_VALUE);
    TRACE("...(min) move value %f\n", U_VALUE);
  }

  /* Pattern class T, joseki trick move. For the moment we never play
   * these.
   */
  if (class & CLASS_T) {
    TRACE("...joseki trick move\n");
    add_antisuji_move(move);
    TRACE("...antisuji\n");
  }

  /* Pattern class W, worthwhile threat move. */
  if (class & CLASS_W) {
    TRACE("...worthwhile threat move\n");
    add_worthwhile_threat_move(move);
  }

  /* Minimum move value specified. */
  if (class & VALUE_MINVAL) {
    set_minimum_move_value(move, pattern->value);
    TRACE("...(min) move value %f\n", pattern->value);
  }

  /* Maximum move value specified. */
  if (class & VALUE_MAXVAL) {
    set_maximum_move_value(move, pattern->maxvalue);
    TRACE("...max move value %f\n", pattern->maxvalue);
  }

  /* Minimum territorial value specified. */
  if (class & VALUE_MINTERRITORY) {
    set_minimum_territorial_value(move, pattern->minterritory);
    TRACE("...(min) territorial value %f\n", pattern->minterritory);
  }

  /* Maximum territorial value specified. */
  if (class & VALUE_MAXTERRITORY) {
    set_maximum_territorial_value(move, pattern->maxterritory);
    TRACE("...max territorial value %f\n", pattern->maxterritory);
  }

  /* Shape value specified. */
  if (class & VALUE_SHAPE) {
    add_shape_value(move, pattern->shape);
    TRACE("...shape value %f\n", pattern->shape);
  }

  /* Followup value specified. */
  if (class & VALUE_FOLLOWUP) {
    add_followup_value(move, pattern->followup);
    TRACE("...followup value %f\n", pattern->followup);
  }

  /* Reverse followup value specified. */
  if (class & VALUE_REV_FOLLOWUP) {
    add_reverse_followup_value(move, pattern->reverse_followup);
    TRACE("...reverse followup value %f\n", pattern->reverse_followup);
  }
}


/*
 * Match all patterns in patterns.db and patterns2.db on all positions.  
 *
 * This function is one of the basic generators of move reasons, called
 * by genmove().
 */
void
shapes(int color)
{
  TRACE("\nPattern matcher is looking for move reasons for %s!\n",
	color_to_string(color));

  /* Modify joseki values if using experimental influence. */
  if (experimental_influence) {
    J_value = EXP_J_VALUE;
    j_value = EXP_j_VALUE;
    t_value = EXP_t_VALUE;
  }

  matchpat(shapes_callback, color, &pat_db, NULL, NULL);

  if (josekidb)
    matchpat(shapes_callback, color, &joseki_db, NULL, NULL);

  if (!disable_fuseki && !doing_scoring)
    matchpat(shapes_callback, color, &fusekipat_db, NULL, NULL);
}


/*
 * Match all patterns in endgame.db on all positions.
 */
void
endgame_shapes(int color)
{
  TRACE("\nEndgame pattern matcher is looking for move reasons for %s!\n",
	color_to_string(color));

  matchpat(shapes_callback, color, &endpat_db, NULL, NULL);
}


/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */


/* utils.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* #include <stdio.h> */
/* #include <string.h> */
/* #include <stdlib.h> */
/* #include <stdarg.h> */
/* #include <math.h> */

/* #include "sgftree.h" */
/* #include "gnugo.h" */
/* #include "liberty.h" */
/* #include "gg_utils.h" */

/* #include "random.h" */


/*
 * Change the status of all the stones in the dragon at (dr).
 */

void
change_matcher_status(int dr, int status)
{
  int pos;
  int origin = dragon[dr].origin;

  for (pos = BOARDMIN; pos < BOARDMAX; pos++)
    if (ON_BOARD(pos)) {
      if (dragon[pos].origin == origin)
	dragon[pos].matcher_status = status;
    }
}


/*
 * Check whether a move at (move) stops the enemy from playing at (apos).
 */

int
defend_against(int move, int color, int apos)
{
  if (trymove(move, color, "defend_against", NO_MOVE, EMPTY, NO_MOVE)) {
    if (safe_move(apos, OTHER_COLOR(color)) == 0) {
      popgo();
      return 1;
    }
    popgo();
  }
  return 0;
}


/* 
 * Returns true if color can cut at (pos), or if connection through (pos)
 * is inhibited. This information is collected by find_cuts(), using the B
 * patterns in the connections database.
 */

int
cut_possible(int pos, int color)
{
  if (color == WHITE)
    return (black_eye[pos].cut
	    || (black_eye[pos].type & INHIBIT_CONNECTION));
  else
    return (white_eye[pos].cut
	    || (white_eye[pos].type & INHIBIT_CONNECTION));
}


/*
 * does_attack(move, str) returns true if the move at (move)
 * attacks (str). This means that it captures the string, and that
 * (str) is not already dead.
 */

int
does_attack(int move, int str)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int result = 0;
  int acode = 0;
  int dcode = 0;
  int spos = NO_MOVE;
  
  if (stackp == 0) {
    if (worm[str].attack_codes[0] != 0 
	&& worm[str].defend_codes[0] == 0)
      return 0;
    spos = worm[str].defense_points[0];
  }
  else {
    attack_and_defend(str, &acode, NULL, &dcode, &spos);
    if (acode != 0 && dcode == 0)
      return 0;
  }
  
  if (trymove(move, other, "does_attack-A", str, EMPTY, NO_MOVE)) {
    if (!board[str] || !find_defense(str, NULL)) {
      result = WIN;
      increase_depth_values();
      if (spos != NO_MOVE && trymove(spos, color, "does_attack-B", str,
				     EMPTY, NO_MOVE)) {
	if (board[str] && !attack(str, NULL))
	  result = 0;
	popgo();
      }
      decrease_depth_values();
    }
    popgo();
  }

  return result;
}


/*
 * does_defend(move, str) returns true if the move at (move)
 * defends (str). This means that it defends the string, and that
 * (str) can be captured if no defense is made.
 */

int
does_defend(int move, int str)
{
  int color = board[str];
  int other = OTHER_COLOR(color);
  int result = 0;
  int spos = NO_MOVE;

  if (stackp == 0) {
    if (worm[str].attack_codes[0] == 0)
      return 0;
    else
      spos = worm[str].attack_points[0];
  }
  else if (!attack(str, &spos))
    return 0;

  gg_assert(spos != NO_MOVE);
  
  if (trymove(move, color, "does_defend-A", str, EMPTY, NO_MOVE)) {
    if (!attack(str, NULL)) {
      result = 1;
      increase_depth_values();
      if (trymove(spos, other, "does_defend-B", str, EMPTY, NO_MOVE)) {
	if (!board[str] || !find_defense(str, NULL))
	  result = 0;
	popgo();
      }
      decrease_depth_values();
    }
    popgo();
  }

  return result;
}


/* 
 * Example: somewhere(WHITE, 2, apos, bpos, cpos).
 * 
 * Returns true if one of the vertices listed
 * satisfies board[pos]==color. Here last_move is the
 * number of moves minus one.
 */

int
somewhere(int color, int last_move, ...)
{
  va_list ap;
  int pos;
  int k;
  
  va_start(ap, last_move);
  for (k = 0; k <= last_move; k++) {
    pos = va_arg(ap, int);

    if (board[pos] == color
	&& (stackp > 0 || dragon[pos].matcher_status != DEAD))
      return 1;
  }

  return 0;
}


/* The function play_break_through_n() plays a sequence of moves,
 * alternating between the players and starting with color. After
 * having played through the sequence, the three last coordinate pairs
 * gives a position to be analyzed by break_through(), to see whether
 * either color has managed to enclose some stones and/or connected
 * his own stones. If any of the three last positions is empty, it's
 * assumed that the enclosure has failed, as well as the attempt to
 * connect.
 *
 * If one or more of the moves to play turns out to be illegal for
 * some reason, the rest of the sequence is played anyway, and
 * break_through() is called as if nothing special happened.
 *
 * Like break_through(), this function returns 1 if the attempt to
 * break through was succesful and 2 if it only managed to cut
 * through.
 */
   
int
play_break_through_n(int color, int num_moves, ...)
{
  va_list ap;
  int mcolor = color;
  int success = 0;
  int i;
  int played_moves = 0;
  int apos;
  int xpos;
  int ypos;
  int zpos;
  
  va_start(ap, num_moves);

  /* Do all the moves with alternating colors. */
  for (i = 0; i < num_moves; i++) {
    apos = va_arg(ap, int);

    if (apos != NO_MOVE
	&& (trymove(apos, mcolor, "play_break_through_n", NO_MOVE,
		    EMPTY, NO_MOVE)
	    || tryko(apos, mcolor, "play_break_through_n", EMPTY, NO_MOVE)))
      played_moves++;
    mcolor = OTHER_COLOR(mcolor);
  }

  /* Now do the real work. */
  xpos = va_arg(ap, int);
  ypos = va_arg(ap, int);
  zpos = va_arg(ap, int);
    
  /* Temporarily increase the depth values with the number of explicitly
   * placed stones.
   */
#if 0
  modify_depth_values(played_moves);
#endif
  
  if (board[xpos] == EMPTY
      || board[ypos] == EMPTY
      || board[zpos] == EMPTY)
    success = 1;
  else
    success = break_through(xpos, ypos, zpos);

#if 0
  modify_depth_values(-played_moves);
#endif
  
  /* Pop all the moves we could successfully play. */
  for (i = 0; i < played_moves; i++)
    popgo();

  va_end(ap);
  return success;
}


/* The function play_attack_defend_n() plays a sequence of moves,
 * alternating between the players and starting with color. After
 * having played through the sequence, the last coordinate pair gives
 * a target to attack or defend, depending on the value of do_attack.
 * If there is no stone present to attack or defend, it is assumed
 * that it has already been captured. If one or more of the moves to
 * play turns out to be illegal for some reason, the rest of the
 * sequence is played anyway, and attack/defense is tested as if
 * nothing special happened.
 *
 * A typical use for these functions is to set up a ladder in an
 * autohelper and see whether it works or not.
 */
   
int
play_attack_defend_n(int color, int do_attack, int num_moves, ...)
{
  va_list ap;
  int mcolor = color;
  int success = 0;
  int i;
  int played_moves = 0;
  int apos;
  int zpos;
  
  va_start(ap, num_moves);

  /* Do all the moves with alternating colors. */
  for (i = 0; i < num_moves; i++) {
    apos = va_arg(ap, int);

    if (apos != NO_MOVE
	&& (trymove(apos, mcolor, "play_attack_defend_n", NO_MOVE,
		    EMPTY, NO_MOVE)
	    || tryko(apos, mcolor, "play_attack_defend_n", EMPTY, NO_MOVE)))
      played_moves++;
    mcolor = OTHER_COLOR(mcolor);
  }

  /* Now do the real work. */
  zpos = va_arg(ap, int);

  /* Temporarily increase the depth values with the number of explicitly
   * placed stones.
   *
   * This improves the reading of pattern constraints but
   * unfortunately tends to be too expensive. For the time being it is
   * disabled.
   */
#if 0
  modify_depth_values(played_moves);
#endif
  
  if (do_attack) {
    if (board[zpos] == EMPTY)
      success = WIN;
    else
      success = attack(zpos, NULL);
  }
  else {
    if (board[zpos] == EMPTY)
      success = 0;
    else {
      int dcode = find_defense(zpos, NULL);
      if (dcode == 0 && !attack(zpos, NULL))
	success = WIN;
      else
	success = dcode;
    }
  }

#if 0
  modify_depth_values(-played_moves);
#endif
  
  /* Pop all the moves we could successfully play. */
  for (i = 0; i < played_moves; i++)
    popgo();

  va_end(ap);
  return success;
}


/* The function play_attack_defend2_n() plays a sequence of moves,
 * alternating between the players and starting with color. After
 * having played through the sequence, the two last coordinate pairs
 * give two targets to simultaneously attack or defend, depending on
 * the value of do_attack. If there is no stone present to attack or
 * defend, it is assumed that it has already been captured. If one or
 * more of the moves to play turns out to be illegal for some reason,
 * the rest of the sequence is played anyway, and attack/defense is
 * tested as if nothing special happened.
 *
 * A typical use for these functions is to set up a crosscut in an
 * autohelper and see whether at least one cutting stone can be
 * captured.
 */
   
int
play_attack_defend2_n(int color, int do_attack, int num_moves, ...)
{
  va_list ap;
  int mcolor = color;
  int success = 0;
  int i;
  int played_moves = 0;
  int apos;
  int ypos;
  int zpos;
  
  va_start(ap, num_moves);

  /* Do all the moves with alternating colors. */
  for (i = 0; i < num_moves; i++) {
    apos = va_arg(ap, int);

    if (apos != NO_MOVE
	&& (trymove(apos, mcolor, "play_attack_defend_n", NO_MOVE,
		    EMPTY, NO_MOVE)
	    || tryko(apos, mcolor, "play_attack_defend_n", EMPTY, NO_MOVE)))
      played_moves++;
    mcolor = OTHER_COLOR(mcolor);
  }

  /* Now do the real work. */
  ypos = va_arg(ap, int);
  zpos = va_arg(ap, int);

  /* Temporarily increase the depth values with the number of explicitly
   * placed stones.
   */
#if 0
  modify_depth_values(played_moves);
#endif
  

  /* FIXED: tm - returns ko results correctly (3.1.22) */
  if (do_attack) {
    if (board[ypos] == EMPTY || board[zpos] == EMPTY)
      success = WIN;
    else
      success = attack_either(ypos, zpos);
  }
  else {
    if (board[ypos] == EMPTY || board[zpos] == EMPTY)
      success = 0;
    else
      success = defend_both(ypos, zpos);
  }

#if 0
  modify_depth_values(-played_moves);
#endif
  
  /* Pop all the moves we could successfully play. */
  for (i = 0; i < played_moves; i++)
    popgo();

  va_end(ap);
  return success;
}


/* FIXME: documentation needs expanding - identical in concept 
 * to play_attack_defend2_n
 */

int 
play_connect_n(int color, int do_connect, int num_moves, ...)
{
  va_list ap;
  int mcolor = color;
  int success = 0;
  int i;
  int played_moves = 0;
  int apos;
  int ypos;
  int zpos;

  /* FIXME: very pessimistic approach if connections module not
   * included. */
  if (!experimental_connections) {
    return do_connect;
  }

  va_start(ap, num_moves);

  /* Do all the moves with alternating colors. */
  for (i = 0; i < num_moves; i++) {
    apos = va_arg(ap, int);

    if (apos != NO_MOVE
	&& (trymove(apos, mcolor, "play_attack_defend_n", NO_MOVE,
		    EMPTY, NO_MOVE)
	    || tryko(apos, mcolor, "play_attack_defend_n", EMPTY, NO_MOVE)))
      played_moves++;
    mcolor = OTHER_COLOR(mcolor);
  }

  /* Now do the real work. */
  ypos = va_arg(ap, int);
  zpos = va_arg(ap, int);

  /* Temporarily increase the depth values with the number of explicitly
   * placed stones.
   *
   * This improves the reading of pattern constraints but
   * unfortunately tends to be too expensive. For the time being it is
   * disabled.
   */
#if 0
  modify_depth_values(played_moves);
#endif
  
  if (do_connect) {
    if (board[ypos] == EMPTY || board[zpos] == EMPTY)
      success = 0;
    else
      success = string_connect(ypos, zpos, NULL);
  }
  else {
    if (board[ypos] == EMPTY || board[zpos] == EMPTY)
      success = WIN;
    else
      success = disconnect(ypos, zpos, NULL);
  }

#if 0
  modify_depth_values(-played_moves);
#endif
  
  /* Pop all the moves we could successfully play. */
  for (i = 0; i < played_moves; i++)
    popgo();

  va_end(ap);
  return success;
}



/* 
 * It is assumed in reading a ladder if stackp >= depth that
 * as soon as a bounding stone is in atari, the string is safe.
 * It is used similarly at other places in reading.c to implement simplifying
 * assumptions when stackp is large. DEPTH is the default value of depth.
 *
 * Unfortunately any such scheme invites the ``horizon effect.'' Increasing
 * DEPTH will make the program stronger and slower.
 *
 */

/* Tactical reading using C functions */
#define DEPTH                16
#define BRANCH_DEPTH         13
#define BACKFILL_DEPTH       12
#define BACKFILL2_DEPTH       5
#define SUPERSTRING_DEPTH     7
#define FOURLIB_DEPTH         7
#define KO_DEPTH              8

#if 0
#undef FOURLIB_DEPTH
#define FOURLIB_DEPTH         9
#endif


#define AA_DEPTH              6
#define AA_THREAT_DEPTH       3

/* Pattern based reading */
#define OWL_DISTRUST_DEPTH    6
#define OWL_BRANCH_DEPTH      8
#define OWL_READING_DEPTH    20
#define OWL_NODE_LIMIT     1000

/* Set the various reading depth parameters. If mandated_depth_value
 * is not -1 that value is used; otherwise the depth values are
 * set as a function of level. The parameter mandated_depth_value
 * can be set at the command line to force a particular value of
 * depth; normally it is -1.
 */

void
set_depth_values(int level)
{
  static int node_limits[10] = {500, 450, 400, 325, 275,
				200, 150, 100, 75, 50};
  if (level >= 10) {
    depth               = gg_max(6, DEPTH - 10 + level);
    ko_depth            = gg_max(1, KO_DEPTH - 10 + level);
    backfill_depth      = gg_max(2, BACKFILL_DEPTH - 10 + level);
    backfill2_depth     = gg_max(1, BACKFILL2_DEPTH - 10 + level);
    superstring_depth   = gg_max(1, SUPERSTRING_DEPTH - 10 + level);
    branch_depth        = gg_max(3, BRANCH_DEPTH - 10 + level);
    fourlib_depth       = gg_max(1, FOURLIB_DEPTH - 10 + level);
    aa_depth            = gg_max(0, AA_DEPTH - 10 + level);
    aa_threat_depth     = gg_max(0, AA_THREAT_DEPTH - 10 + level);
    owl_distrust_depth  = gg_max(1, OWL_DISTRUST_DEPTH - 5 + level/2);
    owl_branch_depth    = gg_max(2, OWL_BRANCH_DEPTH - 5 + level/2);
    owl_reading_depth   = gg_max(5, OWL_READING_DEPTH - 5 + level/2);
    if (level == 10)
      owl_node_limit    = OWL_NODE_LIMIT;
    else
      owl_node_limit    = OWL_NODE_LIMIT * pow(1.5, -10 + level);
    urgent              = 0;
  }
  else if (level > 7) {
    depth               = gg_max(6, DEPTH - 9 + level);
    ko_depth            = gg_max(1, KO_DEPTH - 9 + level);
    backfill_depth      = gg_max(2, BACKFILL_DEPTH - 9 + level);
    backfill2_depth     = gg_max(1, BACKFILL2_DEPTH - 9 + level);
    superstring_depth   = 0 ;
    branch_depth        = gg_max(3, BRANCH_DEPTH - 9 + level);
    if (level < 9)
      fourlib_depth     = gg_max(1, FOURLIB_DEPTH - 8 + level);
    else
      fourlib_depth     = gg_max(1, FOURLIB_DEPTH - 9 + level);
    aa_depth            = gg_max(0, AA_DEPTH - 10 + level);
    aa_threat_depth     = gg_max(0, AA_THREAT_DEPTH - 10 + level);
    owl_distrust_depth  = gg_max(1, OWL_DISTRUST_DEPTH - 5 
			      + (level+1)/2);
    owl_branch_depth    = gg_max(2, OWL_BRANCH_DEPTH - 5 + (level+1)/2);
    owl_reading_depth   = gg_max(5, OWL_READING_DEPTH - 5 + (level+1)/2);
    owl_node_limit      = (OWL_NODE_LIMIT * node_limits[9 - level] /
			   node_limits[0]);
    owl_node_limit      = gg_max(20, owl_node_limit);
    urgent              = 0;
  }
  else if (level == 7) {
    depth               = gg_max(6, DEPTH - 1);
    ko_depth            = gg_max(1, KO_DEPTH - 1);
    backfill_depth      = gg_max(2, BACKFILL_DEPTH - 1);
    backfill2_depth     = gg_max(1, BACKFILL2_DEPTH - 1);
    superstring_depth   = 0 ;
    branch_depth        = gg_max(3, BRANCH_DEPTH - 1);
    if (level < 9)
      fourlib_depth     = gg_max(1, FOURLIB_DEPTH);
    else
      fourlib_depth     = gg_max(1, FOURLIB_DEPTH - 1);
    aa_depth            = gg_max(0, AA_DEPTH - 2);
    aa_threat_depth     = gg_max(0, AA_THREAT_DEPTH - 2);
    owl_distrust_depth  = gg_max(1, OWL_DISTRUST_DEPTH - 1);
    owl_branch_depth    = gg_max(2, OWL_BRANCH_DEPTH - 5 + (level+1)/2);
    owl_reading_depth   = gg_max(5, OWL_READING_DEPTH - 5 + (level+1)/2);
    owl_node_limit      = (OWL_NODE_LIMIT * node_limits[9 - level] /
			   node_limits[0]);
    owl_node_limit      = gg_max(20, owl_node_limit);
    urgent              = 0;
  }
  else if (level < 7) {
    depth               = gg_max(6, DEPTH - 8 + level);
    ko_depth            = gg_max(1, KO_DEPTH - 9 + level);
    backfill_depth      = gg_max(2, BACKFILL_DEPTH - 8 + level);
    backfill2_depth     = gg_max(1, BACKFILL2_DEPTH - 8 + level);
    superstring_depth   = 0 ;
    branch_depth        = gg_max(3, BRANCH_DEPTH - 8 + level);
    if (level < 9)
      fourlib_depth     = gg_max(1, FOURLIB_DEPTH - 7 + level);
    else
      fourlib_depth     = gg_max(1, FOURLIB_DEPTH - 8 + level);
    aa_depth            = gg_max(0, AA_DEPTH - 9 + level);
    aa_threat_depth     = gg_max(0, AA_THREAT_DEPTH - 9 + level);
    owl_distrust_depth  = gg_max(1, OWL_DISTRUST_DEPTH - 5
			      + (level+1)/2);
    owl_branch_depth    = gg_max(2, OWL_BRANCH_DEPTH - 4 + level/2);
    owl_reading_depth   = gg_max(5, OWL_READING_DEPTH - 4 + level/2);
    owl_node_limit      = (OWL_NODE_LIMIT * node_limits[8 - level] /
			   node_limits[0]);
    owl_node_limit      = gg_max(20, owl_node_limit);
    urgent              = 0;
  }


  if (mandated_depth != -1)
    depth = mandated_depth;
  if (mandated_backfill_depth != -1)
    backfill_depth = mandated_backfill_depth;
  if (mandated_backfill2_depth != -1)
    backfill2_depth = mandated_backfill2_depth;
  if (mandated_superstring_depth != -1)
    superstring_depth = mandated_superstring_depth;
  if (mandated_fourlib_depth != -1)
    fourlib_depth = mandated_fourlib_depth;
  if (mandated_ko_depth != -1)
    ko_depth = mandated_ko_depth;
  if (mandated_branch_depth != -1)
    branch_depth = mandated_branch_depth;
  if (mandated_aa_depth != -1)
    aa_depth = mandated_aa_depth;
  if (mandated_aa_threat_depth != -1)
    aa_threat_depth = mandated_aa_threat_depth;
  if (mandated_owl_distrust_depth != -1)
    owl_distrust_depth = mandated_owl_distrust_depth;
  if (mandated_owl_branch_depth != -1)
    owl_branch_depth = mandated_owl_branch_depth;
  if (mandated_owl_reading_depth != -1)
    owl_reading_depth = mandated_owl_reading_depth;
  if (mandated_owl_node_limit != -1)
    owl_node_limit = mandated_owl_node_limit;
}


/*
 * Modify the various tactical reading depth parameters. This is
 * typically used to avoid horizon effects. By temporarily increasing
 * the depth values when trying some move, one can avoid that an
 * irrelevant move seems effective just because the reading hits a
 * depth limit earlier than it did when reading only on relevant
 * moves.
 */

void
modify_depth_values(int n)
{
  depth              += n;
  backfill_depth     += n;
  backfill2_depth    += n;
  superstring_depth  += n;
  branch_depth       += n;
  fourlib_depth      += n;
  ko_depth           += n;
}

void
increase_depth_values(void)
{
  modify_depth_values(1);
}

void
decrease_depth_values(void)
{
  modify_depth_values(-1);
}

/* These functions allow more drastic temporary modifications of the
 * depth values. Typical use is to turn certain depth values way down
 * for reading where speed is more important than accuracy, e.g. for
 * the influence function.
 */

static int save_depth;
static int save_backfill_depth;
static int save_backfill2_depth;
static int save_superstring_depth;
static int save_branch_depth;
static int save_fourlib_depth;
static int save_ko_depth;

/* Currently this function is never called. */

void
set_temporary_depth_values(int d, int b, int f, int k, int br, int b2, int ss)
{
  save_depth             = depth;
  save_backfill_depth    = backfill_depth;
  save_backfill2_depth   = backfill2_depth;
  save_superstring_depth = superstring_depth;
  save_branch_depth      = branch_depth;
  save_fourlib_depth     = fourlib_depth;
  save_ko_depth          = ko_depth;

  depth             = d;
  backfill_depth    = b;
  backfill2_depth   = b2;
  superstring_depth = ss;
  branch_depth      = br;
  fourlib_depth     = f;
  ko_depth          = k;
}

void
restore_depth_values()
{
  depth             = save_depth;
  backfill_depth    = save_backfill_depth;
  backfill2_depth   = save_backfill2_depth;
  superstring_depth = save_superstring_depth;
  branch_depth      = save_branch_depth;
  fourlib_depth     = save_fourlib_depth;
  ko_depth          = save_ko_depth;
}

/* Play a stone at (pos) and count the number of liberties for the
 * resulting string. This requires (pos) to be empty.
 *
 * This function differs from approxlib() by the fact that it removes
 * captured stones before counting the liberties.
 */

int
accurate_approxlib(int pos, int color, int maxlib, int *libs)
{
  int fast_liberties = -1;
  int liberties = 0;
  SGFTree *save_sgf_dumptree = sgf_dumptree;
  int save_count_variations = count_variations;

  ASSERT1(board[pos] == EMPTY, pos);
  ASSERT1(IS_STONE(color), pos);

  if (!libs) {
    fast_liberties = fastlib(pos, color, 0);
    if (fast_liberties >= 0) {
      return fast_liberties;
    } 
  }

  sgf_dumptree = 0;
  /* Use tryko() since we don't care whether the move would violate
   * the ko rule.
   */
  if (tryko(pos, color, "accurate approxlib", EMPTY, 0)) {
    if (libs != NULL)
      liberties = findlib(pos, maxlib, libs);
    else
      liberties = countlib(pos);
    popgo();
  }

  if (fast_liberties >= 0 && liberties > 0) {
    ASSERT1(fast_liberties == liberties, pos);
  }

  sgf_dumptree = save_sgf_dumptree;
  count_variations = save_count_variations;

  return liberties;
}


/* This function will detect some blunders. If the move reduces the
 * number of liberties of an adjacent friendly string, there is a
 * danger that the move could backfire, so the function checks that no
 * friendly worm which was formerly not attackable becomes attackable,
 * and it checks that no opposing worm which was not defendable
 * becomes defendable. Only worms with worm.size>size are checked.
 *
 * The arrays saved_dragons[] and saved_worms[] should be one for
 * stones belonging to dragons or worms respectively, which are
 * supposedly saved by (move). These may be NULL if no stones are
 * supposed to gaving been saved.
 *
 * For use when called from fill_liberty, this function may optionally
 * return a point of defense, which, if taken, will presumably make
 * the move at (move) safe on a subsequent turn.
 *
 * FIXME: Most TRACE calls below are ineffective because we have
 * decreased the verbose value to avoid traces in the owl code.
 */

int
confirm_safety(int move, int color, int size, int *defense_point,
	       int saved_dragons[BOARDMAX], int saved_worms[BOARDMAX])
{
  int libs[5];
  int liberties = accurate_approxlib(move, color, 5, libs);
  int other = OTHER_COLOR(color);
  int issafe = 1;
  int pos;
  int apos;
  int trouble = 0;
  int k;
  int save_verbose = verbose;

  if (defense_point)
    *defense_point = NO_MOVE;

  TRACE("Checking safety of a %s move at %1m\n", color_to_string(color), move);

  if (verbose > 0)
    verbose--;
  
  if (!atari_atari_confirm_safety(color, move, &apos, size,
				  saved_dragons, saved_worms)) {
    ASSERT_ON_BOARD1(apos);
    if (defense_point)
      *defense_point = apos;
    verbose = save_verbose;
    TRACE("Combination attack appears at %1m.\n", apos);
    return 0;
  }

  if (liberties > 4) {
    verbose = save_verbose;
    return 1;
  }

  for (k = 0; k < 4; k++) {
    int bpos = move + delta[k];
    if (board[bpos] == color
	&& liberties <= worm[bpos].liberties) {
      trouble = 1;
      if ((dragon[bpos].matcher_status == ALIVE
	   || (dragon[bpos].matcher_status == CRITICAL
	       && saved_dragons != NULL
	       && saved_dragons[bpos]))
	  && DRAGON2(bpos).safety != INVINCIBLE
	  && DRAGON2(bpos).safety != STRONGLY_ALIVE
	  && dragon[bpos].size >= size
	  && !owl_confirm_safety(move, bpos, defense_point)) {
	verbose = save_verbose;
	return 0;
      }
    }
  }

  if (!trouble) {
    verbose = save_verbose;
    return 1;
  }

  /* Need to increase the depth values during this reading to avoid
   * horizon effects.
   */
  increase_depth_values();
  
  if (trymove(move, color, NULL, NO_MOVE, EMPTY, NO_MOVE)) {
    for (pos = BOARDMIN; issafe && pos < BOARDMAX; pos++)
      if (issafe
	  && IS_STONE(board[pos])
	  && worm[pos].origin == pos
	  && pos != move) {
	if (board[pos] == color
	    && worm[pos].attack_codes[0] == 0
	    && worm[pos].size >= size
	    && attack(pos, NULL)) {
	  if (defense_point)
	    find_defense(pos, defense_point);
	  issafe = 0;
	  TRACE("After %1m Worm at %1m becomes attackable.\n", move, pos);
	}
	else if (board[pos] == other
		 && worm[pos].attack_codes[0] != 0
		 && worm[pos].defend_codes[0] == 0
		 && worm[pos].size >= size
		 && find_defense(pos, NULL)) {
	  /* Also ask the owl code whether the string can live
	   * strategically. To do this we need to temporarily undo
	   * the trymove().
	   */
	  popgo();
	  decrease_depth_values();
	  if (owl_does_attack(move, pos) != WIN)
	    issafe = 0;
	  trymove(move, color, NULL, NO_MOVE, EMPTY, NO_MOVE);
	  increase_depth_values();
	  
	  if (!issafe) {
	    if (defense_point) {
	      int dpos;
	      if (attack(pos, &dpos))
		*defense_point = dpos;
	      else
		TRACE("No attack found (unexpectedly) on %1m after move at %1m.\n",
		      pos, move);
	    }
	    
	    TRACE("After %1m worm at %1m becomes defendable.\n",
		  move, pos);
	  }
	}
      }
    
    if (liberties == 2) {
      if (double_atari(libs[0], other)) {
	if (defense_point && safe_move(libs[0], color) == WIN)
	  *defense_point = libs[0];
	issafe = 0;
	TRACE("Double threat appears at %1m.\n", libs[0]);
      }
      else if (double_atari(libs[1], other)) {
	if (defense_point && safe_move(libs[1], color) == WIN)
	  *defense_point = libs[1];
	issafe = 0;
	TRACE("Double threat appears at %1m.\n", libs[1]);
      }
    }
    popgo();
  }
  
  /* Reset the depth values. */
  decrease_depth_values();
  verbose = save_verbose;
  return issafe;
}


/* Returns true if a move by (color) fits the following shape:
 * 
 *
 *    X*        (O=color)
 *    OX
 * 
 * capturing one of the two X strings. The name is a slight
 * misnomer since this includes attacks which are not necessarily
 * double ataris, though the common double atari is the most
 * important special case.
 */

int
double_atari(int move, int color)
{
  int other = OTHER_COLOR(color);
  int k;
  int m = I(move);
  int n = J(move);

  if (!ON_BOARD(move))
    return 0;

  /* Loop over the diagonal directions. */
  for (k = 4; k < 8; k++) {
    int dm = deltai[k];
    int dn = deltaj[k];
    
    /* because (m, n) and (m+dm, n+dn) are opposite
     * corners of a square, ON_BOARD2(m, n) && ON_BOARD2(m+dm, n+dn)
     * implies ON_BOARD2(m+dm, n) and ON_BOARD2(n, n+dn)
     */
    if (BOARD(m+dm, n+dn) == color
	&& BOARD(m, n+dn) == other
	&& BOARD(m+dm, n) == other
	&& trymove(move, color, "double_atari", NO_MOVE, EMPTY, NO_MOVE)) {
      if (countlib(move) > 1
	  && (BOARD(m, n+dn) == EMPTY || BOARD(m+dm, n) == EMPTY 
	      || !defend_both(POS(m, n+dn), POS(m+dm, n)))) {
	popgo();
	return 1;
      }
      popgo();
    }
  }
  
  return 0;
}
    

/* Find those worms of the given color that can never be captured,
 * even if the opponent is allowed an arbitrary number of consecutive
 * moves. The coordinates of the origins of these worms are written to
 * the worm arrays and the number of non-capturable worms is
 * returned.
 *
 * The algorithm is to cycle through the worms until none remains or
 * no more can be captured. A worm is removed when it is found to be
 * capturable, by letting the opponent try to play on all its
 * liberties. If the attack fails, the moves are undone. When no more
 * worm can be removed in this way, the remaining ones are
 * unconditionally alive.
 *
 * After this, unconditionally dead opponent worms and unconditional
 * territory are identified. To find these, we continue from the
 * position obtained at the end of the previous operation (only
 * unconditionally alive strings remain for color) with the following
 * steps:
 *
 * 1. Play opponent stones on all liberties of the unconditionally
 *    alive strings except where illegal. (That the move order may
 *    determine exactly which liberties can be played legally is not
 *    important. Just pick an arbitrary order).
 * 2. Recursively extend opponent strings in atari, except where this
 *    would be suicide.
 * 3. Play an opponent stone anywhere it can get two empty
 *    neighbors. (I.e. split big eyes into small ones).
 * 4. Play an opponent stone anywhere it can get one empty
 *    neighbor. (I.e. reduce two space eyes to one space eyes.)
 *
 * Remaining opponent strings in atari and remaining liberties of the
 * unconditionally alive strings constitute the unconditional
 * territory.
 *
 * Opponent strings from the initial position placed on
 * unconditional territory are unconditionally dead.
 *
 * On return, unconditional_territory[][] is 1 where color has
 * unconditionally alive stones, 2 where it has unconditional
 * territory, and 0 otherwise.
 */

void
unconditional_life(int unconditional_territory[BOARDMAX], int color)
{
  int something_captured = 1; /* To get into the first turn of the loop. */
  int found_one;
  int moves_played = 0;
  int save_moves;
  int m, n;
  int k;
  int libs[MAXLIBS];
  int liberties;
  int other = OTHER_COLOR(color);
  
  while (something_captured) {
    /* Nothing captured so far in this turn of the loop. */
    something_captured = 0;

    /* Visit all friendly strings on the board. */
    for (m = 0; m < board_size; m++)
      for (n = 0; n < board_size; n++) {
	int ii = POS(m, n);
	if (board[ii] != color || !is_worm_origin(ii, ii))
	  continue;
	
	/* Try to capture the worm at (m, n). */
	liberties = findlib(ii, MAXLIBS, libs);
	save_moves = moves_played;
	for (k = 0; k < liberties; k++) {
	  if (trymove(libs[k], other, "unconditional_life", ii, EMPTY, 0))
	    moves_played++;
	}

	/* Successful if already captured or a single liberty remains.
	 * Otherwise we must rewind and take back the last batch of moves.
	 */
	if (board[ii] == EMPTY)
	  something_captured = 1;
	else if (findlib(ii, 2, libs) == 1) {
	  /* Need to use tryko as a defense against the extreme case
           * when the only opponent liberty that is not suicide is an
           * illegal ko capture, like in this 5x5 position:
	   * +-----+
	   * |.XO.O|
	   * |XXOO.|
	   * |X.XOO|
	   * |XXOO.|
	   * |.XO.O|
	   * +-----+
	   */
	  int success = tryko(libs[0], other, "unconditional_life", EMPTY, 0);
	  gg_assert(success);
	  moves_played++;
	  something_captured++;
	}
	else
	  while (moves_played > save_moves) {
	    popgo();
	    moves_played--;
	  }
      }
  }

  /* The strings still remaining are uncapturable. Now see which
   * opponent strings can survive.
   *
   * 1. Play opponent stones on all liberties of the unconditionally
   *    alive strings except where illegal.
   */
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      int ii = POS(m, n);
      if (board[ii] != color || !is_worm_origin(ii, ii))
	continue;
      
      /* Play as many liberties as we can. */
      liberties = findlib(ii, MAXLIBS, libs);
      for (k = 0; k < liberties; k++) {
	if (trymove(libs[k], other, "unconditional_life", ii, EMPTY, 0))
	  moves_played++;
      }
    }

  /* 2. Recursively extend opponent strings in atari, except where this
   *    would be suicide.
   */
  found_one = 1;
  while (found_one) {
    /* Nothing found so far in this turn of the loop. */
    found_one = 0;

    for (m = 0; m < board_size; m++)
      for (n = 0; n < board_size; n++) {
	int ii = POS(m, n);
	if (board[ii] != other || countlib(ii) > 1)
	  continue;
	
	/* Try to extend the string at (m, n). */
	findlib(ii, 1, libs);
	if (trymove(libs[0], other, "unconditional_life", ii, EMPTY, 0)) {
	  moves_played++;
	  found_one = 1;
	}
      }
  }

  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      int ii = POS(m, n);
      int aa;
      int bb;
      int aopen, bopen;
      int alib, blib;
      if (board[ii] != other || countlib(ii) != 2)
	continue;
      findlib(ii, 2, libs);
      aa = libs[0];
      bb = libs[1];
      if (abs(I(aa) - I(bb)) + abs(J(aa) - J(bb)) != 1)
	continue;

      /* Only two liberties and these are adjacent. Play one. We want
       * to maximize the number of open liberties. In this particular
       * situation we can count this with approxlib for the opposite
       * color. If the number of open liberties is the same, we
       * maximize the total number of obtained liberties.
       * Two relevant positions:
       *
       * |XXX. 
       * |OOXX    |XXXXXXX
       * |O.OX    |OOXOOOX
       * |..OX    |..OO.OX
       * +----    +-------
       */
      aopen = approxlib(aa, color, 4, NULL);
      bopen = approxlib(bb, color, 4, NULL);
      alib  = approxlib(aa, other, 4, NULL);
      blib  = approxlib(bb, other, 4, NULL);

      if (aopen > bopen || (aopen == bopen && alib >= blib)) {
	trymove(aa, other, "unconditional_life", ii, EMPTY, 0);
	moves_played++;
      }
      else {
	trymove(bb, other, "unconditional_life", ii, EMPTY, 0);
	moves_played++;
      }
    }

  /* Identify unconditionally alive stones and unconditional territory. */
  memset(unconditional_territory, 0, sizeof(int) * BOARDMAX);
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      int ii = POS(m, n);

      if (board[ii] == color) {
	unconditional_territory[ii] = 1;
	if (is_worm_origin(ii, ii)) {
	  liberties = findlib(ii, MAXLIBS, libs);
	  for (k = 0; k < liberties; k++)
	    unconditional_territory[libs[k]] = 2;
	}
      }
      else if (board[ii] == other && countlib(ii) == 1) {
	unconditional_territory[ii] = 2;
	findlib(ii, 1, libs);
	unconditional_territory[libs[0]] = 2;
      }
    }

  /* Take back all moves. */
  while (moves_played > 0) {
    popgo();
    moves_played--;
  }
}


/* Score the game and determine the winner */

void
who_wins(int color, FILE *outfile)
{
  float result;

#if 0
  float white_score;
  float black_score;
  int winner;
#endif

  if (color != BLACK && color != WHITE)
    color = BLACK;

#if 0
  /* Use the aftermath code to compute the final score. (Slower but
   * more reliable.) 
   */
  result = aftermath_compute_score(color, komi);
  if (result > 0.0)
    winner = WHITE;
  else {
    winner = BLACK;
    result = -result;
  }
#endif

  result = estimate_score(NULL, NULL);
  if (result == 0.0)
    fprintf(outfile, "Result: jigo   ");
  else
    fprintf(outfile, "Result: %c+%.1f   ",
	    (result > 0.0) ? 'W' : 'B', gg_abs(result));
}



/* Find the stones of an extended string, where the extensions are
 * through the following kinds of connections:
 *
 * 1. Solid connections (just like ordinary string).
 *
 *    OO
 *
 * 2. Diagonal connection or one space jump through an intersection
 *    where an opponent move would be suicide or self-atari.
 *
 *    ...
 *    O.O
 *    XOX
 *    X.X
 *
 * 3. Bamboo joint.
 *
 *    OO
 *    ..
 *    OO
 *
 * 4. Diagonal connection where both adjacent intersections are empty.
 *
 *    .O
 *    O.
 *
 * 5. Connection through adjacent or diagonal tactically captured stones.
 *    Connections of this type are omitted when the superstring code is
 *    called from reading.c, but included when the superstring code is
 *    called from owl.c
 */

static void
do_find_superstring(int str, int *num_stones, int *stones,
		    int *num_lib, int *libs, int maxlibs,
		    int *num_adj, int *adjs, int liberty_cap,
		    int proper, int type);

static void
superstring_add_string(int str,
		       int *num_my_stones, int *my_stones,
		       int *num_stones, int *stones,
		       int *num_libs, int *libs, int maxlibs,
		       int *num_adj, int *adjs, int liberty_cap,
		       char mx[BOARDMAX],
		       char ml[BOARDMAX],
		       char ma[BOARDMAX],
		       int do_add);

void
find_superstring(int str, int *num_stones, int *stones)
{
  do_find_superstring(str, num_stones, stones,
		      NULL, NULL, 0,
		      NULL, NULL, 0,
		      0, 1);
}


/* This function computes the superstring at (str) as described above,
 * but omitting connections of type 5. Then it constructs a list of
 * liberties of the superstring which are not already liberties of
 * (str).
 *
 * If liberty_cap is nonzero, only liberties of substrings of the
 * superstring which have fewer than liberty_cap liberties are
 * generated.
 */

void
find_superstring_liberties(int str,
			   int *num_libs, int *libs, int liberty_cap)
{
  do_find_superstring(str, NULL, NULL,
		      num_libs, libs, MAX_LIBERTIES,
		      NULL, NULL, liberty_cap,
		      0, 0);
}

/* This function is the same as find_superstring_liberties, but it
 * omits those liberties of the string (str), presumably since
 * those have already been treated elsewhere.
 *
 * If liberty_cap is nonzero, only liberties of substrings of the
 * superstring which have at most liberty_cap liberties are
 * generated.
 */

void
find_proper_superstring_liberties(int str, 
				  int *num_libs, int *libs, 
				  int liberty_cap)
{
  do_find_superstring(str, NULL, NULL,
		      num_libs, libs, MAX_LIBERTIES,
		      NULL, NULL, liberty_cap,
		      1, 0);
}

/* This function computes the superstring at (str) as described above,
 * but omitting connections of type 5. Then it constructs a list of
 * liberties of the superstring which are not already liberties of
 * (str).
 *
 * If liberty_cap is nonzero, only liberties of substrings of the
 * superstring which have fewer than liberty_cap liberties are
 * generated.
 */

void
find_superstring_stones_and_liberties(int str,
				      int *num_stones, int *stones,
				      int *num_libs, int *libs,
				      int liberty_cap)
{
  do_find_superstring(str, num_stones, stones,
		      num_libs, libs, MAX_LIBERTIES,
		      NULL, NULL, liberty_cap,
		      0, 0);
}

/* analogous to chainlinks, this function finds boundary chains of the
 * superstring at (str), including those which are boundary chains of
 * (str) itself. If liberty_cap != 0, only those boundary chains with
 * <= liberty_cap liberties are reported.
 */

void
superstring_chainlinks(int str, 
		       int *num_adj, int adjs[MAXCHAIN],
		       int liberty_cap)
{
  do_find_superstring(str, NULL, NULL,
		      NULL, NULL, 0,
		      num_adj, adjs, liberty_cap,
		      0, 2);
}


/* analogous to chainlinks, this function finds boundary chains of the
 * superstring at (str), omitting those which are boundary chains of
 * (str) itself. If liberty_cap != 0, only those boundary chains with
 * <= liberty_cap liberties are reported.
 */

void
proper_superstring_chainlinks(int str,
			      int *num_adj, int adjs[MAXCHAIN],
			      int liberty_cap)
{
  do_find_superstring(str, NULL, NULL,
		      NULL, NULL, 0,
		      num_adj, adjs, liberty_cap,
		      1, 2);
}

/* Do the real work finding the superstring and recording stones,
 * liberties, and/or adjacent strings.
 */
static void
do_find_superstring(int str, int *num_stones, int *stones,
		    int *num_libs, int *libs, int maxlibs,
		    int *num_adj, int *adjs, int liberty_cap,
		    int proper, int type)
{
  int num_my_stones;
  int my_stones[MAX_BOARD * MAX_BOARD];
  
  char mx[BOARDMAX]; /* stones */
  char ml[BOARDMAX]; /* liberties */
  char ma[BOARDMAX]; /* adjacent strings */

  int k, l, r;
  int color = board[str];
  int other = OTHER_COLOR(color);

  memset(mx, 0, sizeof(mx));
  memset(ml, 0, sizeof(ml));
  memset(ma, 0, sizeof(ma));

  if (num_stones)
    *num_stones = 0;
  if (num_libs)
    *num_libs = 0;
  if (num_adj)
    *num_adj = 0;

  /* Include the string itself in the superstring. Only record stones,
   * liberties, and/or adjacent strings if proper==0.
   */
  num_my_stones = 0;
  superstring_add_string(str, &num_my_stones, my_stones,
			 num_stones, stones,
			 num_libs, libs, maxlibs,
			 num_adj, adjs, liberty_cap,
			 mx, ml, ma,
			 !proper);

  /* Loop over all found stones, looking for more strings to include
   * in the superstring. The loop is automatically extended over later
   * found stones as well.
   */
  for (r = 0; r < num_my_stones; r++) {
    int pos = my_stones[r];

    for (k = 0; k < 4; k++) {
      /* List of relative coordinates. (pos) is marked by *.
       *
       *  ef.
       *  gb.
       *  *ac
       *  .d.
       *
       */
      int right = delta[k];
      int up = delta[(k+1)%4];
      
      int apos = pos + right;
      int bpos = pos + right + up;
      int cpos = pos + 2*right;
      int dpos = pos + right - up;
      int epos = pos + 2*up;
      int fpos = pos + right + 2*up;
      int gpos = pos + up;
      int unsafe_move;
      
      if (!ON_BOARD(apos))
	continue;
      
      /* Case 1. Nothing to do since stones are added string by string. */
            
      /* Case 2. */
      if (board[apos] == EMPTY) {
	if (type == 2)
	  unsafe_move = (approxlib(apos, other, 2, NULL) < 2);
	else
	  unsafe_move = is_self_atari(apos, other);
	
	if (unsafe_move && type == 1 && is_ko(apos, other, NULL))
	  unsafe_move = 0;
	
	if (unsafe_move) {
	  if (board[bpos] == color && !mx[bpos])
	    superstring_add_string(bpos, &num_my_stones, my_stones,
				   num_stones, stones,
				   num_libs, libs, maxlibs,
				   num_adj, adjs, liberty_cap,
				   mx, ml, ma, 1);
	  if (board[cpos] == color && !mx[cpos])
	    superstring_add_string(cpos, &num_my_stones, my_stones,
				   num_stones, stones,
				   num_libs, libs, maxlibs,
				   num_adj, adjs, liberty_cap,
				   mx, ml, ma, 1);
	  if (board[dpos] == color && !mx[dpos])
	    superstring_add_string(dpos, &num_my_stones, my_stones,
				   num_stones, stones,
				   num_libs, libs, maxlibs,
				   num_adj, adjs, liberty_cap,
				   mx, ml, ma, 1);
	}
      }
      
      /* Case 3. */
      /* Notice that the order of these tests is significant. We must
       * check bpos before fpos and epos to avoid accessing memory
       * outside the board array. (Notice that fpos is two steps away
       * from pos, which we know is on the board.)
       */
      if (board[apos] == color && board[bpos] == EMPTY
	  && board[fpos] == color && board[epos] == color && !mx[epos]
	  && board[gpos] == EMPTY)
	superstring_add_string(epos, &num_my_stones, my_stones,
			       num_stones, stones,
			       num_libs, libs, maxlibs,
			       num_adj, adjs, liberty_cap,
			       mx, ml, ma, 1);
      /* Don't bother with f, it is part of the string just added. */
      
      /* Case 4. */
      if (board[bpos] == color && !mx[bpos]
	  && board[apos] == EMPTY && board[gpos] == EMPTY)
	superstring_add_string(bpos, &num_my_stones, my_stones,
			       num_stones, stones,
			       num_libs, libs, maxlibs,
			       num_adj, adjs, liberty_cap,
			       mx, ml, ma, 1);
      
      /* Case 5. */
      if (type == 1)
	for (l = 0; l < 2; l++) {
	  int upos;
	  
	  if (l == 0) {
	    /* adjacent lunch */
	    upos = apos;
	  }
	  else {
	    /* diagonal lunch */
	    upos = bpos;
	  }
	  
	  if (board[upos] != other)
	    continue;
	  
	  upos = find_origin(upos);
	  
	  /* Only do the reading once. */
	  if (mx[upos] == 1)
	    continue;
	  
	  mx[upos] = 1;
	  
	  if (attack(upos, NULL)
	      && !find_defense(upos, NULL)) {
	    int lunch_stones[MAX_BOARD*MAX_BOARD];
	    int num_lunch_stones = findstones(upos, MAX_BOARD*MAX_BOARD,
					      lunch_stones);
	    int r, s;
	    for (r = 0; r < num_lunch_stones; r++)
	      for (s = 0; s < 8; s++) {
		int vpos = lunch_stones[r] + delta[s];
		if (board[vpos] == color && !mx[vpos])
		  superstring_add_string(vpos,
					 &num_my_stones, my_stones,
					 num_stones, stones,
					 num_libs, libs, maxlibs,
					 num_adj, adjs, liberty_cap,
					 mx, ml, ma, 1);
	      }
	  }
	}
      if (num_libs && maxlibs > 0 && *num_libs >= maxlibs)
	return;
    }
  }
}

/* Add a new string to a superstring. Record stones, liberties, and
 * adjacent strings as asked for.
 */
static void
superstring_add_string(int str,
		       int *num_my_stones, int *my_stones,
		       int *num_stones, int *stones,
		       int *num_libs, int *libs, int maxlibs,
		       int *num_adj, int *adjs, int liberty_cap,
		       char mx[BOARDMAX],
		       char ml[BOARDMAX],
		       char ma[BOARDMAX],
		       int do_add)
{
  int num_my_libs;
  int my_libs[MAXLIBS];
  int num_my_adj;
  int my_adjs[MAXCHAIN];
  int new_stones;
  int k;
  
  ASSERT1(mx[str] == 0, str);

  /* Pick up the stones of the new string. */
  new_stones = findstones(str, board_size * board_size,
			  &(my_stones[*num_my_stones]));
  
  mark_string(str, mx, 1);
  if (stones) {
    gg_assert(num_stones);
    for (k = 0; k < new_stones; k++) {
      if (do_add) {
	stones[*num_stones] = my_stones[*num_my_stones + k];
	(*num_stones)++;
      }
    }
  }
  (*num_my_stones) += new_stones;

  /* Pick up the liberties of the new string. */
  if (libs) {
    gg_assert(num_libs);
    /* Get the liberties of the string. */
    num_my_libs = findlib(str, MAXLIBS, my_libs);

    /* Remove this string from the superstring if it has too many
     * liberties.
     */
    if (liberty_cap > 0 && num_my_libs > liberty_cap)
      (*num_my_stones) -= new_stones;

    for (k = 0; k < num_my_libs; k++) {
      if (ml[my_libs[k]])
	continue;
      ml[my_libs[k]] = 1;
      if (do_add && (liberty_cap == 0 || num_my_libs <= liberty_cap)) {
	libs[*num_libs] = my_libs[k];
	(*num_libs)++;
	if (*num_libs == maxlibs)
	  break;
      }
    }
  }

  /* Pick up adjacent strings to the new string. */
  if (adjs) {
    gg_assert(num_adj);
    num_my_adj = chainlinks(str, my_adjs);
    for (k = 0; k < num_my_adj; k++) {
      if (liberty_cap > 0 && countlib(my_adjs[k]) > liberty_cap)
	continue;
      if (ma[my_adjs[k]])
	continue;
      ma[my_adjs[k]] = 1;
      if (do_add) {
	adjs[*num_adj] = my_adjs[k];
	(*num_adj)++;
      }
    }
  }
}

/* Internal timers for assessing time spent on various tasks. */
#define NUMBER_OF_TIMERS 4
double timers[NUMBER_OF_TIMERS];

/* Start a timer. */
void
start_timer(int n)
{
  gg_assert(n >= 0 && n < NUMBER_OF_TIMERS);
  if (!showtime)
    return;

  timers[n] = gg_cputime();
}

/* Report time spent and restart the timer. Make no report if elapsed
 * time is less than mintime.
 */
double
time_report(int n, const char *occupation, int move, double mintime)
{
  double t;
  double dt;
  gg_assert(n >= 0 && n < NUMBER_OF_TIMERS);

  if (!showtime)
    return 0.0;

  t = gg_cputime();
  dt = t - timers[n];
  if (dt > mintime) {
    gprintf("%s", occupation);
    if (move != NO_MOVE)
      gprintf("%1m", move);
    fprintf(stderr, ": %.2f sec\n", dt);
  }
  timers[n] = t;
  return dt;
}

/* Update the random seed with the current value in the random sequence. */
void
update_random_seed(void)
{
  random_seed = gg_rand();
  /* Since random seed 0 has a special interpretation when given as
   * command line argument with the -r option, we make sure to avoid
   * it.
   */
  if (random_seed == 0)
    random_seed = 1;
}


/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */



/* value_moves.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* #include <stdio.h> */
/* #include <stdlib.h> */
/* #include <string.h> */
/* #include <math.h> */

/* #include "gnugo.h" */
/* #include "liberty.h" */
/* #include "gg_utils.h" */


/*mgena*/
/*#include "move_reasons.h"*/


/* Test all moves which defend, attack, connect or cut to see if they
 * also attack or defend some other worm.
 *
 * FIXME: We would like to see whether an arbitrary move works to cut
 *        or connect something else too.
 *
 * FIXME: Keep track of ko results.
 */

static void
find_more_attack_and_defense_moves(int color)
{
  int unstable_worms[MAX_WORMS];
  int N = 0;  /* number of unstable worms */
  int m, n;
  int ii;
  int k;
  int other = OTHER_COLOR(color);
  int cursor_at_start_of_line;
  
  TRACE("\nLooking for additional attack and defense moves. Trying moves ...\n");
  
  /* Identify the unstable worms and store them in a list. */
  for (m = 0; m < board_size; m++)
    for (n = 0; n  <board_size; n++) {
      ii = POS(m, n);

      if (board[ii]
	  && worm[ii].origin == ii
	  && worm[ii].attack_codes[0] != 0
	  && worm[ii].defend_codes[0] != 0) {
	unstable_worms[N] = find_worm(ii);
	N++;
      }
    }
  
  /* To avoid horizon effects, we temporarily increase the depth values. */
  increase_depth_values();
  
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      ii = POS(m, n);

      for (k = 0; k < MAX_REASONS; k++) {
	int r = move[ii].reason[k];
	int what;

	if (r < 0)
	  break;
	what = move_reasons[r].what;
	if (move_reasons[r].type == ATTACK_MOVE
	    || move_reasons[r].type == ATTACK_MOVE_GOOD_KO
	    || move_reasons[r].type == ATTACK_MOVE_BAD_KO
	    || move_reasons[r].type == DEFEND_MOVE
	    || move_reasons[r].type == DEFEND_MOVE_GOOD_KO
	    || move_reasons[r].type == DEFEND_MOVE_BAD_KO
	    || move_reasons[r].type == CONNECT_MOVE
	    || move_reasons[r].type == CUT_MOVE)
	  break;
	/* FIXME: Add code for EITHER_MOVE and ALL_MOVE here. */
      }
      
      if (k == MAX_REASONS || move[ii].reason[k] == -1)
	continue;

      /* Try the move at (ii) and see what happens. */
      cursor_at_start_of_line = 0;
      TRACE("%1m ", ii);
      if (trymove(ii, color, "find_more_attack_and_defense_moves",
		  NO_MOVE, EMPTY, NO_MOVE)) {
	for (k = 0; k < N; k++) {
	  int aa = worms[unstable_worms[k]];

	  /* string of our color, see if there still is an attack,
	   * unless we already know the move works as defense move.
	   */
	  if (board[aa] == color
	      && !defense_move_reason_known(ii, unstable_worms[k]))
	    if (!attack(aa, NULL)) {
	      if (!cursor_at_start_of_line)
		TRACE("\n");
	      TRACE("%ofound extra point of defense of %1m at %1m\n", 
		    aa, ii);
	      cursor_at_start_of_line = 1;
	      add_defense_move(ii, aa, WIN);
	    }
	    
	  /* string of opponent color, see if there still is a defense,
	   * unless we already know the move works as attack move.
	   */
	  if (board[aa] == other
	      && !attack_move_reason_known(ii, unstable_worms[k]))
	    if (!find_defense(aa, NULL)) {
	      /* Maybe find_defense() doesn't find the defense. Try to
	       * defend with the stored defense move.
	       */
	      int attack_works = 1;

	      if (trymove(worm[aa].defense_points[0], other, 
			  "find_more_attack_and_defense_moves", 0,
			  EMPTY, 0)) {
		if (!attack(aa, NULL))
		  attack_works = 0;
		popgo();
	      }
		
	      if (attack_works) {
		if (!cursor_at_start_of_line)
		  TRACE("\n");
		TRACE("%ofound extra point of attack of %1m at %1m\n",
		      aa, ii);
		cursor_at_start_of_line = 1;
		add_attack_move(ii, aa, WIN);
	      }
	    }
	}
	popgo();
      }
    }
  
  TRACE("\n");
  decrease_depth_values();
}


/* Test certain moves to see whether they (too) can owl attack or
 * defend an owl critical dragon. Tested moves are
 * 1. Strategical attacks or defenses for the dragon.
 * 2. Vital eye points for the dragon.
 * 3. Tactical attacks or defenses for a part of the dragon.
 * 4. Moves connecting the dragon to something else.
 */
static void
find_more_owl_attack_and_defense_moves(int color)
{
  int pos, pos2;
  int k;
  int s;
  int dd1, dd2;
  int dd = NO_MOVE;
  int worth_trying;
  
  TRACE("\nTrying to upgrade strategical attack and defense moves.\n");

  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (!ON_BOARD(pos))
      continue;
      
    for (k = 0; k < MAX_REASONS; k++) {
      int r = move[pos].reason[k];
      int what;
      dd1 = NO_MOVE;
      dd2 = NO_MOVE;
      
      if (r < 0)
	break;
      what = move_reasons[r].what;
      if (move_reasons[r].type == STRATEGIC_ATTACK_MOVE
	  || move_reasons[r].type == STRATEGIC_DEFEND_MOVE)
	dd1 = dragons[what];
      else if (move_reasons[r].type == ATTACK_MOVE
	       || move_reasons[r].type == ATTACK_MOVE_GOOD_KO
	       || move_reasons[r].type == ATTACK_MOVE_BAD_KO
	       || move_reasons[r].type == DEFEND_MOVE
	       || move_reasons[r].type == DEFEND_MOVE_GOOD_KO
	       || move_reasons[r].type == DEFEND_MOVE_BAD_KO)
	dd1 = worms[what];
      else if (move_reasons[r].type == VITAL_EYE_MOVE) {
	int ee = eyes[move_reasons[r].what];
	int ecolor = eyecolor[move_reasons[r].what];
	
	if (ecolor == WHITE)
	  dd1 = white_eye[ee].dragon;
	else
	  dd1 = black_eye[ee].dragon;
	
	if (dd1 == NO_MOVE) /* Maybe we should assert this not to happen. */
	  continue;
      }      
      else if (move_reasons[r].type == CONNECT_MOVE) {
	int dragon1 = conn_dragon1[move_reasons[r].what];
	int dragon2 = conn_dragon2[move_reasons[r].what];
	dd1 = dragons[dragon1];
	dd2 = dragons[dragon2];
      }
      else
	continue;
      
      for (s = 0; s < 2; s++) {
	if (s == 0)
	  dd = dd1;
	else
	  dd = dd2;
	
	if (dd == NO_MOVE)
	  continue;
	
	/* Don't care about inessential dragons. */
	if (DRAGON2(dd).safety == INESSENTIAL)
	  continue;
	
	if (dragon[dd].owl_status != CRITICAL)
	  continue;
	
	if ((move_reasons[r].type == STRATEGIC_ATTACK_MOVE 
	     || move_reasons[r].type == ATTACK_MOVE
	     || move_reasons[r].type == ATTACK_MOVE_GOOD_KO
	     || move_reasons[r].type == ATTACK_MOVE_BAD_KO
	     || (move_reasons[r].type == VITAL_EYE_MOVE
		 && board[dd] == OTHER_COLOR(color)))
	    && !owl_attack_move_reason_known(pos, find_dragon(dd))) {
	  int acode = owl_does_attack(pos, dd);
	  if (acode >= dragon[dd].owl_attack_code) {
	    add_owl_attack_move(pos, dd, acode);
	    TRACE("Move at %1m owl attacks %1m, result %d.\n", pos, dd, acode);
	  }
	}
	
	if ((move_reasons[r].type == STRATEGIC_DEFEND_MOVE
	     || move_reasons[r].type == CONNECT_MOVE
	     || move_reasons[r].type == DEFEND_MOVE
	     || move_reasons[r].type == DEFEND_MOVE_GOOD_KO
	     || move_reasons[r].type == DEFEND_MOVE_BAD_KO
	     || (move_reasons[r].type == VITAL_EYE_MOVE
		 && board[dd] == color))
	    && !owl_defense_move_reason_known(pos, find_dragon(dd))) {
	  int dcode = owl_does_defend(pos, dd);
	  if (dcode >= dragon[dd].owl_defense_code) {
	    add_owl_defense_move(pos, dd, dcode);
	    TRACE("Move at %1m owl defends %1m, result %d.\n", pos, dd, dcode);
	  }
	}
      }
    }
  }

  /* If two critical dragons are adjacent, test whether a move to owl
   * attack or defend one also is effective on the other.
   */
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (IS_STONE(board[pos])
	&& dragon[pos].origin == pos
	&& dragon[pos].owl_status == CRITICAL) {
      for (pos2 = BOARDMIN; pos2 < BOARDMAX; pos2++) {
	if (board[pos2] != EMPTY)
	  continue;
	worth_trying = 0;
	for (k = 0; k < MAX_REASONS; k++) {
	  int r = move[pos2].reason[k];
	  
	  if (r < 0)
	    break;
	  if (move_reasons[r].type == OWL_ATTACK_MOVE
	      || move_reasons[r].type == OWL_ATTACK_MOVE_GOOD_KO
	      || move_reasons[r].type == OWL_ATTACK_MOVE_BAD_KO
	      || move_reasons[r].type == OWL_DEFEND_MOVE
	      || move_reasons[r].type == OWL_DEFEND_MOVE_GOOD_KO
	      || move_reasons[r].type == OWL_DEFEND_MOVE_BAD_KO) {
	    dd = dragons[move_reasons[r].what];
	    if (are_neighbor_dragons(dd, pos)) {
	      worth_trying = 1;
	      break;
	    }
	  }
	}

	if (worth_trying) {
	  if (board[pos] == color
	      && !owl_defense_move_reason_known(pos2, find_dragon(pos))) {
	    int dcode = owl_does_defend(pos2, pos);
	    if (dcode >= dragon[pos].owl_defense_code)
	      add_owl_defense_move(pos2, pos, dcode);
	  }
	  else if (board[pos] != color
		   && !owl_attack_move_reason_known(pos2, find_dragon(pos))) {
	    int acode = owl_does_attack(pos2, pos);
	    if (acode >= dragon[pos].owl_attack_code)
	      add_owl_attack_move(pos2, pos, acode);
	  }
	}
      }
    }
  }
}


/*
 * It's often bad to run away with a worm that is in a strategically
 * weak position. This function gives heuristics for determining
 * whether a move at (ti, tj) to defend the worm (ai, aj) is
 * strategically sound.
 *
 * FIXME: This function has played out its role. Should be eliminated.
 */
static int
strategically_sound_defense(int aa, int tt)
{
  UNUSED(aa);
  return move[tt].move_safety;
}



/*
 * Any move that captures or defends a worm also connects or cuts
 * the surrounding dragons. Find these secondary move reasons.
 *
 * We also let an owl attack count as a strategical defense of our
 * neighbors of the owl attacked dragon. We only do this for
 * tactically safe dragons, however, because otherwise the effects of
 * capturing has already been taken into account elsewhere.
 *
 * FIXME: There is a certain amount of optimizations that could be
 *        done here.
 *
 * FIXME: Even when we defend a worm, it's possible that the opponent
 *        still can secure a connection, e.g. underneath a string with
 *        few liberties. Thus a defense move isn't necessarily a cut
 *        move. This problem can be solved when we have a working
 *        connection reader.
 *
 */

static void
induce_secondary_move_reasons(int color)
{
  int m;
  int n;
  int pos;
  int k;
  int i;
  int aa;
  int dd = NO_MOVE;
  int biggest;
  
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      pos = POS(m, n);

      for (k = 0; k < MAX_REASONS; k++) {
	int r = move[pos].reason[k];
	
	if (r < 0)
	  break;
	
	if (move_reasons[r].type == ATTACK_MOVE
	    || move_reasons[r].type == DEFEND_MOVE) {
	  aa = worms[move_reasons[r].what];

	  if (worm[aa].defend_codes[0] == 0)
	    continue; /* No defense. */

	  /* Don't care about inessential dragons. */
	  if (DRAGON2(aa).safety == INESSENTIAL)
	    continue;
	  
	  /*
	   * If this is a defense move and the defense is futile for
	   * strategical reasons, we shouldn't induce a cutting move
	   * reason.
	   */
	  if (move_reasons[r].type == DEFEND_MOVE
	      && !strategically_sound_defense(aa, pos))
	    continue;
	  
	  /*
	   * Find the biggest of the surrounding dragons and say that
	   * all other dragons are connected or cut with respect to that
	   * one. We might want to use some other property than size, or
	   * still better induce cuts/connections for all combinations.
	   */
	  biggest = 0;
	  
	  /* A tactically unstable worm should never be amalgamated into
	   * a larger dragon. Occasionally this does still happen and in
	   * that case we need a workaround. Eventually this workaround
	   * should become unnecessary.
	   */
	  if (dragon[aa].size == worm[aa].size) {
	    for (i = 0; i < DRAGON2(aa).neighbors; i++) {
	      int d = DRAGON2(aa).adjacent[i];
	      if (DRAGON(d).color == dragon[aa].color)
		continue;
	      
	      if (DRAGON(d).size > biggest) {
		dd = DRAGON(d).origin;
		biggest = DRAGON(d).size;
	      }
	    }
	    
	    if (biggest == 0)
	      continue;
	    
	    for (i = 0; i < DRAGON2(aa).neighbors; i++) {
	      int d = DRAGON2(aa).adjacent[i];
	      int ee = DRAGON(d).origin;
	      
	      if (DRAGON(d).color == dragon[aa].color)
		continue;
	      
	      if (dd != ee) {
		if (move_reasons[r].type == ATTACK_MOVE) {
		  /* Exclude the case when (aa) is dead and both
		   * (dd) and (ee) are strongly alive or
		   * better. Then the move would only be losing
		   * points.
		   */
		  if (dragon[aa].matcher_status != DEAD
		      || (DRAGON2(dd).safety != STRONGLY_ALIVE
			  && DRAGON2(dd).safety != INVINCIBLE)
		      || (DRAGON2(ee).safety != STRONGLY_ALIVE
			  && DRAGON2(ee).safety != INVINCIBLE)) {
		    /* If one of the strings can be attacked and the
                     * move at (pos) does not defend, do not induce a
                     * connection move.
		     */
		    if ((worm[dd].attack_codes[0] == 0
			 || does_defend(pos, dd))
			&& (worm[ee].attack_codes[0] == 0
			    || does_defend(pos, ee)))
		      add_connection_move(pos, dd, ee);
		  }
		}
		else
		  add_cut_move(pos, dd, ee);
	      }
	    }
	  }
	  else {
	    /* Workaround. If the unstable worm has been amalgamated
	     * with stable worms, it would be incorrect to add
	     * cut/connect move reasons for all neighbors of this
	     * dragon. Instead we fall back to using chainlinks() to
	     * find the neighbors of the worm. The shortcoming of this
	     * is that it only counts neighbors in direct contact with
	     * the worm, which is not always sufficient.
	     */
	    int num_adj, adjs[MAXCHAIN];
	    
	    num_adj = chainlinks(aa, adjs);
	    for (i = 0; i < num_adj; i++) {
	      int adj = adjs[i];
	      
	      if (dragon[adj].color == dragon[aa].color)
		continue;
	      if (dragon[adj].size > biggest) {
		dd = dragon[adj].origin;
		biggest = dragon[adj].size;
	      }
	    }
	    
	    if (biggest == 0)
	      continue;
	    
	    for (i = 0; i < num_adj; i++) {
	      int adj = adjs[i];
	      int ee  = dragon[adj].origin;
	      
	      if (dragon[adj].color == dragon[aa].color)
		continue;
	      
	      if (dd != ee) {
		if (move_reasons[r].type == ATTACK_MOVE) {
		  /* Exclude the case when (aa) is dead and both
		   * (dd) and (ee) are strongly alive or
		   * better. Then the move would only be losing
		   * points.
		   */
		  if (dragon[aa].matcher_status != DEAD
		      || (DRAGON2(dd).safety != STRONGLY_ALIVE
			  && DRAGON2(dd).safety != INVINCIBLE)
		      || (DRAGON2(ee).safety != STRONGLY_ALIVE
			  && DRAGON2(ee).safety != INVINCIBLE)) {
		    /* If one of the strings can be attacked and the
                     * move at (pos) does not defend, do not induce a
                     * connection move.
		     */
		    if ((worm[dd].attack_codes[0] == 0
			 || does_defend(pos, dd))
			&& (worm[ee].attack_codes[0] == 0
			    || does_defend(pos, ee)))
		      add_connection_move(pos, dd, ee);
		  }
		}
		else
		  add_cut_move(pos, dd, ee);
	      }
	    }
	  }
	}
	else if (move_reasons[r].type == OWL_ATTACK_MOVE) {
	  aa = dragons[move_reasons[r].what];
	  for (i = 0; i < DRAGON2(aa).neighbors; i++) {
	    int bb = dragon2[DRAGON2(aa).adjacent[i]].origin;
	    if (dragon[bb].color == color && worm[bb].attack_codes[0] == 0)
	      add_strategical_defense_move(pos, bb);
	  }
	}
      }
    }
}


/* Examine the strategical and tactical safety of the moves. This is
 * used to decide whether or not the stone should generate influence
 * when the move is evaluated. The idea is to avoid overestimating the
 * value of strategically unsafe defense moves and connections of dead
 * dragons. This sets the move.move_safety field.
 */
static void
examine_move_safety(int color)
{
  int i, j;
  int k;
  
  start_timer(3);
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      int pos = POS(i, j);
      int safety = 0;
      int tactical_safety = 0;
      
      for (k = 0; k < MAX_REASONS; k++) {
	int r = move[pos].reason[k];
	int type;
	int what;

	if (r == -1)
	  break;
	type = move_reasons[r].type;
	what = move_reasons[r].what;
	switch (type) {
	case CUT_MOVE:
	  /* We don't trust cut moves, unless some other move reason
           * indicates they are safe.
	   */
	  break;
	case SEMEAI_MOVE:
	case OWL_DEFEND_MOVE:
	case OWL_DEFEND_MOVE_GOOD_KO:
	case OWL_DEFEND_MOVE_BAD_KO:
	case MY_ATARI_ATARI_MOVE:
	case EITHER_MOVE:         /* FIXME: More advanced handling? */
	case ALL_MOVE:            /* FIXME: More advanced handling? */
	  tactical_safety = 1;
	  safety = 1;
	  break;
	case BLOCK_TERRITORY_MOVE:
	case EXPAND_TERRITORY_MOVE:
	case EXPAND_MOYO_MOVE:
	  safety = 1;
	  break;
	case ATTACK_MOVE:
	case ATTACK_MOVE_GOOD_KO:
	case ATTACK_MOVE_BAD_KO:
	case OWL_ATTACK_MOVE:
	case OWL_ATTACK_MOVE_GOOD_KO:
	case OWL_ATTACK_MOVE_BAD_KO:
	  {
	    int aa = NO_MOVE;
	    int bb = NO_MOVE;
	    int size;
	    int our_color_neighbors;
	    int k;
	    
	    if (type == ATTACK_MOVE
		|| type == ATTACK_MOVE_GOOD_KO
		|| type == ATTACK_MOVE_BAD_KO) {
	      aa = worms[what];
	      size = worm[aa].effective_size;
	    }
	    else {
	      aa = dragons[what];
	      size = dragon[aa].effective_size;
	    }
	    
	    /* No worries if we catch something big. */
	    if (size >= 8) {
	      tactical_safety = 1;
	      safety = 1;
	      break;
	    }
	    
	    /* If the victim has multiple neighbor dragons of our
             * color, we leave it to the connection move reason to
             * determine safety.
	     *
	     * The exception is an owl_attack where we only require
	     * one neighbor to be alive.
	     */
	    our_color_neighbors = 0;
	    if (type == ATTACK_MOVE
		|| type == ATTACK_MOVE_GOOD_KO
		|| type == ATTACK_MOVE_BAD_KO) {
	      /* We could use the same code as for OWL_ATTACK_MOVE
               * below if we were certain that the capturable string
               * had not been amalgamated with a living dragon.
	       */
	      int num_adj, adjs[MAXCHAIN];

	      num_adj = chainlinks(aa, adjs);
	      for (k = 0; k < num_adj; k++) {
		int adj = adjs[k];

		if (board[adj] == color) {
		  /* Check whether this string is part of the same
                   * dragon as an earlier string. We only want to
                   * count distinct neighbor dragons.
		   */
		  int l;

		  for (l = 0; l < k; l++)
		    if (dragon[adjs[l]].id == dragon[adj].id)
		      break;
		  if (l == k) {
		    /* New dragon. */
		    our_color_neighbors++;
		    bb = adj;
		  }
		}
	      }
	    }
	    else {
	      for (k = 0; k < DRAGON2(aa).neighbors; k++)
		if (DRAGON(DRAGON2(aa).adjacent[k]).color == color) {
		  our_color_neighbors++;
		  bb = dragon2[DRAGON2(aa).adjacent[k]].origin;
		  if (dragon[bb].matcher_status == ALIVE) {
		    tactical_safety = 1;
		    safety = 1;
		  }
		}
	    }
	    
	    if (our_color_neighbors > 1)
	      break;
	    
	    /* It may happen in certain positions that no neighbor of
             * our color is found. The working hypothesis is that
	     * the move is safe then. One example is a position like
	     *
	     * ----+
	     * OX.X|
	     * OOX.|
	     *  OOX|
	     *   OO|
	     *
	     * where the top right stone only has friendly neighbors
	     * but can be attacked.
	     *
	     * As a further improvement, we also look for a friendly
	     * dragon adjacent to the considered move.
	     */

	    for (k = 0; k < 4; k++) {
	      int d = delta[k];
	      if (board[pos+d] == color) {
		bb = pos + d;
		break;
	      }
	    }
	    
	    if (bb == NO_MOVE) {
	      tactical_safety = 1;
	      safety = 1;
	      break;
	    }
	    
	    /* If the attacker is thought to be alive, we trust that
             * sentiment.
	     */
	    if (dragon[bb].matcher_status == ALIVE) {
	      tactical_safety = 1;
	      safety = 1;
	      break;
	    }
	    
	    /* It remains the possibility that what we have captured
             * is just a nakade shape. Ask the owl code whether this
             * move saves our attacking dragon.
	     *
	     * FIXME: Might need to involve semeai code too here.
	     */
	    if (owl_does_defend(pos, bb)) {
	      tactical_safety = 1;
	      safety = 1;
	    }
	    break;
	  }
	case DEFEND_MOVE:
	case DEFEND_MOVE_GOOD_KO:
	case DEFEND_MOVE_BAD_KO:
	  {
	    int aa = worms[what];

	    if (dragon[aa].matcher_status == ALIVE)
	      /* It would be better if this never happened, but it does
	       * sometimes. The owl reading can be very slow then.
	       */
	      safety = 1;
	    
	    else if (owl_does_defend(pos, aa))
	      safety = 1;
	    break;
	  }
	  
	case ATTACK_THREAT:
	case DEFEND_THREAT:
	  break;

	case CONNECT_MOVE:
	  {
	    int dragon1 = conn_dragon1[move_reasons[r].what];
	    int dragon2 = conn_dragon2[move_reasons[r].what];
	    int aa = dragons[dragon1];
	    int bb = dragons[dragon2];

	    if (dragon[aa].owl_status == ALIVE
		|| dragon[bb].owl_status == ALIVE) {
	      tactical_safety = 1;
	      safety = 1;
	    }
	    else if ((dragon[aa].owl_status == UNCHECKED
		      && dragon[aa].status == ALIVE)
		     || (dragon[bb].owl_status == UNCHECKED
			 && dragon[bb].status == ALIVE)) {
	      tactical_safety = 1;
	      safety = 1;
	    }
	    else if (owl_connection_defends(pos, aa, bb)) {
	      tactical_safety = 1;
	      safety = 1;
	    }
	    break;
	  }
	}
	if (safety == 1 && (tactical_safety == 1 || safe_move(pos, color)))
	  break;
      }
      
      if (safety == 1 && (tactical_safety || safe_move(pos, color)))
	move[pos].move_safety = 1;
      else
	move[pos].move_safety = 0;

      time_report(3, "    examine_move_safety: ", pos, 1.0);
    }
}


/*
 * An attempt to estimate the safety of a dragon.
 *
 * FIXME: Important to test more exactly how effective a strategical
 *        attack or defense of a weak dragon is. This can be done by
 *        measuring escape factor and moyo size after the move and
 *        compare with the old values. Also necessary to test whether
 *        an attack or defense of a critical dragon is effective.
 *        Notice that this wouldn't exactly go into this function but
 *        rather where it's called.
 */

static float safety_values[10] = {
/* DEAD        */  0.0,
/* ALIVE       */  0.9,
/* CRITICAL    */  0.1,
/* INESSENTIAL */  1.0,   /* Yes, 1.0. We simply don't worry about it. */
/* TACT. DEAD  */  0.0,
/* WEAK        */  0.4,
/* WEAK ALIVE  */  0.6,
/* SEKI        */  0.8,
/* STR. ALIVE  */  1.0,
/* INVINCIBLE  */  1.0};
		  
static float
dragon_safety(int dr, int ignore_dead_dragons)
{
  int dragon_safety = DRAGON2(dr).safety;

  /* Kludge: If a dragon is dead, we return 1.0 in order not
   * to try to run away.
   */
  if (ignore_dead_dragons
      && (dragon_safety == DEAD
	  || dragon_safety == INESSENTIAL
	  || dragon_safety == TACTICALLY_DEAD))
    return 1.0;

  /* When scoring, we don't want to reinforce ALIVE dragons. */
  if (doing_scoring && dragon_safety == ALIVE)
    return 1.0;
  
  /* More detailed guesses for WEAK and WEAKLY_ALIVE dragons. */
  if (dragon_safety == WEAK || dragon_safety == WEAKLY_ALIVE) {
    int escape = DRAGON2(dr).escape_route;
    int moyo = DRAGON2(dr).moyo;
    /* If escape <= 5 and moyo <= 10, the dragon won't be WEAK, since
     * the owl code has been run.
     */
    if (escape < 10 && moyo < 5)
      return 0.1;
    else if (escape < 15 && moyo < 5)
      return 0.2;
    else if (escape < 10 && moyo < 10)
      return 0.3;
    else if (escape < 5 && moyo < 15)
      return 0.4;
    else if (escape < 15 && moyo < 15)
      return 0.7;
    else
      return 0.9;
  }
  
  return safety_values[dragon_safety];
}

/*
 * Strategical value of connecting (or cutting) the dragon at (dragona)
 * to the dragon at (dragonb). Notice that this function is asymmetric.
 * This is because connection_value(a, b) is intended to measure the
 * strategical value on the a dragon from a connection to the b dragon.
 * 
 * Consider the following position:
 * +---------+
 * |XXO.O.OXX|
 * |.XOOOOOX.|
 * |XXXX.XXXX|
 * |.XOOXOOX.|
 * |XXO.X.O.X|
 * |OOOXXXOOO|
 * |..OOOOO..|
 * |.........|
 * +---------+
 * 
 * X has three dragons, one invincible to the left (A), one critical to
 * the right (B), and one dead in the center (C). The move at the cutting
 * point has three move reasons:
 * connect A and B
 * connect A and C
 * connect B and C
 * 
 * The strategical value on A of either connection is of course zero,
 * since it's very unconditionally alive. The strategical value on B is
 * high when it's connected to A but small (at least should be) from the
 * connection to C. Similarly for dragon C. In effect the total
 * strategical value of this move is computed as:
 * 
 * max(connection_value(A, B), connection_value(A, C))
 * + max(connection_value(B, A), connection_value(B, C))
 * + max(connection_value(C, A), connection_value(C, B))
 *
 * The parameter 'margin' is the margin by which we are ahead.
 * If this exceeds 20 points we use the cautious impact values,
 * which value connections more.  This is because we can afford
 * to waste a move making sure of safety. If the margin is between
 * 0 and 20 points we interpret linearly between the two sets of
 * impact values.
 */

/* Values higher than 1.0 to give connections a bonus over other vital
 * moves.
 */
static float impact_values[10][10] = {
/*      (dragonb) DEAD ALIV CRIT INES TACT WEAK WE_A SEKI STRO INVI */
/* DEAD        */ {0.0, 0.9, 0.0, 0.0, 0.0, 0.8, 0.85,0.8, 0.95,1.0 },
/* ALIVE       */ {0.0, 0.08,0.05,0.0, 0.0, 0.05,0.07,0.05,0.09,0.1 },
/* CRITICAL    */ {0.0, 1.04,0.85,0.0, 0.0, 0.75,0.9, 0.85,1.08,1.1 },
/* INESSENTIAL */ {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
/* TACT. DEAD  */ {0.0, 0.9, 0.0, 0.0, 0.0, 0.8, 0.85,0.8, 0.95,1.0 },
/* WEAK        */ {0.1, 0.6, 0.25,0.0, 0.0, 0.2, 0.25,0.25,0.65,0.65},
/* WEAK ALIVE  */ {0.0, 0.4, 0.3, 0.0, 0.0, 0.15,0.2, 0.2 ,0.45,0.45},
/* SEKI        */ {0.0, 0.2, 0.15,0.0, 0.0, 0.1, 0.15,0.2, 0.25,0.3 },
/* STR. ALIVE  */ {0.0, 0.01,0.01,0.0, 0.0, 0.01,0.01,0.01,0.01,0.01},
/* INVINCIBLE  */ {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 }};
/* (dragona)    */
		  
static float cautious_impact_values[10][10] = {
/*      (dragonb) DEAD ALIV CRIT INES TACT WEAK WE_A SEKI STRO INVI */
/* DEAD        */ {0.3, 0.9, 0.0, 0.0, 0.0, 0.8, 0.85,0.8, 0.95,1.0 },
/* ALIVE       */ {0.0, 0.2, 0.05,0.0, 0.0, 0.1,0.15, 0.10,0.2 ,0.2 },
/* CRITICAL    */ {0.0, 1.04,0.85,0.0, 0.0, 0.75,0.9, 0.85,1.08,1.1 },
/* INESSENTIAL */ {0.1, 0.6, 0.0, 0.0, 0.0, 0.3, 0.5, 0.5, 0.6, 0.6 },
/* TACT. DEAD  */ {0.2, 0.9, 0.0, 0.0, 0.0, 0.8, 0.85,0.8, 0.95,1.0 },
/* WEAK        */ {0.1, 0.6, 0.25,0.0, 0.0, 0.2, 0.25,0.25,0.65,0.65},
/* WEAK ALIVE  */ {0.0, 0.4, 0.3, 0.0, 0.0, 0.2, 0.2, 0.2 ,0.45,0.45},
/* SEKI        */ {0.0, 0.2, 0.15,0.0, 0.0, 0.1, 0.15,0.2, 0.25,0.3 },
/* STR. ALIVE  */ {0.0, 0.02,0.01,0.0, 0.0, 0.01,0.01,0.01,0.02,0.02},
/* INVINCIBLE  */ {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 }};
/* (dragona)    */
		  
static float
connection_value(int dragona, int dragonb, int tt, float margin)
{
  int safety1 = DRAGON2(dragona).safety;
  int safety2 = DRAGON2(dragonb).safety;
  int true_genus1 = 2 * DRAGON2(dragona).genus + DRAGON2(dragona).heyes;
  int true_genus2 = 2 * DRAGON2(dragonb).genus + DRAGON2(dragonb).heyes;
  float impact;

  /* If the connected dragon gets sufficient eyespace to live on its
   * own, although neither of the unconnected ones did, we simulate
   * this by upgrading the safety of the second dragon to ALIVE.
   */
  if (true_genus1 < 4 && true_genus2 < 4) {
    if (true_genus1 + true_genus2 >= 4
	||  (true_genus1 + true_genus2 >= 3
	     && (DRAGON2(dragona).heye == tt
		 || DRAGON2(dragonb).heye == tt)))
      safety2 = ALIVE;
  }

  /* If the b dragon is critical but has genus 0 and no moyo, we
   * assume it doesn't help dragon a to connect to b.
   */
  if (safety2 == CRITICAL && true_genus2 == 0
      && DRAGON2(dragonb).moyo == 0)
    return 0.0;
  

  /* When scoring, we want to be restrictive with reinforcement moves
   * inside own territory. Thus if both dragons are weakly_alive,
   * alive, strongly alive, or invincible, no bonus is awarded.
   *
   * Notice that this requires that the territorial value is computed
   * before the strategical value.
   */
  if (doing_scoring && move[tt].territorial_value < 0.0) {
    if ((safety1 == WEAKLY_ALIVE
	 || safety1 == ALIVE
	 || safety1 == STRONGLY_ALIVE
	 || safety1 == INVINCIBLE)
	&& (safety2 == WEAKLY_ALIVE
	    || safety2 == ALIVE
	    || safety2 == STRONGLY_ALIVE
	    || safety2 == INVINCIBLE))
      return 0.0;
  }

  if (doing_scoring || margin < 0.0)
    impact = impact_values[safety1][safety2];
  else if (margin > 20.0)
    impact = cautious_impact_values[safety1][safety2];
  else
    impact = (0.05 * margin * cautious_impact_values[safety1][safety2]
	      + (1 - 0.05 * margin) * impact_values[safety1][safety2]);


  /* Trying to connect an inessential string to something else with a
   * self atari is almost certainly worthless.
   */
  if (impact > 0.0
      && safety1 == INESSENTIAL
      && is_self_atari(tt, board[dragona]))
    impact = 0.0;
  
  return impact * 2.0 * dragon[dragona].effective_size;
}


/*
 * Usually the value of attacking a worm is twice its effective size,
 * but when evaluating certain move reasons we need to adjust this to
 * take effects on neighbors into account, e.g. for an attack_either
 * move reason. This does not apply to the attack and defense move
 * reasons, however, because then the neighbors already have separate
 * attack or defense move reasons (if such apply).
 *
 * If the worm has an adjacent (friendly) dead dragon we add its
 * value. At least one of the surrounding dragons must be alive. 
 * If not, the worm must produce an eye of sufficient size, and that 
 * should't be accounted for here.  As a guess, we suppose that
 * a critical dragon is alive for our purpose here.
 *
 * On the other hand if it has an adjacent critical worm, and
 * if (pos) does not defend that worm, we subtract the value of the
 * worm, since (pos) may be defended by attacking that worm. We make at
 * most one adjustment of each type.
 */

static float
adjusted_worm_attack_value(int pos, int ww)
{
  int color;
  int num_adj;
  int adjs[MAXCHAIN];
  int has_live_neighbor = 0;
  float adjusted_value = 2 * worm[ww].effective_size;
  float adjustment_up = 0.0;
  float adjustment_down = 0.0;
  int s;

  color = OTHER_COLOR(board[ww]);
  num_adj = chainlinks(ww, adjs);
  for (s = 0; s < num_adj; s++) {
    int adj = adjs[s];

    if (dragon[adj].matcher_status != DEAD)
      has_live_neighbor = 1;

    if (dragon[adj].matcher_status == DEAD
	&& 2*dragon[adj].effective_size > adjustment_up)
      adjustment_up = 2*dragon[adj].effective_size;

    if (worm[adj].attack_codes[0] != 0
	&& !does_defend(pos, ww)
	&& 2*worm[adj].effective_size > adjustment_down)
      adjustment_down = 2*worm[adj].effective_size;
  }

  if (has_live_neighbor)
    adjusted_value += adjustment_up;
  adjusted_value -= adjustment_down;

  return adjusted_value;
}


/* The new (3.2) territorial evaluation overvalues moves creating a new
 * group in the opponent's sphere of influence. The influence module cannot
 * see that the opponent will gain by attacking the new (probably weak)
 * group.
 * This function uses some heuristics to estimate the strategic penalty
 * of invasion moves, and moves that try to run away with a group of size
 * 1 in front of opponent's strength.
 */
static float
strategic_penalty(int pos, int color)
{
  int k;
  float ret_val;
  
  /* We try to detect support from an alive friendly stone by checking
   * whether all neighboring intersections belong to the opponent's moyo.
   */
  for (k = 0; k < 4; k++)
    if (ON_BOARD(pos + delta[k])
	&& board[pos + delta[k]] != OTHER_COLOR(color)
        && influence_moyo_color(pos + delta[k]) != OTHER_COLOR(color))
      return 0.0;

  for (k = 0; k < MAX_REASONS; k++) {
    int r = move[pos].reason[k];
    if (r == -1)
      break;
    /* We assume that invasion moves can only have the move reasons listed
     * below.
     */
    switch (move_reasons[r].type) {
    case EXPAND_TERRITORY_MOVE:
    case BLOCK_TERRITORY_MOVE:
    case EXPAND_MOYO_MOVE:
    case STRATEGIC_ATTACK_MOVE:
      continue;
    /* If we find a tactical defense move, we just test whether it concerns
     * a single-stone-dragon; if not, we stop, if yes, we let the necessary
     * tests be made in the OWL_DEFEND_MOVE case.
     */
    case DEFEND_MOVE:
      {
	int target = worms[move_reasons[r].what];
	if (dragon[target].size > 1)
	  return 0.0;
	continue;
      }
    /* An owl defense of a single stone might be a stupid attempt to run
     * away with an unimportant (kikashi like) stone. We assume this is the
     * case if this single stone has a strong hostile direct neighbor.
     */
    case OWL_DEFEND_MOVE:
      {
	int target = dragons[move_reasons[r].what];
	int has_strong_neighbor = 0;
	int has_weak_neighbor = 0;
	int i;
	/* We award no penalty for running away with a cutting stone. */
	if (dragon[target].size > 1
	    || worm[target].cutstone > 0
	    || worm[target].cutstone2 > 0)
	  return 0.0;
	/* Third line moves (or lower) are ok -- they try to live, not run
         * away.
	 *
	 * FIXME: Add an "edge_distance()" function in board.c which can
	 *        be used here.
         */
        if (gg_min(gg_min(I(pos), board_size-1 - I(pos)),
                   gg_min(J(pos), board_size-1 - J(pos)))
            < 3)
	  return 0.0;
	
	for (i = 0; i < 4; i++)
	  if (board[target + delta[i]] == OTHER_COLOR(color)) {
	    if (dragon[target + delta[i]].size == 1) {
	      has_weak_neighbor = 1;
	      break;
	    }
	    switch (DRAGON2(target + delta[i]).safety) {
	    case INVINCIBLE:
	    case STRONGLY_ALIVE:
	      has_strong_neighbor = 1;
	      break;
	    case ALIVE:
	      continue;
	    default:
	      has_weak_neighbor = 1;
	    }
	  }
	if (has_weak_neighbor || (!has_strong_neighbor))
	  return 0.0;
	else
	  continue;
      }
    default:
      return 0.0;
    }  
  }

  /* We have to make a guess how much the point where we want to play
   * is dominated by the opponent. The territorial valuation is a
   * good try here.
   */
  ret_val = influence_initial_territory(pos, OTHER_COLOR(color));
  
  ret_val *= 12.0;
  ret_val = gg_max(0.0, ret_val);
  return ret_val;
}


/*
 * Estimate the direct territorial value of a move at (pos).
 */
static void
estimate_territorial_value(int pos, int color, float score)
{
  int other = OTHER_COLOR(color);
  int k;
  int aa = NO_MOVE;
  
  float this_value = 0.0;
  float tot_value = 0.0;
  float secondary_value = 0.0;

  int does_block = 0;
  char saved_stones[BOARDMAX];

  memset(saved_stones, 0, BOARDMAX);
  
  for (k = 0; k < MAX_REASONS; k++) {
    int r = move[pos].reason[k];
    if (r < 0)
      break;
    if (move_reasons[r].status & TERRITORY_REDUNDANT)
      continue;

    this_value = 0.0;
    switch (move_reasons[r].type) {
    case ATTACK_MOVE:
    case ATTACK_MOVE_GOOD_KO:
    case ATTACK_MOVE_BAD_KO:
      aa = worms[move_reasons[r].what];
      
      gg_assert(board[aa] != color);
      
      /* Defenseless stone. */
      if (worm[aa].defend_codes[0] == 0) {
	DEBUG(DEBUG_MOVE_REASONS,
	      "  %1m:   %f (secondary) - attack on %1m (defenseless)\n",
	      pos, worm[aa].effective_size, aa);
	secondary_value += worm[aa].effective_size;
	does_block = 1;
	break;
      }

      this_value = 2 * worm[aa].effective_size;

      /* If the stones are dead, there is only a secondary value in
       * capturing them tactically as well.
       */
      if (dragon[aa].matcher_status == DEAD) {
	DEBUG(DEBUG_MOVE_REASONS,
	      "  %1m:   %f (secondary) - attack on %1m (dead)\n",
	      pos, 0.2 * this_value, aa);
	secondary_value += 0.2 * this_value;
	does_block = 1;
	break;
      }

      /* Mark the string as captured, for evaluation in the influence code. */
      mark_string(aa, saved_stones, INFLUENCE_CAPTURED_STONE);
      TRACE("  %1m: attack on worm %1m\n", pos, aa);
      
      /* FIXME: How much should we reduce the value for ko attacks? */
      if (move_reasons[r].type == ATTACK_MOVE)
	this_value = 0.0;
      else if (move_reasons[r].type == ATTACK_MOVE_GOOD_KO) {
	this_value *= 0.3;
	TRACE("  %1m: -%f - attack on worm %1m only with good ko\n",
	      pos, this_value, aa);
      }	
      else if (move_reasons[r].type == ATTACK_MOVE_BAD_KO) {
	this_value *= 0.5;
	TRACE("  %1m: -%f - attack on worm %1m only with bad ko\n",
	      pos, this_value, aa);
      }
      
      tot_value -= this_value;
      does_block = 1;
      break;
      
    case DEFEND_MOVE:
    case DEFEND_MOVE_GOOD_KO:
    case DEFEND_MOVE_BAD_KO:
      aa = worms[move_reasons[r].what];
      
      gg_assert(board[aa] == color);
      
      /* 
       * Estimate value 
       */
      this_value = 2 * worm[aa].effective_size;

      /* If the stones are dead, we use the convention that
       * defending them has a strategical value rather than
       * territorial. Admittedly this make more sense for attacks on
       * dead stones.
       */
      if (dragon[aa].matcher_status == DEAD) {
	DEBUG(DEBUG_MOVE_REASONS,
	      "  %1m:   %f (secondary) - defense of %1m (dead)\n",
	      pos, 0.2 * this_value, aa);
	secondary_value += 0.2 * this_value;
	break;
      }

      /* Mark the string as saved, for evaluation in the influence code. */
      mark_string(aa, saved_stones, INFLUENCE_SAVED_STONE);
      TRACE("  %1m: defense of worm %1m\n", pos, aa);
      
      /* FIXME: How much should we reduce the value for ko defenses? */
      if (move_reasons[r].type == DEFEND_MOVE)
	this_value = 0.0;
      else if (move_reasons[r].type == DEFEND_MOVE_GOOD_KO) {
	this_value *= 0.3;
	TRACE("  %1m: -%f - defense of worm %1m with good ko\n",
	      pos, this_value, aa);
      }	
      else if (move_reasons[r].type == DEFEND_MOVE_BAD_KO) {
	this_value *= 0.5;
	TRACE("  %1m: -%f - defense of worm %1m with bad ko\n",
	      pos, this_value, aa);
      }	
    
      tot_value -= this_value;
      does_block = 1;
      break;

    case ATTACK_THREAT:
      aa = worms[move_reasons[r].what];

      /* Make sure this is a threat to attack opponent stones. */
      ASSERT1(board[aa] == other, aa);
      
      if (dragon[aa].matcher_status == DEAD) {
	DEBUG(DEBUG_MOVE_REASONS,
	      "    %1m: 0.0 - threatens to capture %1m (dead)\n", pos, aa);
	break;
      }

      /* The followup value of a move threatening to attack (aa)
       * is twice its effective size, with adjustments. If the
       * worm has an adjacent (friendly) dead dragon we add its
       * value. On the other hand if it has an adjacent critical
       * worm, and if (pos) does not defend that worm, we subtract
       * the value of the worm, since (aa) may be defended by
       * attacking that worm. We make at most one adjustment
       * of each type.
       *
       * No followup value is awarded if the defense move is a threat
       * back on our move because we're likely to end in gote then,
       * unless the move is unsafe anyway and played as a ko threat.
       *
       * FIXME: It might be possible that parts of the dragon
       *        can be cut in the process of capturing the (aa)
       *        worm. In that case, not the entire size of the 
       *        adjacent dead dragon should be counted as a positive
       *        adjustment.  However, it seems difficult to do this
       *        analysis, and in most cases it won't apply, so we
       *        leave it as it is for now.
       *
       * FIXME: The same analysis should be applied to
       *        DEFEND_THREAT,
       *        ATTACK_EITHER_MOVE, DEFEND_BOTH_MOVE. It should be 
       *        broken out as separate functions and dealt with in
       *        a structured manner.
       */

      if (trymove(pos, color, "estimate_territorial_value-A",
		  NO_MOVE, EMPTY, NO_MOVE)) {
	int adjs[MAXCHAIN];
	float adjusted_value = 2 * worm[aa].effective_size;
	float adjustment_up = 0.0;
	float adjustment_down = 0.0;
	int s;
	int num_adj;
	int defense_move;

	/* In rare cases it may happen that the trymove() above
         * actually removed the string at aa.
	 */
	if (board[aa] == EMPTY)
	  num_adj = 0;
	else
	  num_adj = chainlinks(aa, adjs);

	/* No followup value if string can be defended with threat
         * against our move. An exception to this is when our move
         * isn't safe anyway and we play this only for the followup
         * value, typically as a ko threat.
	 *
	 * FIXME: This is somewhat halfhearted since only one defense
	 * move is tested.
	 */
	if (board[aa] != EMPTY
	    && move[pos].move_safety == 1
	    && find_defense(aa, &defense_move) == WIN
	    && defense_move != NO_MOVE) {
	  if (trymove(defense_move, other,
		      "estimate_territorial_value-b", NO_MOVE,
		      EMPTY, NO_MOVE)) {
	    if (board[pos] == EMPTY || attack(pos, NULL) == WIN) {
	      popgo();
	      popgo();
	      break;
	    }
	    popgo();
	  }
	}

	for (s = 0; s < num_adj; s++) {
	  int adj = adjs[s];

	  if (same_string(pos, adj))
	    continue;
	  if (dragon[adj].color == color
	      && dragon[adj].matcher_status == DEAD
	      && 2*dragon[adj].effective_size > adjustment_up)
	    adjustment_up = 2*dragon[adj].effective_size;
	  if (dragon[adj].color == color
	      && attack(adj, NULL)
	      && 2*worm[adj].effective_size > adjustment_down)
	    adjustment_down = 2*worm[adj].effective_size;
	}

	popgo();

	/* No followup if the string is not substantial. */
	{
	  int save_verbose = verbose;
	  if (verbose > 0)
	    verbose --;
	  if (move[pos].move_safety == 0
	      && !owl_substantial(aa)) {
	    verbose = save_verbose;
	    break;
	  }
	  verbose = save_verbose;
	}
	
	adjusted_value += adjustment_up;
	adjusted_value -= adjustment_down;
	if (adjusted_value > 0.0) {
	  add_followup_value(pos, adjusted_value);
	  /* Inside trymove, so don't re-indented.*/
	  TRACE("%1m:   %f (followup) - threatens to capture %1m\n",
		pos, adjusted_value, aa);
	}
      }
      break;

    case DEFEND_THREAT:
      aa = worms[move_reasons[r].what];

      /* Make sure this is a threat to defend our stones. */
      ASSERT1(board[aa] == color, aa);
      
      add_followup_value(pos, 2 * worm[aa].effective_size);

      TRACE("  %1m: %f (followup) - threatens to defend %1m\n",
	    pos, 2 * worm[aa].effective_size, aa);

      break;

    case UNCERTAIN_OWL_DEFENSE:
      /* This move reason is valued as a strategical value. */
      break;
      
    case CONNECT_MOVE:
    case CUT_MOVE:
    case STRATEGIC_ATTACK_MOVE:
    case STRATEGIC_DEFEND_MOVE:
    case BLOCK_TERRITORY_MOVE:
      does_block = 1;
      break;
      
    case EXPAND_MOYO_MOVE:
    case EXPAND_TERRITORY_MOVE:
      /* We don't make any difference between blocking and expanding
       * territory.
       *
       * FIXME: Fuse the BLOCK_TERRITORY and EXPAND_TERRITORY move
       * reasons to one and do the same with the b and e class
       * patterns.
       */
      does_block = 1;
      break;
      
    case SEMEAI_MOVE:
      aa = dragons[move_reasons[r].what];
      
      this_value = 2 * dragon[aa].effective_size;
      TRACE("  %1m: %f - semeai involving %1m\n", pos, this_value, aa);
      tot_value += this_value;
      break;
      
    case SEMEAI_THREAT:
      aa = dragons[move_reasons[r].what];

      /* threaten to win the semeai as a ko threat */
      add_followup_value(pos, 2 * dragon[aa].effective_size);
      TRACE("  %1m: %f (followup) - threatens to win semeai for %1m\n",
	    pos, 2 * dragon[aa].effective_size, aa);
      break;
      
    case VITAL_EYE_MOVE:
      /* These are upgraded to owl attacks or defenses in
       * find_more_owl_attack_and_defense_moves() and should no longer
       * be counted here.
       */
      break;
	
    case OWL_ATTACK_MOVE:
    case OWL_ATTACK_MOVE_GOOD_KO:
    case OWL_ATTACK_MOVE_BAD_KO:
    case OWL_DEFEND_MOVE:
    case OWL_DEFEND_MOVE_GOOD_KO:
    case OWL_DEFEND_MOVE_BAD_KO:
      aa = dragons[move_reasons[r].what];

      /* If the dragon is a single ko stone, the owl code currently
       * won't detect that the owl attack is conditional. As a
       * workaround we deduct 0.5 points for the move here.
       */
      if (dragon[aa].size == 1
	  && is_ko_point(aa)) {
	TRACE("  %1m: -0.5 - penalty for ko stone %1m (workaround)\n",
	      pos, aa);
	tot_value -= 0.5;
	break;
      }

      {
	int ii;
	for (ii = BOARDMIN; ii < BOARDMAX; ii++) {
	  if (IS_STONE(board[ii]) && is_same_dragon(ii, aa)) {
	    if (move_reasons[r].type == OWL_ATTACK_MOVE
		|| move_reasons[r].type == OWL_ATTACK_MOVE_GOOD_KO
		|| move_reasons[r].type == OWL_ATTACK_MOVE_BAD_KO)
	      saved_stones[ii] = INFLUENCE_CAPTURED_STONE;
	    else
	      saved_stones[ii] = INFLUENCE_SAVED_STONE;
	  }
	}
      }
      TRACE("  %1m: owl attack/defend for %1m\n", pos, aa);
      
      /* FIXME: How much should we reduce the value for ko attacks? */
      this_value = 2 * dragon[aa].effective_size;
      if (move_reasons[r].type == OWL_ATTACK_MOVE
	  || move_reasons[r].type == OWL_DEFEND_MOVE)
	this_value = 0.0;
      else if (move_reasons[r].type == OWL_ATTACK_MOVE_GOOD_KO
	       || move_reasons[r].type == OWL_DEFEND_MOVE_GOOD_KO) {
	this_value *= 0.3;
	TRACE("  %1m: -%f - owl attack/defense of %1m only with good ko\n",
	      pos, this_value, aa);
      }	
      else if (move_reasons[r].type == OWL_ATTACK_MOVE_BAD_KO
	       || move_reasons[r].type == OWL_DEFEND_MOVE_BAD_KO) {
	this_value *= 0.5;
	TRACE("  %1m: -%f - owl attack/defense of %1m only with bad ko\n",
	      pos, this_value, aa);
      }
      
      tot_value -= this_value;
      does_block = 1;
      break;

    case OWL_ATTACK_THREAT:
      aa = dragons[move_reasons[r].what];

      if (dragon[aa].matcher_status == DEAD) {
	DEBUG(DEBUG_MOVE_REASONS,
	      "    %1m: 0.0 - threatens to owl attack %1m (dead)\n", pos, aa);
	break;
      }

      /* The followup value of a move threatening to attack (aa) is
       * twice its effective size, unless it has an adjacent
       * (friendly) critical dragon. In that case it's probably a
       * mistake to make the threat since it can defend itself with
       * profit.
       *
       * FIXME: We probably need to verify that the critical dragon is
       * substantial enough that capturing it saves the threatened
       * dragon.
       */	 
      {
	float value = 2 * dragon[aa].effective_size;
	int s;

	for (s = 0; s < DRAGON2(aa).neighbors; s++) {
	  int d = DRAGON2(aa).adjacent[s];
	  int adj = dragon2[d].origin;

	  if (dragon[adj].color == color
	      && dragon[adj].matcher_status == CRITICAL
	      && dragon2[d].safety != INESSENTIAL
	      && !owl_defense_move_reason_known(pos, find_dragon(adj)))
	    value = 0.0;
	}
	
	if (value > 0.0) {
	  add_followup_value(pos, value);
	  TRACE("  %1m: %f (followup) - threatens to owl attack %1m\n",
		pos, value, aa);
	}
      }
      break;

    case OWL_DEFEND_THREAT:
      aa = dragons[move_reasons[r].what];

      add_followup_value(pos, 2 * dragon[aa].effective_size);
      TRACE("  %1m: %f (followup) - threatens to owl defend %1m\n",
	    pos, 2 * dragon[aa].effective_size, aa);
      break;

    case OWL_PREVENT_THREAT:
      /* A move attacking a dragon whose defense can be threatened.
       */
      aa = dragons[move_reasons[r].what];

      /* If the opponent just added a stone to a dead dragon, then
       * attack it. If we are ahead, add a safety move here, at most
       * half the margin of victory.
       *
       * This does not apply if we are doing scoring.
       */
      if (!doing_scoring
	  && is_same_dragon(get_last_opponent_move(color), aa)) {
	this_value = 1.5 * dragon[aa].effective_size;
	TRACE("  %1m: %f - attack last move played, although it seems dead\n",
	      pos, this_value);
	tot_value += this_value;
      }
      else if (!doing_scoring && ((color == BLACK && score < 0.0)
				  || (color == WHITE && score > 0.0))) {
	/* tm - devalued this bonus (3.1.17) */
	this_value = gg_min(0.9 * dragon[aa].effective_size,
			    gg_abs(score/2) - board_size/2 - 1);
	this_value = gg_max(this_value, 0);
	TRACE("  %1m: %f - attack %1m, although it seems dead, as we are ahead\n",
	      pos, this_value, aa);
	tot_value += this_value;
      }
      else {
	/* FIXME: Why are we computing a this_value here when it's
         * never used?
	 */
	if ((color == BLACK && score > 0.0)
	    || (color == WHITE && score < 0.0))
	  this_value = 0.0;
	else 
	  this_value = gg_min(2*dragon[aa].effective_size, gg_abs(score/2));
	
	add_reverse_followup_value(pos, 2 * dragon[aa].effective_size);
	if (board[aa] == color)
	  TRACE("  %1m: %f (reverse followup) - prevent threat to attack %1m\n",
		pos, 2 * dragon[aa].effective_size, aa);
	else 
	  TRACE("  %1m: %f (reverse followup) - prevent threat to defend %1m\n",
		pos, 2 * dragon[aa].effective_size, aa);
      }
      break;
      
    case MY_ATARI_ATARI_MOVE:
      /* Add 1.0 to compensate for -1.0 penalty because the move is
       * thought to be a sacrifice.
       */
      this_value = move_reasons[r].what + 1.0;
      tot_value += this_value;
      TRACE("  %1m: %f - combination attack kills one of several worms\n",
	    pos, this_value);
      break;
      
    case YOUR_ATARI_ATARI_MOVE:
      this_value = move_reasons[r].what;
      tot_value += this_value;
      TRACE("  %1m: %f - defends against combination attack on several worms\n",
	    pos, this_value);
      break;
    }
  }

  /* Currently no difference in the valuation between blocking and
   * expanding moves.
   */
  this_value = 0.0;

  if (move[pos].move_safety == 1 && safe_move(pos, color) == WIN)
    saved_stones[pos] = INFLUENCE_SAVED_STONE;
  else
    saved_stones[pos] = INFLUENCE_CAPTURED_STONE;
  
  /* tm added move_safety check (3.1.22) (see trevorc:880) */
  if (does_block && move[pos].move_safety) {
    if (experimental_influence)
      this_value = influence_delta_territory(pos, color, saved_stones,
                                             &move[pos].influence_followup_value);
    else
      this_value = influence_delta_territory(pos, color, saved_stones, NULL);
    if (this_value != 0.0)
      TRACE("  %1m: %f - change in territory\n", pos, this_value);
    else
      DEBUG(DEBUG_MOVE_REASONS, "  %1m: 0.00 - change in territory\n", 
	    pos);
  }

  tot_value += this_value;
  
  /* Test if min_territory or max_territory values constrain the
   * delta_territory value.
   */
  if (tot_value < move[pos].min_territory
      && move[pos].min_territory > 0) {
    tot_value = move[pos].min_territory;
    TRACE("  %1m:   %f - revised to meet minimum territory value\n", 
	  pos, tot_value);
  }
  if (tot_value > move[pos].max_territory) {
    tot_value = move[pos].max_territory;
    TRACE("  %1m:   %f - revised to meet maximum territory value\n",
	  pos, tot_value);
  }
    
  /* subtract one point for a sacrifice (playing in opponent's territory) */
  if (tot_value > 1.0 && safe_move(pos, color) != WIN) {
    TRACE("  %1m:   -1 - unsafe move, assumed sacrifice\n", pos);
    tot_value -= 1.0;
  }

  move[pos].territorial_value = tot_value;
  move[pos].secondary_value  += secondary_value;
}


/*
 * Estimate the strategical value of a move at (pos).
 */
static void
estimate_strategical_value(int pos, int color, float score)
{
  int k;
  int l;
  int aa = NO_MOVE;
  int bb = NO_MOVE;
  float aa_value = 0.0;
  float bb_value = 0.0;
  int d1 = -1;
  int d2 = -1;
  int worm1 = -1;
  int worm2 = -1;
  int ecolor = 0;
  
  float this_value = 0.0;
  float tot_value = 0.0;

  /* Strategical value of connecting or cutting dragons. */
  static float dragon_value[MAX_DRAGONS];

  /* This loop used to be up to next_dragon, but that is not safe
   * because while doing the computations below, next_dragon might
   * increase (through calls to find_dragon()). Thus we could then
   * reference improperly initialized memory.
   */
  for (k = 0; k < MAX_DRAGONS; k++)
    dragon_value[k] = 0.0;
  
  for (k = 0; k < MAX_REASONS; k++) {
    int r = move[pos].reason[k];
    if (r < 0)
      break;
    if (move_reasons[r].status & STRATEGICALLY_REDUNDANT)
      continue;
    
    this_value = 0.0;
    switch (move_reasons[r].type) {
      case ATTACK_MOVE:
      case ATTACK_MOVE_GOOD_KO:
      case ATTACK_MOVE_BAD_KO:
      case DEFEND_MOVE:
      case DEFEND_MOVE_GOOD_KO:
      case DEFEND_MOVE_BAD_KO:
	worm1 = move_reasons[r].what;
	aa = worms[worm1];
      
	/* Defenseless stone */
	if (worm[aa].defend_codes[0] == 0)
	  break;

	/* FIXME: This is totally ad hoc, just guessing the value of
         *        potential cutting points.
	 * FIXME: When worm[aa].cutstone2 == 1 we should probably add
	 *        a followup value.
	 */
	if (worm[aa].cutstone2 > 1) {
	  double ko_factor = 1;
	  if (move_reasons[r].type == ATTACK_MOVE_GOOD_KO
	      || move_reasons[r].type == DEFEND_MOVE_GOOD_KO) {
	    ko_factor = 0.6;
	  }
	  else if (move_reasons[r].type == ATTACK_MOVE_BAD_KO
		   || move_reasons[r].type == DEFEND_MOVE_BAD_KO) {
	    ko_factor = 0.4;
	  }
	  this_value = 10.0 * (worm[aa].cutstone2 - 1) * ko_factor;
	  TRACE("  %1m: %f - %1m cutstone\n", pos, this_value, aa);
	}
	
	tot_value += this_value;
	
	/* If the string is a lunch for a weak dragon, the attack or
         * defense has a strategical value. This can be valued along
	 * the same lines as strategic_attack/strategic_defend.
	 *
	 * No points are awarded if the lunch is an inessential dragon
	 * or worm.
	 */
	if (DRAGON2(aa).safety == INESSENTIAL
	    || worm[aa].inessential)
	  break;

	/* Can't use k in this loop too. */
	for (l = 0; l < next_lunch; l++)
	  if (lunch_worm[l] == worm1) {
	    d1 = lunch_dragon[l];
	    bb = dragons[d1];

	    /* FIXME: This value cannot be computed without some
	     * measurement of how the actual move affects the dragon.
	     * The dragon safety alone is not enough. The question is
	     * whether the dragon is threatened by the move or not.
	     */
	    this_value = (dragon[bb].effective_size
			  * (1.0 - dragon_safety(bb, 0)));

	    /* If this dragon consists of only one worm and that worm
	     * can be tactically captured or defended by this move, we
	     * have already counted the points as territorial value,
	     * unless it's assumed to be dead.
	     */
	    if (dragon[bb].matcher_status != DEAD
		&& dragon[bb].size == worm[bb].size
		&& (attack_move_reason_known(pos, find_worm(bb))
		    || defense_move_reason_known(pos, find_worm(bb))))
	      this_value = 0.0;

	    /* If this dragon can be tactically attacked and the move
             * does not defend, no points.
	     */
	    if (worm[bb].attack_codes[0] != 0 && !does_defend(pos, bb))
	      this_value = 0.0;

	    /* If we are doing scoring, are alive, and the move loses
             * territory, no points.
	     */
	    if (doing_scoring
		&& move[pos].territorial_value < 0.0
		&& (DRAGON2(bb).safety == WEAKLY_ALIVE
		    || DRAGON2(bb).safety == ALIVE
		    || DRAGON2(bb).safety == STRONGLY_ALIVE
		    || DRAGON2(bb).safety == INVINCIBLE))
	      this_value = 0.0;
	    
	    if (this_value > dragon_value[d1]) {
	      DEBUG(DEBUG_MOVE_REASONS,
		    "  %1m:   %f - %1m attacked/defended\n",
		    pos, this_value, bb);
	      dragon_value[d1] = this_value;
	    }
	  }

	break;
	
      case ATTACK_THREAT:
      case DEFEND_THREAT:
        break;

      case EITHER_MOVE:
	/* FIXME: Generalize this to more types of threats. */
	worm1 = either_data[move_reasons[r].what].what1;
	worm2 = either_data[move_reasons[r].what].what2;
	aa = worms[worm1];
	bb = worms[worm2];

	/* If both worms are dead, this move reason has no value. */
	if (dragon[aa].matcher_status == DEAD 
	    && dragon[bb].matcher_status == DEAD)
	  break;

	/* Also if there is a combination attack, we assume it covers
	 * the same thing.
	 */
	if (move_reason_known(pos, MY_ATARI_ATARI_MOVE, -1))
	  break;

	aa_value = adjusted_worm_attack_value(pos, aa);
	bb_value = adjusted_worm_attack_value(pos, bb);
	this_value = gg_min(aa_value, bb_value);

	TRACE("  %1m: %f - either attacks %1m (%f) or attacks %1m (%f)\n",
	      pos, this_value, aa, aa_value, bb, bb_value);

	tot_value += this_value;
	break;
	
      case ALL_MOVE:
	/* FIXME: Generalize this to more types of threats. */
	worm1 = all_data[move_reasons[r].what].what1;
	worm2 = all_data[move_reasons[r].what].what2;
	aa = worms[worm1];
	bb = worms[worm2];

	/* If both worms are dead, this move reason has no value. */
	if (dragon[aa].matcher_status == DEAD 
	    && dragon[bb].matcher_status == DEAD)
	  break;

	/* Also if there is a combination attack, we assume it covers
	 * the same thing.
	 */
	if (move_reason_known(pos, YOUR_ATARI_ATARI_MOVE, -1))
	  break;

	aa_value = worm[aa].effective_size;
	bb_value = worm[bb].effective_size;
	this_value = 2 * gg_min(aa_value, bb_value);

	TRACE("  %1m: %f - both defends %1m (%f) and defends %1m (%f)\n",
	      pos, this_value, aa, aa_value, bb, bb_value);

	tot_value += this_value;
	break;
	
      case CONNECT_MOVE:
	if (!move[pos].move_safety)
	  break;
	/* Otherwise fall through. */
      case CUT_MOVE:
	if (doing_scoring && !move[pos].move_safety)
	  break;

	d1 = conn_dragon1[move_reasons[r].what];
	d2 = conn_dragon2[move_reasons[r].what];
	aa = dragons[d1];
	bb = dragons[d2];

	/* If we are ahead by more than 20, value connections more strongly */
	if ((color == WHITE && score > 20.0)
	    || (color == BLACK && score < -20.0))
	  this_value = connection_value(aa, bb, pos, gg_abs(score));
	else
	  this_value = connection_value(aa, bb, pos, 0);
	if (this_value > dragon_value[d1]) {
	  dragon_value[d1] = this_value;
          DEBUG(DEBUG_MOVE_REASONS,
		"  %1m:   %f - %1m cut/connect strategic value\n",
		pos, this_value, aa);
	}

	
	if ((color == WHITE && score > 20.0)
	    || (color == BLACK && score < -20.0))
	  this_value = connection_value(bb, aa, pos, gg_abs(score));
	else
	  this_value = connection_value(bb, aa, pos, 0);
	if (this_value > dragon_value[d2]) {
	  dragon_value[d2] = this_value;
          DEBUG(DEBUG_MOVE_REASONS,
		"  %1m:   %f - %1m cut/connect strategic value\n",
		pos, this_value, bb);
	}
	
	break;
	
      case SEMEAI_MOVE:
	/*
	 * The strategical value of winning a semeai is
	 * own dragons (usually) becomes fully secure, while adjoining
	 * enemy dragons do not.
	 *
	 * FIXME: Valuation not implemented at all yet. 
	 */

	break;
	
      case VITAL_EYE_MOVE:
	/*
	 * The value of the threatened group itself has already been
	 * accounted for in territorial_value. Now we need to determine
	 * the effect this has on surrounding groups.
	 *
	 * FIXME: Valuation not implemented.
	 */
	aa = eyes[move_reasons[r].what];
	ecolor = eyecolor[move_reasons[r].what];

	if (ecolor == WHITE) 
	  bb = white_eye[aa].dragon;
	else
	  bb = black_eye[aa].dragon;

	if (bb == NO_MOVE) /* Maybe we should assert this not to happen. */
	  break; 

	/* If there is an owl attack/defend move reason for this location,
	 * we don't care about it, since otherwise we would count the
	 * points twice.
	 */
	if (owl_defense_move_reason_known(pos, find_dragon(bb))
	    || owl_attack_move_reason_known(pos, find_dragon(bb))) {
	  DEBUG(DEBUG_MOVE_REASONS,
		"    %1m: 0.0 - vital for %1m: owl attack/defense as well\n",
		pos, bb);
	  break;
	}

#if 0
       if (dragon[bb].matcher_status == CRITICAL) {
	  this_value = ???
         TRACE("  %1m: %f - vital for %1m\n",
               pos, this_value, bb);
	  tot_value += this_value;
	}
#endif
	break;

      case STRATEGIC_ATTACK_MOVE:
      case STRATEGIC_DEFEND_MOVE:	
	/* The right way to do this is to estimate the safety of the
	 * dragon before and after the move. Unfortunately we are
	 * missing good ways to do this currently.
	 *
	 * Temporary solution is to only look at an ad hoc measure of
	 * the dragon safety and ignoring the effectiveness of the
	 * move.
	 *
	 * FIXME: Improve the implementation.
	 */
	d1 = move_reasons[r].what;
	aa = dragons[d1];

	/* FIXME: This value cannot be computed without some
	 * measurement of how the actual move affects the dragon. The
	 * dragon safety alone is not enough. The question is whether
	 * the dragon is threatened by the move or not.
	 */
	this_value = (dragon[aa].effective_size
		      * (1.0 - dragon_safety(aa, 1)));

	/* To prefer good connections and cuts, we lower this value
	 * somewhat.
	 */
	this_value *= 0.75;

	/* No strategical attack value is awarded if the dragon at (aa)
	 * has an adjacent (friendly) critical dragon, which is not
	 * defended by this move. In that case it's probably a mistake
	 * to make the strategical attack since the dragon can defend
	 * itself with profit.
	 *
	 * FIXME: We probably need to verify that the critical dragon is
	 * substantial enough that capturing it saves the strategically
	 * attacked dragon.
	 */
	if (move_reasons[r].type == STRATEGIC_ATTACK_MOVE) {
	  int s;
	  
	  for (s = 0; s < DRAGON2(aa).neighbors; s++) {
	    int d = DRAGON2(aa).adjacent[s];
	    int adj = dragon2[d].origin;
	    
	    if (dragon[adj].color == color
		&& dragon[adj].matcher_status == CRITICAL
		&& dragon2[d].safety != INESSENTIAL
		&& !owl_defense_move_reason_known(pos, find_dragon(adj)))
	      this_value = 0.0;
	  }
	}
		
	if (this_value > dragon_value[d1]) {
	  dragon_value[d1] = this_value;
          DEBUG(DEBUG_MOVE_REASONS,
		"  %1m:   %f - %1m strategic attack/defend\n",
		pos, this_value, aa);

	}
	break;

      case UNCERTAIN_OWL_DEFENSE:
	d1 = move_reasons[r].what;
	aa = dragons[d1];
	
	/* If there is an adjacent dragon which is critical we should
	 * skip this type of move reason, since attacking or defending
	 * the critical dragon is more urgent.
	 */
	{
	  int d;
	  int found_one = 0;
	  
	  for (d = 0; d < DRAGON2(aa).neighbors; d++)
	    if (DRAGON(DRAGON2(aa).adjacent[d]).matcher_status == CRITICAL)
	      found_one = 1;
	  if (found_one)
	    break;
	}
	
	/* If we are behind, we should skip this type of move reason. 
	 * If we are ahead, we should value it more. 
	 */
	if ((color == BLACK && score > 0.0)
	    || (color == WHITE && score < 0.0))
	  this_value = 0.0;
	else 
	  this_value = gg_min(2*dragon[aa].effective_size, gg_abs(.65*score));
	
	if (this_value > dragon_value[d1]) {
	  dragon_value[d1] = this_value;
	  DEBUG(DEBUG_MOVE_REASONS,
		"  %1m:   %f - %1m uncertain owl defense bonus\n",
		pos, this_value, aa);
	}

	break;
    }
  }
  
  for (k = 0; k < next_dragon; k++) {
    if (dragon_value[k] == 0.0)
      continue;

    aa = dragons[k];
    
    /* If this dragon consists of only one worm and that worm can
     * be tactically captured or defended by this move, we have
     * already counted the points as territorial value, unless
     * it's assumed to be dead.
     */
    if (dragon[aa].matcher_status != DEAD
	&& dragon[aa].size == worm[aa].size
	&& (attack_move_reason_known(pos, find_worm(aa))
	    || defense_move_reason_known(pos, find_worm(aa)))) {
      TRACE("  %1m:   %f - %1m strategic value already counted.\n",
	    pos, dragon_value[k], aa);
      continue;
    }
    /* If the dragon has been owl captured, owl defended, or involved
     * in a semeai, we have likewise already counted the points as
     * territorial value.
     */
    if (owl_attack_move_reason_known(pos, k)
	|| owl_defense_move_reason_known(pos, k)
	|| move_reason_known(pos, SEMEAI_MOVE, k)) {
      /* But if the strategical value was larger than the territorial
       * value (e.g. because connecting to strong dragon) we award the
       * excess value as a bonus.
       */
      float excess_value = (dragon_value[k] - 
			    2 * dragon[dragons[k]].effective_size);
      if (excess_value > 0.0) {
	TRACE("  %1m: %f - strategic bonus for %1m\n",
	      pos, excess_value, dragons[k]);
	tot_value += excess_value;
      }
      else {
	TRACE("  %1m:   %f - %1m strategic value already counted.\n",
	      pos, dragon_value[k], aa);
      }
      
      continue;
    }

    TRACE("  %1m: %f - strategic effect on %1m\n",
	  pos, dragon_value[k], dragons[k]);
    tot_value += dragon_value[k];
  }
  
  /* Finally, subtract penalty for invasion type moves. */
  this_value = strategic_penalty(pos, color);
  if (this_value > 0.0) {
    TRACE("  %1m: %f - strategic penalty, considered as invasion.\n",
	  pos, -this_value);
    tot_value -= this_value;
  }

  move[pos].strategical_value = tot_value;
}


/* Compare two move reasons, used for sorting before presentation. */
static int
compare_move_reasons(const void *p1, const void *p2)
{
  const int mr1 = *(const int *) p1;
  const int mr2 = *(const int *) p2;

  if (move_reasons[mr1].type != move_reasons[mr2].type)
    return move_reasons[mr2].type - move_reasons[mr1].type;
  else
    return move_reasons[mr2].what - move_reasons[mr1].what;
}


/*
 * Combine the reasons for a move at (pos) into a simple numerical value.
 * These heuristics are now somewhat less ad hoc than before but probably
 * still need a lot of improvement.
 */
static float
value_move_reasons(int pos, int color, float pure_threat_value,
		   float score)
{
  float tot_value;
  float shape_factor;

  gg_assert(stackp == 0);
  
  /* Is it an antisuji? */
  if (is_antisuji_move(pos))
    return 0.0; /* This move must not be played. End of story. */

  /* If this move has no reason at all, we can skip some steps. */
  if ((!urgent || allpats)
      && (move[pos].reason[0] >= 0
	  || move[pos].min_territory > 0.0)) {
    int num_reasons;

    /* Sort the move reasons. This makes it easier to visually compare
     * the reasons for different moves in the trace outputs.
     */
    num_reasons = 0;
    while (move[pos].reason[num_reasons] >= 0)
      num_reasons++;
    gg_sort(move[pos].reason, num_reasons, sizeof(move[pos].reason[0]),
	    compare_move_reasons);

    /* Discard move reasons that only duplicate another. */
    discard_redundant_move_reasons(pos);

    /* Estimate the value of various aspects of the move. The order
     * is significant. Territorial value must be computed before
     * strategical value. See connection_value().
     */
    estimate_territorial_value(pos, color, score);
    estimate_strategical_value(pos, color, score);
  }

  tot_value = move[pos].territorial_value + move[pos].strategical_value;

  shape_factor = compute_shape_factor(pos);

  if (tot_value > 0.0) {
    int c;
    float followup_value;
    if (experimental_influence) {
      followup_value = move[pos].followup_value
                       + move[pos].influence_followup_value;
      TRACE("  %1m:   %f - total followup value, added %f as territorial followup\n",
            pos, followup_value, move[pos].influence_followup_value);
    }
    else
      followup_value = move[pos].followup_value;
    
    /* In the endgame, there are a few situations where the value can
     * be 0 points + followup.  But we want to take the intersections first
     * were we actually get some points.  0.5 points is a 1 point ko which
     * is the smallest value that is actually worth something.
     * tm - But with reverse_followup values, we may want to play a 0
     *      point move. 
     */
    if (tot_value >= 0.5 
        || (move[pos].reverse_followup_value >= 1.0)) {
      float old_tot_value = tot_value;
      float contribution;
      /* We adjust the value according to followup and reverse followup
       * values.
       */
      contribution = gg_min(gg_min(0.5 * followup_value
				   + 0.5 * move[pos].reverse_followup_value,
				   1.0 * tot_value
				   + followup_value),
			    1.1 * tot_value
			    + move[pos].reverse_followup_value);
      tot_value += contribution;
      /* The first case applies to gote vs gote situation, the
       * second to reverse sente, and the third to sente situations.
       * The usual rule is that a sente move should count at double
       * value. But if we have a 1 point move with big followup (i.e.
       * sente) we want to play that before a 2 point gote move. Hence
       * the factor 1.1 above.
       */
      
      if (contribution != 0.0) {
	TRACE("  %1m: %f - added due to followup (%f) and reverse followup values (%f)\n",
              pos, contribution, followup_value,
              move[pos].reverse_followup_value);
      }

      /* If a ko fight is going on, we should use the full followup
       * and reverse followup values in the total value. We save the
       * additional contribution for later access.
       */
      move[pos].additional_ko_value =
	followup_value 
	+ move[pos].reverse_followup_value 
	- (tot_value - old_tot_value);

      /* Not sure whether this could happen, but check for safety. */
      if (move[pos].additional_ko_value < 0.0)
	move[pos].additional_ko_value = 0.0;
    }
    else {
      move[pos].additional_ko_value =
	shape_factor * (move[pos].followup_value
			+ move[pos].reverse_followup_value);
    }

    tot_value += 0.05 * move[pos].secondary_value;
    if (move[pos].secondary_value != 0.0)
      TRACE("  %1m: %f - secondary\n", pos, 0.05 * move[pos].secondary_value);

    if (move[pos].numpos_shape + move[pos].numneg_shape > 0) {
      /* shape_factor has already been computed. */
      float old_value = tot_value;
      tot_value *= shape_factor;
      if (verbose) {
	/* Should all have been TRACE, except we want field sizes. */
	gprintf("  %1m: %f - shape ", pos, tot_value - old_value);
	fprintf(stderr,
		"(shape values +%4.2f(%d) -%4.2f(%d), shape factor %5.3f)\n",
		move[pos].maxpos_shape, move[pos].numpos_shape,
		move[pos].maxneg_shape, move[pos].numneg_shape,
		shape_factor);
      }
    }

    /* Add a special shape bonus for moves which connect own strings
     * or cut opponent strings.
     */
    c = (move_connects_strings(pos, color)
	 + move_connects_strings(pos, OTHER_COLOR(color)));
    if (c > 0) {
      float shape_factor2 = pow(1.02, (float) c) - 1;
      float base_value = gg_max(gg_min(tot_value, 5.0), 1.0);
      if (verbose) {
	/* Should all have been TRACE, except we want field sizes. */
	gprintf("  %1m: %f - connects strings ", pos,
		base_value * shape_factor2);
	fprintf(stderr, "(connect value %d, shape factor %5.3f)\n", c,
		shape_factor2);
      }
      tot_value += base_value * shape_factor2;
    }
  }
  else {
    move[pos].additional_ko_value =
      shape_factor * (move[pos].followup_value +
		      gg_min(move[pos].followup_value,
			     move[pos].reverse_followup_value));
  }

  /* If the move is valued 0 or small, but has followup values and is
   * flagged as a worthwhile threat, add up to pure_threat_value to
   * the move.
   *
   * FIXME: We shouldn't have to call confirm_safety() here. It's
   * potentially too expensive.
   */
  if (pure_threat_value > 0.0 
      && move[pos].worthwhile_threat
      && tot_value <= pure_threat_value
      && board[pos] == EMPTY
      && move[pos].additional_ko_value > 0.0
      && is_legal(pos, color)
      && move_reasons_confirm_safety(pos, color, 0)) {
    float new_tot_value = gg_min(pure_threat_value,
				 tot_value
				 + 0.25 * move[pos].additional_ko_value);

    /* Make sure that moves with independent value are preferred over
     * those without.
     */
    new_tot_value *= (1.0 - 0.1 * (pure_threat_value - tot_value)
		      / pure_threat_value);
    
    if (new_tot_value > tot_value) {
      TRACE("  %1m: %f - carry out threat or defend against threat\n",
	    pos, new_tot_value - tot_value);
      tot_value = new_tot_value;
    }
  }
  
  /* Test if min_value or max_value values constrain the total value.
   * First avoid contradictions between min_value and max_value,
   * assuming that min_value is right.
   */
  if (move[pos].min_value > move[pos].max_value)
    move[pos].max_value = move[pos].min_value;

  /* If several moves have an identical minimum value, then GNU Go uses the
   * following secondary criterion (unless min_value and max_value agree, and
   * unless min_value is bigger than 25, in which case it probably comes from
   * a J or U pattern): 
   */
  if (move[pos].min_value < 25)
    move[pos].min_value += tot_value / 200;
  if (tot_value < move[pos].min_value
      && move[pos].min_value > 0) {
    tot_value = move[pos].min_value;
    TRACE("  %1m:   %f - minimum accepted value\n", pos, tot_value);
  }
  
  if (tot_value > move[pos].max_value) {
    tot_value = move[pos].max_value;
    TRACE("  %1m:   %f - maximum accepted value\n",
          pos, tot_value);
  }

  if (tot_value > 0
      || move[pos].territorial_value > 0
      || move[pos].strategical_value > 0) {
    TRACE("Move generation values %1m to %f\n", pos, tot_value);
    move_considered(pos, tot_value);
  }

  return tot_value;
}


/*
 * Loop over all possible moves and value the move reasons for each.
 */
static void
value_moves(int color, float pure_threat_value, float score)
{
  int m;
  int n;
  int pos;

  TRACE("\nMove valuation:\n");
  
  /* Visit the moves in the standard lexicographical order */
  for (n = 0; n < board_size; n++)
    for (m = board_size-1; m >= 0; m--) {
      pos = POS(m, n);

      move[pos].value = value_move_reasons(pos, color, 
					   pure_threat_value, score);
      if (move[pos].value == 0.0)
	continue;

      /* Maybe this test should be performed elsewhere. This is just
       * to get some extra safety. We don't filter out illegal ko
       * captures here though, because if that is the best move, we
       * should reevaluate ko threats.
       */
      if (is_legal(pos, color) || is_illegal_ko_capture(pos, color)) {
	/* Add a random number between 0 and 0.01 to use in comparisons. */
	move[pos].value += 0.01 * move[pos].random_number;
      }
      else {
	move[pos].value = 0.0;
	TRACE("Move at %1m wasn't legal.\n", pos);
      }
    }
}


/* Search through all board positions for the 10 highest valued
 * moves and print them.
 */

static void
print_top_moves(void)
{
  int k;
  int m, n;
  int pos;
  float tval;
  
  for (k = 0; k < 10; k++)
    best_move_values[k] = 0.0;
  
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      pos = POS(m, n);

      if (move[pos].final_value <= 0.0)
	continue;
      
      tval = move[pos].final_value;

      for (k = 9; k >= 0; k--)
	if (tval > best_move_values[k]) {
	  if (k < 9) {
	    best_move_values[k+1] = best_move_values[k];
	    best_moves[k+1] = best_moves[k];
	  }
	  best_move_values[k] = tval;
	  best_moves[k] = pos;
	}
    }

  TRACE("\nTop moves:\n");
  for (k = 0; k < 10 && best_move_values[k] > 0.0; k++) {
    TRACE("%d. %1M %f\n", k+1, best_moves[k], best_move_values[k]);
  }
}


/* This function is called if the biggest move on board was an illegal
 * ko capture.
 * FIXME: We need a check here whether the threat still works after
 * the opponent fills in the ko (or resolves it in another way.)
 */
static void
reevaluate_ko_threats(int ko_move, int color)
{
  int ko_stone = NO_MOVE;
  int opp_ko_move;
  int m, n;
  int pos;
  int k;
  int type, what;
  int threat_does_work = 0;
  int ko_move_target;
  float threat_size;

  ko_move_target = get_biggest_owl_target(ko_move);
  
  /* Find the ko stone. */
  for (k = 0; k <= 3; k++) {
    ko_stone = ko_move + delta[k];
    if (ON_BOARD(ko_stone) && countlib(ko_stone) == 1)
      break;
  }
  ASSERT_ON_BOARD1(ko_stone);
  
  TRACE("Reevaluating ko threats.\n");
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      pos = POS(m, n);
      if (pos == ko_move)
        continue;
      if (move[pos].additional_ko_value <= 0.0) 
        continue;

      /* Otherwise we look for the biggest threat, and then check whether
       * it still works after ko has been resolved.
       */
      threat_size = 0.0;
      type = -1;
      what = -1;
      for (k = 0; k < MAX_REASONS; k++) {
        int r = move[pos].reason[k];
        if (r < 0)
          break;
        if (!(move_reasons[r].type & THREAT_BIT))
          continue;
        switch (move_reasons[r].type) {
        case ATTACK_THREAT:
        case DEFEND_THREAT:
          if (worm[worms[move_reasons[r].what]].effective_size
              > threat_size) {
            threat_size = worm[worms[move_reasons[r].what]].effective_size;
            type = move_reasons[r].type;
            what = move_reasons[r].what;
          }
          break;
        case OWL_ATTACK_THREAT:
        case OWL_DEFEND_THREAT:   
        case SEMEAI_THREAT:
          if (dragon[dragons[move_reasons[r].what]].effective_size
              > threat_size) {
            threat_size = dragon[dragons[move_reasons[r].what]]\
                          .effective_size;
            type = move_reasons[r].type;
            what = move_reasons[r].what;
          }
          break;
        default:
          /* This means probably someone has introduced a new threat type
           * without adding the corresponding case above.
           */
          gg_assert(0);
          break;
        }
      } 
      /* If there is no threat recorded, the followup value is probably
       * contributed by a pattern. We can do nothing but accept this value.
       * (although this does cause problems).
       */
      if (type == -1)
        threat_does_work = 1;
      else
        if (trymove(pos, color, "reevaluate_ko_threats", ko_move,
                    EMPTY, ko_move)) {
	  ASSERT_ON_BOARD1(ko_stone);
          if (!find_defense(ko_stone, &opp_ko_move))
            threat_does_work = 1;
          else {
            if (trymove(opp_ko_move, OTHER_COLOR(color),
                        "reevaluate_ko_threats", ko_move, EMPTY, NO_MOVE)) {
              switch (type) {
              case ATTACK_THREAT:
                threat_does_work = attack(worms[what], NULL);
                break;
              case DEFEND_THREAT:
                threat_does_work = (board[worms[what]] != EMPTY
                                    && find_defense(worms[what], NULL));
                break;
              case OWL_ATTACK_THREAT:
              case OWL_DEFEND_THREAT:
                /* Should we call do_owl_attack/defense here?
                 * Maybe too expensive? For the moment we just assume
                 * that the attack does not work if it concerns the
                 * same dragon as ko_move. (Can this really happen?)
                 */
                threat_does_work = (ko_move_target != what);
              }
              popgo();
            }
          }
          popgo();
        }
 
      if (threat_does_work) {
	TRACE("%1m: %f + %f = %f\n", pos, move[pos].value,
	      move[pos].additional_ko_value,
	      move[pos].value + move[pos].additional_ko_value);
	move[pos].value += move[pos].additional_ko_value;
      }
      else
        DEBUG(DEBUG_MOVE_REASONS,
              "%1m: no additional ko value (threat does not work as ko threat)\n", pos);
    }
}


/* Redistribute points. When one move is declared a replacement for
 * another by a replacement move reason, the move values for the
 * inferior move are transferred to the replacement.
 */
static void
redistribute_points(void)
{
  int m, n;
  int pos;
  int ii;

  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      pos = POS(m, n);

      move[pos].final_value = move[pos].value;
    }
  
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      pos = POS(m, n);
      
      ii = replacement_map[pos];
      if (ii == NO_MOVE)
	continue;

      TRACE("Redistributing points from %1m to %1m.\n", pos, ii);
      if (move[ii].final_value < move[pos].final_value) {
	TRACE("%1m is now valued %f.\n", ii, move[pos].final_value);
	move[ii].final_value = move[pos].final_value;
      }
      TRACE("%1m is now valued 0.\n", pos);
      move[pos].final_value = 0.0;
    }
}


/*
 * Review the move reasons to find which (if any) move we want to play.
 *
 * The parameter pure_threat_value is the value assigned to a move
 * which only threatens to capture or kill something. The reason for
 * playing these is that the move may be effective because we have
 * misevaluated the dangers or because the opponent misplays.
 */
int
review_move_reasons(int *the_move, float *val, int color,
		    float pure_threat_value, float score)
{
  int m, n;
  int ii;
  float tval;
  float bestval = 0.0;
  int best_move = NO_MOVE;
  int ko_values_have_been_added = 0;
  int allowed_blunder_size = 0;

  int good_move_found = 0;
  int save_verbose;
  
  start_timer(2);
  if (!urgent || allpats) {
    find_more_attack_and_defense_moves(color);
    time_report(2, "  find_more_attack_and_defense_moves", NO_MOVE, 1.0);
  }

  save_verbose = verbose;
  if (verbose > 0)
    verbose--;
  if (level > 5) {
    find_more_owl_attack_and_defense_moves(color);
    time_report(2, "  find_more_owl_attack_and_defense_moves", NO_MOVE, 1.0);
  }
  verbose = save_verbose;

  induce_secondary_move_reasons(color);
  time_report(2, "  induce_secondary_move_reasons", NO_MOVE, 1.0);
  
  if (verbose > 0)
    verbose--;
  examine_move_safety(color);
  time_report(2, "  examine_move_safety", NO_MOVE, 1.0);
  verbose = save_verbose;

  if (printworms || verbose)
    list_move_reasons(color);

  /* Evaluate all moves with move reasons. */
  value_moves(color, pure_threat_value, score);
  time_report(2, "  value_moves", NO_MOVE, 1.0);

  /* Perform point redistribution */
  redistribute_points();

  /* Search through all board positions for the 10 highest valued
   * moves and print them.
   */
  print_top_moves();
  while (!good_move_found) {
    bestval = 0.0;
    best_move = NO_MOVE;

    /* Search through all board positions for the highest valued move. */
    for (m = 0; m < board_size; m++)
      for (n = 0; n < board_size; n++) {
	ii = POS(m, n);

	if (move[ii].final_value == 0.0)
	  continue;
	
	tval = move[ii].final_value;
	
	if (tval > bestval) {
	  if (is_legal(ii, color) || is_illegal_ko_capture(ii, color)) {
	    bestval = tval;
	    best_move = ii;
	  }
	  else {
	    TRACE("Move at %1m would be suicide.\n", ii);
	    move[ii].value = 0.0;
	    move[ii].final_value = 0.0;
	  }
	}
      }
    
    /* Compute the size of strings we can allow to lose due to blunder
     * effects. If ko threat values have been added, only the base
     * value of the move must be taken into account here.
     */
    if (!ko_values_have_been_added || !ON_BOARD(best_move))
      allowed_blunder_size = (int) (bestval / 2 - 1);
    else {
      int base_value;

      ASSERT_ON_BOARD1(best_move);
      base_value = bestval - move[best_move].additional_ko_value;
      allowed_blunder_size = (int) (base_value / 2 - 1);
    }
    
    /* If the best move is an illegal ko capture, reevaluate ko
     * threats and search again.
     */
    if (bestval > 0.0 && is_illegal_ko_capture(best_move, color)) {
      TRACE("Move at %1m would be an illegal ko capture.\n", best_move);
      reevaluate_ko_threats(best_move, color);
      redistribute_points();
      time_report(2, "  reevaluate_ko_threats", NO_MOVE, 1.0);
      ko_values_have_been_added = 1;
      move[best_move].value = 0.0;
      move[best_move].final_value = 0.0;
      print_top_moves();
      good_move_found = 0;
    }
    /* Call confirm_safety() to check that we're not about to make a
     * blunder. Otherwise reject this move and scan through all move
     * values once more.
     */
    else if (bestval > 0.0
	     && !move_reasons_confirm_safety(best_move, color,
					     allowed_blunder_size)) {
      TRACE("Move at %1m would be a blunder.\n", best_move);
      move[best_move].value = 0.0;
      move[best_move].final_value = 0.0;
      good_move_found = 0;
    }
    else
      good_move_found = 1;
  }
  
  if (bestval > 0.0 
      && best_move != NO_MOVE) {
    *the_move = best_move;
    *val = bestval;
    return 1;
  }

  return 0;
}


/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */



/* worm.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* #include <stdio.h> */
/* #include <stdlib.h> */
/* #include <string.h> */

/* #include "gnugo.h" */
/* #include "liberty.h" */

/* #include "patterns.h" */


static void compute_effective_worm_sizes(void);
static void compute_unconditional_status(void);
static void find_worm_attacks_and_defenses(void);
static void find_worm_threats(void);
static int find_lunch(int str, int *lunch);
static void change_tactical_point(int str, int move, int code,
				  int points[MAX_TACTICAL_POINTS],
				  int codes[MAX_TACTICAL_POINTS]);
static void propagate_worm2(int str);
static int genus(int str);
static void markcomponent(int str, int pos, int mg[BOARDMAX]);
static int examine_cavity(int pos, int *edge);
static void cavity_recurse(int pos, int mx[BOARDMAX], 
			   int *border_color, int *edge, int str);
static void ping_cave(int str, int *result1,  int *result2,
		      int *result3, int *result4);
static void ping_recurse(int pos, int *counter, 
			 int mx[BOARDMAX], 
			 int mr[BOARDMAX], int color);
static int touching(int pos, int color);
static void find_attack_patterns(void);
static void attack_callback(int m, int n, int color,
			    struct pattern *pattern, int ll, void *data);
static void find_defense_patterns(void);
static void defense_callback(int m, int n, int color,
			     struct pattern *pattern, int ll, void *data);
static void build_worms(void);

/* A STRING is a maximal connected set of stones of the same color, 
 * black or white. A WORM is the same thing as a string, except that
 * its color can be empty. An empty worm is called a CAVITY.
 *
 * Worms are eventually amalgamated into dragons. An empty dragon
 * is called a CAVE.
 */



/* make_worms() finds all worms and assembles some data about them.
 *
 * Each worm is marked with an origin.  This is an arbitrarily chosen
 * element of the worm, in practice the algorithm puts the origin at
 * the first element when they are given the lexicographical order,
 * though its location is irrelevant for applications. To see if two
 * stones lie in the same worm, compare their origins.
 *
 * We will use the field dragon[ii].genus to keep track of
 * black- or white-bordered cavities (essentially eyes) which are found.  
 * so this field must be zero'd now.
 */

void
make_worms(int save_verbose)
{
  int m, n; /* iterate over board */

  /* Build the basic worm data:  color, origin, size, liberties. */
  build_worms();

  /* No point continuing if the board is completely empty. */
  if (stones_on_board(BLACK | WHITE) == 0)
    return;

  /* Compute effective sizes of all worms. */
  compute_effective_worm_sizes();

  /* Look for unconditionally alive and dead worms, and unconditional
   * territory.
   */
  compute_unconditional_status();
  
  find_worm_attacks_and_defenses();
  
  gg_assert(stackp == 0);

  /* Count liberties of different orders and initialize cutstone fields. */
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      int pos = POS(m, n);
      if (board[pos] && is_worm_origin(pos, pos)) {
	int lib1, lib2, lib3, lib4;

	ping_cave(pos, &lib1, &lib2, &lib3, &lib4);
	gg_assert(worm[pos].liberties == lib1);
	worm[pos].liberties2 = lib2;
	worm[pos].liberties3 = lib3;
	worm[pos].liberties4 = lib4;
	worm[pos].cutstone = 0;
	worm[pos].cutstone2 = 0;
	propagate_worm(pos);
      }
    }
  
  gg_assert(stackp == 0);

/*
 * There are two concepts of cutting stones in the worm array.
 *
 * worm.cutstone:
 *
 *     A CUTTING STONE is one adjacent to two enemy strings,
 *     which do not have a liberty in common. The most common
 *     type of cutting string is in this situation.
 *  
 *     XO
 *     OX
 *     
 *     A POTENTIAL CUTTING STONE is adjacent to two enemy
 *     strings which do share a liberty. For example, X in:
 *     
 *     XO
 *     O.
 *     
 *     For cutting strings we set worm[m][n].cutstone=2. For potential
 *     cutting strings we set worm[m][n].cutstone=1. For other strings,
 *     worm[m][n].cutstone=0.
 *
 * worm.cutstone2:
 *
 *     Cutting points are identified by the patterns in the
 *     connections database. Proper cuts are handled by the fact
 *     that attacking and defending moves also count as moves
 *     cutting or connecting the surrounding dragons. 
 *
 * The cutstone field will now be set. The cutstone2 field is set
 * later, during find_cuts(), called from make_domains().
 *
 * We maintain both fields because the historically older cutstone
 * field is needed to deal with the fact that e.g. in the position
 *
 *
 *    OXX.O
 *    .OOXO
 *    OXX.O
 *
 * the X stones are amalgamated into one dragon because neither cut
 * works as long as the two O stones are in atari. Therefore we add
 * one to the cutstone field for each potential cutting point,
 * indicating that these O stones are indeed worth rescuing.
 *
 * For the time being we use both concepts in parallel. It's
 * possible we also need the old concept for correct handling of lunches.
 */

  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      int pos = POS(m, n);
      int w1 = NO_MOVE;
      int w2 = NO_MOVE;
      int i, j, k;

      /* Only work on each worm once. This is easiest done if we only 
       * work with the origin of each worm.
       */
      if (board[pos] == EMPTY || !is_worm_origin(pos, pos))
	continue;

      /* Try to find two adjacent worms (w1) and (w2) 
       * of opposite colour from (pos).
       */
      for (i = 0; i < board_size; i++)
	for (j = 0; j < board_size; j++) {
	  int pos2 = POS(i, j);
	  /* Work only with the opposite color from (pos). */
	  if (board[pos2] != OTHER_COLOR(board[pos])) 
	    continue;
	      
	  for (k = 0; k < 4; k++) {
	    if (!ON_BOARD(pos2 + delta[k])
		|| worm[pos2 + delta[k]].origin != pos)
	      continue;

	    ASSERT1(board[pos2 + delta[k]] == board[pos], pos);

	    /* If we have not already found a worm which meets the criteria,
	     * store it into (w1), otherwise store it into (w2).
	     */
	    if (w1 == NO_MOVE)
	      w1 = worm[pos2].origin;
	    else if (!is_same_worm(pos2, w1))
	      w2 = worm[pos2].origin;
	  } /* loop over k */
	} /* loop over i, j */

      /* 
       *  We now verify the definition of cutting stones. We have
       *  verified that the string at (pos) is adjacent to two enemy
       *  strings at (w1) and (w2). We need to know if these
       *  strings share a liberty.
       */

      /* Only do this if we really found something. */
      if (w2 != NO_MOVE) {
        worm[pos].cutstone = 2;
	if (count_common_libs(w1, w2) > 0)
	  worm[pos].cutstone = 1;
	  
	DEBUG(DEBUG_WORMS, 
	      "Worm at %1m has w1 %1m and w2 %1m, cutstone %d\n",
	      pos, w1, w2, worm[pos].cutstone);
      }

    } /* loop over m, n */

  gg_assert(stackp == 0);
  
  /* Set the genus of all worms. */
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      int pos = POS(m, n);
      if (IS_STONE(board[pos]) && is_worm_origin(pos, pos)) {
 	worm[pos].genus = genus(pos);
	propagate_worm(pos);
      }
    }
  gg_assert(stackp == 0);

  /* We try first to resolve small semeais. */
  small_semeai(save_verbose);
  gg_assert(stackp == 0);

  /* Now we try to improve the values of worm.attack and worm.defend.
   * If we find that capturing the string at (m, n) also defends the
   * string at (i, j), or attacks it, then we add points of attack and
   * defense. We don't add attacking point for strings that can't be
   * defended.
   */
  {
    int mi[BOARDMAX]; /* mark changed information */
    int mxcolor[BOARDMAX]; /* mark tried moves for color */
    int mxother[BOARDMAX]; /* mark tried moves for other */
    int i, j;

    memset(mi, 0, sizeof(mi));
    memset(mxcolor, 0, sizeof(mi));
    memset(mxother, 0, sizeof(mi));
    
    for (m = 0; m < board_size; m++)
      for (n = 0; n < board_size; n++) {
	int pos = POS(m, n);
	
	int color = board[pos];
	int other = OTHER_COLOR(color);
	
	int aa = worm[pos].attack_points[0];
	int dd = worm[pos].defense_points[0];
	
	/* For each worm, only work with the origin. */
	if (board[pos] == EMPTY || !is_worm_origin(pos, pos))
	  continue;
	
	/* If the opponent has an attack on the worm (m, n), and we
	 * have not tried this move before, carry it out and see
	 * what it leads to.
	 */
	if (aa != NO_MOVE && mxother[aa] == 0) {
	  
	  mxother[aa] = 1;
	  /* First, carry out the attacking move. */
	  if (trymove(aa, other, "make_worms", NO_MOVE, EMPTY, NO_MOVE)) {
	    
	    /* We must read to the same depth that was used in the
	     * initial determination of worm.attack and worm.defend
	     * to avoid horizon effect. Since stackp has been
	     * incremented we must also increment depth and
	     * backfill_depth. */
	    
	    /* Now we try to find a group which is saved or attacked as well
	       by this move. */
	    DEBUG(DEBUG_WORMS, "trying %1m\n", aa);
	    increase_depth_values();
	    
	    for (i = 0; i < board_size; i++)
	      for (j = 0; j < board_size; j++) {
		int pos2 = POS(i, j);
		/* If a worm has its origin (i, j), and it's not (m, n)...*/
		if (board[pos2]
		    && is_worm_origin(pos2, pos2)
		    && pos2 != pos) {
		  
		  /* Either the worm is of the same color as (m, n),
		   * then we try to attack it.  If there was a previous 
		   * attack and defense of it, and there is no defense
		   * for the attack now...
		   */
		  if (worm[pos2].color == color
		      && worm[pos2].attack_codes[0] != 0
		      && worm[pos2].defend_codes[0] != 0) {
		    int dcode = find_defense(pos2, NULL);
		    if (dcode < worm[pos2].defend_codes[0]) {
		      int attack_works = 1;
		      /* Sometimes find_defense() fails to find a
		       * defense which has been found by other means.
		       * Try if the old defense move still works.
		       */
		      if (worm[pos2].defend_codes[0] != 0
			  && trymove(worm[pos2].defense_points[0],
				     color, "make_worms", 0, EMPTY, 0)) {
			if (!attack(pos2, NULL))
			  attack_works = 0;
			popgo();
		      }
		    
		      /* ...then move the attack point of that worm to
		       * the attack point of (m, n).
		       */
		      if (attack_works) {
			DEBUG(DEBUG_WORMS,
			      "adding point of attack of %1m at %1m with code %d\n",
			      pos2, aa, 3 - dcode);
			change_attack(pos2, aa, 3 - dcode);
			mi[pos2] = 1;
		      }
		    }
		  }
		  
		  /* Or the worm is of the opposite color as (m, n).
		   * If there previously was an attack on it, but there
		   * is none now, then move the defense point of (i, j)
		   * to the defense point of (m, n).
		   */
		  else if (worm[pos2].color == other
			   && worm[pos2].attack_codes[0] != 0) {
		    int acode = attack(pos2, NULL); 
		    if (acode < worm[pos2].attack_codes[0]) {
		      DEBUG(DEBUG_WORMS,
			    "adding point of defense of %1m at %1m with code %d\n",
			    pos2, aa, 3 - acode);
		      change_defense(pos2, aa, 3 - acode);
		      mi[pos2] = 1;
		    }
		  }
		}
	      }
	    popgo();
	    decrease_depth_values();
	  }
	}
	
	/* If there is a defense point for the worm (m, n), and we
	 * have not tried this move before, move there and see what
	 * it leads to.
	 */
	if (dd != NO_MOVE && mxcolor[dd] == 0) {

	  mxcolor[dd] = 1;
	  /* First carry out the defending move. */
	  if (trymove(dd, color, "make_worms", NO_MOVE, EMPTY, NO_MOVE)) {
	    
	    DEBUG(DEBUG_WORMS, "trying %1m\n", dd);
	    increase_depth_values();
	    
	    for (i = 0; i < board_size; i++)
	      for (j = 0; j < board_size; j++) {
		int pos2 = POS(i, j);
		
		/* If a worm has its origin (i, j), and it's not (m, n)...*/
		if (board[pos2]
		    && is_worm_origin(pos2, pos2)
		    && pos2 != pos) {
		  
		  /* Either the worm is of the opposite color as (m, n),
		   * then we try to attack it.  If there was a previous 
		   * attack and defense of it, and there is no defense
		   * for the attack now...
		   */
		  if (worm[pos2].color == other
		      && worm[pos2].attack_codes[0] != 0 
		      && worm[pos2].defend_codes[0] != 0) {
		    int dcode = find_defense(pos2, NULL);
		    if (dcode < worm[pos2].defend_codes[0]) {
		    
		      int attack_works = 1;
		      /* Sometimes find_defense() fails to find a
			 defense which has been found by other means.
			 Try if the old defense move still works. */
		      if (trymove(worm[pos2].defense_points[0],
				  other, "make_worms",
				  NO_MOVE, EMPTY, NO_MOVE)) {
			if (!attack(pos2, NULL))
			  attack_works = 0;
			popgo();
		      }
		      
		      /* ...then move the attack point of that worm to
		       * the defense point of (m, n).
		       */
		      if (attack_works) {
			DEBUG(DEBUG_WORMS,
			      "adding point of attack of %1m at %1m with code %d\n",
			      pos2, dd, 3 - dcode);
			change_attack(pos2, dd, 3 - dcode);
			mi[pos2] = 1;
		      }
		    }
		  }
		  /* Or the worm is of the same color as (m, n).
		   * If there previously was an attack on it, but there
		   * is none now, then move the defense point of (i, j)
		   * to the defense point of (m, n).
		   */
		  else if (worm[pos2].color == color
			   && worm[pos2].attack_codes[0] != 0) {
		    int acode = attack(pos2, NULL);
		    if (acode < worm[pos2].attack_codes[0]) {
		      DEBUG(DEBUG_WORMS,
			    "adding point of defense of %1m at %1m with code %d\n",
			    pos2, dd, 3 - acode);
		      change_defense(pos2, dd, 3 - acode);
		      mi[pos2] = 1;
		    }
		  }
		}
	      }
	    popgo();
	    decrease_depth_values();
	  }
	}
      }

    /* FIXME: Should be redundant now. */
    /* Propagate the newly generated info to all other stones of each worm. */
    for (i = 0; i < board_size; i++)
      for (j = 0; j < board_size; j++)
	if (mi[POS(i, j)])
	  propagate_worm(POS(i, j));
  }

  gg_assert(stackp == 0);
  
  /* Sometimes it happens that the tactical reading finds adjacent
   * strings which both can be attacked but not defended. (The reason
   * seems to be that the attacker tries harder to attack a string,
   * than the defender tries to capture it's neighbors.) When this
   * happens, the eyes code produces overlapping eye spaces and still
   * worse all the nondefendable stones actually get amalgamated with
   * their allies on the outside.
   *
   * To solve this we scan through the strings which can't be defended
   * and check whether they have a neighbor that can be attacked. In
   * this case we set the defense point of the former string to the
   * attacking point of the latter.
   *
   * Please notice that find_defense() will still read this out
   * incorrectly, which may lead to some confusion later.
   */

  /* First look for vertical neighbors. */
  for (m = 0; m < board_size-1; m++)
    for (n = 0; n < board_size; n++) {
      int pos = POS(m, n);
      if (!is_same_worm(pos, SOUTH(pos))
	  && IS_STONE(board[pos])
	  && IS_STONE(board[SOUTH(pos)])) {
        if (worm[pos].attack_codes[0] != 0
	    && worm[SOUTH(pos)].attack_codes[0] != 0) {
	  if (worm[pos].defend_codes[0] == 0
	      && does_defend(worm[SOUTH(pos)].attack_points[0], pos)) {
	    /* FIXME: need to check ko relationship here */
	    change_defense(pos, worm[SOUTH(pos)].attack_points[0], WIN);
	  }
	  if (worm[SOUTH(pos)].defend_codes[0] == 0
              && does_defend(worm[pos].attack_points[0], SOUTH(pos))) {
	    /* FIXME: need to check ko relationship here */	    
	    change_defense(SOUTH(pos), worm[pos].attack_points[0], WIN);
	  }
        }
      }
    }
  
  /* Then look for horizontal neighbors. */
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size-1; n++) {
      int pos = POS(m, n);
      if (!is_same_worm(pos, EAST(pos))
	  && IS_STONE(board[pos])
	  && IS_STONE(board[EAST(pos)])) {
        if (worm[pos].attack_codes[0] != 0
	    && worm[EAST(pos)].attack_codes[0] != 0) {
	  if (worm[pos].defend_codes[0] == 0
              && does_defend(worm[EAST(pos)].attack_points[0], pos)) {
	    /* FIXME: need to check ko relationship here */	    
	    change_defense(pos, worm[EAST(pos)].attack_points[0], WIN);
	  }
	  if (worm[EAST(pos)].defend_codes[0] == 0
              && does_defend(worm[pos].attack_points[0], EAST(pos))) {
	    /* FIXME: need to check ko relationship here */	    
	    change_defense(EAST(pos), worm[pos].attack_points[0], WIN);
	  }
	}
      }
    }
  
  gg_assert(stackp == 0);
  
  /* Find adjacent worms that can be easily captured, aka lunches. */

  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      int pos = POS(m, n);
      int lunch;

      if (board[pos] == EMPTY || !is_worm_origin(pos, pos))
	continue;

      if (find_lunch(pos, &lunch)
	  && (worm[lunch].attack_codes[0] == WIN
	      || worm[lunch].attack_codes[0] == KO_A)) {
	DEBUG(DEBUG_WORMS, "lunch found for %1m at %1m\n", pos, lunch);
	worm[pos].lunch = lunch;
      }
      else
	worm[pos].lunch = NO_MOVE;

      propagate_worm(pos);
    }
  
  if (!disable_threat_computation)
    find_worm_threats();

  /* Identify INESSENTIAL strings.
   *
   * These are defined as surrounded strings which have no life
   * potential unless part of their surrounding chain can be captured.
   * We give a conservative definition of inessential:
   *  - the genus must be zero 
   *  - there can no second order liberties
   *  - there can be no more than two edge liberties
   *  - if it is removed from the board, the remaining cavity has
   *    border color the opposite color of the string 
   *  - it contains at most two edge vertices.
   *
   * If we get serious about identifying seki, we might want to add:
   *
   *  - if it has fewer than 4 liberties it is tactically dead.
   *
   * The last condition is helpful in excluding strings which are
   * alive in seki.
   *
   * An inessential string can be thought of as residing inside the
   * opponent's eye space.
   */

  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      int pos = POS(m, n);
      if (board[pos]
	  && worm[pos].origin == pos
	  && worm[pos].genus == 0
	  && worm[pos].liberties2 == 0
	  && !worm[pos].cutstone
	  && worm[pos].lunch == NO_MOVE)
      {
	int edge;

	int border_color = examine_cavity(pos, &edge);
	if (border_color != GRAY_BORDER && edge < 3) {
	  DEBUG(DEBUG_WORMS, "Worm %1m identified as inessential.\n", pos);
	  worm[pos].inessential = 1;
	  propagate_worm(pos);
	}
      }
    }
}


/* 
 * Clear all worms and initialize the basic data fields:
 *   color, origin, size, liberties
 * This is a substep of make_worms().
 */

static void
build_worms()
{
  int m, n;
  int pos;

  /* Set all worm data fields to 0. */
  memset(worm, 0 , sizeof(worm));

  /* Initialize the worm data for each worm. */
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++)
      worm[POS(m, n)].origin = NO_MOVE;

  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      pos = POS(m, n);
      if (worm[pos].origin != NO_MOVE)
	continue;
      worm[pos].color = board[pos];
      worm[pos].origin = pos;
      worm[pos].inessential = 0;
      worm[pos].invincible = 0;
      worm[pos].unconditional_status = UNKNOWN;
      worm[pos].effective_size = 0.0;
      if (IS_STONE(board[pos])) {
	worm[pos].liberties = countlib(pos);
	worm[pos].size = countstones(pos);
	propagate_worm(pos);
      }
    }
}


/* Compute effective size of each worm. 
 *
 * Effective size is the number of stones in a worm plus half the
 * number of empty intersections that are at least as close to this
 * worm as to any other worm. This is used to estimate the direct
 * territorial value of capturing a worm. Intersections that are
 * shared are counted with equal fractional values for each worm.
 *
 * We never count intersections further away than distance 3.
 */

static void
compute_effective_worm_sizes()
{
  int m, n;

  /* Distance to closest worm, -1 means unassigned, 0 that there is
   * a stone at the location, 1 a liberty of a stone, and so on.
   */
  int distance[MAX_BOARD][MAX_BOARD];
  /* Pointer to the origin of the closest worms. A very large number of
   * worms may potentially be equally close, but no more than
   * 2*(board_size-1).
   */
  static int worms[MAX_BOARD][MAX_BOARD][2*(MAX_BOARD-1)];
  int nworms[MAX_BOARD][MAX_BOARD];   /* number of equally close worms */
  int found_one;
  int dist; /* current distance */
  int k, l;
  int r;
    
  /* Initialize arrays. */
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {

      for (k = 0; k < 2*(board_size-1); k++)
	worms[m][n][k] = NO_MOVE;
      
      nworms[m][n] = 0;
	
      if (BOARD(m, n) == EMPTY)
	distance[m][n] = -1;
      else {
	distance[m][n] = 0;
	worms[m][n][0] = worm[POS(m, n)].origin;
	nworms[m][n]++;
      }
    }

  dist = 0;
  found_one = 1;
  while (found_one && dist <= 3) {
    found_one = 0;
    dist++;
    for (m = 0; m < board_size; m++)
      for (n = 0; n < board_size; n++) {
	if (distance[m][n] != -1)
	  continue; /* already claimed */

	for (r = 0; r < 4; r++) {
	  int ai = m + deltai[r];
	  int aj = n + deltaj[r];
	  
	  if (ON_BOARD2(ai, aj) && distance[ai][aj] == dist - 1) {
	    found_one = 1;
	    distance[m][n] = dist;
	    for (k = 0; k < nworms[ai][aj]; k++) {
	      int already_counted = 0;
	      for (l = 0; l < nworms[m][n]; l++)
		if (worms[m][n][l] == worms[ai][aj][k]) {
		  already_counted = 1;
		  break;
		}
	      if (!already_counted) {
		gg_assert(nworms[m][n] < 2*(board_size-1));
		worms[m][n][nworms[m][n]] = worms[ai][aj][k];
		nworms[m][n]++;
	      }
	    }
	  }
	}
      }
  }

  /* Distribute (fractional) contributions to the worms. */
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++)
      for (k = 0; k < nworms[m][n]; k++) {
	int aa = worms[m][n][k];
	if (BOARD(m, n) == EMPTY)
	  worm[aa].effective_size += 0.5/nworms[m][n];
	else
	  worm[aa].effective_size += 1.0;
      }
	
  /* Propagate the effective size values all over the worms. */
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++)
      if (IS_STONE(BOARD(m, n)) && is_worm_origin(POS(m, n), POS(m, n)))
	propagate_worm(POS(m, n));
}

/* Identify worms which are unconditionally uncapturable in the
 * strongest sense, i.e. even if the opponent is allowed an arbitrary
 * number of consecutive moves. Also identify worms which are
 * similarly unconditionally dead and empty points which are
 * unconditional territory for either player.
 */
static void
compute_unconditional_status()
{
  int unconditional_territory[BOARDMAX];
  int m, n;
  int color;
  int other;
  
  for (color = WHITE; color <= BLACK; color++) {
    other = OTHER_COLOR(color);
    unconditional_life(unconditional_territory, color);
    for (m = 0; m < board_size; m++)
      for (n = 0; n < board_size; n++) {
	int ii = POS(m, n);

	if (!unconditional_territory[ii])
	  continue;
	
	if (board[ii] == color) {
	  worm[ii].unconditional_status = ALIVE;
	  if (unconditional_territory[ii] == 1)
	    worm[ii].invincible = 1;
	}
	else if (board[ii] == EMPTY) {
	  if (color == WHITE)
	    worm[ii].unconditional_status = WHITE_BORDER;
	  else
	    worm[ii].unconditional_status = BLACK_BORDER;
	}
	else
	  worm[ii].unconditional_status = DEAD;
      }
  }
  gg_assert(stackp == 0);
}

/*
 * Analyze tactical safety of each worm. 
 */

static void
find_worm_attacks_and_defenses()
{
  int m, n;
  int k;

   /* 1. Start with finding attack points. */
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      int pos = POS(m, n);
      int acode;
      int tpos;

      if (board[pos] == EMPTY || !is_worm_origin(pos, pos))
	continue;

      TRACE("considering attack of %1m\n", pos);
      /* Initialize all relevant fields at once. */
      for (k = 0; k < MAX_TACTICAL_POINTS; k++) {
	worm[pos].attack_codes[k]   = 0;
	worm[pos].attack_points[k]  = 0;
	worm[pos].defend_codes[k]   = 0;
	worm[pos].defense_points[k] = 0;
      }
      propagate_worm(pos);
      
      acode = attack(pos, &tpos);
      if (acode) {
	DEBUG(DEBUG_WORMS, "worm at %1m can be attacked at %1m\n", pos, tpos);
	change_attack(pos, tpos, acode);
      }
    }
  gg_assert(stackp == 0);
  
  /* 2. Use pattern matching to find a few more attacks. */
  find_attack_patterns();
  gg_assert(stackp == 0);
  
  /* 3. Now find defense moves. */
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      int pos = POS(m, n);
      int dcode;

      if (board[pos] == EMPTY || !is_worm_origin(pos, pos))
	continue;

      if (worm[pos].attack_codes[0] != 0) {
	int tpos = NO_MOVE;

	TRACE("considering defense of %1m\n", pos);
	dcode = find_defense(pos, &tpos);
	if (dcode) {
	  TRACE("worm at %1m can be defended at %1m\n", pos, tpos);
	  if (tpos != NO_MOVE)
	    change_defense(pos, tpos, dcode);
	}
	else {
	  /* If the point of attack is not adjacent to the worm, 
	   * it is possible that this is an overlooked point of
	   * defense, so we try and see if it defends.
	   */
	  int aa = worm[pos].attack_points[0];
	  if (!liberty_of_string(aa, pos))
	    if (trymove(aa, worm[pos].color, "make_worms", NO_MOVE,
			EMPTY, NO_MOVE)) {
	      int acode = attack(pos, NULL);
	      if (acode != WIN) {
		change_defense(pos, aa, 3 - acode);
		TRACE("worm at %1m can be defended at %1m with code %d\n",
		      pos, aa, 3 - acode);
	      }	 
	      popgo();
	    }
	}
      }
    }
  gg_assert(stackp == 0);

  /* 4. Use pattern matching to find a few more defense moves. */
  find_defense_patterns();
  gg_assert(stackp == 0);
  
  /*
   * In the new move generation scheme, we need to find all moves that
   * attacks and or defends some string.
   */

  /*
   * 5. Find additional attacks and defenses by testing all immediate
   *    liberties. Further attacks and defenses are found by pattern
   *    matching and by trying whether each attack or defense point
   *    attacks or defends other strings.
   */
  {
    static int libs[MAXLIBS];
    int k;
    int color;
    int other;
    int liberties;

    for (m = 0; m < board_size; m++)
      for (n = 0; n < board_size; n++) {
	int pos = POS(m, n);
	color = board[pos];
	if (color == EMPTY || !is_worm_origin(pos, pos))
	  continue;

	other = OTHER_COLOR(color);
	
	if (worm[pos].attack_codes[0] == 0)
	  continue;
	
	/* There is at least one attack on this group. Try the
	 * liberties.
	 */
	liberties = findlib(pos, MAXLIBS, libs);
	
	for (k = 0; k < liberties; k++) {
	  int aa = libs[k];
	  if (!attack_move_known(aa, pos)) {
	    /* Try to attack on the liberty. */
	    if (trymove(aa, other, "make_worms", pos, EMPTY, NO_MOVE)) {
	      if (!board[pos] || attack(pos, NULL)) {
		int dcode;
		if (!board[pos])
		  dcode = 0;
		else
		  dcode = find_defense(pos, NULL);
		
		if (dcode != WIN) {
		  change_attack(pos, aa, 3 - dcode);
		}
	      }
	      popgo();
	    }
	  }
	  /* Try to defend at the liberty. */
	  if (!defense_move_known(aa, pos)) {
	    if (worm[pos].defend_codes[0] != 0)
	      if (trymove(aa, color, "make_worms", NO_MOVE, EMPTY, NO_MOVE)) {
		int acode = attack(pos, NULL);
		if (acode != WIN) {
		  change_defense(pos, aa, 3 - acode);
		}
		popgo();
	      }
	  }
	}
      }
  }
  gg_assert(stackp == 0);
}


/*
 * Find moves threatening to attack or save all worms.
 */

static void
find_worm_threats()
{
  int m, n;

  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      int pos = POS(m, n);
      int liberties;
      static int libs[MAXLIBS];

      int k;
      int l;
      int color;
      int other;

      /* Only work with origins. */
      color = board[pos];
      if (color == EMPTY || !is_worm_origin(pos, pos))
	continue;

      other = OTHER_COLOR(color);

      /* 1. Start with finding attack threats. */
      /* Only try those worms that have no attack. */
      if (worm[pos].attack_codes[0] == 0) {
	attack_threats(pos, MAX_TACTICAL_POINTS,
		       worm[pos].attack_threat_points,
		       worm[pos].attack_threat_codes);
#if 0
	/* Threaten to attack by saving weak neighbors. */
	num_adj = chainlinks(pos, adjs);
	for (k = 0; k < num_adj; k++) {
	  if (worm[adjs[k]].attack_codes[0] != 0
	      && worm[adjs[k]].defend_codes[0] != 0)
	    for (r = 0; r < MAX_TACTICAL_POINTS; r++) {
	      int bb;

	      if (worm[adjs[k]].defend_codes[r] == 0)
		break;
	      bb = worm[adjs[k]].defense_points[r];
	      if (trymove(bb, other, "threaten attack", pos,
			  EMPTY, NO_MOVE)) {
		int acode;
		if (board[pos] == EMPTY)
		  acode = WIN;
		else
		  acode = attack(pos, NULL);
		if (acode != 0)
		  change_attack_threat(pos, bb, acode);
		popgo();
	      }
	    }
	}
#endif
	/* FIXME: Try other moves also (patterns?). */
      }

      /* 2. Continue with finding defense threats. */
      /* Only try those worms that have an attack. */
      if (worm[pos].attack_codes[0] != 0
	  && worm[pos].defend_codes[0] == 0) {

	liberties = findlib(pos, MAXLIBS, libs);

	for (k = 0; k < liberties; k++) {
	  int aa = libs[k];

	  /* Try to threaten on the liberty. */
	  if (trymove(aa, color, "threaten defense", NO_MOVE,
		      EMPTY, NO_MOVE)) {
	    if (attack(pos, NULL) == WIN) {
	      int dcode = find_defense(pos, NULL);
	      if (dcode != 0)
		change_defense_threat(pos, aa, dcode);
	    }
	    popgo();
	  }

	  /* Try to threaten on second order liberties. */
	  for (l = 0; l < 4; l++) {
	    int bb = libs[k] + delta[l];

	    if (!ON_BOARD(bb)
		|| IS_STONE(board[bb])
		|| liberty_of_string(bb, pos))
	      continue;

	    if (trymove(bb, color, "threaten defense", pos, EMPTY, NO_MOVE)) {
	      if (attack(pos, NULL) == WIN) {
		int dcode = find_defense(pos, NULL);
		if (dcode != 0)
		  change_defense_threat(pos, bb, dcode);
	      }
	      popgo();
	    }
	  }
	}

	/* It might be interesting to look for defense threats by
         * attacking weak neighbors, similar to threatening attack by
         * defending a weak neighbor. However, in this case it seems
         * probable that if there is such an attack, it's a real
         * defense, not only a threat. 
	 */
	
	/* FIXME: Try other moves also (patterns?). */
      }
    }
}


/* find_lunch(str, &worm) looks for a worm adjoining the
 * string at (str) which can be easily captured. Whether or not it can
 * be defended doesn't matter.
 *
 * Returns the location of the string in (*lunch).
 */
	
static int
find_lunch(int str, int *lunch)
{
  int i, j;
  int k;

  ASSERT1(IS_STONE(board[str]), str);
  ASSERT1(stackp == 0, str);

  *lunch = NO_MOVE;
  for (i = 0; i < board_size; i++)
    for (j = 0; j < board_size; j++) {
      int pos = POS(i, j);
      if (board[pos] != OTHER_COLOR(board[str]))
	continue;
      for (k = 0; k < 8; k++) {
	int apos = pos + delta[k];
	if (ON_BOARD(apos) && is_same_worm(apos, str)) {
	  if (worm[pos].attack_codes[0] != 0 && !is_ko_point(pos)) {
	    /*
	     * If several adjacent lunches are found, we pick the 
	     * juiciest. First maximize cutstone, then minimize liberties. 
	     * We can only do this if the worm data is available, 
	     * i.e. if stackp==0.
	     */
	    if (*lunch == NO_MOVE
		|| worm[pos].cutstone > worm[*lunch].cutstone 
		|| (worm[pos].cutstone == worm[*lunch].cutstone 
		    && worm[pos].liberties < worm[*lunch].liberties)) {
	      *lunch = worm[pos].origin;
	    }
	  }
	  break;
	}
      }
    }

  if (*lunch != NO_MOVE)
    return 1;

  return 0;
}


/*
 * Test whether two worms are the same. Used by autohelpers.
 * Before this function can be called, build_worms must have been run.
 */

int
is_same_worm(int w1, int w2)
{
  return worm[w1].origin == worm[w2].origin;
}


/*
 * Test whether the origin of the worm at (w) is (pos).
 */

int
is_worm_origin(int w, int pos)
{
  return worm[w].origin == pos;
}


/* 
 * change_defense(str, move, dcode) is used to add and remove defense
 * points. It can also be used to change the defense code. The meaning
 * of the call is that the string (str) can be defended by (move) with
 * defense code (dcode). If (dcode) is zero, the move is removed from
 * the list of defense moves if it was previously listed.
 */

void
change_defense(int str, int move, int dcode)
{
  str = worm[str].origin;
  change_tactical_point(str, move, dcode,
			worm[str].defense_points, worm[str].defend_codes);
}


/* 
 * change_attack(str, move, acode) is used to add and remove attack
 * points. It can also be used to change the attack code. The meaning
 * of the call is that the string (str) can be attacked by (move) with
 * attack code (acode). If (acode) is zero, the move is removed from
 * the list of attack moves if it was previously listed.
 */

void
change_attack(int str, int move, int acode)
{
  str = worm[str].origin;
  DEBUG(DEBUG_WORMS, "change_attack: %1m %1m %d\n", str, move, acode);
  change_tactical_point(str, move, acode,
			worm[str].attack_points, worm[str].attack_codes);
}


/* 
 * change_defense_threat(str, move, dcode) is used to add and remove
 * defense threat points. It can also be used to change the defense
 * threat code. The meaning of the call is that the string (str) can
 * threaten to be defended by (move) with defense threat code (dcode).
 * If (dcode) is zero, the move is removed from the list of defense
 * threat moves if it was previously listed.
 */

void
change_defense_threat(int str, int move, int dcode)
{
  str = worm[str].origin;
  change_tactical_point(str, move, dcode,
			worm[str].defense_threat_points,
			worm[str].defense_threat_codes);
}


/* 
 * change_attack_threat(str, move, acode) is used to add and remove
 * attack threat points. It can also be used to change the attack
 * threat code. The meaning of the call is that the string (str) can
 * threaten to be attacked by (move) with attack threat code (acode).
 * If (acode) is zero, the move is removed from the list of attack
 * threat moves if it was previously listed.
 */

void
change_attack_threat(int str, int move, int acode)
{
  str = worm[str].origin;
  change_tactical_point(str, move, acode,
			worm[str].attack_threat_points,
			worm[str].attack_threat_codes);
}


/* Check whether (move) is listed as an attack point for (str) and
 * return the attack code. If (move) is not listed, return 0.
 */
int
attack_move_known(int move, int str)
{
  return movelist_move_known(move, MAX_TACTICAL_POINTS,
			     worm[str].attack_points,
			     worm[str].attack_codes);
}

/* Check whether (move) is listed as a defense point for (str) and
 * return the defense code. If (move) is not listed, return 0.
 */
int
defense_move_known(int move, int str)
{
  return movelist_move_known(move, MAX_TACTICAL_POINTS,
			     worm[str].defense_points,
			     worm[str].defend_codes);
}

/* Check whether (move) is listed as an attack threat point for (str)
 * and return the attack threat code. If (move) is not listed, return
 * 0.
 */
int
attack_threat_move_known(int move, int str)
{
  return movelist_move_known(move, MAX_TACTICAL_POINTS,
			     worm[str].attack_threat_points,
			     worm[str].attack_threat_codes);
}

/* Check whether (move) is listed as a defense threat point for (str)
 * and return the defense threat code. If (move) is not listed, return
 * 0.
 */
int
defense_threat_move_known(int move, int str)
{
  return movelist_move_known(move, MAX_TACTICAL_POINTS,
			     worm[str].defense_threat_points,
			     worm[str].defense_threat_codes);
}


/*
 * This function does the real work for change_attack(),
 * change_defense(), change_attack_threat(), and
 * change_defense_threat().
 */

static void
change_tactical_point(int str, int move, int code,
		      int points[MAX_TACTICAL_POINTS],
		      int codes[MAX_TACTICAL_POINTS])
{
  gg_assert(ON_BOARD(str));
  gg_assert(str == worm[str].origin);
  
  movelist_change_point(move, code, MAX_TACTICAL_POINTS, points, codes);
  propagate_worm2(str);
}


/* 
 * propagate_worm() takes the worm data at one stone and copies it to 
 * the remaining members of the worm.
 *
 * Even though we don't need to copy all the fields, it's probably
 * better to do a structure copy which should compile to a block copy.
 */

void 
propagate_worm(int pos)
{
  int k;
  int num_stones;
  int stones[MAX_BOARD * MAX_BOARD];
  gg_assert(stackp == 0);
  ASSERT1(IS_STONE(board[pos]), pos);

  num_stones = findstones(pos, MAX_BOARD * MAX_BOARD, stones);
  for (k = 0; k < num_stones; k++)
    if (stones[k] != pos)
      worm[stones[k]] = worm[pos];
}


/* 
 * propagate_worm2() is a relative to propagate_worm() which can be
 * used when stack>0 but not for the initial construction of the
 * worms.
 */

static void 
propagate_worm2(int str)
{
  int pos;
  ASSERT_ON_BOARD1(str);
  ASSERT1(IS_STONE(worm[str].color), str);

  for (pos = BOARDMIN; pos < BOARDMAX; pos++)
    if (board[pos] == board[str] && is_same_worm(pos, str))
      worm[pos] = worm[str];
}


/* Report all known attack, defense, attack threat, and defense threat
 * moves. But limit this to the moves which can be made by (color).
 */
void
worm_reasons(int color)
{
  int pos;
  int k;
  
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (!ON_BOARD(pos) || board[pos] == EMPTY)
      continue;

    if (!is_worm_origin(pos, pos))
      continue;

    if (board[pos] == OTHER_COLOR(color)) {
      for (k = 0; k < MAX_TACTICAL_POINTS; k++) {
	if (worm[pos].attack_codes[k] != 0)
	  add_attack_move(worm[pos].attack_points[k], pos,
			  worm[pos].attack_codes[k]);
	if (worm[pos].attack_threat_codes[k] != 0)
	  add_attack_threat_move(worm[pos].attack_threat_points[k], pos,
				 worm[pos].attack_threat_codes[k]);
      }
    }
      
    if (board[pos] == color) {
      for (k = 0; k < MAX_TACTICAL_POINTS; k++) {
	if (worm[pos].defend_codes[k] != 0)
	  add_defense_move(worm[pos].defense_points[k], pos,
			   worm[pos].defend_codes[k]);

	if (worm[pos].defense_threat_codes[k] != 0)
	  add_defense_threat_move(worm[pos].defense_threat_points[k], pos,
				  worm[pos].defense_threat_codes[k]);
      }
    }
  }
}


/* ping_cave(str, *lib1, ...) is applied when (str) points to a string.
 * It computes the vector (*lib1, *lib2, *lib3, *lib4), 
 * where *lib1 is the number of liberties of the string, 
 * *lib2 is the number of second order liberties (empty vertices
 * at distance two) and so forth.
 *
 * The definition of liberties of order >1 is adapted to the problem
 * of detecting the shape of the surrounding cavity. In particular
 * we want to be able to see if a group is loosely surrounded.
 *
 * A liberty of order n is an empty space which may be connected
 * to the string by placing n stones of the same color on the board, 
 * but no fewer. The path of connection may pass through an intervening group
 * of the same color. The stones placed at distance >1 may not touch a
 * group of the opposite color. At the edge, also diagonal neighbors
 * count as touching. The path may also not pass through a liberty at distance
 * 1 if that liberty is flanked by two stones of the opposing color. This
 * reflects the fact that the O stone is blocked from expansion to the
 * left by the two X stones in the following situation:
 * 
 *          X.
 *          .O
 *          X.
 *
 * On the edge, one stone is sufficient to block expansion:
 *
 *          X.
 *          .O
 *          --
 */

static void 
ping_cave(int str, int *lib1, int *lib2, int *lib3, int *lib4)
{
  int pos;
  int k;
  int libs[MAXLIBS];
  int mrc[BOARDMAX];
  int mse[BOARDMAX];
  int color = board[str];
  int other = OTHER_COLOR(color);

  memset(mse, 0, sizeof(mse));

  /* Find and mark the first order liberties. */
  *lib1 = findlib(str, MAXLIBS, libs);
  for (k = 0; k < *lib1; k++)
    mse[libs[k]] = 1;

  /* Reset mse at liberties which are flanked by two stones of the
   * opposite color, or one stone and the edge.
   */

  for (pos = BOARDMIN; pos < BOARDMAX; pos++)
    if (ON_BOARD(pos)
	&& mse[pos]
	&& (((      !ON_BOARD(SOUTH(pos)) || board[SOUTH(pos)] == other)
	     && (   !ON_BOARD(NORTH(pos)) || board[NORTH(pos)] == other))
	    || ((   !ON_BOARD(WEST(pos))  || board[WEST(pos)] == other)
		&& (!ON_BOARD(EAST(pos))  || board[EAST(pos)] == other))))
      mse[pos] = 0;
  
  *lib2 = 0;
  memset(mrc, 0, sizeof(mrc));
  ping_recurse(str, lib2, mse, mrc, color);

  *lib3 = 0;
  memset(mrc, 0, sizeof(mrc));
  ping_recurse(str, lib3, mse, mrc, color);

  *lib4 = 0;
  memset(mrc, 0, sizeof(mrc));
  ping_recurse(str, lib4, mse, mrc, color);
}


/* recursive function called by ping_cave */

static void 
ping_recurse(int pos, int *counter,
	     int mx[BOARDMAX], int mr[BOARDMAX],
	     int color)
{
  int k;
  mr[pos] = 1;

  for (k = 0; k < 4; k++) {
    int apos = pos + delta[k];
    if (board[apos] == EMPTY
	&& mx[apos] == 0
	&& mr[apos] == 0
	&& !touching(apos, OTHER_COLOR(color))) {
      (*counter)++;
      mr[apos] = 1;
      mx[apos] = 1;
    }
  }
  
  if (!is_ko_point(pos)) {
    for (k = 0; k < 4; k++) {
      int apos = pos + delta[k];
      if (ON_BOARD(apos)
	  && mr[apos] == 0
	  && (mx[apos] == 1
	      || board[apos] == color))
	ping_recurse(apos, counter, mx, mr, color);
    }
  }
}


/* touching(i, j, color) returns true if the vertex at (i, j) is
 * touching any stone of (color).
 */

static int
touching(int pos, int color)
{
  return (board[SOUTH(pos)] == color
	  || board[WEST(pos)] == color
	  || board[NORTH(pos)] == color
	  || board[EAST(pos)] == color);
}


/* The GENUS of a string is the number of connected components of
 * its complement, minus one. It is an approximation to the number of
 * eyes of the string. If (i, j) points to the origin of a string,
 * genus(i, j) returns its genus.
 */

static int 
genus(int str)
{
  int m, n;
  int mg[BOARDMAX];
  int gen = -1;

  memset(mg, 0, sizeof(mg));
  for (m = 0; m < board_size; m++)
    for (n = 0; n < board_size; n++) {
      int pos = POS(m, n);
      if (!mg[pos] && (board[pos] == EMPTY || !is_worm_origin(pos, str))) {
	markcomponent(str, pos, mg);
	gen++;
      }
    }

  return gen;
}


/* This recursive function marks the component at (m, n) of 
 * the complement of the string with origin (i, j)
 */

static void 
markcomponent(int str, int pos, int mg[BOARDMAX])
{
  int k;
  mg[pos] = 1;
  for (k = 0; k < 4; k++) {
    int apos = pos + delta[k];
    if (ON_BOARD(apos)
	&& mg[apos] == 0
	&& (board[apos] == EMPTY || !is_worm_origin(apos, str)))
      markcomponent(str, apos, mg);
  }
}


/* examine_cavity(m, n, *edge), if (m, n) is EMPTY, examines the
 * cavity at (m, n) and returns its bordercolor,
 * which can be BLACK_BORDER, WHITE_BORDER or GRAY_BORDER. The edge
 * parameter is set to the number of edge vertices in the cavity.
 *
 * If (m, n) is nonempty, it returns the same result, imagining
 * that the string at (m, n) is removed. The edge parameter is
 * set to the number of vertices where the cavity meets the
 * edge in a point outside the removed string.  
 */

static int
examine_cavity(int pos, int *edge)
{
  int border_color = EMPTY;
  int ml[BOARDMAX];
  int origin = NO_MOVE;
  
  ASSERT_ON_BOARD1(pos);
  gg_assert(edge != NULL);
  
  memset(ml, 0, sizeof(ml));

  *edge = 0;

  if (IS_STONE(board[pos]))
    origin = find_origin(pos);
  
  cavity_recurse(pos, ml, &border_color, edge, origin);

  if (border_color == (BLACK | WHITE))
    return GRAY_BORDER;  
  if (border_color == BLACK)
    return BLACK_BORDER;
  if (border_color == WHITE)
    return WHITE_BORDER;

  /* We should have returned now, unless the board is completely empty.
   * Verify that this is the case and then return GRAY_BORDER.
   *
   * Notice that the board appears completely empty if there's only a
   * single string and pos points to it.
   */
  gg_assert(border_color == EMPTY
	    && ((pos == NO_MOVE
		 && stones_on_board(BLACK | WHITE) == 0)
		|| (pos != NO_MOVE
		    && stones_on_board(BLACK | WHITE) == countstones(pos))));
  
  return GRAY_BORDER;
}


/* helper function for examine_cavity.
 * border_color contains information so far : transitions allowed are
 *   EMPTY       -> BLACK/WHITE
 *   BLACK/WHITE -> BLACK | WHITE
 *
 * mx[i][j] is 1 if (i, j) has already been visited.
 *
 * if (ai, aj) points to the origin of a string, it will be ignored.
 *
 * On (fully-unwound) exit
 *   *border_color should be BLACK, WHITE or BLACK | WHITE
 *   *edge is the count of edge pieces
 *
 * *border_color should be EMPTY if and only if the board
 * is completely empty or only contains the ignored string.
 */

static void 
cavity_recurse(int pos, int mx[BOARDMAX], 
	       int *border_color, int *edge, int str)
{
  int k;
  ASSERT1(mx[pos] == 0, pos);

  mx[pos] = 1;

  
  if (is_edge_vertex(pos) && board[pos] == EMPTY) 
    (*edge)++;

  /* Loop over the four neighbors. */
  for (k = 0; k < 4; k++) {
    int apos = pos + delta[k];
    if (ON_BOARD(apos) && !mx[apos]) {
      int neighbor_empty = 0;
      
      if (board[apos] == EMPTY)
	neighbor_empty = 1;
      else {
	/* Count the neighbor as empty if it is part of the (ai, aj) string. */
	if (str == find_origin(apos))
	  neighbor_empty = 1;
	else
	  neighbor_empty = 0;
      }
      
      if (!neighbor_empty)
	*border_color |= board[apos];
      else
	cavity_recurse(apos, mx, border_color, edge, str);
    }
  }
}


/* Find attacking moves by pattern matching, for both colors. */
static void
find_attack_patterns(void)
{
  matchpat(attack_callback, ANCHOR_OTHER, &attpat_db, NULL, NULL);
}

/* Try to attack every X string in the pattern, whether there is an attack
 * before or not. Only exclude already known attacking moves.
 */
static void
attack_callback(int m, int n, int color, struct pattern *pattern, int ll,
		void *data)
{
  int move;
  int k;
  UNUSED(data);

  move = AFFINE_TRANSFORM(pattern->movei, pattern->movej, ll, m, n);

  /* If the pattern has a constraint, call the autohelper to see
   * if the pattern must be rejected.
   */
  if (pattern->autohelper_flag & HAVE_CONSTRAINT) {
    if (!pattern->autohelper(pattern, ll, move, color, 0))
      return;
  }

  /* If the pattern has a helper, call it to see if the pattern must
   * be rejected.
   */
  if (pattern->helper) {
    if (!pattern->helper(pattern, ll, move, color)) {
      DEBUG(DEBUG_WORMS,
	    "Attack pattern %s+%d rejected by helper at %1m\n",
	    pattern->name, ll, move);
      return;
    }
  }

  /* Loop through pattern elements in search of X strings to attack. */
  for (k = 0; k < pattern->patlen; ++k) { /* match each point */
    if (pattern->patn[k].att == ATT_X) {
      /* transform pattern real coordinate */
      int pos = AFFINE_TRANSFORM(pattern->patn[k].x, pattern->patn[k].y,
				 ll, m, n);

      int str = worm[pos].origin;

      /* A string with 5 liberties or more is considered tactically alive. */
      if (countlib(str) > 4)
	continue;

      if (attack_move_known(move, str))
	continue;

      /* No defenses are known at this time, so defend_code is always 0. */
#if 0
      /* If the string can be attacked but not defended, ignore it. */
      if (worm[str].attack_codes[0] == WIN && worm[str].defend_codes[0] == 0)
	continue;
#endif
      
      /* FIXME: Don't attack the same string more than once.
       * Play (ti, tj) and see if there is a defense.
       */
      if (trymove(move, color, "attack_callback", str, EMPTY, NO_MOVE)) {
	int dcode;
	if (!board[str])
	  dcode = 0;
	else if (!attack(str, NULL))
	  dcode = WIN;
	else
	  dcode = find_defense(str, NULL);

	popgo();

	/* Do not pick up suboptimal attacks at this time. Since we
         * don't know whether the string can be defended it's quite
         * possible that it only has a ko defense and then we would
         * risk to find an irrelevant move to attack with ko.
	 */
	if (dcode != WIN && 3 - dcode >= worm[str].attack_codes[0]) {
	  change_attack(str, move, 3 - dcode);
	  DEBUG(DEBUG_WORMS,
		"Attack pattern %s+%d found attack on %1m at %1m with code %d\n",
		pattern->name, ll, str, move, 3 - dcode);
	}
      }
    }
  }
}

static void
find_defense_patterns(void)
{
  matchpat(defense_callback, ANCHOR_COLOR, &defpat_db, NULL, NULL);
}

static void
defense_callback(int m, int n, int color, struct pattern *pattern, int ll,
		 void *data)
{
  int move;
  int k;
  UNUSED(data);

  move = AFFINE_TRANSFORM(pattern->movei, pattern->movej, ll, m, n);
  
  /* If the pattern has a constraint, call the autohelper to see
   * if the pattern must be rejected.
   */
  if (pattern->autohelper_flag & HAVE_CONSTRAINT) {
    if (!pattern->autohelper(pattern, ll, move, color, 0))
      return;
  }

  /* If the pattern has a helper, call it to see if the pattern must
   * be rejected.
   */
  if (pattern->helper) {
    if (!pattern->helper(pattern, ll, move, color)) {
      DEBUG(DEBUG_WORMS,
	    "Defense pattern %s+%d rejected by helper at %1m\n",
	    pattern->name, ll, move);
      return;
    }
  }

  /* Loop through pattern elements in search for O strings to defend. */
  for (k = 0; k < pattern->patlen; ++k) { /* match each point */
    if (pattern->patn[k].att == ATT_O) {
      /* transform pattern real coordinate */
      int pos = AFFINE_TRANSFORM(pattern->patn[k].x, pattern->patn[k].y,
				 ll, m, n);
      int str = worm[pos].origin;

      if (worm[str].attack_codes[0] == 0
	  || defense_move_known(move, str))
	continue;
      
      /* FIXME: Don't try to defend the same string more than once.
       * FIXME: For all attacks on this string, we should test whether
       *        the proposed move happens to refute the attack.
       * Play (move) and see if there is an attack.
       */
      if (trymove(move, color, "defense_callback", str, EMPTY, NO_MOVE)) {
	int acode = attack(str, NULL);

	popgo();
	
	if (acode < worm[str].attack_codes[0]) {
	  change_defense(str, move, 3 - acode);
	  DEBUG(DEBUG_WORMS,
		"Defense pattern %s+%d found defense of %1m at %1m with code %d\n",
		pattern->name, ll, str, move, 3 - acode);
	}
      }
    }
  }
}

/* ================================================================ */
/*                      Debugger functions                          */
/* ================================================================ */

/* For use in gdb, print details of the worm at (m, n). 
 * Add this to your .gdbinit file:
 *
 * define worm
 * set ascii_report_worm("$arg0")
 * end
 *
 * Now 'worm S8' will report the details of the S8 worm.
 *
 */

void
ascii_report_worm(char *string)
{
  int m, n;
  string_to_location(board_size, string, &m, &n);
  report_worm(m, n);
}


void
report_worm(int m, int n)
{
  int pos = POS(m, n);
  if (board[pos] == EMPTY) {
    gprintf("There is no worm at %1m\n", pos);
    return;
  }

  gprintf("*** worm at %1m:\n", pos);
  gprintf("color: %s; origin: %1m; size: %d; effective size: %f\n",
	  (worm[pos].color == WHITE) ? "White" : "Black",
	  worm[pos].origin, worm[pos].size, worm[pos].effective_size);

  gprintf("liberties: %d order 2 liberties:%d order 3:%d order 4:%d\n",
	  worm[pos].liberties, 
	  worm[pos].liberties2, 
	  worm[pos].liberties3, 
	  worm[pos].liberties4);

  /* FIXME: List all attack points. */
  if (worm[pos].attack_points[0] != NO_MOVE)
    gprintf("attack point %1m, ", worm[pos].attack_points[0]);
  else
    gprintf("no attack point, ");

  if (worm[pos].attack_codes[0] == WIN)
    gprintf("attack code WIN\n");
  else if (worm[pos].attack_codes[0] == KO_A)
    gprintf("attack code KO_A\n");
  else if (worm[pos].attack_codes[0] == KO_B)
    gprintf("attack code KO_B\n");

  /* FIXME: List all defense points. */
  if (worm[pos].defense_points[0] != NO_MOVE)
    gprintf("defense point %1m, ", worm[pos].defense_points[0]);
  else
    gprintf("no defense point, ");

  if (worm[pos].defend_codes[0] == WIN)
    gprintf("defend code WIN\n");
  else if (worm[pos].defend_codes[0] == KO_A)
    gprintf("defend code KO_A\n");
  else if (worm[pos].defend_codes[0] == KO_B)
    gprintf("defend code KO_B\n");

  /* FIXME: List all attack and defense threat points. */


  if (worm[pos].lunch != NO_MOVE)
    gprintf("lunch at %1m\n", worm[pos].lunch);

  gprintf("cutstone: %d, cutstone2: %d\n",
	  worm[pos].cutstone, worm[pos].cutstone2);

  gprintf("genus: %d, ", worm[pos].genus);

  if (worm[pos].inessential)
    gprintf("inessential: YES, ");
  else
    gprintf("inessential: NO, ");

  if (worm[pos].invincible)
    gprintf("invincible: YES, \n");
  else
    gprintf("invincible: NO, \n");

  if (worm[pos].unconditional_status == ALIVE)
    gprintf("unconditional status ALIVE\n");
  else if (worm[pos].unconditional_status == DEAD)
    gprintf("unconditional status DEAD\n");
  else if (worm[pos].unconditional_status == WHITE_BORDER)
    gprintf("unconditional status WHITE_BORDER\n");
  else if (worm[pos].unconditional_status == BLACK_BORDER)
    gprintf("unconditional status BLACK_BORDER\n");
  else if (worm[pos].unconditional_status == UNKNOWN)
    gprintf("unconditional status UNKNOWN\n");
}

/********************************************************************/

/**********************************************************************/

/* dfa.c */
/* transform.c */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\
 * This is GNU GO, a Go program. Contact gnugo@gnu.org, or see       *
 * http://www.gnu.org/software/gnugo/ for more information.          *
 *                                                                   *
 * Copyright 1999, 2000, 2001, 2002 by the Free Software Foundation. *
 *                                                                   *
 * This program is free software; you can redistribute it and/or     *
 * modify it under the terms of the GNU General Public License as    *
 * published by the Free Software Foundation - version 2             *
 *                                                                   *
 * This program is distributed in the hope that it will be useful,   *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     *
 * GNU General Public License in file COPYING for more details.      *
 *                                                                   *
 * You should have received a copy of the GNU General Public         *
 * License along with this program; if not, write to the Free        *
 * Software Foundation, Inc., 59 Temple Place - Suite 330,           *
 * Boston, MA 02111, USA.                                            *
\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * * * * * * * * fast pattern matching with DFA  version 2.9 * * *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


/*-----------------------------------*/
/* #ifdef HAVE_CONFIG_H */
/* #include "config.h" */
/* #endif */

/* #include <assert.h> */

/* #ifdef HAVE_UNISTD_H */
/* #include <unistd.h> */
/* #endif */


/* #include "patterns.h" */
/* #include "dfa.h" */
/*-----------------------------------*/


/* #include "patterns.h" */
/* #include "dfa.h" */
#include <assert.h>

/* #ifdef HAVE_CONFIG_H */
/* #include <config.h> */
/* #endif */

/* #ifdef HAVE_UNISTD_H */
/* #include <unistd.h> */
/* #endif */



#define mgena_dfa_gg_assert(x) assert(x);


/*********************
 *   Public data     *
 *********************/

/* If > 0 more detailled infomation is given */
int dfa_verbose = 0;

/* conversion array (stupid hack) */
int dfa_asc2val[90] = {
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 0, 3, 3, 3,	/* '.' == 46 */
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 1,	/* 'O' == 79 */
  3, 3, 3, 3, 3, 3, 3, 3, 2, 3	/* 'X' == 88 */
};

char dfa_val2asc[4] = {
    '.', 'O', 'X', '#' };


/*********************
 *  Private data     *
 *********************/

/* the private board */
int dfa_p[DFA_MAX_BOARD * 4 * DFA_MAX_BOARD * 4];

/* auxiliary dfa's for high level functions */
static dfa_t aux_dfa1;		/* used to store strings */
static dfa_t aux_dfa2;		/* used to store the result of dfa's products*/

/* To be sure that everything was well initialized */
static int dfa_was_initialized = 0;


/* convert is a table to convert the colors */
const int convert[3][4] = {
  {-1, -1, -1, -1},		/* not used */
  {EMPTY, WHITE, BLACK, OUT_BOARD},	/* WHITE */
  {EMPTY, BLACK, WHITE, OUT_BOARD}	/* BLACK */

};


/* convert ATT_* values to the corresponding expected values on the board */
static const char att2val[8] =
  { '.', 'X', 'O', 'x', 'o', ',', 'a', '!' };

#define EXPECTED_VAL(att_val) att2val[att_val]


/************************************************
 *   forward declaration of private functions   *
 ************************************************/
static void clean_dfa(dfa_t *pdfa);
static void resize_dfa(dfa_t *pdfa, int maxStates, int maxIndexes);
static void create_dfa(dfa_t *pdfa, const char *str, int att_val);
static void do_sync_product(int l, int r);
static void sync_product(dfa_t *pout, dfa_t *pleft, dfa_t *pright);


/********************************
 *   manipulating scan orders   *
 ********************************/

/* The spiral order is the way we scan the board,
 * we begin on the anchor and we 
 * progressively scan all its neigbouring intersections,
 * collecting all the known patterns we meet on our way:
 *
 *                  4      4      4
 * 1    1     13    13    513    513  ... and so on until we reach
 *      2     2     2      2     827      a stopping state in the
 *                                6        dfa.
 */

int spiral[8][MAX_ORDER];

/*
 * Build the spiral order for each
 * transformation: instead of changing the board
 * or changing the patterns, we only change the order,
 * for eg. the same dfa can perform the pattern matching
 *
 * that way for identity:
 *
 *     765                                            567
 *     814F      and this way for mirror symetry:    F418
 *     923E                                          E329
 *     CABD                                          DBAC
 *
 * Anther possibility is to generate one string by pattern and by
 * transformation in mkpat to avoid any runtime transformation 
 * but it may increase the size of the dfa.
 * 
 */

static const int generator[4] =
  { 4 * DFA_MAX_BOARD, 1, -4 * DFA_MAX_BOARD, -1 };

void
buildSpiralOrder(int order[8][MAX_ORDER])
{
  int Mark[DFA_MAX_BOARD * 4 * DFA_MAX_BOARD * 4];
  int fifo[8 * MAX_ORDER];
  int top = 0, end = 0;
  int i, j, i0, j0;
  int k, ll;
  int ii;
  int delta;

  

  if (dfa_verbose > 1)
    fprintf(stderr, "Building spiral order\n");

  /* First we build the basic (pseudo)spiral order */

  /* initialization */

  for (ii = 0; ii < DFA_MAX_BOARD * 4 * DFA_MAX_BOARD * 4; ii++)
    Mark[ii] = 1;

  for (i = DFA_MAX_BOARD; i < DFA_MAX_BOARD * 3; i++)
    for (j = DFA_MAX_BOARD; j < DFA_MAX_BOARD * 3; j++)
      Mark[DFA_POS(i, j)] = 0;

  end = 0;
  top = 1;
  fifo[end] = 2 * DFA_OFFSET;
  Mark[fifo[end]] = 1;

  /* generation */
  while (end < MAX_ORDER) {
    ii = fifo[end];
    order[0][end] = ii - 2 * DFA_OFFSET;
    end++;
    
    for (k = 0; k != 4; k++) {
      delta = generator[k];
      
      if (!Mark[ii + delta]) {
	fifo[top] = ii + delta;
	Mark[ii + delta] = 1;
	top++;
      }
    }
  }

  /* Then we compute all the geometric transformations
     on this order */
  for (k = 0; k < MAX_ORDER; k++) {
    j0 = order[0][k] % (4 * DFA_MAX_BOARD);
    if (j0 >= 2 * DFA_MAX_BOARD)
      j0 -= 4 * DFA_MAX_BOARD;
    if (j0 < - 2 * DFA_MAX_BOARD)
      j0 += 4 * DFA_MAX_BOARD;
    i0 = (order[0][k] - j0) / (4 * DFA_MAX_BOARD);
    for (ll = 1; ll != 8; ll++) {
      TRANSFORM(i0, j0, &i, &j, ll);
      order[ll][k] = DFA_POS(i, j);
    }
  }

}

/********************************
 * manipulating attributes list *
 ********************************/

/*
 * Test if val is member of the attributes set att
 */

static int
member_att(dfa_t *pdfa, int att, int val)
{
  int res;

  res = 0;
  while (!res && att != 0) {
    res = (pdfa->indexes[att].val == val);
    att = pdfa->indexes[att].next;
  }
  return res;
}

/* 
 * return the union of two attribute sets att1 & att2
 * repectively from dfa1 and dfa2 into
 * att in dfa.
 */

static int
union_att(dfa_t *pdfa, dfa_t *pdfa1, int att1, dfa_t *pdfa2, int att2)
{
  int att;
  int att_aux;

  /* copy att1 in att */
  att = 0;
  while (att1 != 0) {
    pdfa->lastIndex++;
    if (pdfa->lastIndex >= pdfa->maxIndexes)
      resize_dfa(pdfa, pdfa->maxStates,
		 pdfa->maxIndexes + DFA_RESIZE_STEP);
    att_aux = pdfa->lastIndex;
    
    pdfa->indexes[att_aux].val = pdfa1->indexes[att1].val;
    pdfa->indexes[att_aux].next = att;
    att = att_aux;
    att1 = pdfa1->indexes[att1].next;
  }

  /* add to att the new elements of att2 */
  while (att2 != 0) {
    if (!member_att(pdfa, att, pdfa2->indexes[att2].val)) {
      pdfa->lastIndex++;
      if (pdfa->lastIndex >= pdfa->maxIndexes)
	resize_dfa(pdfa, pdfa->maxStates, pdfa->maxIndexes + DFA_RESIZE_STEP);
      att_aux = pdfa->lastIndex;

      pdfa->indexes[att_aux].val = pdfa2->indexes[att2].val;
      pdfa->indexes[att_aux].next = att;
      att = att_aux;
    }
    att2 = pdfa2->indexes[att2].next;
  }

  return att;
}

/**********************
 * manipulating dfa's *
 **********************/


/*
 * return the effective size of a dfa in kB.
 */

int
dfa_size(dfa_t *pdfa)
{
  int states_size, indexes_size;

  states_size = (pdfa->lastState + 1) * sizeof(state_t);
  indexes_size = (pdfa->lastIndex + 1) * sizeof(attrib_t);

  return (states_size + indexes_size + sizeof(dfa_t)) / 1024;
}


/* 
 * resize memory for a dfa 
 */

static void
resize_dfa(dfa_t *pdfa, int maxStates, int maxIndexes)
{
  state_t *pBuf;
  attrib_t *pBuf2;
  int i;

  if (dfa_verbose > 1)
    fprintf(stderr, "Resizing dfa %s\n", pdfa->name);

  mgena_dfa_gg_assert(pdfa->lastState <= pdfa->maxStates);
  mgena_dfa_gg_assert(pdfa->lastIndex <= pdfa->maxIndexes);

  pBuf = realloc(pdfa->states, maxStates * sizeof(state_t));
  pBuf2 = realloc(pdfa->indexes, maxIndexes * sizeof(attrib_t));
  if (pBuf == NULL || pBuf2 == NULL) {
    fprintf(stderr, "No memory left for dfa: %s", pdfa->name);
    exit(1);
  }

  for (i = pdfa->maxStates; i < maxStates; i++)
    memset(pBuf + i, 0, sizeof(state_t));
  for (i = pdfa->maxIndexes; i < maxIndexes; i++)
    memset(pBuf2 + i, 0, sizeof(attrib_t));

  pdfa->states = pBuf;
  pdfa->maxStates = maxStates;
  pdfa->indexes = pBuf2;
  pdfa->maxIndexes = maxIndexes;

}



/* 
 * dump a dfa (debugging purpose).
 */

static const char *line =
  "----------------------------------------------------\n";

void
dump_dfa(FILE *f, dfa_t *pdfa)
{
  int i;
  int att, k;

  fprintf(f, line);
  fprintf(f, " name : %s\n", pdfa->name);
  fprintf(f, " Nb states :  %7d, max= %d\n", pdfa->lastState + 1,
	  pdfa->maxStates);
  fprintf(f, " Nb Indexes : %7d, max= %d\n", pdfa->lastIndex,
	  pdfa->maxIndexes);
  fprintf(f, " memory needed : %d Mb\n", dfa_size(pdfa) / 1024);
  fprintf(f, line);

  if (dfa_size(pdfa) > 10000) /* change this value if needed */
    return;
  fprintf(f, " state  |   .    |   O    |   X    |   #    |  att \n");
  fprintf(f, line);
  for (i = 1; i != pdfa->lastState + 1; i++) {
    int *pnext = pdfa->states[i].next;
    fprintf(f, " %6d |", i);
    fprintf(f, " %6d | %6d | %6d |", pnext[0], pnext[1], pnext[2]);
    fprintf(f, " %6d |", pnext[OUT_BOARD]);
    att = pdfa->states[i].att;
    k = 0;
    fprintf(f, " %5d:", att);
    while (att != 0 && k < 10) {
      fprintf(f, " %4d", pdfa->indexes[att].val);
      att = pdfa->indexes[att].next;
      k++;
    }
    if (att != 0)
      fprintf(f, " ...");
    fprintf(f, "\n");
  }
  fprintf(f, line);
  fflush(f);
}


/*
 * Reset a dfa
 */

static void
clean_dfa(dfa_t *pdfa)
{
  memset(pdfa->states, 0, pdfa->maxStates * sizeof(state_t));
  memset(pdfa->indexes, 0, pdfa->maxIndexes * sizeof(attrib_t));
  pdfa->lastState = 1;		/* initial state */
  pdfa->lastIndex = 0;
  pdfa->indexes[0].val = -1;
}


/* 
 * allocate memory for a new dfa 
 */

void
new_dfa(dfa_t *pdfa, const char *name)
{
  memset(pdfa, 0, sizeof(dfa_t));
  resize_dfa(pdfa, DFA_INIT_SIZE, DFA_INIT_SIZE);
  clean_dfa(pdfa);
  if (name != NULL)
    strcpy(pdfa->name, name);
  else
    strcpy(pdfa->name, "noname ");

  if (dfa_verbose > 1)
    fprintf(stderr, "dfa %s is born :)\n", pdfa->name);

}

/*
 * free memory used by a dfa
 */

void
kill_dfa(dfa_t *pdfa)
{
  free(pdfa->states);
  free(pdfa->indexes);
  if (dfa_verbose > 1)
    fprintf(stderr, "dfa %s is dead :(\n", pdfa->name);

  memset(pdfa, 0, sizeof(dfa_t));
}


/*
 * Copy a dfa.
 * and rezise the destination dfa if necessary.
 */

void
copy_dfa(dfa_t *p_to, dfa_t *p_from)
{
  mgena_dfa_gg_assert(p_to != p_from);

  if (p_to->maxStates < p_from->lastState)
    resize_dfa(p_to, p_from->maxStates, p_to->maxIndexes);

  if (p_to->maxIndexes < p_from->lastIndex)
    resize_dfa(p_to, p_to->maxStates, p_from->maxIndexes);

  clean_dfa(p_to);

  memcpy(p_to->states, p_from->states,
	 sizeof(state_t) * (p_from->lastState + 1));
  memcpy(p_to->indexes, p_from->indexes,
	 sizeof(attrib_t) * (p_from->lastIndex + 1));

  p_to->lastState = p_from->lastState;
  p_to->lastIndex = p_from->lastIndex;
}



/*
 * print c dfa:
 * print the dfa in c format.
 */

void
print_c_dfa(FILE *of, const char *name, dfa_t *pdfa)
{
  int i;

  fprintf(of, "\n#include \"dfa.h\"\n");

  fprintf(of, "static state_t state_%s[%d] = {\n", name, pdfa->lastState + 1);
  for (i = 0; i != pdfa->lastState + 1; i++) {
    fprintf(of, "{%d,", pdfa->states[i].att);
    fprintf(of, "{%d,", pdfa->states[i].next[0]);
    fprintf(of, "%d,", pdfa->states[i].next[1]);
    fprintf(of, "%d,", pdfa->states[i].next[2]);
    fprintf(of, "%d}},\n", pdfa->states[i].next[3]);
  }
  fprintf(of, "};\n\n");


  fprintf(of, "static attrib_t idx_%s[%d] = {\n", name, pdfa->lastIndex + 1);
  for (i = 0; i != pdfa->lastIndex + 1; i++)
    fprintf(of, "{%d,%d},\n", pdfa->indexes[i].val, pdfa->indexes[i].next);
  fprintf(of, "};\n\n");

  fprintf(of, "static struct dfa dfa_%s = {\n", name);
  fprintf(of, " \"%s\",\n", name);
  fprintf(of, "state_%s, %d, %d,\n", name,
	  pdfa->lastState + 1, pdfa->lastState);
  fprintf(of, "idx_%s, %d, %d", name, pdfa->lastIndex + 1, pdfa->lastIndex);
  fprintf(of, "};\n");

}


/*
 * Create a linear dfa from a string and an attributes value
 * and resize the dfa if needed.
 *
 * For eg.
 * create_dfa (pdfa, "Oo?.", 2001)
 * gives:
 *
 *           1              0,1            0,1,2             0
 * (1,{}) -------> (2,{}) -------> (3,{}) -------> (4,{}) ------> (5,{2001})
 *                                                  
 * An empty string force a junk pattern : The scanner will always 
 * consider this pattern as active.
 *
 * The possible input symbols are :
 * 
 * '.', ',', '*', '!' for EMPTY expected.
 * 'X'                for BLACK expected.
 * 'O'                for WHITE expected.
 * 'x'                for BLACK|EMPTY expected.
 * 'o'                for WHITE|EMPTY expected.
 * '#', '+', '-', '|' for OUT_BOARD expected.
 * '?'                for EMPTY|BLACK|WHITE expected.
 * '$'                for EMPTY|BLACK|WHITE|OUT_BOARD expected.
 */

static void
create_dfa(dfa_t *pdfa, const char *str, int att_val)
{
  int new_state;

  if (dfa_verbose > 1)
    fprintf(stderr, "linear dfa in %s with string\n%s\n", pdfa->name, str);

  mgena_dfa_gg_assert(str != NULL);
  mgena_dfa_gg_assert(pdfa->maxStates > 1);
  mgena_dfa_gg_assert(pdfa->maxIndexes > 1);

  clean_dfa(pdfa);
  new_state = 1;
  for (; *str != '\0' && strchr("$#+-|OoXx.?,!a*", *str); str++) {
    memset(pdfa->states[new_state].next, 0, 4 * sizeof(int));
    if (strchr("$?.ox,a!*", *str))
      pdfa->states[new_state].next[0] = new_state + 1;
    if (strchr("$?Oo", *str))
      pdfa->states[new_state].next[1] = new_state + 1;
    if (strchr("$?Xx", *str))
      pdfa->states[new_state].next[2] = new_state + 1;
    if (strchr("$#+-|", *str))
      pdfa->states[new_state].next[OUT_BOARD] = new_state + 1;
    new_state++;
    if (new_state >= pdfa->maxStates)
      resize_dfa(pdfa, pdfa->maxStates + DFA_RESIZE_STEP,
		 pdfa->maxIndexes);
  }
  memset(pdfa->states[new_state].next, 0, 4 * sizeof(int));

  pdfa->lastIndex++;
  if (pdfa->lastIndex >= pdfa->maxIndexes)
    resize_dfa(pdfa, pdfa->maxStates,
	       pdfa->maxIndexes + DFA_RESIZE_STEP);

  memset(&(pdfa->indexes[pdfa->lastIndex]), 0, sizeof(attrib_t));
  pdfa->states[new_state].att = pdfa->lastIndex;

  pdfa->indexes[pdfa->states[new_state].att].val = att_val;
  pdfa->indexes[pdfa->states[new_state].att].next = 0;
  pdfa->lastState = new_state;
}


/**************************
 * Test array with a      *
 * hash table             *
 **************************/
/* used by sync_product   *
 * to store visited states*
 **************************/

#define MAX_HASH_VALUE 4096

typedef struct entry {
  int l, r; /* key */
  int val; /* value */
  struct entry *pnext; /* NULL if end of list */
} entry_t;

typedef struct test_array {
  entry_t *hash[MAX_HASH_VALUE];
} test_array_t;


/* initialize empty lists */
static void
new_test_array(test_array_t *pta)
{
  int h;

  for (h = 0; h != MAX_HASH_VALUE ; h++)
    pta->hash[h] = NULL;
}

/* Searh for (l, r) in the linked list plist */
static int 
get_from_entry_list(entry_t *plist, int l, int r)
{
  int val = 0;
  
  while (plist != NULL) {
    if (plist->l == l && plist->r == r)
      val = plist->val;
    plist = plist->pnext;
  }
  return val;
}

/* get the value associated with (l, r) or 0 if none */
static int
get_from_test_array(test_array_t *pta, int l, int r)
{
  return get_from_entry_list(pta->hash[(l+r) % MAX_HASH_VALUE], l, r);
}


/* insert a new entry at the beginning of the linked list pplist */
static void
add_to_entry_list(entry_t **pplist, int l, int r, int val)
{
  entry_t *new_entry;

  /* make sure val > 0: val = 0 is used in get_from_entry_list */
  mgena_dfa_gg_assert(val > 0);
  mgena_dfa_gg_assert(!get_from_entry_list(*pplist, l, r));

  new_entry = malloc(sizeof(entry_t));
  if (new_entry == NULL) {
    fprintf(stderr, "No memory left for new entry\n");
    exit(1);
  }
  new_entry->pnext = *pplist;
  new_entry->l = l;
  new_entry->r = r;
  new_entry->val = val;
  *pplist = new_entry;
}


/* add a value at (l, r) */
static void
add_to_test_array(test_array_t *pta, int l, int r, int val)
{
  add_to_entry_list(&(pta->hash[(l+r) % MAX_HASH_VALUE]), l, r, val);
}

/* free the elements of the linked list plist */
static void
free_entry_list(entry_t *plist)
{
  entry_t *pentry;
  
  while (plist != NULL) {
    pentry = plist;
    plist = plist->pnext;
    free(pentry);
  }
}

/* free allocated memory */
static void
free_test_array(test_array_t *pta)
{
  int h;

  for (h=0; h!=MAX_HASH_VALUE; h++) {
    free_entry_list(pta->hash[h]);
    pta->hash[h] = NULL;
  }
}


/* 
 * Synchronization product between two automata.
 *
 * L(A) is the set of patterns recognized by the automaton A.
 *
 * A syncronized product betwenn two acyclic deterministic automata
 * A1 and A2 is an acyclic deterministic classifier A1xA2 that 
 * recognize and classify the languages 
 * L(A1), L(A2), L(A1 Union A2) and L(A1 Inter A2).
 *
 * This algorithm do the product and the reduction at the same time.
 *
 * See Hopcroft & Ullman "The design and analysis of computer algorithms"
 * Ed. Addison-Wesley, Reading MA, 1974
 * For the theorical aspects.
 */

/* globals used to improve readability */
static dfa_t *gpout, *gpleft, *gpright;

/* Hash table used to test if a state has already been
   visited and then give its position in the new automaton. */
static test_array_t gtest;

static void
do_sync_product(int l, int r)
{
  int c;
  int nextl, nextr;
  int state;

  state = gpout->lastState;

  /* unify the attributes of states l and r */
  gpout->states[state].att = union_att(gpout, gpleft, gpleft->states[l].att,
				       gpright, gpright->states[r].att);

  /* scan each possible out-transition */
  for (c = 0; c != 4; c++) {
    nextl = gpleft->states[l].next[c];
    nextr = gpright->states[r].next[c];
    mgena_dfa_gg_assert(nextl < gpleft->lastState + 1);
    mgena_dfa_gg_assert(nextr < gpright->lastState + 1);
    
    /* transition to (0,0) mean no transition at all */
    if (nextl != 0 || nextr != 0) {
      /* if the out-state doesn't already exist */
      if (get_from_test_array(&gtest, nextl, nextr) == 0) {
	/* create it! */
	gpout->lastState++;
	if (gpout->lastState >= gpout->maxStates)
	  resize_dfa(gpout, gpout->maxStates + DFA_RESIZE_STEP,
		     gpout->maxIndexes);
	
	add_to_test_array(&gtest, nextl, nextr, gpout->lastState);
	
	/* link it */
	gpout->states[state].next[c] = gpout->lastState;
	
	/* create also its sub-automaton */
	do_sync_product(nextl, nextr);
      }
      else {
	/* link it */
	gpout->states[state].next[c] =
	  get_from_test_array(&gtest, nextl, nextr);
      }
    }
    else {
      /* no output by c from the actual state */
      gpout->states[state].next[c] = 0;
    }
  }
}

static void
sync_product(dfa_t *pout, dfa_t *pleft, dfa_t *pright)
{
  pout->lastIndex = 0;

  if (dfa_verbose > 2) {
    fprintf(stderr, "Product between %s and %s\n", pleft->name,
	    pright->name);
    fprintf(stderr, "result in %s\n", pout->name);
  }


  gpout = pout;
  gpleft = pleft;
  gpright = pright;
  new_test_array(&gtest);
  add_to_test_array(&gtest, 1, 1, 1);
  pout->lastState = 1;

  do_sync_product(1, 1);

  free_test_array(&gtest);
}

/* 
 * Init/end functions
 */

void
dfa_init(void)
{
  int ii;

  if (dfa_verbose > 1)
    fprintf(stderr, "dfa: init\n");
  dfa_was_initialized++;
  buildSpiralOrder(spiral);
  new_dfa(&aux_dfa1, "stringAux ");
  new_dfa(&aux_dfa2, "copyAux ");

  /* set the private board to OUT_BOARD */
  for (ii = 0; ii < 4 * DFA_MAX_BOARD * 4 * DFA_MAX_BOARD; ii++)
    dfa_p[ii] = OUT_BOARD;
}

void
dfa_end(void)
{
  if (dfa_verbose > 1)
    fprintf(stderr, "dfa: end\n");

  kill_dfa(&aux_dfa1);
  kill_dfa(&aux_dfa2);
  dfa_was_initialized--;
}


/*
 * Add a new string with attribute att_val into the dfa.
 * if the new size of the dfa respect some size conditions
 * return increase in kB or -1 if the pattern was rejected.
 * This function never rejects string of length <= 1.
 */

float
dfa_add_string(dfa_t *pdfa, const char *str, int pattern_index)
{
  float ratio;

  if (dfa_verbose > 1)
    fprintf(stderr, "Adding %s\n to dfa %s\n", str, pdfa->name);

  mgena_dfa_gg_assert(dfa_was_initialized > 0);
  mgena_dfa_gg_assert(pdfa != NULL);

  /* We first create a dfa in aux_dfa1 from the string. */
  create_dfa(&aux_dfa1, str, pattern_index);

  /* then we do the synchronization product with dfa */
  sync_product(&aux_dfa2, &aux_dfa1, pdfa);

  ratio = 1;
  if (dfa_size(pdfa) > 0)
    ratio = (float) (dfa_size(&aux_dfa2) / dfa_size(pdfa));

  /* the result is copied in dfa */
  copy_dfa(pdfa, &aux_dfa2);

  return ratio;
}


/*
 * Build a pattern string from a pattern.
 * str must refer a buffer of size greater than MAX_ORDER.
 */
void
pattern_2_string(struct pattern *pat, char *str, int trans, int ci, int cj)
{
  char work_space[DFA_MAX_BOARD * 4][DFA_MAX_BOARD * 4];
  int m, n;			/* anchor position */
  int edges, borders, to_test;
  int i, j, k;
  char c;

  m = DFA_MAX_BOARD * 2 + ci;
  n = DFA_MAX_BOARD * 2 + cj;	/* position of the anchor */

  mgena_dfa_gg_assert(dfa_was_initialized);
  memset(str, 0, MAX_ORDER);
  memset(work_space, '#', sizeof(work_space));

  if (dfa_verbose > 0)
    fprintf(stderr, "converting pattern into string.\n");

  /* basic edge constraints */
  for (i = DFA_MAX_BOARD; i != DFA_MAX_BOARD * 3; i++)
    for (j = DFA_MAX_BOARD; j != DFA_MAX_BOARD * 3; j++)
      work_space[i][j] = '$';

  /* pattern mask */
  for (i = pat->mini + m; i != pat->maxi + m + 1; i++)
    for (j = pat->minj + n; j != pat->maxj + n + 1; j++)
      work_space[i][j] = '?';

  /* more advanced edge constraints */

  /* South constraint */
  if (pat->edge_constraints & SOUTH_EDGE) {
    for (i = m + pat->maxi + 1; i != DFA_MAX_BOARD * 3; i++)
      for (j = 0; j != DFA_MAX_BOARD * 3; j++)
	work_space[i][j] = '-';
  }

  /* East constraint */
  if (pat->edge_constraints & EAST_EDGE) {
    for (i = 0; i != DFA_MAX_BOARD * 3; i++)
      for (j = n + pat->maxj + 1; j != DFA_MAX_BOARD * 3; j++)
	work_space[i][j] = '|';
  }
  
  /* North constraint */
  if (pat->edge_constraints & NORTH_EDGE) {
    for (i = 0; i != m + pat->mini; i++)
      for (j = 0; j != DFA_MAX_BOARD * 4; j++)
	work_space[i][j] = '-';
  }

  /* West constraint */
  if (pat->edge_constraints & WEST_EDGE) {
    /* take care not to erase the south edge constraint */
    for (i = 0; i != m + pat->maxi + 1; i++)
      for (j = 0; j != n + pat->minj; j++)
	work_space[i][j] = '|';

    /* complete the last corner only if necessary */
    if (!(pat->edge_constraints & SOUTH_EDGE)) {
      for (i = m + pat->maxi + 1; i != DFA_MAX_BOARD * 3; i++)
	for (j = 0; j != n + pat->minj; j++)
	  work_space[i][j] = '|';
    }
  }

  /* dump */
  if (dfa_verbose > 4) {
    for (i = DFA_MAX_BOARD - 1; i != DFA_MAX_BOARD * 3 + 1; i++) {
      for (j = DFA_MAX_BOARD - 1; j != DFA_MAX_BOARD * 3 + 1; j++) {
	if (i == m && j == n)
	  fprintf(stderr, "s");	/* mark the anchor */
	else
	  fprintf(stderr, "%c", work_space[i][j]);
      }
      fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");
  }

  /* pattern representation on the work space */
  for (k = 0; k != pat->patlen; k++) {
    c = EXPECTED_VAL(pat->patn[k].att);
    mgena_dfa_gg_assert(work_space[m + pat->patn[k].x - ci]
	      [n + pat->patn[k].y - cj] == '?');
    work_space[m + pat->patn[k].x - ci][n + pat->patn[k].y - cj] = c;
  }

  /* dump */
  if (dfa_verbose > 3) {
    for (i = DFA_MAX_BOARD - 1; i != DFA_MAX_BOARD * 3 + 1; i++) {
      for (j = DFA_MAX_BOARD - 1; j != DFA_MAX_BOARD * 3 + 1; j++) {
	if (i == m && j == n)
	  fprintf(stderr, "s");	/* mark the anchor */
	else
	  fprintf(stderr, "%c", work_space[i][j]);
      }
      fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");
  }

  /* Now we can build the smaller pattern string as possible 
   * from the anchor */

  to_test = pat->patlen;	/* How many positions left to test ? */
  edges = pat->edge_constraints;	/* how many constraint tested ? */
  borders = 0xF; 
  /* we must test at least one intersection by border for 
   * patterns like
   * 
   * ???
   * O.O
   * ???
   * 
   * To ensure edge position.
   */

  for (k = 0;
       (k != MAX_ORDER - 1) && ((borders > 0) || edges || to_test > 0);
       k++) {
    j = spiral[trans][k] % (4 * DFA_MAX_BOARD);
    if (j >= 2 * DFA_MAX_BOARD)
      j -= 4 * DFA_MAX_BOARD;
    if (j <  - 2 * DFA_MAX_BOARD)
      j += 4 * DFA_MAX_BOARD;
    i = (spiral[trans][k] - j) / (4 * DFA_MAX_BOARD);

    if (i == pat->maxi)
      borders &= ~SOUTH_EDGE;
    if (i == pat->mini)
      borders &= ~NORTH_EDGE;
    if (j == pat->maxj)
      borders &= ~EAST_EDGE;
    if (j == pat->minj)
      borders &= ~WEST_EDGE;
    
    mgena_dfa_gg_assert(m + i < DFA_MAX_BOARD * 3 && m + i < DFA_MAX_BOARD * 3);
    str[k] = work_space[m + i][n + j];
    mgena_dfa_gg_assert(strchr("XOxo.,a!?$#|-+", str[k]));
    
    if (strchr("XOxo.,a!", str[k]))
      to_test--;
    if (strchr("#|-+", str[k])) {
      if (i > pat->maxi)
	edges &= ~SOUTH_EDGE;
      if (i < pat->mini)
	edges &= ~NORTH_EDGE;
      if (j > pat->maxj)
	edges &= ~EAST_EDGE;
      if (j < pat->minj)
	edges &= ~WEST_EDGE;
    }
  }
  
  mgena_dfa_gg_assert(k < MAX_ORDER);
  str[k] = '\0';		/* end of string */
}

/*=====================================================================*/

/********************************************************************/
